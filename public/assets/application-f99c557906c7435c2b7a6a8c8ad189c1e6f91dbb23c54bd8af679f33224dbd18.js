/*
Unobtrusive JavaScript
https://github.com/rails/rails/blob/main/actionview/app/assets/javascripts
Released under the MIT license
 */ (function () {
  var context = this;

  (function () {
    (function () {
      this.Rails = {
        linkClickSelector:
          "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]",
        buttonClickSelector: {
          selector:
            "button[data-remote]:not([form]), button[data-confirm]:not([form])",
          exclude: "form button",
        },
        inputChangeSelector:
          "select[data-remote], input[data-remote], textarea[data-remote]",
        formSubmitSelector: "form:not([data-turbo=true])",
        formInputClickSelector:
          "form:not([data-turbo=true]) input[type=submit], form:not([data-turbo=true]) input[type=image], form:not([data-turbo=true]) button[type=submit], form:not([data-turbo=true]) button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])",
        formDisableSelector:
          "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled",
        formEnableSelector:
          "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled",
        fileInputSelector: "input[name][type=file]:not([disabled])",
        linkDisableSelector: "a[data-disable-with], a[data-disable]",
        buttonDisableSelector:
          "button[data-remote][data-disable-with], button[data-remote][data-disable]",
      };
    }).call(this);
  }).call(context);

  var Rails = context.Rails;

  (function () {
    (function () {
      var nonce;

      nonce = null;

      Rails.loadCSPNonce = function () {
        var ref;
        return (nonce =
          (ref = document.querySelector("meta[name=csp-nonce]")) != null
            ? ref.content
            : void 0);
      };

      Rails.cspNonce = function () {
        return nonce != null ? nonce : Rails.loadCSPNonce();
      };
    }).call(this);
    (function () {
      var expando, m;

      m =
        Element.prototype.matches ||
        Element.prototype.matchesSelector ||
        Element.prototype.mozMatchesSelector ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.oMatchesSelector ||
        Element.prototype.webkitMatchesSelector;

      Rails.matches = function (element, selector) {
        if (selector.exclude != null) {
          return (
            m.call(element, selector.selector) &&
            !m.call(element, selector.exclude)
          );
        } else {
          return m.call(element, selector);
        }
      };

      expando = "_ujsData";

      Rails.getData = function (element, key) {
        var ref;
        return (ref = element[expando]) != null ? ref[key] : void 0;
      };

      Rails.setData = function (element, key, value) {
        if (element[expando] == null) {
          element[expando] = {};
        }
        return (element[expando][key] = value);
      };

      Rails.isContentEditable = function (element) {
        var isEditable;
        isEditable = false;
        while (true) {
          if (element.isContentEditable) {
            isEditable = true;
            break;
          }
          element = element.parentElement;
          if (!element) {
            break;
          }
        }
        return isEditable;
      };

      Rails.$ = function (selector) {
        return Array.prototype.slice.call(document.querySelectorAll(selector));
      };
    }).call(this);
    (function () {
      var $, csrfParam, csrfToken;

      $ = Rails.$;

      csrfToken = Rails.csrfToken = function () {
        var meta;
        meta = document.querySelector("meta[name=csrf-token]");
        return meta && meta.content;
      };

      csrfParam = Rails.csrfParam = function () {
        var meta;
        meta = document.querySelector("meta[name=csrf-param]");
        return meta && meta.content;
      };

      Rails.CSRFProtection = function (xhr) {
        var token;
        token = csrfToken();
        if (token != null) {
          return xhr.setRequestHeader("X-CSRF-Token", token);
        }
      };

      Rails.refreshCSRFTokens = function () {
        var param, token;
        token = csrfToken();
        param = csrfParam();
        if (token != null && param != null) {
          return $('form input[name="' + param + '"]').forEach(function (
            input
          ) {
            return (input.value = token);
          });
        }
      };
    }).call(this);
    (function () {
      var CustomEvent, fire, matches, preventDefault;

      matches = Rails.matches;

      CustomEvent = window.CustomEvent;

      if (typeof CustomEvent !== "function") {
        CustomEvent = function (event, params) {
          var evt;
          evt = document.createEvent("CustomEvent");
          evt.initCustomEvent(
            event,
            params.bubbles,
            params.cancelable,
            params.detail
          );
          return evt;
        };
        CustomEvent.prototype = window.Event.prototype;
        preventDefault = CustomEvent.prototype.preventDefault;
        CustomEvent.prototype.preventDefault = function () {
          var result;
          result = preventDefault.call(this);
          if (this.cancelable && !this.defaultPrevented) {
            Object.defineProperty(this, "defaultPrevented", {
              get: function () {
                return true;
              },
            });
          }
          return result;
        };
      }

      fire = Rails.fire = function (obj, name, data) {
        var event;
        event = new CustomEvent(name, {
          bubbles: true,
          cancelable: true,
          detail: data,
        });
        obj.dispatchEvent(event);
        return !event.defaultPrevented;
      };

      Rails.stopEverything = function (e) {
        fire(e.target, "ujs:everythingStopped");
        e.preventDefault();
        e.stopPropagation();
        return e.stopImmediatePropagation();
      };

      Rails.delegate = function (element, selector, eventType, handler) {
        return element.addEventListener(eventType, function (e) {
          var target;
          target = e.target;
          while (!(!(target instanceof Element) || matches(target, selector))) {
            target = target.parentNode;
          }
          if (target instanceof Element && handler.call(target, e) === false) {
            e.preventDefault();
            return e.stopPropagation();
          }
        });
      };
    }).call(this);
    (function () {
      var AcceptHeaders,
        CSRFProtection,
        createXHR,
        cspNonce,
        fire,
        prepareOptions,
        processResponse;

      (cspNonce = Rails.cspNonce),
        (CSRFProtection = Rails.CSRFProtection),
        (fire = Rails.fire);

      AcceptHeaders = {
        "*": "*/*",
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript",
        script:
          "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
      };

      Rails.ajax = function (options) {
        var xhr;
        options = prepareOptions(options);
        xhr = createXHR(options, function () {
          var ref, response;
          response = processResponse(
            (ref = xhr.response) != null ? ref : xhr.responseText,
            xhr.getResponseHeader("Content-Type")
          );
          if (Math.floor(xhr.status / 100) === 2) {
            if (typeof options.success === "function") {
              options.success(response, xhr.statusText, xhr);
            }
          } else {
            if (typeof options.error === "function") {
              options.error(response, xhr.statusText, xhr);
            }
          }
          return typeof options.complete === "function"
            ? options.complete(xhr, xhr.statusText)
            : void 0;
        });
        if (options.beforeSend != null && !options.beforeSend(xhr, options)) {
          return false;
        }
        if (xhr.readyState === XMLHttpRequest.OPENED) {
          return xhr.send(options.data);
        }
      };

      prepareOptions = function (options) {
        options.url = options.url || location.href;
        options.type = options.type.toUpperCase();
        if (options.type === "GET" && options.data) {
          if (options.url.indexOf("?") < 0) {
            options.url += "?" + options.data;
          } else {
            options.url += "&" + options.data;
          }
        }
        if (AcceptHeaders[options.dataType] == null) {
          options.dataType = "*";
        }
        options.accept = AcceptHeaders[options.dataType];
        if (options.dataType !== "*") {
          options.accept += ", */*; q=0.01";
        }
        return options;
      };

      createXHR = function (options, done) {
        var xhr;
        xhr = new XMLHttpRequest();
        xhr.open(options.type, options.url, true);
        xhr.setRequestHeader("Accept", options.accept);
        if (typeof options.data === "string") {
          xhr.setRequestHeader(
            "Content-Type",
            "application/x-www-form-urlencoded; charset=UTF-8"
          );
        }
        if (!options.crossDomain) {
          xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
          CSRFProtection(xhr);
        }
        xhr.withCredentials = !!options.withCredentials;
        xhr.onreadystatechange = function () {
          if (xhr.readyState === XMLHttpRequest.DONE) {
            return done(xhr);
          }
        };
        return xhr;
      };

      processResponse = function (response, type) {
        var parser, script;
        if (typeof response === "string" && typeof type === "string") {
          if (type.match(/\bjson\b/)) {
            try {
              response = JSON.parse(response);
            } catch (error) {}
          } else if (type.match(/\b(?:java|ecma)script\b/)) {
            script = document.createElement("script");
            script.setAttribute("nonce", cspNonce());
            script.text = response;
            document.head.appendChild(script).parentNode.removeChild(script);
          } else if (type.match(/\b(xml|html|svg)\b/)) {
            parser = new DOMParser();
            type = type.replace(/;.+/, "");
            try {
              response = parser.parseFromString(response, type);
            } catch (error) {}
          }
        }
        return response;
      };

      Rails.href = function (element) {
        return element.href;
      };

      Rails.isCrossDomain = function (url) {
        var e, originAnchor, urlAnchor;
        originAnchor = document.createElement("a");
        originAnchor.href = location.href;
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = url;
          return !(
            ((!urlAnchor.protocol || urlAnchor.protocol === ":") &&
              !urlAnchor.host) ||
            originAnchor.protocol + "//" + originAnchor.host ===
              urlAnchor.protocol + "//" + urlAnchor.host
          );
        } catch (error) {
          e = error;
          return true;
        }
      };
    }).call(this);
    (function () {
      var matches, toArray;

      matches = Rails.matches;

      toArray = function (e) {
        return Array.prototype.slice.call(e);
      };

      Rails.serializeElement = function (element, additionalParam) {
        var inputs, params;
        inputs = [element];
        if (matches(element, "form")) {
          inputs = toArray(element.elements);
        }
        params = [];
        inputs.forEach(function (input) {
          if (!input.name || input.disabled) {
            return;
          }
          if (matches(input, "fieldset[disabled] *")) {
            return;
          }
          if (matches(input, "select")) {
            return toArray(input.options).forEach(function (option) {
              if (option.selected) {
                return params.push({
                  name: input.name,
                  value: option.value,
                });
              }
            });
          } else if (
            input.checked ||
            ["radio", "checkbox", "submit"].indexOf(input.type) === -1
          ) {
            return params.push({
              name: input.name,
              value: input.value,
            });
          }
        });
        if (additionalParam) {
          params.push(additionalParam);
        }
        return params
          .map(function (param) {
            if (param.name != null) {
              return (
                encodeURIComponent(param.name) +
                "=" +
                encodeURIComponent(param.value)
              );
            } else {
              return param;
            }
          })
          .join("&");
      };

      Rails.formElements = function (form, selector) {
        if (matches(form, "form")) {
          return toArray(form.elements).filter(function (el) {
            return matches(el, selector);
          });
        } else {
          return toArray(form.querySelectorAll(selector));
        }
      };
    }).call(this);
    (function () {
      var allowAction, fire, stopEverything;

      (fire = Rails.fire), (stopEverything = Rails.stopEverything);

      Rails.handleConfirm = function (e) {
        if (!allowAction(this)) {
          return stopEverything(e);
        }
      };

      Rails.confirm = function (message, element) {
        return confirm(message);
      };

      allowAction = function (element) {
        var answer, callback, message;
        message = element.getAttribute("data-confirm");
        if (!message) {
          return true;
        }
        answer = false;
        if (fire(element, "confirm")) {
          try {
            answer = Rails.confirm(message, element);
          } catch (error) {}
          callback = fire(element, "confirm:complete", [answer]);
        }
        return answer && callback;
      };
    }).call(this);
    (function () {
      var disableFormElement,
        disableFormElements,
        disableLinkElement,
        enableFormElement,
        enableFormElements,
        enableLinkElement,
        formElements,
        getData,
        isContentEditable,
        isXhrRedirect,
        matches,
        setData,
        stopEverything;

      (matches = Rails.matches),
        (getData = Rails.getData),
        (setData = Rails.setData),
        (stopEverything = Rails.stopEverything),
        (formElements = Rails.formElements),
        (isContentEditable = Rails.isContentEditable);

      Rails.handleDisabledElement = function (e) {
        var element;
        element = this;
        if (element.disabled) {
          return stopEverything(e);
        }
      };

      Rails.enableElement = function (e) {
        var element;
        if (e instanceof Event) {
          if (isXhrRedirect(e)) {
            return;
          }
          element = e.target;
        } else {
          element = e;
        }
        if (isContentEditable(element)) {
          return;
        }
        if (matches(element, Rails.linkDisableSelector)) {
          return enableLinkElement(element);
        } else if (
          matches(element, Rails.buttonDisableSelector) ||
          matches(element, Rails.formEnableSelector)
        ) {
          return enableFormElement(element);
        } else if (matches(element, Rails.formSubmitSelector)) {
          return enableFormElements(element);
        }
      };

      Rails.disableElement = function (e) {
        var element;
        element = e instanceof Event ? e.target : e;
        if (isContentEditable(element)) {
          return;
        }
        if (matches(element, Rails.linkDisableSelector)) {
          return disableLinkElement(element);
        } else if (
          matches(element, Rails.buttonDisableSelector) ||
          matches(element, Rails.formDisableSelector)
        ) {
          return disableFormElement(element);
        } else if (matches(element, Rails.formSubmitSelector)) {
          return disableFormElements(element);
        }
      };

      disableLinkElement = function (element) {
        var replacement;
        if (getData(element, "ujs:disabled")) {
          return;
        }
        replacement = element.getAttribute("data-disable-with");
        if (replacement != null) {
          setData(element, "ujs:enable-with", element.innerHTML);
          element.innerHTML = replacement;
        }
        element.addEventListener("click", stopEverything);
        return setData(element, "ujs:disabled", true);
      };

      enableLinkElement = function (element) {
        var originalText;
        originalText = getData(element, "ujs:enable-with");
        if (originalText != null) {
          element.innerHTML = originalText;
          setData(element, "ujs:enable-with", null);
        }
        element.removeEventListener("click", stopEverything);
        return setData(element, "ujs:disabled", null);
      };

      disableFormElements = function (form) {
        return formElements(form, Rails.formDisableSelector).forEach(
          disableFormElement
        );
      };

      disableFormElement = function (element) {
        var replacement;
        if (getData(element, "ujs:disabled")) {
          return;
        }
        replacement = element.getAttribute("data-disable-with");
        if (replacement != null) {
          if (matches(element, "button")) {
            setData(element, "ujs:enable-with", element.innerHTML);
            element.innerHTML = replacement;
          } else {
            setData(element, "ujs:enable-with", element.value);
            element.value = replacement;
          }
        }
        element.disabled = true;
        return setData(element, "ujs:disabled", true);
      };

      enableFormElements = function (form) {
        return formElements(form, Rails.formEnableSelector).forEach(
          enableFormElement
        );
      };

      enableFormElement = function (element) {
        var originalText;
        originalText = getData(element, "ujs:enable-with");
        if (originalText != null) {
          if (matches(element, "button")) {
            element.innerHTML = originalText;
          } else {
            element.value = originalText;
          }
          setData(element, "ujs:enable-with", null);
        }
        element.disabled = false;
        return setData(element, "ujs:disabled", null);
      };

      isXhrRedirect = function (event) {
        var ref, xhr;
        xhr = (ref = event.detail) != null ? ref[0] : void 0;
        return (
          (xhr != null ? xhr.getResponseHeader("X-Xhr-Redirect") : void 0) !=
          null
        );
      };
    }).call(this);
    (function () {
      var isContentEditable, stopEverything;

      stopEverything = Rails.stopEverything;

      isContentEditable = Rails.isContentEditable;

      Rails.handleMethod = function (e) {
        var csrfParam, csrfToken, form, formContent, href, link, method;
        link = this;
        method = link.getAttribute("data-method");
        if (!method) {
          return;
        }
        if (isContentEditable(this)) {
          return;
        }
        href = Rails.href(link);
        csrfToken = Rails.csrfToken();
        csrfParam = Rails.csrfParam();
        form = document.createElement("form");
        formContent =
          "<input name='_method' value='" + method + "' type='hidden' />";
        if (
          csrfParam != null &&
          csrfToken != null &&
          !Rails.isCrossDomain(href)
        ) {
          formContent +=
            "<input name='" +
            csrfParam +
            "' value='" +
            csrfToken +
            "' type='hidden' />";
        }
        formContent += '<input type="submit" />';
        form.method = "post";
        form.action = href;
        form.target = link.target;
        form.innerHTML = formContent;
        form.style.display = "none";
        document.body.appendChild(form);
        form.querySelector('[type="submit"]').click();
        return stopEverything(e);
      };
    }).call(this);
    (function () {
      var ajax,
        fire,
        getData,
        isContentEditable,
        isCrossDomain,
        isRemote,
        matches,
        serializeElement,
        setData,
        stopEverything,
        slice = [].slice;

      (matches = Rails.matches),
        (getData = Rails.getData),
        (setData = Rails.setData),
        (fire = Rails.fire),
        (stopEverything = Rails.stopEverything),
        (ajax = Rails.ajax),
        (isCrossDomain = Rails.isCrossDomain),
        (serializeElement = Rails.serializeElement),
        (isContentEditable = Rails.isContentEditable);

      isRemote = function (element) {
        var value;
        value = element.getAttribute("data-remote");
        return value != null && value !== "false";
      };

      Rails.handleRemote = function (e) {
        var button, data, dataType, element, method, url, withCredentials;
        element = this;
        if (!isRemote(element)) {
          return true;
        }
        if (!fire(element, "ajax:before")) {
          fire(element, "ajax:stopped");
          return false;
        }
        if (isContentEditable(element)) {
          fire(element, "ajax:stopped");
          return false;
        }
        withCredentials = element.getAttribute("data-with-credentials");
        dataType = element.getAttribute("data-type") || "script";
        if (matches(element, Rails.formSubmitSelector)) {
          button = getData(element, "ujs:submit-button");
          method =
            getData(element, "ujs:submit-button-formmethod") || element.method;
          url =
            getData(element, "ujs:submit-button-formaction") ||
            element.getAttribute("action") ||
            location.href;
          if (method.toUpperCase() === "GET") {
            url = url.replace(/\?.*$/, "");
          }
          if (element.enctype === "multipart/form-data") {
            data = new FormData(element);
            if (button != null) {
              data.append(button.name, button.value);
            }
          } else {
            data = serializeElement(element, button);
          }
          setData(element, "ujs:submit-button", null);
          setData(element, "ujs:submit-button-formmethod", null);
          setData(element, "ujs:submit-button-formaction", null);
        } else if (
          matches(element, Rails.buttonClickSelector) ||
          matches(element, Rails.inputChangeSelector)
        ) {
          method = element.getAttribute("data-method");
          url = element.getAttribute("data-url");
          data = serializeElement(element, element.getAttribute("data-params"));
        } else {
          method = element.getAttribute("data-method");
          url = Rails.href(element);
          data = element.getAttribute("data-params");
        }
        ajax({
          type: method || "GET",
          url: url,
          data: data,
          dataType: dataType,
          beforeSend: function (xhr, options) {
            if (fire(element, "ajax:beforeSend", [xhr, options])) {
              return fire(element, "ajax:send", [xhr]);
            } else {
              fire(element, "ajax:stopped");
              return false;
            }
          },
          success: function () {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return fire(element, "ajax:success", args);
          },
          error: function () {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return fire(element, "ajax:error", args);
          },
          complete: function () {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return fire(element, "ajax:complete", args);
          },
          crossDomain: isCrossDomain(url),
          withCredentials:
            withCredentials != null && withCredentials !== "false",
        });
        return stopEverything(e);
      };

      Rails.formSubmitButtonClick = function (e) {
        var button, form;
        button = this;
        form = button.form;
        if (!form) {
          return;
        }
        if (button.name) {
          setData(form, "ujs:submit-button", {
            name: button.name,
            value: button.value,
          });
        }
        setData(form, "ujs:formnovalidate-button", button.formNoValidate);
        setData(
          form,
          "ujs:submit-button-formaction",
          button.getAttribute("formaction")
        );
        return setData(
          form,
          "ujs:submit-button-formmethod",
          button.getAttribute("formmethod")
        );
      };

      Rails.preventInsignificantClick = function (e) {
        var data,
          insignificantMetaClick,
          link,
          metaClick,
          method,
          nonPrimaryMouseClick;
        link = this;
        method = (link.getAttribute("data-method") || "GET").toUpperCase();
        data = link.getAttribute("data-params");
        metaClick = e.metaKey || e.ctrlKey;
        insignificantMetaClick = metaClick && method === "GET" && !data;
        nonPrimaryMouseClick = e.button != null && e.button !== 0;
        if (nonPrimaryMouseClick || insignificantMetaClick) {
          return e.stopImmediatePropagation();
        }
      };
    }).call(this);
    (function () {
      var $,
        CSRFProtection,
        delegate,
        disableElement,
        enableElement,
        fire,
        formSubmitButtonClick,
        getData,
        handleConfirm,
        handleDisabledElement,
        handleMethod,
        handleRemote,
        loadCSPNonce,
        preventInsignificantClick,
        refreshCSRFTokens;

      (fire = Rails.fire),
        (delegate = Rails.delegate),
        (getData = Rails.getData),
        ($ = Rails.$),
        (refreshCSRFTokens = Rails.refreshCSRFTokens),
        (CSRFProtection = Rails.CSRFProtection),
        (loadCSPNonce = Rails.loadCSPNonce),
        (enableElement = Rails.enableElement),
        (disableElement = Rails.disableElement),
        (handleDisabledElement = Rails.handleDisabledElement),
        (handleConfirm = Rails.handleConfirm),
        (preventInsignificantClick = Rails.preventInsignificantClick),
        (handleRemote = Rails.handleRemote),
        (formSubmitButtonClick = Rails.formSubmitButtonClick),
        (handleMethod = Rails.handleMethod);

      if (
        typeof jQuery !== "undefined" &&
        jQuery !== null &&
        jQuery.ajax != null
      ) {
        if (jQuery.rails) {
          throw new Error(
            "If you load both jquery_ujs and rails-ujs, use rails-ujs only."
          );
        }
        jQuery.rails = Rails;
        jQuery.ajaxPrefilter(function (options, originalOptions, xhr) {
          if (!options.crossDomain) {
            return CSRFProtection(xhr);
          }
        });
      }

      Rails.start = function () {
        if (window._rails_loaded) {
          throw new Error("rails-ujs has already been loaded!");
        }
        window.addEventListener("pageshow", function () {
          $(Rails.formEnableSelector).forEach(function (el) {
            if (getData(el, "ujs:disabled")) {
              return enableElement(el);
            }
          });
          return $(Rails.linkDisableSelector).forEach(function (el) {
            if (getData(el, "ujs:disabled")) {
              return enableElement(el);
            }
          });
        });
        delegate(
          document,
          Rails.linkDisableSelector,
          "ajax:complete",
          enableElement
        );
        delegate(
          document,
          Rails.linkDisableSelector,
          "ajax:stopped",
          enableElement
        );
        delegate(
          document,
          Rails.buttonDisableSelector,
          "ajax:complete",
          enableElement
        );
        delegate(
          document,
          Rails.buttonDisableSelector,
          "ajax:stopped",
          enableElement
        );
        delegate(
          document,
          Rails.linkClickSelector,
          "click",
          preventInsignificantClick
        );
        delegate(
          document,
          Rails.linkClickSelector,
          "click",
          handleDisabledElement
        );
        delegate(document, Rails.linkClickSelector, "click", handleConfirm);
        delegate(document, Rails.linkClickSelector, "click", disableElement);
        delegate(document, Rails.linkClickSelector, "click", handleRemote);
        delegate(document, Rails.linkClickSelector, "click", handleMethod);
        delegate(
          document,
          Rails.buttonClickSelector,
          "click",
          preventInsignificantClick
        );
        delegate(
          document,
          Rails.buttonClickSelector,
          "click",
          handleDisabledElement
        );
        delegate(document, Rails.buttonClickSelector, "click", handleConfirm);
        delegate(document, Rails.buttonClickSelector, "click", disableElement);
        delegate(document, Rails.buttonClickSelector, "click", handleRemote);
        delegate(
          document,
          Rails.inputChangeSelector,
          "change",
          handleDisabledElement
        );
        delegate(document, Rails.inputChangeSelector, "change", handleConfirm);
        delegate(document, Rails.inputChangeSelector, "change", handleRemote);
        delegate(
          document,
          Rails.formSubmitSelector,
          "submit",
          handleDisabledElement
        );
        delegate(document, Rails.formSubmitSelector, "submit", handleConfirm);
        delegate(document, Rails.formSubmitSelector, "submit", handleRemote);
        delegate(document, Rails.formSubmitSelector, "submit", function (e) {
          return setTimeout(function () {
            return disableElement(e);
          }, 13);
        });
        delegate(
          document,
          Rails.formSubmitSelector,
          "ajax:send",
          disableElement
        );
        delegate(
          document,
          Rails.formSubmitSelector,
          "ajax:complete",
          enableElement
        );
        delegate(
          document,
          Rails.formInputClickSelector,
          "click",
          preventInsignificantClick
        );
        delegate(
          document,
          Rails.formInputClickSelector,
          "click",
          handleDisabledElement
        );
        delegate(
          document,
          Rails.formInputClickSelector,
          "click",
          handleConfirm
        );
        delegate(
          document,
          Rails.formInputClickSelector,
          "click",
          formSubmitButtonClick
        );
        document.addEventListener("DOMContentLoaded", refreshCSRFTokens);
        document.addEventListener("DOMContentLoaded", loadCSPNonce);
        return (window._rails_loaded = true);
      };

      if (window.Rails === Rails && fire(document, "rails:attachBindings")) {
        Rails.start();
      }
    }).call(this);
  }).call(this);

  if (typeof module === "object" && module.exports) {
    module.exports = Rails;
  } else if (typeof define === "function" && define.amd) {
    define(Rails);
  }
}).call(this);
/*
Turbolinks 5.2.0
Copyright Â© 2018 Basecamp, LLC
 */
(function () {
  var t = this;
  (function () {
    (function () {
      this.Turbolinks = {
        supported: (function () {
          return (
            null != window.history.pushState &&
            null != window.requestAnimationFrame &&
            null != window.addEventListener
          );
        })(),
        visit: function (t, r) {
          return e.controller.visit(t, r);
        },
        clearCache: function () {
          return e.controller.clearCache();
        },
        setProgressBarDelay: function (t) {
          return e.controller.setProgressBarDelay(t);
        },
      };
    }).call(this);
  }).call(t);
  var e = t.Turbolinks;
  (function () {
    (function () {
      var t,
        r,
        n,
        o = [].slice;
      (e.copyObject = function (t) {
        var e, r, n;
        r = {};
        for (e in t) (n = t[e]), (r[e] = n);
        return r;
      }),
        (e.closest = function (e, r) {
          return t.call(e, r);
        }),
        (t = (function () {
          var t, e;
          return (
            (t = document.documentElement),
            null != (e = t.closest)
              ? e
              : function (t) {
                  var e;
                  for (e = this; e; ) {
                    if (e.nodeType === Node.ELEMENT_NODE && r.call(e, t))
                      return e;
                    e = e.parentNode;
                  }
                }
          );
        })()),
        (e.defer = function (t) {
          return setTimeout(t, 1);
        }),
        (e.throttle = function (t) {
          var e;
          return (
            (e = null),
            function () {
              var r;
              return (
                (r = 1 <= arguments.length ? o.call(arguments, 0) : []),
                null != e
                  ? e
                  : (e = requestAnimationFrame(
                      (function (n) {
                        return function () {
                          return (e = null), t.apply(n, r);
                        };
                      })(this)
                    ))
              );
            }
          );
        }),
        (e.dispatch = function (t, e) {
          var r, o, i, s, a, u;
          return (
            (a = null != e ? e : {}),
            (u = a.target),
            (r = a.cancelable),
            (o = a.data),
            (i = document.createEvent("Events")),
            i.initEvent(t, !0, r === !0),
            (i.data = null != o ? o : {}),
            i.cancelable &&
              !n &&
              ((s = i.preventDefault),
              (i.preventDefault = function () {
                return (
                  this.defaultPrevented ||
                    Object.defineProperty(this, "defaultPrevented", {
                      get: function () {
                        return !0;
                      },
                    }),
                  s.call(this)
                );
              })),
            (null != u ? u : document).dispatchEvent(i),
            i
          );
        }),
        (n = (function () {
          var t;
          return (
            (t = document.createEvent("Events")),
            t.initEvent("test", !0, !0),
            t.preventDefault(),
            t.defaultPrevented
          );
        })()),
        (e.match = function (t, e) {
          return r.call(t, e);
        }),
        (r = (function () {
          var t, e, r, n;
          return (
            (t = document.documentElement),
            null !=
            (e =
              null !=
              (r =
                null != (n = t.matchesSelector) ? n : t.webkitMatchesSelector)
                ? r
                : t.msMatchesSelector)
              ? e
              : t.mozMatchesSelector
          );
        })()),
        (e.uuid = function () {
          var t, e, r;
          for (r = "", t = e = 1; 36 >= e; t = ++e)
            r +=
              9 === t || 14 === t || 19 === t || 24 === t
                ? "-"
                : 15 === t
                ? "4"
                : 20 === t
                ? (Math.floor(4 * Math.random()) + 8).toString(16)
                : Math.floor(15 * Math.random()).toString(16);
          return r;
        });
    }).call(this),
      function () {
        e.Location = (function () {
          function t(t) {
            var e, r;
            null == t && (t = ""),
              (r = document.createElement("a")),
              (r.href = t.toString()),
              (this.absoluteURL = r.href),
              (e = r.hash.length),
              2 > e
                ? (this.requestURL = this.absoluteURL)
                : ((this.requestURL = this.absoluteURL.slice(0, -e)),
                  (this.anchor = r.hash.slice(1)));
          }
          var e, r, n, o;
          return (
            (t.wrap = function (t) {
              return t instanceof this ? t : new this(t);
            }),
            (t.prototype.getOrigin = function () {
              return this.absoluteURL.split("/", 3).join("/");
            }),
            (t.prototype.getPath = function () {
              var t, e;
              return null !=
                (t =
                  null != (e = this.requestURL.match(/\/\/[^\/]*(\/[^?;]*)/))
                    ? e[1]
                    : void 0)
                ? t
                : "/";
            }),
            (t.prototype.getPathComponents = function () {
              return this.getPath().split("/").slice(1);
            }),
            (t.prototype.getLastPathComponent = function () {
              return this.getPathComponents().slice(-1)[0];
            }),
            (t.prototype.getExtension = function () {
              var t, e;
              return null !=
                (t =
                  null != (e = this.getLastPathComponent().match(/\.[^.]*$/))
                    ? e[0]
                    : void 0)
                ? t
                : "";
            }),
            (t.prototype.isHTML = function () {
              return this.getExtension().match(/^(?:|\.(?:htm|html|xhtml))$/);
            }),
            (t.prototype.isPrefixedBy = function (t) {
              var e;
              return (e = r(t)), this.isEqualTo(t) || o(this.absoluteURL, e);
            }),
            (t.prototype.isEqualTo = function (t) {
              return this.absoluteURL === (null != t ? t.absoluteURL : void 0);
            }),
            (t.prototype.toCacheKey = function () {
              return this.requestURL;
            }),
            (t.prototype.toJSON = function () {
              return this.absoluteURL;
            }),
            (t.prototype.toString = function () {
              return this.absoluteURL;
            }),
            (t.prototype.valueOf = function () {
              return this.absoluteURL;
            }),
            (r = function (t) {
              return e(t.getOrigin() + t.getPath());
            }),
            (e = function (t) {
              return n(t, "/") ? t : t + "/";
            }),
            (o = function (t, e) {
              return t.slice(0, e.length) === e;
            }),
            (n = function (t, e) {
              return t.slice(-e.length) === e;
            }),
            t
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.HttpRequest = (function () {
          function r(r, n, o) {
            (this.delegate = r),
              (this.requestCanceled = t(this.requestCanceled, this)),
              (this.requestTimedOut = t(this.requestTimedOut, this)),
              (this.requestFailed = t(this.requestFailed, this)),
              (this.requestLoaded = t(this.requestLoaded, this)),
              (this.requestProgressed = t(this.requestProgressed, this)),
              (this.url = e.Location.wrap(n).requestURL),
              (this.referrer = e.Location.wrap(o).absoluteURL),
              this.createXHR();
          }
          return (
            (r.NETWORK_FAILURE = 0),
            (r.TIMEOUT_FAILURE = -1),
            (r.timeout = 60),
            (r.prototype.send = function () {
              var t;
              return this.xhr && !this.sent
                ? (this.notifyApplicationBeforeRequestStart(),
                  this.setProgress(0),
                  this.xhr.send(),
                  (this.sent = !0),
                  "function" == typeof (t = this.delegate).requestStarted
                    ? t.requestStarted()
                    : void 0)
                : void 0;
            }),
            (r.prototype.cancel = function () {
              return this.xhr && this.sent ? this.xhr.abort() : void 0;
            }),
            (r.prototype.requestProgressed = function (t) {
              return t.lengthComputable
                ? this.setProgress(t.loaded / t.total)
                : void 0;
            }),
            (r.prototype.requestLoaded = function () {
              return this.endRequest(
                (function (t) {
                  return function () {
                    var e;
                    return 200 <= (e = t.xhr.status) && 300 > e
                      ? t.delegate.requestCompletedWithResponse(
                          t.xhr.responseText,
                          t.xhr.getResponseHeader("Turbolinks-Location")
                        )
                      : ((t.failed = !0),
                        t.delegate.requestFailedWithStatusCode(
                          t.xhr.status,
                          t.xhr.responseText
                        ));
                  };
                })(this)
              );
            }),
            (r.prototype.requestFailed = function () {
              return this.endRequest(
                (function (t) {
                  return function () {
                    return (
                      (t.failed = !0),
                      t.delegate.requestFailedWithStatusCode(
                        t.constructor.NETWORK_FAILURE
                      )
                    );
                  };
                })(this)
              );
            }),
            (r.prototype.requestTimedOut = function () {
              return this.endRequest(
                (function (t) {
                  return function () {
                    return (
                      (t.failed = !0),
                      t.delegate.requestFailedWithStatusCode(
                        t.constructor.TIMEOUT_FAILURE
                      )
                    );
                  };
                })(this)
              );
            }),
            (r.prototype.requestCanceled = function () {
              return this.endRequest();
            }),
            (r.prototype.notifyApplicationBeforeRequestStart = function () {
              return e.dispatch("turbolinks:request-start", {
                data: { url: this.url, xhr: this.xhr },
              });
            }),
            (r.prototype.notifyApplicationAfterRequestEnd = function () {
              return e.dispatch("turbolinks:request-end", {
                data: { url: this.url, xhr: this.xhr },
              });
            }),
            (r.prototype.createXHR = function () {
              return (
                (this.xhr = new XMLHttpRequest()),
                this.xhr.open("GET", this.url, !0),
                (this.xhr.timeout = 1e3 * this.constructor.timeout),
                this.xhr.setRequestHeader(
                  "Accept",
                  "text/html, application/xhtml+xml"
                ),
                this.xhr.setRequestHeader("Turbolinks-Referrer", this.referrer),
                (this.xhr.onprogress = this.requestProgressed),
                (this.xhr.onload = this.requestLoaded),
                (this.xhr.onerror = this.requestFailed),
                (this.xhr.ontimeout = this.requestTimedOut),
                (this.xhr.onabort = this.requestCanceled)
              );
            }),
            (r.prototype.endRequest = function (t) {
              return this.xhr
                ? (this.notifyApplicationAfterRequestEnd(),
                  null != t && t.call(this),
                  this.destroy())
                : void 0;
            }),
            (r.prototype.setProgress = function (t) {
              var e;
              return (
                (this.progress = t),
                "function" == typeof (e = this.delegate).requestProgressed
                  ? e.requestProgressed(this.progress)
                  : void 0
              );
            }),
            (r.prototype.destroy = function () {
              var t;
              return (
                this.setProgress(1),
                "function" == typeof (t = this.delegate).requestFinished &&
                  t.requestFinished(),
                (this.delegate = null),
                (this.xhr = null)
              );
            }),
            r
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.ProgressBar = (function () {
          function e() {
            (this.trickle = t(this.trickle, this)),
              (this.stylesheetElement = this.createStylesheetElement()),
              (this.progressElement = this.createProgressElement());
          }
          var r;
          return (
            (r = 300),
            (e.defaultCSS =
              ".turbolinks-progress-bar {\n  position: fixed;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 3px;\n  background: #0076ff;\n  z-index: 9999;\n  transition: width " +
              r +
              "ms ease-out, opacity " +
              r / 2 +
              "ms " +
              r / 2 +
              "ms ease-in;\n  transform: translate3d(0, 0, 0);\n}"),
            (e.prototype.show = function () {
              return this.visible
                ? void 0
                : ((this.visible = !0),
                  this.installStylesheetElement(),
                  this.installProgressElement(),
                  this.startTrickling());
            }),
            (e.prototype.hide = function () {
              return this.visible && !this.hiding
                ? ((this.hiding = !0),
                  this.fadeProgressElement(
                    (function (t) {
                      return function () {
                        return (
                          t.uninstallProgressElement(),
                          t.stopTrickling(),
                          (t.visible = !1),
                          (t.hiding = !1)
                        );
                      };
                    })(this)
                  ))
                : void 0;
            }),
            (e.prototype.setValue = function (t) {
              return (this.value = t), this.refresh();
            }),
            (e.prototype.installStylesheetElement = function () {
              return document.head.insertBefore(
                this.stylesheetElement,
                document.head.firstChild
              );
            }),
            (e.prototype.installProgressElement = function () {
              return (
                (this.progressElement.style.width = 0),
                (this.progressElement.style.opacity = 1),
                document.documentElement.insertBefore(
                  this.progressElement,
                  document.body
                ),
                this.refresh()
              );
            }),
            (e.prototype.fadeProgressElement = function (t) {
              return (
                (this.progressElement.style.opacity = 0), setTimeout(t, 1.5 * r)
              );
            }),
            (e.prototype.uninstallProgressElement = function () {
              return this.progressElement.parentNode
                ? document.documentElement.removeChild(this.progressElement)
                : void 0;
            }),
            (e.prototype.startTrickling = function () {
              return null != this.trickleInterval
                ? this.trickleInterval
                : (this.trickleInterval = setInterval(this.trickle, r));
            }),
            (e.prototype.stopTrickling = function () {
              return (
                clearInterval(this.trickleInterval),
                (this.trickleInterval = null)
              );
            }),
            (e.prototype.trickle = function () {
              return this.setValue(this.value + Math.random() / 100);
            }),
            (e.prototype.refresh = function () {
              return requestAnimationFrame(
                (function (t) {
                  return function () {
                    return (t.progressElement.style.width =
                      10 + 90 * t.value + "%");
                  };
                })(this)
              );
            }),
            (e.prototype.createStylesheetElement = function () {
              var t;
              return (
                (t = document.createElement("style")),
                (t.type = "text/css"),
                (t.textContent = this.constructor.defaultCSS),
                t
              );
            }),
            (e.prototype.createProgressElement = function () {
              var t;
              return (
                (t = document.createElement("div")),
                (t.className = "turbolinks-progress-bar"),
                t
              );
            }),
            e
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.BrowserAdapter = (function () {
          function r(r) {
            (this.controller = r),
              (this.showProgressBar = t(this.showProgressBar, this)),
              (this.progressBar = new e.ProgressBar());
          }
          var n, o, i;
          return (
            (i = e.HttpRequest),
            (n = i.NETWORK_FAILURE),
            (o = i.TIMEOUT_FAILURE),
            (r.prototype.visitProposedToLocationWithAction = function (t, e) {
              return this.controller.startVisitToLocationWithAction(t, e);
            }),
            (r.prototype.visitStarted = function (t) {
              return (
                t.issueRequest(), t.changeHistory(), t.loadCachedSnapshot()
              );
            }),
            (r.prototype.visitRequestStarted = function (t) {
              return (
                this.progressBar.setValue(0),
                t.hasCachedSnapshot() || "restore" !== t.action
                  ? this.showProgressBarAfterDelay()
                  : this.showProgressBar()
              );
            }),
            (r.prototype.visitRequestProgressed = function (t) {
              return this.progressBar.setValue(t.progress);
            }),
            (r.prototype.visitRequestCompleted = function (t) {
              return t.loadResponse();
            }),
            (r.prototype.visitRequestFailedWithStatusCode = function (t, e) {
              switch (e) {
                case n:
                case o:
                  return this.reload();
                default:
                  return t.loadResponse();
              }
            }),
            (r.prototype.visitRequestFinished = function (t) {
              return this.hideProgressBar();
            }),
            (r.prototype.visitCompleted = function (t) {
              return t.followRedirect();
            }),
            (r.prototype.pageInvalidated = function () {
              return this.reload();
            }),
            (r.prototype.showProgressBarAfterDelay = function () {
              return (this.progressBarTimeout = setTimeout(
                this.showProgressBar,
                this.controller.progressBarDelay
              ));
            }),
            (r.prototype.showProgressBar = function () {
              return this.progressBar.show();
            }),
            (r.prototype.hideProgressBar = function () {
              return (
                this.progressBar.hide(), clearTimeout(this.progressBarTimeout)
              );
            }),
            (r.prototype.reload = function () {
              return window.location.reload();
            }),
            r
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.History = (function () {
          function r(e) {
            (this.delegate = e),
              (this.onPageLoad = t(this.onPageLoad, this)),
              (this.onPopState = t(this.onPopState, this));
          }
          return (
            (r.prototype.start = function () {
              return this.started
                ? void 0
                : (addEventListener("popstate", this.onPopState, !1),
                  addEventListener("load", this.onPageLoad, !1),
                  (this.started = !0));
            }),
            (r.prototype.stop = function () {
              return this.started
                ? (removeEventListener("popstate", this.onPopState, !1),
                  removeEventListener("load", this.onPageLoad, !1),
                  (this.started = !1))
                : void 0;
            }),
            (r.prototype.push = function (t, r) {
              return (t = e.Location.wrap(t)), this.update("push", t, r);
            }),
            (r.prototype.replace = function (t, r) {
              return (t = e.Location.wrap(t)), this.update("replace", t, r);
            }),
            (r.prototype.onPopState = function (t) {
              var r, n, o, i;
              return this.shouldHandlePopState() &&
                (i = null != (n = t.state) ? n.turbolinks : void 0)
                ? ((r = e.Location.wrap(window.location)),
                  (o = i.restorationIdentifier),
                  this.delegate.historyPoppedToLocationWithRestorationIdentifier(
                    r,
                    o
                  ))
                : void 0;
            }),
            (r.prototype.onPageLoad = function (t) {
              return e.defer(
                (function (t) {
                  return function () {
                    return (t.pageLoaded = !0);
                  };
                })(this)
              );
            }),
            (r.prototype.shouldHandlePopState = function () {
              return this.pageIsLoaded();
            }),
            (r.prototype.pageIsLoaded = function () {
              return this.pageLoaded || "complete" === document.readyState;
            }),
            (r.prototype.update = function (t, e, r) {
              var n;
              return (
                (n = { turbolinks: { restorationIdentifier: r } }),
                history[t + "State"](n, null, e)
              );
            }),
            r
          );
        })();
      }.call(this),
      function () {
        e.HeadDetails = (function () {
          function t(t) {
            var e, r, n, s, a, u;
            for (this.elements = {}, n = 0, a = t.length; a > n; n++)
              (u = t[n]),
                u.nodeType === Node.ELEMENT_NODE &&
                  ((s = u.outerHTML),
                  (r =
                    null != (e = this.elements)[s]
                      ? e[s]
                      : (e[s] = { type: i(u), tracked: o(u), elements: [] })),
                  r.elements.push(u));
          }
          var e, r, n, o, i;
          return (
            (t.fromHeadElement = function (t) {
              var e;
              return new this(
                null != (e = null != t ? t.childNodes : void 0) ? e : []
              );
            }),
            (t.prototype.hasElementWithKey = function (t) {
              return t in this.elements;
            }),
            (t.prototype.getTrackedElementSignature = function () {
              var t, e;
              return function () {
                var r, n;
                (r = this.elements), (n = []);
                for (t in r) (e = r[t].tracked), e && n.push(t);
                return n;
              }
                .call(this)
                .join("");
            }),
            (t.prototype.getScriptElementsNotInDetails = function (t) {
              return this.getElementsMatchingTypeNotInDetails("script", t);
            }),
            (t.prototype.getStylesheetElementsNotInDetails = function (t) {
              return this.getElementsMatchingTypeNotInDetails("stylesheet", t);
            }),
            (t.prototype.getElementsMatchingTypeNotInDetails = function (t, e) {
              var r, n, o, i, s, a;
              (o = this.elements), (s = []);
              for (n in o)
                (i = o[n]),
                  (a = i.type),
                  (r = i.elements),
                  a !== t || e.hasElementWithKey(n) || s.push(r[0]);
              return s;
            }),
            (t.prototype.getProvisionalElements = function () {
              var t, e, r, n, o, i, s;
              (r = []), (n = this.elements);
              for (e in n)
                (o = n[e]),
                  (s = o.type),
                  (i = o.tracked),
                  (t = o.elements),
                  null != s || i
                    ? t.length > 1 && r.push.apply(r, t.slice(1))
                    : r.push.apply(r, t);
              return r;
            }),
            (t.prototype.getMetaValue = function (t) {
              var e;
              return null != (e = this.findMetaElementByName(t))
                ? e.getAttribute("content")
                : void 0;
            }),
            (t.prototype.findMetaElementByName = function (t) {
              var r, n, o, i;
              (r = void 0), (i = this.elements);
              for (o in i) (n = i[o].elements), e(n[0], t) && (r = n[0]);
              return r;
            }),
            (i = function (t) {
              return r(t) ? "script" : n(t) ? "stylesheet" : void 0;
            }),
            (o = function (t) {
              return "reload" === t.getAttribute("data-turbolinks-track");
            }),
            (r = function (t) {
              var e;
              return (e = t.tagName.toLowerCase()), "script" === e;
            }),
            (n = function (t) {
              var e;
              return (
                (e = t.tagName.toLowerCase()),
                "style" === e ||
                  ("link" === e && "stylesheet" === t.getAttribute("rel"))
              );
            }),
            (e = function (t, e) {
              var r;
              return (
                (r = t.tagName.toLowerCase()),
                "meta" === r && t.getAttribute("name") === e
              );
            }),
            t
          );
        })();
      }.call(this),
      function () {
        e.Snapshot = (function () {
          function t(t, e) {
            (this.headDetails = t), (this.bodyElement = e);
          }
          return (
            (t.wrap = function (t) {
              return t instanceof this
                ? t
                : "string" == typeof t
                ? this.fromHTMLString(t)
                : this.fromHTMLElement(t);
            }),
            (t.fromHTMLString = function (t) {
              var e;
              return (
                (e = document.createElement("html")),
                (e.innerHTML = t),
                this.fromHTMLElement(e)
              );
            }),
            (t.fromHTMLElement = function (t) {
              var r, n, o, i;
              return (
                (o = t.querySelector("head")),
                (r =
                  null != (i = t.querySelector("body"))
                    ? i
                    : document.createElement("body")),
                (n = e.HeadDetails.fromHeadElement(o)),
                new this(n, r)
              );
            }),
            (t.prototype.clone = function () {
              return new this.constructor(
                this.headDetails,
                this.bodyElement.cloneNode(!0)
              );
            }),
            (t.prototype.getRootLocation = function () {
              var t, r;
              return (
                (r = null != (t = this.getSetting("root")) ? t : "/"),
                new e.Location(r)
              );
            }),
            (t.prototype.getCacheControlValue = function () {
              return this.getSetting("cache-control");
            }),
            (t.prototype.getElementForAnchor = function (t) {
              try {
                return this.bodyElement.querySelector(
                  "[id='" + t + "'], a[name='" + t + "']"
                );
              } catch (e) {}
            }),
            (t.prototype.getPermanentElements = function () {
              return this.bodyElement.querySelectorAll(
                "[id][data-turbolinks-permanent]"
              );
            }),
            (t.prototype.getPermanentElementById = function (t) {
              return this.bodyElement.querySelector(
                "#" + t + "[data-turbolinks-permanent]"
              );
            }),
            (t.prototype.getPermanentElementsPresentInSnapshot = function (t) {
              var e, r, n, o, i;
              for (
                o = this.getPermanentElements(), i = [], r = 0, n = o.length;
                n > r;
                r++
              )
                (e = o[r]), t.getPermanentElementById(e.id) && i.push(e);
              return i;
            }),
            (t.prototype.findFirstAutofocusableElement = function () {
              return this.bodyElement.querySelector("[autofocus]");
            }),
            (t.prototype.hasAnchor = function (t) {
              return null != this.getElementForAnchor(t);
            }),
            (t.prototype.isPreviewable = function () {
              return "no-preview" !== this.getCacheControlValue();
            }),
            (t.prototype.isCacheable = function () {
              return "no-cache" !== this.getCacheControlValue();
            }),
            (t.prototype.isVisitable = function () {
              return "reload" !== this.getSetting("visit-control");
            }),
            (t.prototype.getSetting = function (t) {
              return this.headDetails.getMetaValue("turbolinks-" + t);
            }),
            t
          );
        })();
      }.call(this),
      function () {
        var t = [].slice;
        e.Renderer = (function () {
          function e() {}
          var r;
          return (
            (e.render = function () {
              var e, r, n, o;
              return (
                (n = arguments[0]),
                (r = arguments[1]),
                (e = 3 <= arguments.length ? t.call(arguments, 2) : []),
                (o = (function (t, e, r) {
                  r.prototype = t.prototype;
                  var n = new r(),
                    o = t.apply(n, e);
                  return Object(o) === o ? o : n;
                })(this, e, function () {})),
                (o.delegate = n),
                o.render(r),
                o
              );
            }),
            (e.prototype.renderView = function (t) {
              return (
                this.delegate.viewWillRender(this.newBody),
                t(),
                this.delegate.viewRendered(this.newBody)
              );
            }),
            (e.prototype.invalidateView = function () {
              return this.delegate.viewInvalidated();
            }),
            (e.prototype.createScriptElement = function (t) {
              var e;
              return "false" === t.getAttribute("data-turbolinks-eval")
                ? t
                : ((e = document.createElement("script")),
                  (e.textContent = t.textContent),
                  (e.async = !1),
                  r(e, t),
                  e);
            }),
            (r = function (t, e) {
              var r, n, o, i, s, a, u;
              for (i = e.attributes, a = [], r = 0, n = i.length; n > r; r++)
                (s = i[r]),
                  (o = s.name),
                  (u = s.value),
                  a.push(t.setAttribute(o, u));
              return a;
            }),
            e
          );
        })();
      }.call(this),
      function () {
        var t,
          r,
          n = function (t, e) {
            function r() {
              this.constructor = t;
            }
            for (var n in e) o.call(e, n) && (t[n] = e[n]);
            return (
              (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.__super__ = e.prototype),
              t
            );
          },
          o = {}.hasOwnProperty;
        (e.SnapshotRenderer = (function (e) {
          function o(t, e, r) {
            (this.currentSnapshot = t),
              (this.newSnapshot = e),
              (this.isPreview = r),
              (this.currentHeadDetails = this.currentSnapshot.headDetails),
              (this.newHeadDetails = this.newSnapshot.headDetails),
              (this.currentBody = this.currentSnapshot.bodyElement),
              (this.newBody = this.newSnapshot.bodyElement);
          }
          return (
            n(o, e),
            (o.prototype.render = function (t) {
              return this.shouldRender()
                ? (this.mergeHead(),
                  this.renderView(
                    (function (e) {
                      return function () {
                        return (
                          e.replaceBody(),
                          e.isPreview || e.focusFirstAutofocusableElement(),
                          t()
                        );
                      };
                    })(this)
                  ))
                : this.invalidateView();
            }),
            (o.prototype.mergeHead = function () {
              return (
                this.copyNewHeadStylesheetElements(),
                this.copyNewHeadScriptElements(),
                this.removeCurrentHeadProvisionalElements(),
                this.copyNewHeadProvisionalElements()
              );
            }),
            (o.prototype.replaceBody = function () {
              var t;
              return (
                (t = this.relocateCurrentBodyPermanentElements()),
                this.activateNewBodyScriptElements(),
                this.assignNewBody(),
                this.replacePlaceholderElementsWithClonedPermanentElements(t)
              );
            }),
            (o.prototype.shouldRender = function () {
              return (
                this.newSnapshot.isVisitable() &&
                this.trackedElementsAreIdentical()
              );
            }),
            (o.prototype.trackedElementsAreIdentical = function () {
              return (
                this.currentHeadDetails.getTrackedElementSignature() ===
                this.newHeadDetails.getTrackedElementSignature()
              );
            }),
            (o.prototype.copyNewHeadStylesheetElements = function () {
              var t, e, r, n, o;
              for (
                n = this.getNewHeadStylesheetElements(),
                  o = [],
                  e = 0,
                  r = n.length;
                r > e;
                e++
              )
                (t = n[e]), o.push(document.head.appendChild(t));
              return o;
            }),
            (o.prototype.copyNewHeadScriptElements = function () {
              var t, e, r, n, o;
              for (
                n = this.getNewHeadScriptElements(),
                  o = [],
                  e = 0,
                  r = n.length;
                r > e;
                e++
              )
                (t = n[e]),
                  o.push(
                    document.head.appendChild(this.createScriptElement(t))
                  );
              return o;
            }),
            (o.prototype.removeCurrentHeadProvisionalElements = function () {
              var t, e, r, n, o;
              for (
                n = this.getCurrentHeadProvisionalElements(),
                  o = [],
                  e = 0,
                  r = n.length;
                r > e;
                e++
              )
                (t = n[e]), o.push(document.head.removeChild(t));
              return o;
            }),
            (o.prototype.copyNewHeadProvisionalElements = function () {
              var t, e, r, n, o;
              for (
                n = this.getNewHeadProvisionalElements(),
                  o = [],
                  e = 0,
                  r = n.length;
                r > e;
                e++
              )
                (t = n[e]), o.push(document.head.appendChild(t));
              return o;
            }),
            (o.prototype.relocateCurrentBodyPermanentElements = function () {
              var e, n, o, i, s, a, u;
              for (
                a = this.getCurrentBodyPermanentElements(),
                  u = [],
                  e = 0,
                  n = a.length;
                n > e;
                e++
              )
                (i = a[e]),
                  (s = t(i)),
                  (o = this.newSnapshot.getPermanentElementById(i.id)),
                  r(i, s.element),
                  r(o, i),
                  u.push(s);
              return u;
            }),
            (o.prototype.replacePlaceholderElementsWithClonedPermanentElements =
              function (t) {
                var e, n, o, i, s, a, u;
                for (u = [], o = 0, i = t.length; i > o; o++)
                  (a = t[o]),
                    (n = a.element),
                    (s = a.permanentElement),
                    (e = s.cloneNode(!0)),
                    u.push(r(n, e));
                return u;
              }),
            (o.prototype.activateNewBodyScriptElements = function () {
              var t, e, n, o, i, s;
              for (
                i = this.getNewBodyScriptElements(),
                  s = [],
                  e = 0,
                  o = i.length;
                o > e;
                e++
              )
                (n = i[e]), (t = this.createScriptElement(n)), s.push(r(n, t));
              return s;
            }),
            (o.prototype.assignNewBody = function () {
              return (document.body = this.newBody);
            }),
            (o.prototype.focusFirstAutofocusableElement = function () {
              var t;
              return null !=
                (t = this.newSnapshot.findFirstAutofocusableElement())
                ? t.focus()
                : void 0;
            }),
            (o.prototype.getNewHeadStylesheetElements = function () {
              return this.newHeadDetails.getStylesheetElementsNotInDetails(
                this.currentHeadDetails
              );
            }),
            (o.prototype.getNewHeadScriptElements = function () {
              return this.newHeadDetails.getScriptElementsNotInDetails(
                this.currentHeadDetails
              );
            }),
            (o.prototype.getCurrentHeadProvisionalElements = function () {
              return this.currentHeadDetails.getProvisionalElements();
            }),
            (o.prototype.getNewHeadProvisionalElements = function () {
              return this.newHeadDetails.getProvisionalElements();
            }),
            (o.prototype.getCurrentBodyPermanentElements = function () {
              return this.currentSnapshot.getPermanentElementsPresentInSnapshot(
                this.newSnapshot
              );
            }),
            (o.prototype.getNewBodyScriptElements = function () {
              return this.newBody.querySelectorAll("script");
            }),
            o
          );
        })(e.Renderer)),
          (t = function (t) {
            var e;
            return (
              (e = document.createElement("meta")),
              e.setAttribute("name", "turbolinks-permanent-placeholder"),
              e.setAttribute("content", t.id),
              { element: e, permanentElement: t }
            );
          }),
          (r = function (t, e) {
            var r;
            return (r = t.parentNode) ? r.replaceChild(e, t) : void 0;
          });
      }.call(this),
      function () {
        var t = function (t, e) {
            function n() {
              this.constructor = t;
            }
            for (var o in e) r.call(e, o) && (t[o] = e[o]);
            return (
              (n.prototype = e.prototype),
              (t.prototype = new n()),
              (t.__super__ = e.prototype),
              t
            );
          },
          r = {}.hasOwnProperty;
        e.ErrorRenderer = (function (e) {
          function r(t) {
            var e;
            (e = document.createElement("html")),
              (e.innerHTML = t),
              (this.newHead = e.querySelector("head")),
              (this.newBody = e.querySelector("body"));
          }
          return (
            t(r, e),
            (r.prototype.render = function (t) {
              return this.renderView(
                (function (e) {
                  return function () {
                    return (
                      e.replaceHeadAndBody(),
                      e.activateBodyScriptElements(),
                      t()
                    );
                  };
                })(this)
              );
            }),
            (r.prototype.replaceHeadAndBody = function () {
              var t, e;
              return (
                (e = document.head),
                (t = document.body),
                e.parentNode.replaceChild(this.newHead, e),
                t.parentNode.replaceChild(this.newBody, t)
              );
            }),
            (r.prototype.activateBodyScriptElements = function () {
              var t, e, r, n, o, i;
              for (
                n = this.getScriptElements(), i = [], e = 0, r = n.length;
                r > e;
                e++
              )
                (o = n[e]),
                  (t = this.createScriptElement(o)),
                  i.push(o.parentNode.replaceChild(t, o));
              return i;
            }),
            (r.prototype.getScriptElements = function () {
              return document.documentElement.querySelectorAll("script");
            }),
            r
          );
        })(e.Renderer);
      }.call(this),
      function () {
        e.View = (function () {
          function t(t) {
            (this.delegate = t), (this.htmlElement = document.documentElement);
          }
          return (
            (t.prototype.getRootLocation = function () {
              return this.getSnapshot().getRootLocation();
            }),
            (t.prototype.getElementForAnchor = function (t) {
              return this.getSnapshot().getElementForAnchor(t);
            }),
            (t.prototype.getSnapshot = function () {
              return e.Snapshot.fromHTMLElement(this.htmlElement);
            }),
            (t.prototype.render = function (t, e) {
              var r, n, o;
              return (
                (o = t.snapshot),
                (r = t.error),
                (n = t.isPreview),
                this.markAsPreview(n),
                null != o
                  ? this.renderSnapshot(o, n, e)
                  : this.renderError(r, e)
              );
            }),
            (t.prototype.markAsPreview = function (t) {
              return t
                ? this.htmlElement.setAttribute("data-turbolinks-preview", "")
                : this.htmlElement.removeAttribute("data-turbolinks-preview");
            }),
            (t.prototype.renderSnapshot = function (t, r, n) {
              return e.SnapshotRenderer.render(
                this.delegate,
                n,
                this.getSnapshot(),
                e.Snapshot.wrap(t),
                r
              );
            }),
            (t.prototype.renderError = function (t, r) {
              return e.ErrorRenderer.render(this.delegate, r, t);
            }),
            t
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.ScrollManager = (function () {
          function r(r) {
            (this.delegate = r),
              (this.onScroll = t(this.onScroll, this)),
              (this.onScroll = e.throttle(this.onScroll));
          }
          return (
            (r.prototype.start = function () {
              return this.started
                ? void 0
                : (addEventListener("scroll", this.onScroll, !1),
                  this.onScroll(),
                  (this.started = !0));
            }),
            (r.prototype.stop = function () {
              return this.started
                ? (removeEventListener("scroll", this.onScroll, !1),
                  (this.started = !1))
                : void 0;
            }),
            (r.prototype.scrollToElement = function (t) {
              return t.scrollIntoView();
            }),
            (r.prototype.scrollToPosition = function (t) {
              var e, r;
              return (e = t.x), (r = t.y), window.scrollTo(e, r);
            }),
            (r.prototype.onScroll = function (t) {
              return this.updatePosition({
                x: window.pageXOffset,
                y: window.pageYOffset,
              });
            }),
            (r.prototype.updatePosition = function (t) {
              var e;
              return (
                (this.position = t),
                null != (e = this.delegate)
                  ? e.scrollPositionChanged(this.position)
                  : void 0
              );
            }),
            r
          );
        })();
      }.call(this),
      function () {
        e.SnapshotCache = (function () {
          function t(t) {
            (this.size = t), (this.keys = []), (this.snapshots = {});
          }
          var r;
          return (
            (t.prototype.has = function (t) {
              var e;
              return (e = r(t)), e in this.snapshots;
            }),
            (t.prototype.get = function (t) {
              var e;
              if (this.has(t)) return (e = this.read(t)), this.touch(t), e;
            }),
            (t.prototype.put = function (t, e) {
              return this.write(t, e), this.touch(t), e;
            }),
            (t.prototype.read = function (t) {
              var e;
              return (e = r(t)), this.snapshots[e];
            }),
            (t.prototype.write = function (t, e) {
              var n;
              return (n = r(t)), (this.snapshots[n] = e);
            }),
            (t.prototype.touch = function (t) {
              var e, n;
              return (
                (n = r(t)),
                (e = this.keys.indexOf(n)),
                e > -1 && this.keys.splice(e, 1),
                this.keys.unshift(n),
                this.trim()
              );
            }),
            (t.prototype.trim = function () {
              var t, e, r, n, o;
              for (
                n = this.keys.splice(this.size), o = [], t = 0, r = n.length;
                r > t;
                t++
              )
                (e = n[t]), o.push(delete this.snapshots[e]);
              return o;
            }),
            (r = function (t) {
              return e.Location.wrap(t).toCacheKey();
            }),
            t
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.Visit = (function () {
          function r(r, n, o) {
            (this.controller = r),
              (this.action = o),
              (this.performScroll = t(this.performScroll, this)),
              (this.identifier = e.uuid()),
              (this.location = e.Location.wrap(n)),
              (this.adapter = this.controller.adapter),
              (this.state = "initialized"),
              (this.timingMetrics = {});
          }
          var n;
          return (
            (r.prototype.start = function () {
              return "initialized" === this.state
                ? (this.recordTimingMetric("visitStart"),
                  (this.state = "started"),
                  this.adapter.visitStarted(this))
                : void 0;
            }),
            (r.prototype.cancel = function () {
              var t;
              return "started" === this.state
                ? (null != (t = this.request) && t.cancel(),
                  this.cancelRender(),
                  (this.state = "canceled"))
                : void 0;
            }),
            (r.prototype.complete = function () {
              var t;
              return "started" === this.state
                ? (this.recordTimingMetric("visitEnd"),
                  (this.state = "completed"),
                  "function" == typeof (t = this.adapter).visitCompleted &&
                    t.visitCompleted(this),
                  this.controller.visitCompleted(this))
                : void 0;
            }),
            (r.prototype.fail = function () {
              var t;
              return "started" === this.state
                ? ((this.state = "failed"),
                  "function" == typeof (t = this.adapter).visitFailed
                    ? t.visitFailed(this)
                    : void 0)
                : void 0;
            }),
            (r.prototype.changeHistory = function () {
              var t, e;
              return this.historyChanged
                ? void 0
                : ((t = this.location.isEqualTo(this.referrer)
                    ? "replace"
                    : this.action),
                  (e = n(t)),
                  this.controller[e](this.location, this.restorationIdentifier),
                  (this.historyChanged = !0));
            }),
            (r.prototype.issueRequest = function () {
              return this.shouldIssueRequest() && null == this.request
                ? ((this.progress = 0),
                  (this.request = new e.HttpRequest(
                    this,
                    this.location,
                    this.referrer
                  )),
                  this.request.send())
                : void 0;
            }),
            (r.prototype.getCachedSnapshot = function () {
              var t;
              return !(t = this.controller.getCachedSnapshotForLocation(
                this.location
              )) ||
                (null != this.location.anchor &&
                  !t.hasAnchor(this.location.anchor)) ||
                ("restore" !== this.action && !t.isPreviewable())
                ? void 0
                : t;
            }),
            (r.prototype.hasCachedSnapshot = function () {
              return null != this.getCachedSnapshot();
            }),
            (r.prototype.loadCachedSnapshot = function () {
              var t, e;
              return (e = this.getCachedSnapshot())
                ? ((t = this.shouldIssueRequest()),
                  this.render(function () {
                    var r;
                    return (
                      this.cacheSnapshot(),
                      this.controller.render(
                        { snapshot: e, isPreview: t },
                        this.performScroll
                      ),
                      "function" == typeof (r = this.adapter).visitRendered &&
                        r.visitRendered(this),
                      t ? void 0 : this.complete()
                    );
                  }))
                : void 0;
            }),
            (r.prototype.loadResponse = function () {
              return null != this.response
                ? this.render(function () {
                    var t, e;
                    return (
                      this.cacheSnapshot(),
                      this.request.failed
                        ? (this.controller.render(
                            { error: this.response },
                            this.performScroll
                          ),
                          "function" ==
                            typeof (t = this.adapter).visitRendered &&
                            t.visitRendered(this),
                          this.fail())
                        : (this.controller.render(
                            { snapshot: this.response },
                            this.performScroll
                          ),
                          "function" ==
                            typeof (e = this.adapter).visitRendered &&
                            e.visitRendered(this),
                          this.complete())
                    );
                  })
                : void 0;
            }),
            (r.prototype.followRedirect = function () {
              return this.redirectedToLocation && !this.followedRedirect
                ? ((this.location = this.redirectedToLocation),
                  this.controller.replaceHistoryWithLocationAndRestorationIdentifier(
                    this.redirectedToLocation,
                    this.restorationIdentifier
                  ),
                  (this.followedRedirect = !0))
                : void 0;
            }),
            (r.prototype.requestStarted = function () {
              var t;
              return (
                this.recordTimingMetric("requestStart"),
                "function" == typeof (t = this.adapter).visitRequestStarted
                  ? t.visitRequestStarted(this)
                  : void 0
              );
            }),
            (r.prototype.requestProgressed = function (t) {
              var e;
              return (
                (this.progress = t),
                "function" == typeof (e = this.adapter).visitRequestProgressed
                  ? e.visitRequestProgressed(this)
                  : void 0
              );
            }),
            (r.prototype.requestCompletedWithResponse = function (t, r) {
              return (
                (this.response = t),
                null != r && (this.redirectedToLocation = e.Location.wrap(r)),
                this.adapter.visitRequestCompleted(this)
              );
            }),
            (r.prototype.requestFailedWithStatusCode = function (t, e) {
              return (
                (this.response = e),
                this.adapter.visitRequestFailedWithStatusCode(this, t)
              );
            }),
            (r.prototype.requestFinished = function () {
              var t;
              return (
                this.recordTimingMetric("requestEnd"),
                "function" == typeof (t = this.adapter).visitRequestFinished
                  ? t.visitRequestFinished(this)
                  : void 0
              );
            }),
            (r.prototype.performScroll = function () {
              return this.scrolled
                ? void 0
                : ("restore" === this.action
                    ? this.scrollToRestoredPosition() || this.scrollToTop()
                    : this.scrollToAnchor() || this.scrollToTop(),
                  (this.scrolled = !0));
            }),
            (r.prototype.scrollToRestoredPosition = function () {
              var t, e;
              return (
                (t =
                  null != (e = this.restorationData)
                    ? e.scrollPosition
                    : void 0),
                null != t ? (this.controller.scrollToPosition(t), !0) : void 0
              );
            }),
            (r.prototype.scrollToAnchor = function () {
              return null != this.location.anchor
                ? (this.controller.scrollToAnchor(this.location.anchor), !0)
                : void 0;
            }),
            (r.prototype.scrollToTop = function () {
              return this.controller.scrollToPosition({ x: 0, y: 0 });
            }),
            (r.prototype.recordTimingMetric = function (t) {
              var e;
              return null != (e = this.timingMetrics)[t]
                ? e[t]
                : (e[t] = new Date().getTime());
            }),
            (r.prototype.getTimingMetrics = function () {
              return e.copyObject(this.timingMetrics);
            }),
            (n = function (t) {
              switch (t) {
                case "replace":
                  return "replaceHistoryWithLocationAndRestorationIdentifier";
                case "advance":
                case "restore":
                  return "pushHistoryWithLocationAndRestorationIdentifier";
              }
            }),
            (r.prototype.shouldIssueRequest = function () {
              return "restore" === this.action ? !this.hasCachedSnapshot() : !0;
            }),
            (r.prototype.cacheSnapshot = function () {
              return this.snapshotCached
                ? void 0
                : (this.controller.cacheSnapshot(), (this.snapshotCached = !0));
            }),
            (r.prototype.render = function (t) {
              return (
                this.cancelRender(),
                (this.frame = requestAnimationFrame(
                  (function (e) {
                    return function () {
                      return (e.frame = null), t.call(e);
                    };
                  })(this)
                ))
              );
            }),
            (r.prototype.cancelRender = function () {
              return this.frame ? cancelAnimationFrame(this.frame) : void 0;
            }),
            r
          );
        })();
      }.call(this),
      function () {
        var t = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        };
        e.Controller = (function () {
          function r() {
            (this.clickBubbled = t(this.clickBubbled, this)),
              (this.clickCaptured = t(this.clickCaptured, this)),
              (this.pageLoaded = t(this.pageLoaded, this)),
              (this.history = new e.History(this)),
              (this.view = new e.View(this)),
              (this.scrollManager = new e.ScrollManager(this)),
              (this.restorationData = {}),
              this.clearCache(),
              this.setProgressBarDelay(500);
          }
          return (
            (r.prototype.start = function () {
              return e.supported && !this.started
                ? (addEventListener("click", this.clickCaptured, !0),
                  addEventListener("DOMContentLoaded", this.pageLoaded, !1),
                  this.scrollManager.start(),
                  this.startHistory(),
                  (this.started = !0),
                  (this.enabled = !0))
                : void 0;
            }),
            (r.prototype.disable = function () {
              return (this.enabled = !1);
            }),
            (r.prototype.stop = function () {
              return this.started
                ? (removeEventListener("click", this.clickCaptured, !0),
                  removeEventListener("DOMContentLoaded", this.pageLoaded, !1),
                  this.scrollManager.stop(),
                  this.stopHistory(),
                  (this.started = !1))
                : void 0;
            }),
            (r.prototype.clearCache = function () {
              return (this.cache = new e.SnapshotCache(10));
            }),
            (r.prototype.visit = function (t, r) {
              var n, o;
              return (
                null == r && (r = {}),
                (t = e.Location.wrap(t)),
                this.applicationAllowsVisitingLocation(t)
                  ? this.locationIsVisitable(t)
                    ? ((n = null != (o = r.action) ? o : "advance"),
                      this.adapter.visitProposedToLocationWithAction(t, n))
                    : (window.location = t)
                  : void 0
              );
            }),
            (r.prototype.startVisitToLocationWithAction = function (t, r, n) {
              var o;
              return e.supported
                ? ((o = this.getRestorationDataForIdentifier(n)),
                  this.startVisit(t, r, { restorationData: o }))
                : (window.location = t);
            }),
            (r.prototype.setProgressBarDelay = function (t) {
              return (this.progressBarDelay = t);
            }),
            (r.prototype.startHistory = function () {
              return (
                (this.location = e.Location.wrap(window.location)),
                (this.restorationIdentifier = e.uuid()),
                this.history.start(),
                this.history.replace(this.location, this.restorationIdentifier)
              );
            }),
            (r.prototype.stopHistory = function () {
              return this.history.stop();
            }),
            (r.prototype.pushHistoryWithLocationAndRestorationIdentifier =
              function (t, r) {
                return (
                  (this.restorationIdentifier = r),
                  (this.location = e.Location.wrap(t)),
                  this.history.push(this.location, this.restorationIdentifier)
                );
              }),
            (r.prototype.replaceHistoryWithLocationAndRestorationIdentifier =
              function (t, r) {
                return (
                  (this.restorationIdentifier = r),
                  (this.location = e.Location.wrap(t)),
                  this.history.replace(
                    this.location,
                    this.restorationIdentifier
                  )
                );
              }),
            (r.prototype.historyPoppedToLocationWithRestorationIdentifier =
              function (t, r) {
                var n;
                return (
                  (this.restorationIdentifier = r),
                  this.enabled
                    ? ((n = this.getRestorationDataForIdentifier(
                        this.restorationIdentifier
                      )),
                      this.startVisit(t, "restore", {
                        restorationIdentifier: this.restorationIdentifier,
                        restorationData: n,
                        historyChanged: !0,
                      }),
                      (this.location = e.Location.wrap(t)))
                    : this.adapter.pageInvalidated()
                );
              }),
            (r.prototype.getCachedSnapshotForLocation = function (t) {
              var e;
              return null != (e = this.cache.get(t)) ? e.clone() : void 0;
            }),
            (r.prototype.shouldCacheSnapshot = function () {
              return this.view.getSnapshot().isCacheable();
            }),
            (r.prototype.cacheSnapshot = function () {
              var t, r;
              return this.shouldCacheSnapshot()
                ? (this.notifyApplicationBeforeCachingSnapshot(),
                  (r = this.view.getSnapshot()),
                  (t = this.lastRenderedLocation),
                  e.defer(
                    (function (e) {
                      return function () {
                        return e.cache.put(t, r.clone());
                      };
                    })(this)
                  ))
                : void 0;
            }),
            (r.prototype.scrollToAnchor = function (t) {
              var e;
              return (e = this.view.getElementForAnchor(t))
                ? this.scrollToElement(e)
                : this.scrollToPosition({ x: 0, y: 0 });
            }),
            (r.prototype.scrollToElement = function (t) {
              return this.scrollManager.scrollToElement(t);
            }),
            (r.prototype.scrollToPosition = function (t) {
              return this.scrollManager.scrollToPosition(t);
            }),
            (r.prototype.scrollPositionChanged = function (t) {
              var e;
              return (
                (e = this.getCurrentRestorationData()), (e.scrollPosition = t)
              );
            }),
            (r.prototype.render = function (t, e) {
              return this.view.render(t, e);
            }),
            (r.prototype.viewInvalidated = function () {
              return this.adapter.pageInvalidated();
            }),
            (r.prototype.viewWillRender = function (t) {
              return this.notifyApplicationBeforeRender(t);
            }),
            (r.prototype.viewRendered = function () {
              return (
                (this.lastRenderedLocation = this.currentVisit.location),
                this.notifyApplicationAfterRender()
              );
            }),
            (r.prototype.pageLoaded = function () {
              return (
                (this.lastRenderedLocation = this.location),
                this.notifyApplicationAfterPageLoad()
              );
            }),
            (r.prototype.clickCaptured = function () {
              return (
                removeEventListener("click", this.clickBubbled, !1),
                addEventListener("click", this.clickBubbled, !1)
              );
            }),
            (r.prototype.clickBubbled = function (t) {
              var e, r, n;
              return this.enabled &&
                this.clickEventIsSignificant(t) &&
                (r = this.getVisitableLinkForNode(t.target)) &&
                (n = this.getVisitableLocationForLink(r)) &&
                this.applicationAllowsFollowingLinkToLocation(r, n)
                ? (t.preventDefault(),
                  (e = this.getActionForLink(r)),
                  this.visit(n, { action: e }))
                : void 0;
            }),
            (r.prototype.applicationAllowsFollowingLinkToLocation = function (
              t,
              e
            ) {
              var r;
              return (
                (r = this.notifyApplicationAfterClickingLinkToLocation(t, e)),
                !r.defaultPrevented
              );
            }),
            (r.prototype.applicationAllowsVisitingLocation = function (t) {
              var e;
              return (
                (e = this.notifyApplicationBeforeVisitingLocation(t)),
                !e.defaultPrevented
              );
            }),
            (r.prototype.notifyApplicationAfterClickingLinkToLocation =
              function (t, r) {
                return e.dispatch("turbolinks:click", {
                  target: t,
                  data: { url: r.absoluteURL },
                  cancelable: !0,
                });
              }),
            (r.prototype.notifyApplicationBeforeVisitingLocation = function (
              t
            ) {
              return e.dispatch("turbolinks:before-visit", {
                data: { url: t.absoluteURL },
                cancelable: !0,
              });
            }),
            (r.prototype.notifyApplicationAfterVisitingLocation = function (t) {
              return e.dispatch("turbolinks:visit", {
                data: { url: t.absoluteURL },
              });
            }),
            (r.prototype.notifyApplicationBeforeCachingSnapshot = function () {
              return e.dispatch("turbolinks:before-cache");
            }),
            (r.prototype.notifyApplicationBeforeRender = function (t) {
              return e.dispatch("turbolinks:before-render", {
                data: { newBody: t },
              });
            }),
            (r.prototype.notifyApplicationAfterRender = function () {
              return e.dispatch("turbolinks:render");
            }),
            (r.prototype.notifyApplicationAfterPageLoad = function (t) {
              return (
                null == t && (t = {}),
                e.dispatch("turbolinks:load", {
                  data: { url: this.location.absoluteURL, timing: t },
                })
              );
            }),
            (r.prototype.startVisit = function (t, e, r) {
              var n;
              return (
                null != (n = this.currentVisit) && n.cancel(),
                (this.currentVisit = this.createVisit(t, e, r)),
                this.currentVisit.start(),
                this.notifyApplicationAfterVisitingLocation(t)
              );
            }),
            (r.prototype.createVisit = function (t, r, n) {
              var o, i, s, a, u;
              return (
                (i = null != n ? n : {}),
                (a = i.restorationIdentifier),
                (s = i.restorationData),
                (o = i.historyChanged),
                (u = new e.Visit(this, t, r)),
                (u.restorationIdentifier = null != a ? a : e.uuid()),
                (u.restorationData = e.copyObject(s)),
                (u.historyChanged = o),
                (u.referrer = this.location),
                u
              );
            }),
            (r.prototype.visitCompleted = function (t) {
              return this.notifyApplicationAfterPageLoad(t.getTimingMetrics());
            }),
            (r.prototype.clickEventIsSignificant = function (t) {
              return !(
                t.defaultPrevented ||
                t.target.isContentEditable ||
                t.which > 1 ||
                t.altKey ||
                t.ctrlKey ||
                t.metaKey ||
                t.shiftKey
              );
            }),
            (r.prototype.getVisitableLinkForNode = function (t) {
              return this.nodeIsVisitable(t)
                ? e.closest(t, "a[href]:not([target]):not([download])")
                : void 0;
            }),
            (r.prototype.getVisitableLocationForLink = function (t) {
              var r;
              return (
                (r = new e.Location(t.getAttribute("href"))),
                this.locationIsVisitable(r) ? r : void 0
              );
            }),
            (r.prototype.getActionForLink = function (t) {
              var e;
              return null != (e = t.getAttribute("data-turbolinks-action"))
                ? e
                : "advance";
            }),
            (r.prototype.nodeIsVisitable = function (t) {
              var r;
              return (r = e.closest(t, "[data-turbolinks]"))
                ? "false" !== r.getAttribute("data-turbolinks")
                : !0;
            }),
            (r.prototype.locationIsVisitable = function (t) {
              return t.isPrefixedBy(this.view.getRootLocation()) && t.isHTML();
            }),
            (r.prototype.getCurrentRestorationData = function () {
              return this.getRestorationDataForIdentifier(
                this.restorationIdentifier
              );
            }),
            (r.prototype.getRestorationDataForIdentifier = function (t) {
              var e;
              return null != (e = this.restorationData)[t] ? e[t] : (e[t] = {});
            }),
            r
          );
        })();
      }.call(this),
      function () {
        !(function () {
          var t, e;
          if (
            (t = e = document.currentScript) &&
            !e.hasAttribute("data-turbolinks-suppress-warning")
          )
            for (; (t = t.parentNode); )
              if (t === document.body)
                return console.warn(
                  "You are loading Turbolinks from a <script> element inside the <body> element. This is probably not what you meant to do!\n\nLoad your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\nFor more information, see: https://github.com/turbolinks/turbolinks#working-with-script-elements\n\n\u2014\u2014\nSuppress this warning by adding a `data-turbolinks-suppress-warning` attribute to: %s",
                  e.outerHTML
                );
        })();
      }.call(this),
      function () {
        var t, r, n;
        (e.start = function () {
          return r()
            ? (null == e.controller && (e.controller = t()),
              e.controller.start())
            : void 0;
        }),
          (r = function () {
            return null == window.Turbolinks && (window.Turbolinks = e), n();
          }),
          (t = function () {
            var t;
            return (
              (t = new e.Controller()), (t.adapter = new e.BrowserAdapter(t)), t
            );
          }),
          (n = function () {
            return window.Turbolinks === e;
          }),
          n() && e.start();
      }.call(this);
  }).call(this),
    "object" == typeof module && module.exports
      ? (module.exports = e)
      : "function" == typeof define && define.amd && define(e);
}).call(this);
/*!
 * jQuery JavaScript Library v1.12.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:17Z
 */

(function (global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document
      ? factory(global, true)
      : function (w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
  } else {
    factory(global);
  }

  // Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Support: Firefox 18+
  // Can't be in strict mode, several libs including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  //"use strict";
  var deletedIds = [];

  var document = window.document;

  var slice = deletedIds.slice;

  var concat = deletedIds.concat;

  var push = deletedIds.push;

  var indexOf = deletedIds.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var support = {};

  var version = "1.12.4",
    // Define a local copy of jQuery
    jQuery = function (selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },
    // Support: Android<4.1, IE<9
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,
    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,

    constructor: jQuery,

    // Start with an empty selector
    selector: "",

    // The default length of a jQuery object is 0
    length: 0,

    toArray: function () {
      return slice.call(this);
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function (num) {
      return num != null
        ? // Return just the one element from the set
          num < 0
          ? this[num + this.length]
          : this[num]
        : // Return all the elements in a clean array
          slice.call(this);
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems);

      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;
      ret.context = this.context;

      // Return the newly-formed element set
      return ret;
    },

    // Execute a callback for every element in the matched set.
    each: function (callback) {
      return jQuery.each(this, callback);
    },

    map: function (callback) {
      return this.pushStack(
        jQuery.map(this, function (elem, i) {
          return callback.call(elem, i, elem);
        })
      );
    },

    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },

    first: function () {
      return this.eq(0);
    },

    last: function () {
      return this.eq(-1);
    },

    eq: function (i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },

    end: function () {
      return this.prevObject || this.constructor();
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: deletedIds.sort,
    splice: deletedIds.splice,
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var src,
      copyIsArray,
      copy,
      name,
      options,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean") {
      deep = target;

      // skip the boolean and the target
      target = arguments[i] || {};
      i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }

    // extend jQuery itself if only one argument is passed
    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (
            deep &&
            copy &&
            (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))
          ) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[name] = jQuery.extend(deep, clone, copy);

            // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

    // Assume jQuery is ready without the ready module
    isReady: true,

    error: function (msg) {
      throw new Error(msg);
    },

    noop: function () {},

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function (obj) {
      return jQuery.type(obj) === "function";
    },

    isArray:
      Array.isArray ||
      function (obj) {
        return jQuery.type(obj) === "array";
      },

    isWindow: function (obj) {
      /* jshint eqeqeq: false */
      return obj != null && obj == obj.window;
    },

    isNumeric: function (obj) {
      // parseFloat NaNs numeric-cast false positives (null|true|false|"")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      // adding 1 corrects loss of precision from parseFloat (#15100)
      var realStringObj = obj && obj.toString();
      return (
        !jQuery.isArray(obj) &&
        realStringObj - parseFloat(realStringObj) + 1 >= 0
      );
    },

    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },

    isPlainObject: function (obj) {
      var key;

      // Must be an Object.
      // Because of IE, we also have to check the presence of the constructor property.
      // Make sure that DOM nodes and window objects don't pass through, as well
      if (
        !obj ||
        jQuery.type(obj) !== "object" ||
        obj.nodeType ||
        jQuery.isWindow(obj)
      ) {
        return false;
      }

      try {
        // Not own constructor property must be Object
        if (
          obj.constructor &&
          !hasOwn.call(obj, "constructor") &&
          !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")
        ) {
          return false;
        }
      } catch (e) {
        // IE8,9 Will throw exceptions on certain host objects #9897
        return false;
      }

      // Support: IE<9
      // Handle iteration over inherited properties before own properties.
      if (!support.ownFirst) {
        for (key in obj) {
          return hasOwn.call(obj, key);
        }
      }

      // Own properties are enumerated firstly, so to speed up,
      // if last one is own, then all properties are own.
      for (key in obj) {
      }

      return key === undefined || hasOwn.call(obj, key);
    },

    type: function (obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function"
        ? class2type[toString.call(obj)] || "object"
        : typeof obj;
    },

    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function (data) {
      if (data && jQuery.trim(data)) {
        // We use execScript on Internet Explorer
        // We use an anonymous function so that context is window
        // rather than jQuery in Firefox
        (
          window.execScript ||
          function (data) {
            window["eval"].call(window, data); // jscs:ignore requireDotNotation
          }
        )(data);
      }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function (string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },

    nodeName: function (elem, name) {
      return (
        elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
      );
    },

    each: function (obj, callback) {
      var length,
        i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },

    // Support: Android<4.1, IE<9
    trim: function (text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },

    // results is for internal usage only
    makeArray: function (arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },

    inArray: function (elem, arr, i) {
      var len;

      if (arr) {
        if (indexOf) {
          return indexOf.call(arr, elem, i);
        }

        len = arr.length;
        i = i ? (i < 0 ? Math.max(0, len + i) : i) : 0;

        for (; i < len; i++) {
          // Skip accessing in sparse arrays
          if (i in arr && arr[i] === elem) {
            return i;
          }
        }
      }

      return -1;
    },

    merge: function (first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;

      while (j < len) {
        first[i++] = second[j++];
      }

      // Support: IE<9
      // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
      if (len !== len) {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }

      first.length = i;

      return first;
    },

    grep: function (elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;

      // Go through the array, only saving the items
      // that pass the validator function
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },

    // arg is for internal usage only
    map: function (elems, callback, arg) {
      var length,
        value,
        i = 0,
        ret = [];

      // Go through the array, translating each of the items to their new values
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }

        // Go through every key on the object,
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      }

      // Flatten any nested arrays
      return concat.apply([], ret);
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function (fn, context) {
      var args, proxy, tmp;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }

      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }

      // Simulated bind
      args = slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };

      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;

      return proxy;
    },

    now: function () {
      return +new Date();
    },

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support,
  });

  // JSHint would error on this code due to the Symbol not being defined in ES5.
  // Defining this global in .jshintrc would create a danger of using the global
  // unguarded in another place, it seems safer to just disable JSHint for these
  // three lines.
  /* jshint ignore: start */
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = deletedIds[Symbol.iterator];
  }
  /* jshint ignore: end */

  // Populate the class2type map
  jQuery.each(
    "Boolean Number String Function Array Date RegExp Object Error Symbol".split(
      " "
    ),
    function (i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    }
  );

  function isArrayLike(obj) {
    // Support: iOS 8.2 (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
      type = jQuery.type(obj);

    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }

    return (
      type === "array" ||
      length === 0 ||
      (typeof length === "number" && length > 0 && length - 1 in obj)
    );
  }
  var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.2.1
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2015-10-17
     */
    (function (window) {
      var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function (a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        // General-purpose constants
        MAX_NEGATIVE = 1 << 31,
        // Instance methods
        hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function (list, elem) {
          var i = 0,
            len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans =
          "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions

        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes =
          "\\[" +
          whitespace +
          "*(" +
          identifier +
          ")(?:" +
          whitespace +
          // Operator (capture 2)
          "*([*^$|!~]?=)" +
          whitespace +
          // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
          identifier +
          "))|)" +
          whitespace +
          "*\\]",
        pseudos =
          ":(" +
          identifier +
          ")(?:\\((" +
          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
          // 1. quoted (capture 3; capture 4 or capture 5)
          "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
          // 2. simple (capture 6)
          "((?:\\\\.|[^\\\\()[\\]]|" +
          attributes +
          ")*)|" +
          // 3. anything else (capture 2)
          ".*" +
          ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        ),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp(
          "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"
        ),
        rattributeQuotes = new RegExp(
          "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]",
          "g"
        ),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
              whitespace +
              "*(even|odd|(([+-]|)(\\d*)n|)" +
              whitespace +
              "*(?:([+-]|)" +
              whitespace +
              "*(\\d+)|))" +
              whitespace +
              "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp(
            "^" +
              whitespace +
              "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
              whitespace +
              "*((?:-\\d)?\\d*)" +
              whitespace +
              "*\\)|)(?=[^-]|$)",
            "i"
          ),
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp(
          "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)",
          "ig"
        ),
        funescape = function (_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"
          return high !== high || escapedWhitespace
            ? escaped
            : high < 0
            ? // BMP codepoint
              String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
              String.fromCharCode(
                (high >> 10) | 0xd800,
                (high & 0x3ff) | 0xdc00
              );
        },
        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function () {
          setDocument();
        };

      // Optimize for push.apply( _, NodeList )
      try {
        push.apply(
          (arr = slice.call(preferredDoc.childNodes)),
          preferredDoc.childNodes
        );
        // Support: Android<4.0
        // Detect silently failing push.apply
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length
            ? // Leverage slice if possible
              function (target, els) {
                push_native.apply(target, slice.call(els));
              }
            : // Support: IE<9
              // Otherwise append directly
              function (target, els) {
                var j = target.length,
                  i = 0;
                // Can't trust NodeList.length
                while ((target[j++] = els[i++])) {}
                target.length = j - 1;
              },
        };
      }

      function Sizzle(selector, context, results, seed) {
        var m,
          i,
          elem,
          nid,
          nidselect,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;

        results = results || [];

        // Return early from calls with invalid selector or context
        if (
          typeof selector !== "string" ||
          !selector ||
          (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
        ) {
          return results;
        }

        // Try to shortcut find operations (as opposed to filters) in HTML documents
        if (!seed) {
          if (
            (context ? context.ownerDocument || context : preferredDoc) !==
            document
          ) {
            setDocument(context);
          }
          context = context || document;

          if (documentIsHTML) {
            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              // ID selector
              if ((m = match[1])) {
                // Document context
                if (nodeType === 9) {
                  if ((elem = context.getElementById(m))) {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }

                  // Element context
                } else {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (
                    newContext &&
                    (elem = newContext.getElementById(m)) &&
                    contains(context, elem) &&
                    elem.id === m
                  ) {
                    results.push(elem);
                    return results;
                  }
                }

                // Type selector
              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results;

                // Class selector
              } else if (
                (m = match[3]) &&
                support.getElementsByClassName &&
                context.getElementsByClassName
              ) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }

            // Take advantage of querySelectorAll
            if (
              support.qsa &&
              !compilerCache[selector + " "] &&
              (!rbuggyQSA || !rbuggyQSA.test(selector))
            ) {
              if (nodeType !== 1) {
                newContext = context;
                newSelector = selector;

                // qSA looks outside Element context, which is not what we want
                // Thanks to Andrew Dupont for this workaround technique
                // Support: IE <=8
                // Exclude object elements
              } else if (context.nodeName.toLowerCase() !== "object") {
                // Capture the context ID, setting it first if necessary
                if ((nid = context.getAttribute("id"))) {
                  nid = nid.replace(rescape, "\\$&");
                } else {
                  context.setAttribute("id", (nid = expando));
                }

                // Prefix every selector in the list
                groups = tokenize(selector);
                i = groups.length;
                nidselect = ridentifier.test(nid)
                  ? "#" + nid
                  : "[id='" + nid + "']";
                while (i--) {
                  groups[i] = nidselect + " " + toSelector(groups[i]);
                }
                newSelector = groups.join(",");

                // Expand context for sibling selectors
                newContext =
                  (rsibling.test(selector) &&
                    testContext(context.parentNode)) ||
                  context;
              }

              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
        }

        // All others
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }

      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *	deleting the oldest entry
       */
      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }
          return (cache[key + " "] = value);
        }
        return cache;
      }

      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }

      /**
       * Support testing using an element
       * @param {Function} fn Passed the created div and expects a boolean result
       */
      function assert(fn) {
        var div = document.createElement("div");

        try {
          return !!fn(div);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
          // release memory in IE
          div = null;
        }
      }

      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */
      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
          i = arr.length;

        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }

      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */
      function siblingCheck(a, b) {
        var cur = b && a,
          diff =
            cur &&
            a.nodeType === 1 &&
            b.nodeType === 1 &&
            (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

        // Use IE sourceIndex if available on both nodes
        if (diff) {
          return diff;
        }

        // Check if b follows a
        if (cur) {
          while ((cur = cur.nextSibling)) {
            if (cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }

      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */
      function createInputPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */
      function createButtonPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */
      function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
          argument = +argument;
          return markFunction(function (seed, matches) {
            var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;

            // Match elements found at the specified indexes
            while (i--) {
              if (seed[(j = matchIndexes[i])]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */
      function testContext(context) {
        return (
          context &&
          typeof context.getElementsByTagName !== "undefined" &&
          context
        );
      }

      // Expose support vars for convenience
      support = Sizzle.support = {};

      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */
      isXML = Sizzle.isXML = function (elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement =
          elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };

      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */
      setDocument = Sizzle.setDocument = function (node) {
        var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;

        // Return early if doc is invalid or already selected
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }

        // Update global variables
        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document);

        // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
        if ((parent = document.defaultView) && parent.top !== parent) {
          // Support: IE 11
          if (parent.addEventListener) {
            parent.addEventListener("unload", unloadHandler, false);

            // Support: IE 9 - 10 only
          } else if (parent.attachEvent) {
            parent.attachEvent("onunload", unloadHandler);
          }
        }

        /* Attributes
	---------------------------------------------------------------------- */

        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert(function (div) {
          div.className = "i";
          return !div.getAttribute("className");
        });

        /* getElement(s)By*
	---------------------------------------------------------------------- */

        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert(function (div) {
          div.appendChild(document.createComment(""));
          return !div.getElementsByTagName("*").length;
        });

        // Support: IE<9
        support.getElementsByClassName = rnative.test(
          document.getElementsByClassName
        );

        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function (div) {
          docElem.appendChild(div).id = expando;
          return (
            !document.getElementsByName ||
            !document.getElementsByName(expando).length
          );
        });

        // ID find and filter
        if (support.getById) {
          Expr.find["ID"] = function (id, context) {
            if (
              typeof context.getElementById !== "undefined" &&
              documentIsHTML
            ) {
              var m = context.getElementById(id);
              return m ? [m] : [];
            }
          };
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
        } else {
          // Support: IE6/7
          // getElementById is not reliable as a find shortcut
          delete Expr.find["ID"];

          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node =
                typeof elem.getAttributeNode !== "undefined" &&
                elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };
        }

        // Tag
        Expr.find["TAG"] = support.getElementsByTagName
          ? function (tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);

                // DocumentFragment nodes don't have gEBTN
              } else if (support.qsa) {
                return context.querySelectorAll(tag);
              }
            }
          : function (tag, context) {
              var elem,
                tmp = [],
                i = 0,
                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);

              // Filter out possible comments
              if (tag === "*") {
                while ((elem = results[i++])) {
                  if (elem.nodeType === 1) {
                    tmp.push(elem);
                  }
                }

                return tmp;
              }
              return results;
            };

        // Class
        Expr.find["CLASS"] =
          support.getElementsByClassName &&
          function (className, context) {
            if (
              typeof context.getElementsByClassName !== "undefined" &&
              documentIsHTML
            ) {
              return context.getElementsByClassName(className);
            }
          };

        /* QSA/matchesSelector
	---------------------------------------------------------------------- */

        // QSA and matchesSelector support

        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];

        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See http://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];

        if ((support.qsa = rnative.test(document.querySelectorAll))) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function (div) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            docElem.appendChild(div).innerHTML =
              "<a id='" +
              expando +
              "'></a>" +
              "<select id='" +
              expando +
              "-\r\\' msallowcapture=''>" +
              "<option selected=''></option></select>";

            // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
            if (div.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if (!div.querySelectorAll("[selected]").length) {
              rbuggyQSA.push(
                "\\[" + whitespace + "*(?:value|" + booleans + ")"
              );
            }

            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
            if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if (!div.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }

            // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibing-combinator selector` fails
            if (!div.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });

          assert(function (div) {
            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            div.appendChild(input).setAttribute("name", "D");

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if (div.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if (!div.querySelectorAll(":enabled").length) {
              rbuggyQSA.push(":enabled", ":disabled");
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if (
          (support.matchesSelector = rnative.test(
            (matches =
              docElem.matches ||
              docElem.webkitMatchesSelector ||
              docElem.mozMatchesSelector ||
              docElem.oMatchesSelector ||
              docElem.msMatchesSelector)
          ))
        ) {
          assert(function (div) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(div, "div");

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call(div, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches =
          rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

        /* Contains
	---------------------------------------------------------------------- */
        hasCompare = rnative.test(docElem.compareDocumentPosition);

        // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself
        contains =
          hasCompare || rnative.test(docElem.contains)
            ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                  bup = b && b.parentNode;
                return (
                  a === bup ||
                  !!(
                    bup &&
                    bup.nodeType === 1 &&
                    (adown.contains
                      ? adown.contains(bup)
                      : a.compareDocumentPosition &&
                        a.compareDocumentPosition(bup) & 16)
                  )
                );
              }
            : function (a, b) {
                if (b) {
                  while ((b = b.parentNode)) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };

        /* Sorting
	---------------------------------------------------------------------- */

        // Document order sorting
        sortOrder = hasCompare
          ? function (a, b) {
              // Flag for duplicate removal
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }

              // Sort on method existence if only one input has compareDocumentPosition
              var compare =
                !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }

              // Calculate position if both inputs belong to the same document
              compare =
                (a.ownerDocument || a) === (b.ownerDocument || b)
                  ? a.compareDocumentPosition(b)
                  : // Otherwise we know they are disconnected
                    1;

              // Disconnected nodes
              if (
                compare & 1 ||
                (!support.sortDetached &&
                  b.compareDocumentPosition(a) === compare)
              ) {
                // Choose the first element that is related to our preferred document
                if (
                  a === document ||
                  (a.ownerDocument === preferredDoc &&
                    contains(preferredDoc, a))
                ) {
                  return -1;
                }
                if (
                  b === document ||
                  (b.ownerDocument === preferredDoc &&
                    contains(preferredDoc, b))
                ) {
                  return 1;
                }

                // Maintain original order
                return sortInput
                  ? indexOf(sortInput, a) - indexOf(sortInput, b)
                  : 0;
              }

              return compare & 4 ? -1 : 1;
            }
          : function (a, b) {
              // Exit early if the nodes are identical
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }

              var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [a],
                bp = [b];

              // Parentless nodes are either documents or disconnected
              if (!aup || !bup) {
                return a === document
                  ? -1
                  : b === document
                  ? 1
                  : aup
                  ? -1
                  : bup
                  ? 1
                  : sortInput
                  ? indexOf(sortInput, a) - indexOf(sortInput, b)
                  : 0;

                // If the nodes are siblings, we can do a quick check
              } else if (aup === bup) {
                return siblingCheck(a, b);
              }

              // Otherwise we need full lists of their ancestors for comparison
              cur = a;
              while ((cur = cur.parentNode)) {
                ap.unshift(cur);
              }
              cur = b;
              while ((cur = cur.parentNode)) {
                bp.unshift(cur);
              }

              // Walk down the tree looking for a discrepancy
              while (ap[i] === bp[i]) {
                i++;
              }

              return i
                ? // Do a sibling check if the nodes have a common ancestor
                  siblingCheck(ap[i], bp[i])
                : // Otherwise nodes in our document sort first
                ap[i] === preferredDoc
                ? -1
                : bp[i] === preferredDoc
                ? 1
                : 0;
            };

        return document;
      };

      Sizzle.matches = function (expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function (elem, expr) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        // Make sure that attribute selectors are quoted
        expr = expr.replace(rattributeQuotes, "='$1']");

        if (
          support.matchesSelector &&
          documentIsHTML &&
          !compilerCache[expr + " "] &&
          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
          (!rbuggyQSA || !rbuggyQSA.test(expr))
        ) {
          try {
            var ret = matches.call(elem, expr);

            // IE 9's matchesSelector returns false on disconnected nodes
            if (
              ret ||
              support.disconnectedMatch ||
              // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              (elem.document && elem.document.nodeType !== 11)
            ) {
              return ret;
            }
          } catch (e) {}
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function (context, elem) {
        // Set document vars if needed
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };

      Sizzle.attr = function (elem, name) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
          val =
            fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
              ? fn(elem, name, !documentIsHTML)
              : undefined;

        return val !== undefined
          ? val
          : support.attributes || !documentIsHTML
          ? elem.getAttribute(name)
          : (val = elem.getAttributeNode(name)) && val.specified
          ? val.value
          : null;
      };

      Sizzle.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };

      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */
      Sizzle.uniqueSort = function (results) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;

        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if (hasDuplicate) {
          while ((elem = results[i++])) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }

        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;

        return results;
      };

      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */
      getText = Sizzle.getText = function (elem) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while ((node = elem[i++])) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes

        return ret;
      };

      Expr = Sizzle.selectors = {
        // Can be adjusted by the user
        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" },
        },

        preFilter: {
          ATTR: function (match) {
            match[1] = match[1].replace(runescape, funescape);

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = (match[3] || match[4] || match[5] || "").replace(
              runescape,
              funescape
            );

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },

          CHILD: function (match) {
            /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              }

              // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1
              match[4] = +(match[4]
                ? match[5] + (match[6] || 1)
                : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd");

              // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },

          PSEUDO: function (match) {
            var excess,
              unquoted = !match[6] && match[2];

            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            }

            // Accept quoted arguments as-is
            if (match[3]) {
              match[2] = match[4] || match[5] || "";

              // Strip excess characters from unquoted arguments
            } else if (
              unquoted &&
              rpseudo.test(unquoted) &&
              // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) &&
              // advance to the next closing parenthesis
              (excess =
                unquoted.indexOf(")", unquoted.length - excess) -
                unquoted.length)
            ) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice(0, 3);
          },
        },

        filter: {
          TAG: function (nodeNameSelector) {
            var nodeName = nodeNameSelector
              .replace(runescape, funescape)
              .toLowerCase();
            return nodeNameSelector === "*"
              ? function () {
                  return true;
                }
              : function (elem) {
                  return (
                    elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                  );
                };
          },

          CLASS: function (className) {
            var pattern = classCache[className + " "];

            return (
              pattern ||
              ((pattern = new RegExp(
                "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"
              )) &&
                classCache(className, function (elem) {
                  return pattern.test(
                    (typeof elem.className === "string" && elem.className) ||
                      (typeof elem.getAttribute !== "undefined" &&
                        elem.getAttribute("class")) ||
                      ""
                  );
                }))
            );
          },

          ATTR: function (name, operator, check) {
            return function (elem) {
              var result = Sizzle.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }

              result += "";

              return operator === "="
                ? result === check
                : operator === "!="
                ? result !== check
                : operator === "^="
                ? check && result.indexOf(check) === 0
                : operator === "*="
                ? check && result.indexOf(check) > -1
                : operator === "$="
                ? check && result.slice(-check.length) === check
                : operator === "~="
                ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(
                    check
                  ) > -1
                : operator === "|="
                ? result === check ||
                  result.slice(0, check.length + 1) === check + "-"
                : false;
            };
          },

          CHILD: function (type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";

            return first === 1 && last === 0
              ? // Shortcut for :nth-*(n)
                function (elem) {
                  return !!elem.parentNode;
                }
              : function (elem, context, xml) {
                  var cache,
                    uniqueCache,
                    outerCache,
                    node,
                    nodeIndex,
                    start,
                    dir =
                      simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = false;

                  if (parent) {
                    // :(first|last|only)-(child|of-type)
                    if (simple) {
                      while (dir) {
                        node = elem;
                        while ((node = node[dir])) {
                          if (
                            ofType
                              ? node.nodeName.toLowerCase() === name
                              : node.nodeType === 1
                          ) {
                            return false;
                          }
                        }
                        // Reverse direction for :only-* (if we haven't yet done so)
                        start = dir =
                          type === "only" && !start && "nextSibling";
                      }
                      return true;
                    }

                    start = [forward ? parent.firstChild : parent.lastChild];

                    // non-xml :nth-child(...) stores cache data on `parent`
                    if (forward && useCache) {
                      // Seek `elem` from a previously-cached index

                      // ...in a gzip-friendly way
                      node = parent;
                      outerCache = node[expando] || (node[expando] = {});

                      // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)
                      uniqueCache =
                        outerCache[node.uniqueID] ||
                        (outerCache[node.uniqueID] = {});

                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];

                      while (
                        (node =
                          (++nodeIndex && node && node[dir]) ||
                          // Fallback to seeking `elem` from the start
                          (diff = nodeIndex = 0) ||
                          start.pop())
                      ) {
                        // When found, cache indexes on `parent` and break
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          uniqueCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      // Use previously-cached element index if available
                      if (useCache) {
                        // ...in a gzip-friendly way
                        node = elem;
                        outerCache = node[expando] || (node[expando] = {});

                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache =
                          outerCache[node.uniqueID] ||
                          (outerCache[node.uniqueID] = {});

                        cache = uniqueCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }

                      // xml :nth-child(...)
                      // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                      if (diff === false) {
                        // Use the same loop as above to seek `elem` from the start
                        while (
                          (node =
                            (++nodeIndex && node && node[dir]) ||
                            (diff = nodeIndex = 0) ||
                            start.pop())
                        ) {
                          if (
                            (ofType
                              ? node.nodeName.toLowerCase() === name
                              : node.nodeType === 1) &&
                            ++diff
                          ) {
                            // Cache the index of each encountered element
                            if (useCache) {
                              outerCache =
                                node[expando] || (node[expando] = {});

                              // Support: IE <9 only
                              // Defend against cloned attroperties (jQuery gh-1709)
                              uniqueCache =
                                outerCache[node.uniqueID] ||
                                (outerCache[node.uniqueID] = {});

                              uniqueCache[type] = [dirruns, diff];
                            }

                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }

                    // Incorporate the offset, then check against cycle size
                    diff -= last;
                    return (
                      diff === first ||
                      (diff % first === 0 && diff / first >= 0)
                    );
                  }
                };
          },

          PSEUDO: function (pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
              fn =
                Expr.pseudos[pseudo] ||
                Expr.setFilters[pseudo.toLowerCase()] ||
                Sizzle.error("unsupported pseudo: " + pseudo);

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if (fn[expando]) {
              return fn(argument);
            }

            // But maintain support for old signatures
            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())
                ? markFunction(function (seed, matches) {
                    var idx,
                      matched = fn(seed, argument),
                      i = matched.length;
                    while (i--) {
                      idx = indexOf(seed, matched[i]);
                      seed[idx] = !(matches[idx] = matched[i]);
                    }
                  })
                : function (elem) {
                    return fn(elem, 0, args);
                  };
            }

            return fn;
          },
        },

        pseudos: {
          // Potentially complex pseudos
          not: markFunction(function (selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));

            return matcher[expando]
              ? markFunction(function (seed, matches, context, xml) {
                  var elem,
                    unmatched = matcher(seed, null, xml, []),
                    i = seed.length;

                  // Match elements unmatched by `matcher`
                  while (i--) {
                    if ((elem = unmatched[i])) {
                      seed[i] = !(matches[i] = elem);
                    }
                  }
                })
              : function (elem, context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  // Don't keep the element (issue #299)
                  input[0] = null;
                  return !results.pop();
                };
          }),

          has: markFunction(function (selector) {
            return function (elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),

          contains: markFunction(function (text) {
            text = text.replace(runescape, funescape);
            return function (elem) {
              return (
                (elem.textContent || elem.innerText || getText(elem)).indexOf(
                  text
                ) > -1
              );
            };
          }),

          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          lang: markFunction(function (lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;
              do {
                if (
                  (elemLang = documentIsHTML
                    ? elem.lang
                    : elem.getAttribute("xml:lang") ||
                      elem.getAttribute("lang"))
                ) {
                  elemLang = elemLang.toLowerCase();
                  return (
                    elemLang === lang || elemLang.indexOf(lang + "-") === 0
                  );
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),

          // Miscellaneous
          target: function (elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },

          root: function (elem) {
            return elem === docElem;
          },

          focus: function (elem) {
            return (
              elem === document.activeElement &&
              (!document.hasFocus || document.hasFocus()) &&
              !!(elem.type || elem.href || ~elem.tabIndex)
            );
          },

          // Boolean properties
          enabled: function (elem) {
            return elem.disabled === false;
          },

          disabled: function (elem) {
            return elem.disabled === true;
          },

          checked: function (elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (
              (nodeName === "input" && !!elem.checked) ||
              (nodeName === "option" && !!elem.selected)
            );
          },

          selected: function (elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },

          // Contents
          empty: function (elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },

          parent: function (elem) {
            return !Expr.pseudos["empty"](elem);
          },

          // Element/input types
          header: function (elem) {
            return rheader.test(elem.nodeName);
          },

          input: function (elem) {
            return rinputs.test(elem.nodeName);
          },

          button: function (elem) {
            var name = elem.nodeName.toLowerCase();
            return (
              (name === "input" && elem.type === "button") || name === "button"
            );
          },

          text: function (elem) {
            var attr;
            return (
              elem.nodeName.toLowerCase() === "input" &&
              elem.type === "text" &&
              // Support: IE<8
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null ||
                attr.toLowerCase() === "text")
            );
          },

          // Position-in-collection
          first: createPositionalPseudo(function () {
            return [0];
          }),

          last: createPositionalPseudo(function (matchIndexes, length) {
            return [length - 1];
          }),

          eq: createPositionalPseudo(function (matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),

          even: createPositionalPseudo(function (matchIndexes, length) {
            var i = 0;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          odd: createPositionalPseudo(function (matchIndexes, length) {
            var i = 1;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          lt: createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; --i >= 0; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          gt: createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; ++i < length; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
        },
      };

      Expr.pseudos["nth"] = Expr.pseudos["eq"];

      // Add button/input type pseudos
      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true,
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in { submit: true, reset: true }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }

      // Easy API for creating new setFilters
      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
        var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push((tokens = []));
          }

          matched = false;

          // Combinators
          if ((match = rcombinators.exec(soFar))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " "),
            });
            soFar = soFar.slice(matched.length);
          }

          // Filters
          for (type in Expr.filter) {
            if (
              (match = matchExpr[type].exec(soFar)) &&
              (!preFilters[type] || (match = preFilters[type](match)))
            ) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match,
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        }

        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly
          ? soFar.length
          : soFar
          ? Sizzle.error(selector)
          : // Cache the tokens
            tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for (; i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;

        return combinator.first
          ? // Check against closest ancestor/preceding element
            function (elem, context, xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
            }
          : // Check against all ancestor/preceding elements
            function (elem, context, xml) {
              var oldCache,
                uniqueCache,
                outerCache,
                newCache = [dirruns, doneName];

              // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
              if (xml) {
                while ((elem = elem[dir])) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while ((elem = elem[dir])) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});

                    // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)
                    uniqueCache =
                      outerCache[elem.uniqueID] ||
                      (outerCache[elem.uniqueID] = {});

                    if (
                      (oldCache = uniqueCache[dir]) &&
                      oldCache[0] === dirruns &&
                      oldCache[1] === doneName
                    ) {
                      // Assign to newCache so results back-propagate to previous elements
                      return (newCache[2] = oldCache[2]);
                    } else {
                      // Reuse newcache so results back-propagate to previous elements
                      uniqueCache[dir] = newCache;

                      // A match means we're done; a fail means we have to keep checking
                      if ((newCache[2] = matcher(elem, context, xml))) {
                        return true;
                      }
                    }
                  }
                }
              }
            };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1
          ? function (elem, context, xml) {
              var i = matchers.length;
              while (i--) {
                if (!matchers[i](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            }
          : matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
          len = contexts.length;
        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

        for (; i < len; i++) {
          if ((elem = unmatched[i])) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(
        preFilter,
        selector,
        matcher,
        postFilter,
        postFinder,
        postSelector
      ) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function (seed, results, context, xml) {
          var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
            elems =
              seed ||
              multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn =
              preFilter && (seed || !selector)
                ? condense(elems, preMap, preFilter, context, xml)
                : elems,
            matcherOut = matcher
              ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter)
                ? // ...intermediate processing is necessary
                  []
                : // ...otherwise use results directly
                  results
              : matcherIn;

          // Find primary matches
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }

          // Apply postFilter
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while (i--) {
              if ((elem = temp[i])) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i])) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push((matcherIn[i] = elem));
                  }
                }
                postFinder(null, (matcherOut = []), temp, xml);
              }

              // Move matched elements from seed to results to keep them synchronized
              i = matcherOut.length;
              while (i--) {
                if (
                  (elem = matcherOut[i]) &&
                  (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1
                ) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }

            // Add elements to results, through postFinder if defined
          } else {
            matcherOut = condense(
              matcherOut === results
                ? matcherOut.splice(preexisting, matcherOut.length)
                : matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(
            function (elem) {
              return elem === checkContext;
            },
            implicitRelative,
            true
          ),
          matchAnyContext = addCombinator(
            function (elem) {
              return indexOf(checkContext, elem) > -1;
            },
            implicitRelative,
            true
          ),
          matchers = [
            function (elem, context, xml) {
              var ret =
                (!leadingRelative && (xml || context !== outermostContext)) ||
                ((checkContext = context).nodeType
                  ? matchContext(elem, context, xml)
                  : matchAnyContext(elem, context, xml));
              // Avoid hanging onto element (issue #299)
              checkContext = null;
              return ret;
            },
          ];

        for (; i < len; i++) {
          if ((matcher = Expr.relative[tokens[i].type])) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(
              null,
              tokens[i].matches
            );

            // Return special upon seeing a positional matcher
            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i > 1 && elementMatcher(matchers),
                i > 1 &&
                  toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens
                      .slice(0, i - 1)
                      .concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                  ).replace(rtrim, "$1"),
                matcher,
                i < j && matcherFromTokens(tokens.slice(i, j)),
                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                j < len && toSelector(tokens)
              );
            }
            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function (seed, context, xml, results, outermost) {
            var elem,
              j,
              matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
              elems = seed || (byElement && Expr.find["TAG"]("*", outermost)),
              // Use integer dirruns iff this is the outermost matcher
              dirrunsUnique = (dirruns +=
                contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;

            if (outermost) {
              outermostContext = context === document || context || outermost;
            }

            // Add elements passing elementMatchers directly to results
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }

              // Track unmatched elements for set filters
              if (bySet) {
                // They will have gone through all possible matchers
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }

                // Lengthen the array for every element, matched or not
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }

            // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.
            matchedCount += i;

            // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }

              if (seed) {
                // Reintegrate element matches to eliminate the need for sorting
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }

                // Discard index placeholder values to get only actual matches
                setMatched = condense(setMatched);
              }

              // Add matches to results
              push.apply(results, setMatched);

              // Seedless set matches succeeding multiple successful matchers stipulate sorting
              if (
                outermost &&
                !seed &&
                setMatched.length > 0 &&
                matchedCount + setMatchers.length > 1
              ) {
                Sizzle.uniqueSort(results);
              }
            }

            // Override manipulation of globals by nested matchers
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

        return bySet ? markFunction(superMatcher) : superMatcher;
      }

      compile = Sizzle.compile = function (
        selector,
        match /* Internal Use Only */
      ) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }

          // Cache the compiled function
          cached = compilerCache(
            selector,
            matcherFromGroupMatchers(elementMatchers, setMatchers)
          );

          // Save selector and tokenization
          cached.selector = selector;
        }
        return cached;
      };

      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */
      select = Sizzle.select = function (selector, context, results, seed) {
        var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));

        results = results || [];

        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if (match.length === 1) {
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);
          if (
            tokens.length > 2 &&
            (token = tokens[0]).type === "ID" &&
            support.getById &&
            context.nodeType === 9 &&
            documentIsHTML &&
            Expr.relative[tokens[1].type]
          ) {
            context = (Expr.find["ID"](
              token.matches[0].replace(runescape, funescape),
              context
            ) || [])[0];
            if (!context) {
              return results;

              // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];

            // Abort if we hit a combinator
            if (Expr.relative[(type = token.type)]) {
              break;
            }
            if ((find = Expr.find[type])) {
              // Search, expanding context for leading sibling combinators
              if (
                (seed = find(
                  token.matches[0].replace(runescape, funescape),
                  (rsibling.test(tokens[0].type) &&
                    testContext(context.parentNode)) ||
                    context
                ))
              ) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        }

        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        (compiled || compile(selector, match))(
          seed,
          context,
          !documentIsHTML,
          results,
          !context ||
            (rsibling.test(selector) && testContext(context.parentNode)) ||
            context
        );
        return results;
      };

      // One-time assignments

      // Sort stability
      support.sortStable =
        expando.split("").sort(sortOrder).join("") === expando;

      // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function
      support.detectDuplicates = !!hasDuplicate;

      // Initialize against the default document
      setDocument();

      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*
      support.sortDetached = assert(function (div1) {
        // Should return 1, but returns 4 (following)
        return div1.compareDocumentPosition(document.createElement("div")) & 1;
      });

      // Support: IE<8
      // Prevent attribute/property "interpolation"
      // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
      if (
        !assert(function (div) {
          div.innerHTML = "<a href='#'></a>";
          return div.firstChild.getAttribute("href") === "#";
        })
      ) {
        addHandle("type|href|height|width", function (elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(
              name,
              name.toLowerCase() === "type" ? 1 : 2
            );
          }
        });
      }

      // Support: IE<9
      // Use defaultValue in place of getAttribute("value")
      if (
        !support.attributes ||
        !assert(function (div) {
          div.innerHTML = "<input/>";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })
      ) {
        addHandle("value", function (elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }

      // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies
      if (
        !assert(function (div) {
          return div.getAttribute("disabled") == null;
        })
      ) {
        addHandle(booleans, function (elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true
              ? name.toLowerCase()
              : (val = elem.getAttributeNode(name)) && val.specified
              ? val.value
              : null;
          }
        });
      }

      return Sizzle;
    })(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;

  var dir = function (elem, dir, until) {
    var matched = [],
      truncate = until !== undefined;

    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };

  var siblings = function (n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

  var risSimple = /^.[^:#\[\.,]*$/;

  // Implement the identical functionality for filter and not
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        /* jshint -W018 */
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }

    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return (elem === qualifier) !== not;
      });
    }

    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }

      qualifier = jQuery.filter(qualifier, elements);
    }

    return jQuery.grep(elements, function (elem) {
      return jQuery.inArray(elem, qualifier) > -1 !== not;
    });
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    return elems.length === 1 && elem.nodeType === 1
      ? jQuery.find.matchesSelector(elem, expr)
        ? [elem]
        : []
      : jQuery.find.matches(
          expr,
          jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
          })
        );
  };

  jQuery.fn.extend({
    find: function (selector) {
      var i,
        ret = [],
        self = this,
        len = self.length;

      if (typeof selector !== "string") {
        return this.pushStack(
          jQuery(selector).filter(function () {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          })
        );
      }

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      // Needed because $( selector, context ) becomes $( context ).find( selector )
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(
        this,

        // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test(selector)
          ? jQuery(selector)
          : selector || [],
        false
      ).length;
    },
  });

  // Initialize a jQuery object

  // A central reference to the root jQuery(document)
  var rootjQuery,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    init = (jQuery.fn.init = function (selector, context, root) {
      var match, elem;

      // HANDLE: $(""), $(null), $(undefined), $(false)
      if (!selector) {
        return this;
      }

      // init accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)
      root = root || rootjQuery;

      // Handle HTML strings
      if (typeof selector === "string") {
        if (
          selector.charAt(0) === "<" &&
          selector.charAt(selector.length - 1) === ">" &&
          selector.length >= 3
        ) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }

        // Match html or make sure no context is specified for #id
        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;

            // scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present
            jQuery.merge(
              this,
              jQuery.parseHTML(
                match[1],
                context && context.nodeType
                  ? context.ownerDocument || context
                  : document,
                true
              )
            );

            // HANDLE: $(html, props)
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);

                  // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }

            return this;

            // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);

            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            if (elem && elem.parentNode) {
              // Handle the case where IE and Opera return items
              // by name instead of ID
              if (elem.id !== match[2]) {
                return rootjQuery.find(selector);
              }

              // Otherwise, we inject the element directly into the jQuery object
              this.length = 1;
              this[0] = elem;
            }

            this.context = document;
            this.selector = selector;
            return this;
          }

          // HANDLE: $(expr, $(...))
        } else if (!context || context.jquery) {
          return (context || root).find(selector);

          // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        }

        // HANDLE: $(DOMElement)
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;

        // HANDLE: $(function)
        // Shortcut for document ready
      } else if (jQuery.isFunction(selector)) {
        return typeof root.ready !== "undefined"
          ? root.ready(selector)
          : // Execute immediately if ready is not present
            selector(jQuery);
      }

      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }

      return jQuery.makeArray(selector, this);
    });

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery(document);

  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true,
    };

  jQuery.fn.extend({
    has: function (target) {
      var i,
        targets = jQuery(target, this),
        len = targets.length;

      return this.filter(function () {
        for (i = 0; i < len; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },

    closest: function (selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        pos =
          rneedsContext.test(selectors) || typeof selectors !== "string"
            ? jQuery(selectors, context || this.context)
            : 0;

      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          // Always skip document fragments
          if (
            cur.nodeType < 11 &&
            (pos
              ? pos.index(cur) > -1
              : // Don't pass non-elements to Sizzle
                cur.nodeType === 1 &&
                jQuery.find.matchesSelector(cur, selectors))
          ) {
            matched.push(cur);
            break;
          }
        }
      }

      return this.pushStack(
        matched.length > 1 ? jQuery.uniqueSort(matched) : matched
      );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode
          ? this.first().prevAll().length
          : -1;
      }

      // index in selector
      if (typeof elem === "string") {
        return jQuery.inArray(this[0], jQuery(elem));
      }

      // Locate the position of the desired element
      return jQuery.inArray(
        // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[0] : elem,
        this
      );
    },

    add: function (selector, context) {
      return this.pushStack(
        jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context)))
      );
    },

    addBack: function (selector) {
      return this.add(
        selector == null ? this.prevObject : this.prevObject.filter(selector)
      );
    },
  });

  function sibling(cur, dir) {
    do {
      cur = cur[dir];
    } while (cur && cur.nodeType !== 1);

    return cur;
  }

  jQuery.each(
    {
      parent: function (elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function (elem, i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function (elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function (elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function (elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function (elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function (elem, i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function (elem, i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function (elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function (elem) {
        return siblings(elem.firstChild);
      },
      contents: function (elem) {
        return jQuery.nodeName(elem, "iframe")
          ? elem.contentDocument || elem.contentWindow.document
          : jQuery.merge([], elem.childNodes);
      },
    },
    function (name, fn) {
      jQuery.fn[name] = function (until, selector) {
        var ret = jQuery.map(this, fn, until);

        if (name.slice(-5) !== "Until") {
          selector = until;
        }

        if (selector && typeof selector === "string") {
          ret = jQuery.filter(selector, ret);
        }

        if (this.length > 1) {
          // Remove duplicates
          if (!guaranteedUnique[name]) {
            ret = jQuery.uniqueSort(ret);
          }

          // Reverse order for parents* and prev-derivatives
          if (rparentsprev.test(name)) {
            ret = ret.reverse();
          }
        }

        return this.pushStack(ret);
      };
    }
  );
  var rnotwhite = /\S+/g;

  // Convert String-formatted options into Object-formatted ones
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options =
      typeof options === "string"
        ? createOptions(options)
        : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
      firing,
      // Last fire value for non-forgettable lists
      memory,
      // Flag to know if list was already fired
      fired,
      // Flag to prevent firing
      locked,
      // Actual callback list
      list = [],
      // Queue of execution data for repeatable lists
      queue = [],
      // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
      // Fire callbacks
      fire = function () {
        // Enforce single-firing
        locked = options.once;

        // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes
        fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            // Run callback and check for early termination
            if (
              list[firingIndex].apply(memory[0], memory[1]) === false &&
              options.stopOnFalse
            ) {
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        }

        // Forget the data if we're done with it
        if (!options.memory) {
          memory = false;
        }

        firing = false;

        // Clean up if we're done firing for good
        if (locked) {
          // Keep an empty list if we have data for future add calls
          if (memory) {
            list = [];

            // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
      // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function () {
          if (list) {
            // If we have memory from a past run, we should fire after adding
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }

            (function add(args) {
              jQuery.each(args, function (_, arg) {
                if (jQuery.isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);

            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },

        // Remove a callback from the list
        remove: function () {
          jQuery.each(arguments, function (_, arg) {
            var index;
            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);

              // Handle firing indexes
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },

        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },

        // Remove all callbacks from the list
        empty: function () {
          if (list) {
            list = [];
          }
          return this;
        },

        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function () {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function () {
          return !list;
        },

        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function () {
          locked = true;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !!locked;
        },

        // Call all callbacks with the given context and arguments
        fireWith: function (context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },

        // Call all the callbacks with the given arguments
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },

        // To know if the callbacks have already been called at least once
        fired: function () {
          return !!fired;
        },
      };

    return self;
  };

  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          // action, add listener, listener list, final state
          ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
          ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
          ["notify", "progress", jQuery.Callbacks("memory")],
        ],
        state = "pending",
        promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function (/* fnDone, fnFail, fnProgress */) {
            var fns = arguments;
            return jQuery
              .Deferred(function (newDefer) {
                jQuery.each(tuples, function (i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];

                  // deferred[ done | fail | progress ] for forwarding actions to newDefer
                  deferred[tuple[1]](function () {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned
                        .promise()
                        .progress(newDefer.notify)
                        .done(newDefer.resolve)
                        .fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this === promise ? newDefer.promise() : this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              })
              .promise();
          },

          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          },
        },
        deferred = {};

      // Keep pipe for back-compat
      promise.pipe = promise.then;

      // Add list-specific methods
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
          stateString = tuple[3];

        // promise[ done | fail | progress ] = list.add
        promise[tuple[1]] = list.add;

        // Handle state
        if (stateString) {
          list.add(
            function () {
              // state = [ resolved | rejected ]
              state = stateString;

              // [ reject_list | resolve_list ].disable; progress_list.lock
            },
            tuples[i ^ 1][2].disable,
            tuples[2][2].lock
          );
        }

        // deferred[ resolve | reject | notify ]
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](
            this === deferred ? promise : this,
            arguments
          );
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });

      // Make the deferred a promise
      promise.promise(deferred);

      // Call given func if any
      if (func) {
        func.call(deferred, deferred);
      }

      // All done!
      return deferred;
    },

    // Deferred helper
    when: function (subordinate /* , ..., subordinateN */) {
      var i = 0,
        resolveValues = slice.call(arguments),
        length = resolveValues.length,
        // the count of uncompleted subordinates
        remaining =
          length !== 1 ||
          (subordinate && jQuery.isFunction(subordinate.promise))
            ? length
            : 0,
        // the master Deferred.
        // If resolveValues consist of only a single Deferred, just use that.
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
        // Update function for both resolve and progress values
        updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        },
        progressValues,
        progressContexts,
        resolveContexts;

      // add listeners to Deferred subordinates; treat others as resolved
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i]
              .promise()
              .progress(updateFunc(i, progressContexts, progressValues))
              .done(updateFunc(i, resolveContexts, resolveValues))
              .fail(deferred.reject);
          } else {
            --remaining;
          }
        }
      }

      // if we're not waiting on anything, resolve the master
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }

      return deferred.promise();
    },
  });

  // The deferred used on DOM ready
  var readyList;

  jQuery.fn.ready = function (fn) {
    // Add the callback
    jQuery.ready.promise().done(fn);

    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },

    // Handle when the DOM is ready
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }

      // Remember that the DOM is ready
      jQuery.isReady = true;

      // If a normal DOM Ready event fired, decrement, and wait if need be
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }

      // If there are functions bound, to execute
      readyList.resolveWith(document, [jQuery]);

      // Trigger any bound ready events
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    },
  });

  /**
   * Clean-up method for dom ready events
   */
  function detach() {
    if (document.addEventListener) {
      document.removeEventListener("DOMContentLoaded", completed);
      window.removeEventListener("load", completed);
    } else {
      document.detachEvent("onreadystatechange", completed);
      window.detachEvent("onload", completed);
    }
  }

  /**
   * The ready event handler and self cleanup method
   */
  function completed() {
    // readyState === "complete" is good enough for us to call the dom ready in oldIE
    if (
      document.addEventListener ||
      window.event.type === "load" ||
      document.readyState === "complete"
    ) {
      detach();
      jQuery.ready();
    }
  }

  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();

      // Catch cases where $(document).ready() is called
      // after the browser event has already occurred.
      // Support: IE6-10
      // Older IE sometimes signals "interactive" too soon
      if (
        document.readyState === "complete" ||
        (document.readyState !== "loading" &&
          !document.documentElement.doScroll)
      ) {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);

        // Standards-based browsers support DOMContentLoaded
      } else if (document.addEventListener) {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);

        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed);

        // If IE event model is used
      } else {
        // Ensure firing before onload, maybe late but safe also for iframes
        document.attachEvent("onreadystatechange", completed);

        // A fallback to window.onload, that will always work
        window.attachEvent("onload", completed);

        // If IE and not a frame
        // continually check to see if the document is ready
        var top = false;

        try {
          top = window.frameElement == null && document.documentElement;
        } catch (e) {}

        if (top && top.doScroll) {
          (function doScrollCheck() {
            if (!jQuery.isReady) {
              try {
                // Use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                top.doScroll("left");
              } catch (e) {
                return window.setTimeout(doScrollCheck, 50);
              }

              // detach all dom ready events
              detach();

              // and execute any waiting functions
              jQuery.ready();
            }
          })();
        }
      }
    }
    return readyList.promise(obj);
  };

  // Kick off the DOM ready check even if the user does not
  jQuery.ready.promise();

  // Support: IE<9
  // Iteration over object's inherited properties before its own
  var i;
  for (i in jQuery(support)) {
    break;
  }
  support.ownFirst = i === "0";

  // Note: most support tests are defined in their respective modules.
  // false until the test is run
  support.inlineBlockNeedsLayout = false;

  // Execute ASAP in case we need to set body.style.zoom
  jQuery(function () {
    // Minified: var a,b,c,d
    var val, div, body, container;

    body = document.getElementsByTagName("body")[0];
    if (!body || !body.style) {
      // Return for frameset docs that don't have a body
      return;
    }

    // Setup
    div = document.createElement("div");
    container = document.createElement("div");
    container.style.cssText =
      "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
    body.appendChild(container).appendChild(div);

    if (typeof div.style.zoom !== "undefined") {
      // Support: IE<8
      // Check if natively block-level elements act like inline-block
      // elements when setting their display to 'inline' and giving
      // them layout
      div.style.cssText =
        "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

      support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
      if (val) {
        // Prevent IE 6 from affecting layout for positioned elements #11048
        // Prevent IE from shrinking the body in IE 7 mode #12869
        // Support: IE<8
        body.style.zoom = 1;
      }
    }

    body.removeChild(container);
  });

  (function () {
    var div = document.createElement("div");

    // Support: IE<9
    support.deleteExpando = true;
    try {
      delete div.test;
    } catch (e) {
      support.deleteExpando = false;
    }

    // Null elements to avoid leaks in IE.
    div = null;
  })();
  var acceptData = function (elem) {
    var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()],
      nodeType = +elem.nodeType || 1;

    // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
    return nodeType !== 1 && nodeType !== 9
      ? false
      : // Nodes accept data unless otherwise specified; rejection can be conditional
        !noData || (noData !== true && elem.getAttribute("classid") === noData);
  };

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

  function dataAttr(elem, key, data) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data =
            data === "true"
              ? true
              : data === "false"
              ? false
              : data === "null"
              ? null
              : // Only convert to a number if it doesn't change the string
              +data + "" === data
              ? +data
              : rbrace.test(data)
              ? jQuery.parseJSON(data)
              : data;
        } catch (e) {}

        // Make sure we set the data so it isn't changed later
        jQuery.data(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  // checks a cache object for emptiness
  function isEmptyDataObject(obj) {
    var name;
    for (name in obj) {
      // if the public data object is empty, the private is still empty
      if (name === "data" && jQuery.isEmptyObject(obj[name])) {
        continue;
      }
      if (name !== "toJSON") {
        return false;
      }
    }

    return true;
  }

  function internalData(elem, name, data, pvt /* Internal Use Only */) {
    if (!acceptData(elem)) {
      return;
    }

    var ret,
      thisCache,
      internalKey = jQuery.expando,
      // We have to handle DOM nodes and JS objects differently because IE6-7
      // can't GC object references properly across the DOM-JS boundary
      isNode = elem.nodeType,
      // Only DOM nodes need the global jQuery cache; JS object data is
      // attached directly to the object so GC can occur automatically
      cache = isNode ? jQuery.cache : elem,
      // Only defining an ID for JS objects if its cache already exists allows
      // the code to shortcut on the same path as a DOM node with no cache
      id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if (
      (!id || !cache[id] || (!pvt && !cache[id].data)) &&
      data === undefined &&
      typeof name === "string"
    ) {
      return;
    }

    if (!id) {
      // Only DOM nodes need a new unique ID for each element since their data
      // ends up in the global cache
      if (isNode) {
        id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
      } else {
        id = internalKey;
      }
    }

    if (!cache[id]) {
      // Avoid exposing jQuery metadata on plain JS objects when the object
      // is serialized using JSON.stringify
      cache[id] = isNode ? {} : { toJSON: jQuery.noop };
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if (typeof name === "object" || typeof name === "function") {
      if (pvt) {
        cache[id] = jQuery.extend(cache[id], name);
      } else {
        cache[id].data = jQuery.extend(cache[id].data, name);
      }
    }

    thisCache = cache[id];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if (!pvt) {
      if (!thisCache.data) {
        thisCache.data = {};
      }

      thisCache = thisCache.data;
    }

    if (data !== undefined) {
      thisCache[jQuery.camelCase(name)] = data;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if (typeof name === "string") {
      // First Try to find as-is property data
      ret = thisCache[name];

      // Test for null|undefined property data
      if (ret == null) {
        // Try to find the camelCased property
        ret = thisCache[jQuery.camelCase(name)];
      }
    } else {
      ret = thisCache;
    }

    return ret;
  }

  function internalRemoveData(elem, name, pvt) {
    if (!acceptData(elem)) {
      return;
    }

    var thisCache,
      i,
      isNode = elem.nodeType,
      // See jQuery.data for more information
      cache = isNode ? jQuery.cache : elem,
      id = isNode ? elem[jQuery.expando] : jQuery.expando;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if (!cache[id]) {
      return;
    }

    if (name) {
      thisCache = pvt ? cache[id] : cache[id].data;

      if (thisCache) {
        // Support array or space separated string names for data keys
        if (!jQuery.isArray(name)) {
          // try the string as a key before any manipulation
          if (name in thisCache) {
            name = [name];
          } else {
            // split the camel cased version by spaces unless a key with the spaces exists
            name = jQuery.camelCase(name);
            if (name in thisCache) {
              name = [name];
            } else {
              name = name.split(" ");
            }
          }
        } else {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = name.concat(jQuery.map(name, jQuery.camelCase));
        }

        i = name.length;
        while (i--) {
          delete thisCache[name[i]];
        }

        // If there is no data left in the cache, we want to continue
        // and let the cache object itself get destroyed
        if (
          pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)
        ) {
          return;
        }
      }
    }

    // See jQuery.data for more information
    if (!pvt) {
      delete cache[id].data;

      // Don't destroy the parent cache unless the internal data object
      // had been the only thing left in it
      if (!isEmptyDataObject(cache[id])) {
        return;
      }
    }

    // Destroy the cache
    if (isNode) {
      jQuery.cleanData([elem], true);

      // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
      /* jshint eqeqeq: false */
    } else if (support.deleteExpando || cache != cache.window) {
      /* jshint eqeqeq: true */
      delete cache[id];

      // When all else fails, undefined
    } else {
      cache[id] = undefined;
    }
  }

  jQuery.extend({
    cache: {},

    // The following elements (space-suffixed to avoid Object.prototype collisions)
    // throw uncatchable exceptions if you attempt to set expando properties
    noData: {
      "applet ": true,
      "embed ": true,

      // ...but Flash objects (which have this classid) *can* handle expandos
      "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
    },

    hasData: function (elem) {
      elem = elem.nodeType
        ? jQuery.cache[elem[jQuery.expando]]
        : elem[jQuery.expando];
      return !!elem && !isEmptyDataObject(elem);
    },

    data: function (elem, name, data) {
      return internalData(elem, name, data);
    },

    removeData: function (elem, name) {
      return internalRemoveData(elem, name);
    },

    // For internal use only.
    _data: function (elem, name, data) {
      return internalData(elem, name, data, true);
    },

    _removeData: function (elem, name) {
      return internalRemoveData(elem, name, true);
    },
  });

  jQuery.fn.extend({
    data: function (key, value) {
      var i,
        name,
        data,
        elem = this[0],
        attrs = elem && elem.attributes;

      // Special expections of .data basically thwart jQuery.access,
      // so implement the relevant behavior ourselves

      // Gets all values
      if (key === undefined) {
        if (this.length) {
          data = jQuery.data(elem);

          if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
            i = attrs.length;
            while (i--) {
              // Support: IE11+
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            jQuery._data(elem, "parsedAttrs", true);
          }
        }

        return data;
      }

      // Sets multiple values
      if (typeof key === "object") {
        return this.each(function () {
          jQuery.data(this, key);
        });
      }

      return arguments.length > 1
        ? // Sets one value
          this.each(function () {
            jQuery.data(this, key, value);
          })
        : // Gets one value
        // Try to fetch any internally stored data first
        elem
        ? dataAttr(elem, key, jQuery.data(elem, key))
        : undefined;
    },

    removeData: function (key) {
      return this.each(function () {
        jQuery.removeData(this, key);
      });
    },
  });

  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = jQuery._data(elem, type);

        // Speed up dequeue by getting out quickly if this is just a lookup
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = jQuery._data(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },

    dequeue: function (elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function () {
          jQuery.dequeue(elem, type);
        };

      // If the fx queue is dequeued, always remove the progress sentinel
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        }

        // clear up the last queue stop function
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },

    // not intended for public consumption - generates a queueHooks object,
    // or returns the current one
    _queueHooks: function (elem, type) {
      var key = type + "queueHooks";
      return (
        jQuery._data(elem, key) ||
        jQuery._data(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function () {
            jQuery._removeData(elem, type + "queue");
            jQuery._removeData(elem, key);
          }),
        })
      );
    },
  });

  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined
        ? this
        : this.each(function () {
            var queue = jQuery.queue(this, type, data);

            // ensure a hooks for this queue
            jQuery._queueHooks(this, type);

            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || "fx", []);
    },

    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function (type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while (i--) {
        tmp = jQuery._data(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    },
  });

  (function () {
    var shrinkWrapBlocksVal;

    support.shrinkWrapBlocks = function () {
      if (shrinkWrapBlocksVal != null) {
        return shrinkWrapBlocksVal;
      }

      // Will be changed later if needed.
      shrinkWrapBlocksVal = false;

      // Minified: var b,c,d
      var div, body, container;

      body = document.getElementsByTagName("body")[0];
      if (!body || !body.style) {
        // Test fired too early or in an unsupported environment, exit.
        return;
      }

      // Setup
      div = document.createElement("div");
      container = document.createElement("div");
      container.style.cssText =
        "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
      body.appendChild(container).appendChild(div);

      // Support: IE6
      // Check if elements with layout shrink-wrap their children
      if (typeof div.style.zoom !== "undefined") {
        // Reset CSS: box-sizing; display; margin; border
        div.style.cssText =
          // Support: Firefox<29, Android 2.3
          // Vendor-prefix box-sizing
          "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
          "box-sizing:content-box;display:block;margin:0;border:0;" +
          "padding:1px;width:1px;zoom:1";
        div.appendChild(document.createElement("div")).style.width = "5px";
        shrinkWrapBlocksVal = div.offsetWidth !== 3;
      }

      body.removeChild(container);

      return shrinkWrapBlocksVal;
    };
  })();
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

  var cssExpand = ["Top", "Right", "Bottom", "Left"];

  var isHidden = function (elem, el) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return (
      jQuery.css(elem, "display") === "none" ||
      !jQuery.contains(elem.ownerDocument, elem)
    );
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
      scale = 1,
      maxIterations = 20,
      currentValue = tween
        ? function () {
            return tween.cur();
          }
        : function () {
            return jQuery.css(elem, prop, "");
          },
      initial = currentValue(),
      unit =
        (valueParts && valueParts[3]) || (jQuery.cssNumber[prop] ? "" : "px"),
      // Starting value computation is required for potential unit mismatches
      initialInUnit =
        (jQuery.cssNumber[prop] || (unit !== "px" && +initial)) &&
        rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Trust units reported by jQuery.css
      unit = unit || initialInUnit[3];

      // Make sure we update the tween properties later on
      valueParts = valueParts || [];

      // Iteratively approximate from a nonzero starting point
      initialInUnit = +initial || 1;

      do {
        // If previous iteration zeroed out, double until we get *something*.
        // Use string for doubling so we don't accidentally see scale as unchanged below
        scale = scale || ".5";

        // Adjust and apply
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);

        // Update scale, tolerating zero or NaN from tween.cur()
        // Break the loop if scale is unchanged or perfect, or if we've just had enough.
      } while (
        scale !== (scale = currentValue() / initial) &&
        scale !== 1 &&
        --maxIterations
      );
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;

      // Apply relative offset (+=/-=) if specified
      adjusted = valueParts[1]
        ? initialInUnit + (valueParts[1] + 1) * valueParts[2]
        : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }

  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      length = elems.length,
      bulk = key == null;

    // Sets many values
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }

      // Sets one value
    } else if (value !== undefined) {
      chainable = true;

      if (!jQuery.isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null;

          // ...except when executing function values
        } else {
          bulk = fn;
          fn = function (elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < length; i++) {
          fn(
            elems[i],
            key,
            raw ? value : value.call(elems[i], i, fn(elems[i], key))
          );
        }
      }
    }

    return chainable
      ? elems
      : // Gets
      bulk
      ? fn.call(elems)
      : length
      ? fn(elems[0], key)
      : emptyGet;
  };
  var rcheckableType = /^(?:checkbox|radio)$/i;

  var rtagName = /<([\w:-]+)/;

  var rscriptType = /^$|\/(?:java|ecma)script/i;

  var rleadingWhitespace = /^\s+/;

  var nodeNames =
    "abbr|article|aside|audio|bdi|canvas|data|datalist|" +
    "details|dialog|figcaption|figure|footer|header|hgroup|main|" +
    "mark|meter|nav|output|picture|progress|section|summary|template|time|video";

  function createSafeFragment(document) {
    var list = nodeNames.split("|"),
      safeFrag = document.createDocumentFragment();

    if (safeFrag.createElement) {
      while (list.length) {
        safeFrag.createElement(list.pop());
      }
    }
    return safeFrag;
  }

  (function () {
    var div = document.createElement("div"),
      fragment = document.createDocumentFragment(),
      input = document.createElement("input");

    // Setup
    div.innerHTML =
      "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

    // IE strips leading whitespace when .innerHTML is used
    support.leadingWhitespace = div.firstChild.nodeType === 3;

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    support.tbody = !div.getElementsByTagName("tbody").length;

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    support.htmlSerialize = !!div.getElementsByTagName("link").length;

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    support.html5Clone =
      document.createElement("nav").cloneNode(true).outerHTML !==
      "<:nav></:nav>";

    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    input.type = "checkbox";
    input.checked = true;
    fragment.appendChild(input);
    support.appendChecked = input.checked;

    // Make sure textarea (and checkbox) defaultValue is properly cloned
    // Support: IE6-IE11+
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

    // #11217 - WebKit loses check when the name is after the checked attribute
    fragment.appendChild(div);

    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)
    input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");

    div.appendChild(input);

    // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
    // old WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

    // Support: IE<9
    // Cloned elements keep attachEvent handlers, we use addEventListener on IE9+
    support.noCloneEvent = !!div.addEventListener;

    // Support: IE<9
    // Since attributes and properties are the same in IE,
    // cleanData must set properties to undefined rather than use removeAttribute
    div[jQuery.expando] = 1;
    support.attributes = !div.getAttribute(jQuery.expando);
  })();

  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    legend: [1, "<fieldset>", "</fieldset>"],
    area: [1, "<map>", "</map>"],

    // Support: IE8
    param: [1, "<object>", "</object>"],
    thead: [1, "<table>", "</table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
    // unless wrapped in a div with non-breaking characters in front of it.
    _default: support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"],
  };

  // Support: IE8-IE9
  wrapMap.optgroup = wrapMap.option;

  wrapMap.tbody =
    wrapMap.tfoot =
    wrapMap.colgroup =
    wrapMap.caption =
      wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function getAll(context, tag) {
    var elems,
      elem,
      i = 0,
      found =
        typeof context.getElementsByTagName !== "undefined"
          ? context.getElementsByTagName(tag || "*")
          : typeof context.querySelectorAll !== "undefined"
          ? context.querySelectorAll(tag || "*")
          : undefined;

    if (!found) {
      for (
        found = [], elems = context.childNodes || context;
        (elem = elems[i]) != null;
        i++
      ) {
        if (!tag || jQuery.nodeName(elem, tag)) {
          found.push(elem);
        } else {
          jQuery.merge(found, getAll(elem, tag));
        }
      }
    }

    return tag === undefined || (tag && jQuery.nodeName(context, tag))
      ? jQuery.merge([context], found)
      : found;
  }

  // Mark scripts as having already been evaluated
  function setGlobalEval(elems, refElements) {
    var elem,
      i = 0;
    for (; (elem = elems[i]) != null; i++) {
      jQuery._data(
        elem,
        "globalEval",
        !refElements || jQuery._data(refElements[i], "globalEval")
      );
    }
  }

  var rhtml = /<|&#?\w+;/,
    rtbody = /<tbody/i;

  function fixDefaultChecked(elem) {
    if (rcheckableType.test(elem.type)) {
      elem.defaultChecked = elem.checked;
    }
  }

  function buildFragment(elems, context, scripts, selection, ignored) {
    var j,
      elem,
      contains,
      tmp,
      tag,
      tbody,
      wrap,
      l = elems.length,
      // Ensure a safe fragment
      safe = createSafeFragment(context),
      nodes = [],
      i = 0;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

          // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));

          // Convert html into DOM nodes
        } else {
          tmp = tmp || safe.appendChild(context.createElement("div"));

          // Deserialize a standard representation
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;

          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

          // Descend through wrappers to the right content
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }

          // Manually add leading whitespace removed by IE
          if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
            nodes.push(
              context.createTextNode(rleadingWhitespace.exec(elem)[0])
            );
          }

          // Remove IE's autoinserted <tbody> from table fragments
          if (!support.tbody) {
            // String was a <table>, *may* have spurious <tbody>
            elem =
              tag === "table" && !rtbody.test(elem)
                ? tmp.firstChild
                : // String was a bare <thead> or <tfoot>
                wrap[1] === "<table>" && !rtbody.test(elem)
                ? tmp
                : 0;

            j = elem && elem.childNodes.length;
            while (j--) {
              if (
                jQuery.nodeName((tbody = elem.childNodes[j]), "tbody") &&
                !tbody.childNodes.length
              ) {
                elem.removeChild(tbody);
              }
            }
          }

          jQuery.merge(nodes, tmp.childNodes);

          // Fix #12392 for WebKit and IE > 9
          tmp.textContent = "";

          // Fix #12392 for oldIE
          while (tmp.firstChild) {
            tmp.removeChild(tmp.firstChild);
          }

          // Remember the top-level container for proper cleanup
          tmp = safe.lastChild;
        }
      }
    }

    // Fix #11356: Clear elements from fragment
    if (tmp) {
      safe.removeChild(tmp);
    }

    // Reset defaultChecked for any radios and checkboxes
    // about to be appended to the DOM in IE 6/7 (#8060)
    if (!support.appendChecked) {
      jQuery.grep(getAll(nodes, "input"), fixDefaultChecked);
    }

    i = 0;
    while ((elem = nodes[i++])) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      contains = jQuery.contains(elem.ownerDocument, elem);

      // Append to fragment
      tmp = getAll(safe.appendChild(elem), "script");

      // Preserve script evaluation history
      if (contains) {
        setGlobalEval(tmp);
      }

      // Capture executables
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    tmp = null;

    return safe;
  }

  (function () {
    var i,
      eventName,
      div = document.createElement("div");

    // Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)
    for (i in { submit: true, change: true, focusin: true }) {
      eventName = "on" + i;

      if (!(support[i] = eventName in window)) {
        // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
        div.setAttribute(eventName, "t");
        support[i] = div.attributes[eventName].expando === false;
      }
    }

    // Null elements to avoid leaks in IE.
    div = null;
  })();

  var rformElems = /^(?:input|select|textarea)$/i,
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Support: IE9
  // See #13393 for more info
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function on(elem, types, selector, data, fn, one) {
    var origFn, type;

    // Types can be a map of types/handlers
    if (typeof types === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;
      fn = function (event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };

      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {
    global: {},

    add: function (elem, types, handler, data, selector) {
      var tmp,
        events,
        t,
        handleObjIn,
        special,
        eventHandle,
        handleObj,
        handlers,
        type,
        namespaces,
        origType,
        elemData = jQuery._data(elem);

      // Don't attach events to noData or text/comment nodes (but allow plain objects)
      if (!elemData) {
        return;
      }

      // Caller can pass in an object of custom data in lieu of the handler
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }

      // Make sure that the handler has a unique ID, used to find/remove it later
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }

      // Init the element's event structure and main handler, if this is the first
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" &&
            (!e || jQuery.event.triggered !== e.type)
            ? jQuery.event.dispatch.apply(eventHandle.elem, arguments)
            : undefined;
        };

        // Add elem as a property of the handle fn to prevent a memory leak
        // with IE non-native events
        eventHandle.elem = elem;
      }

      // Handle multiple events separated by a space
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // There *must* be a type, no attaching namespace-only handlers
        if (!type) {
          continue;
        }

        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[type] || {};

        // If selector defined, determine special event api type, otherwise given type
        type = (selector ? special.delegateType : special.bindType) || type;

        // Update special based on newly reset type
        special = jQuery.event.special[type] || {};

        // handleObj is passed to all event handlers
        handleObj = jQuery.extend(
          {
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext:
              selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join("."),
          },
          handleObjIn
        );

        // Init the event handler queue if we're the first
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;

          // Only use addEventListener/attachEvent if the special events handler returns false
          if (
            !special.setup ||
            special.setup.call(elem, data, namespaces, eventHandle) === false
          ) {
            // Bind the global event handler to the element
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            } else if (elem.attachEvent) {
              elem.attachEvent("on" + type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }

        // Add to the element's handler list, delegates in front
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }

        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[type] = true;
      }

      // Nullify elem to prevent memory leaks in IE
      elem = null;
    },

    // Detach an event or set of events from an element
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j,
        handleObj,
        tmp,
        origCount,
        t,
        events,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = jQuery.hasData(elem) && jQuery._data(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      }

      // Once for each type.namespace in types; type may be omitted
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // Unbind all events (on this namespace, if provided) for the element
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp =
          tmp[2] &&
          new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

        // Remove matching events
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];

          if (
            (mappedTypes || origType === handleObj.origType) &&
            (!handler || handler.guid === handleObj.guid) &&
            (!tmp || tmp.test(handleObj.namespace)) &&
            (!selector ||
              selector === handleObj.selector ||
              (selector === "**" && handleObj.selector))
          ) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }

        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if (origCount && !handlers.length) {
          if (
            !special.teardown ||
            special.teardown.call(elem, namespaces, elemData.handle) === false
          ) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      }

      // Remove the expando if it's no longer used
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;

        // removeData also checks for emptiness and clears the expando if empty
        // so use it instead of delete
        jQuery._removeData(elem, "events");
      }
    },

    trigger: function (event, data, elem, onlyHandlers) {
      var handle,
        ontype,
        cur,
        bubbleType,
        special,
        tmp,
        i,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace")
          ? event.namespace.split(".")
          : [];

      cur = tmp = elem = elem || document;

      // Don't do events on text and comment nodes
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }

      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;

      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[jQuery.expando]
        ? event
        : new jQuery.Event(type, typeof event === "object" && event);

      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace
        ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)")
        : null;

      // Clean up the event in case it is being reused
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }

      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ? [event] : jQuery.makeArray(data, [event]);

      // Allow special events to draw outside the lines
      special = jQuery.event.special[type] || {};
      if (
        !onlyHandlers &&
        special.trigger &&
        special.trigger.apply(elem, data) === false
      ) {
        return;
      }

      // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }

        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }

      // Fire handlers on the event path
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;

        // jQuery handler
        handle =
          (jQuery._data(cur, "events") || {})[event.type] &&
          jQuery._data(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        }

        // Native handler
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;

      // If nobody prevented the default action, do it now
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if (
          (!special._default ||
            special._default.apply(eventPath.pop(), data) === false) &&
          acceptData(elem)
        ) {
          // Call a native DOM method on the target with the same name name as the event.
          // Can't use an .isFunction() check here because IE6/7 fails that test.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && elem[type] && !jQuery.isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            }

            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
            try {
              elem[type]();
            } catch (e) {
              // IE<9 dies on focus/blur to hidden element (#1486,#12518)
              // only reproducible on winXP IE8 native, not IE9 in IE8 mode
            }
            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },

    dispatch: function (event) {
      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(event);

      var i,
        j,
        ret,
        matched,
        handleObj,
        handlerQueue = [],
        args = slice.call(arguments),
        handlers = (jQuery._data(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};

      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[0] = event;
      event.delegateTarget = this;

      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if (
        special.preDispatch &&
        special.preDispatch.call(this, event) === false
      ) {
        return;
      }

      // Determine handlers
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);

      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;

        j = 0;
        while (
          (handleObj = matched.handlers[j++]) &&
          !event.isImmediatePropagationStopped()
        ) {
          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;

            ret = (
              (jQuery.event.special[handleObj.origType] || {}).handle ||
              handleObj.handler
            ).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }

      // Call the postDispatch hook for the mapped type
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },

    handlers: function (event, handlers) {
      var i,
        matches,
        sel,
        handleObj,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;

      // Support (at least): Chrome, IE9
      // Find delegate handlers
      // Black-hole SVG <use> instance trees (#13180)
      //
      // Support: Firefox<=42+
      // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
      if (
        delegateCount &&
        cur.nodeType &&
        (event.type !== "click" || isNaN(event.button) || event.button < 1)
      ) {
        /* jshint eqeqeq: false */
        for (; cur != this; cur = cur.parentNode || this) {
          /* jshint eqeqeq: true */

          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (
            cur.nodeType === 1 &&
            (cur.disabled !== true || event.type !== "click")
          ) {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];

              // Don't conflict with Object.prototype properties (#13203)
              sel = handleObj.selector + " ";

              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext
                  ? jQuery(sel, this).index(cur) > -1
                  : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({ elem: cur, handlers: matches });
            }
          }
        }
      }

      // Add the remaining (directly-bound) handlers
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount),
        });
      }

      return handlerQueue;
    },

    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }

      // Create a writable copy of the event object and normalize some properties
      var i,
        prop,
        copy,
        type = event.type,
        originalEvent = event,
        fixHook = this.fixHooks[type];

      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type)
          ? this.mouseHooks
          : rkeyEvent.test(type)
          ? this.keyHooks
          : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

      event = new jQuery.Event(originalEvent);

      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }

      // Support: IE<9
      // Fix target property (#1925)
      if (!event.target) {
        event.target = originalEvent.srcElement || document;
      }

      // Support: Safari 6-8+
      // Target should not be a text node (#504, #13143)
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }

      // Support: IE<9
      // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
      event.metaKey = !!event.metaKey;

      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    props: (
      "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
      "metaKey relatedTarget shiftKey target timeStamp view which"
    ).split(" "),

    fixHooks: {},

    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function (event, original) {
        // Add which for key events
        if (event.which == null) {
          event.which =
            original.charCode != null ? original.charCode : original.keyCode;
        }

        return event;
      },
    },

    mouseHooks: {
      props: (
        "button buttons clientX clientY fromElement offsetX offsetY " +
        "pageX pageY screenX screenY toElement"
      ).split(" "),
      filter: function (event, original) {
        var body,
          eventDoc,
          doc,
          button = original.button,
          fromElement = original.fromElement;

        // Calculate pageX/Y if missing and clientX/Y available
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;

          event.pageX =
            original.clientX +
            ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
            ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
          event.pageY =
            original.clientY +
            ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) -
            ((doc && doc.clientTop) || (body && body.clientTop) || 0);
        }

        // Add relatedTarget, if necessary
        if (!event.relatedTarget && fromElement) {
          event.relatedTarget =
            fromElement === event.target ? original.toElement : fromElement;
        }

        // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }

        return event;
      },
    },

    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true,
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            try {
              this.focus();
              return false;
            } catch (e) {
              // Support: IE<9
              // If we error on focus to hidden element (#1486, #12518),
              // let .trigger() run the handlers
            }
          }
        },
        delegateType: "focusin",
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout",
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function () {
          if (
            jQuery.nodeName(this, "input") &&
            this.type === "checkbox" &&
            this.click
          ) {
            this.click();
            return false;
          }
        },

        // For cross-browser consistency, don't fire native .click() on links
        _default: function (event) {
          return jQuery.nodeName(event.target, "a");
        },
      },

      beforeunload: {
        postDispatch: function (event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        },
      },
    },

    // Piggyback on a donor event to simulate a different one
    simulate: function (type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,

        // Previously, `originalEvent: {}` was set here, so stopPropagation call
        // would not be triggered on donor event, since in our own
        // jQuery.event.stopPropagation function we had a check for existence of
        // originalEvent.stopPropagation method, so, consequently it would be a noop.
        //
        // Guard for simulated events was moved to jQuery.event.stopPropagation function
        // since `originalEvent` should point to the original event for the
        // constancy with other events and for more focused logic
      });

      jQuery.event.trigger(e, null, elem);

      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    },
  };

  jQuery.removeEvent = document.removeEventListener
    ? function (elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      }
    : function (elem, type, handle) {
        var name = "on" + type;

        if (elem.detachEvent) {
          // #8545, #7054, preventing memory leaks for custom events in IE6-8
          // detachEvent needed property on element, by name of that event,
          // to properly expose it to GC
          if (typeof elem[name] === "undefined") {
            elem[name] = null;
          }

          elem.detachEvent(name, handle);
        }
      };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }

    // Event object
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented =
        src.defaultPrevented ||
        (src.defaultPrevented === undefined &&
          // Support: IE < 9, Android < 4.0
          src.returnValue === false)
          ? returnTrue
          : returnFalse;

      // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if (props) {
      jQuery.extend(this, props);
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = (src && src.timeStamp) || jQuery.now();

    // Mark it as fixed
    this[jQuery.expando] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: function () {
      var e = this.originalEvent;

      this.isDefaultPrevented = returnTrue;
      if (!e) {
        return;
      }

      // If preventDefault exists, run it on the original event
      if (e.preventDefault) {
        e.preventDefault();

        // Support: IE
        // Otherwise set the returnValue property of the original event to false
      } else {
        e.returnValue = false;
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;

      this.isPropagationStopped = returnTrue;

      if (!e || this.isSimulated) {
        return;
      }

      // If stopPropagation exists, run it on the original event
      if (e.stopPropagation) {
        e.stopPropagation();
      }

      // Support: IE
      // Set the cancelBubble property of the original event to true
      e.cancelBubble = true;
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;

      this.isImmediatePropagationStopped = returnTrue;

      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    },
  };

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://code.google.com/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each(
    {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout",
    },
    function (orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,

        handle: function (event) {
          var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;

          // For mouseenter/leave call the handler if related is outside the target.
          // NB: No relatedTarget if the mouse left/entered the browser window
          if (
            !related ||
            (related !== target && !jQuery.contains(target, related))
          ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        },
      };
    }
  );

  // IE submit delegation
  if (!support.submit) {
    jQuery.event.special.submit = {
      setup: function () {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, "form")) {
          return false;
        }

        // Lazy-add a submit handler when a descendant form may potentially be submitted
        jQuery.event.add(this, "click._submit keypress._submit", function (e) {
          // Node name check avoids a VML-related crash in IE (#9807)
          var elem = e.target,
            form =
              jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button")
                ? // Support: IE <=8
                  // We use jQuery.prop instead of elem.form
                  // to allow fixing the IE8 delegated submit issue (gh-2332)
                  // by 3rd party polyfills/workarounds.
                  jQuery.prop(elem, "form")
                : undefined;

          if (form && !jQuery._data(form, "submit")) {
            jQuery.event.add(form, "submit._submit", function (event) {
              event._submitBubble = true;
            });
            jQuery._data(form, "submit", true);
          }
        });

        // return undefined since we don't need an event listener
      },

      postDispatch: function (event) {
        // If form was submitted by the user, bubble the event up the tree
        if (event._submitBubble) {
          delete event._submitBubble;
          if (this.parentNode && !event.isTrigger) {
            jQuery.event.simulate("submit", this.parentNode, event);
          }
        }
      },

      teardown: function () {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, "form")) {
          return false;
        }

        // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
        jQuery.event.remove(this, "._submit");
      },
    };
  }

  // IE change delegation and checkbox/radio fix
  if (!support.change) {
    jQuery.event.special.change = {
      setup: function () {
        if (rformElems.test(this.nodeName)) {
          // IE doesn't fire change on a check/radio until blur; trigger it on click
          // after a propertychange. Eat the blur-change in special.change.handle.
          // This still fires onchange a second time for check/radio after blur.
          if (this.type === "checkbox" || this.type === "radio") {
            jQuery.event.add(this, "propertychange._change", function (event) {
              if (event.originalEvent.propertyName === "checked") {
                this._justChanged = true;
              }
            });
            jQuery.event.add(this, "click._change", function (event) {
              if (this._justChanged && !event.isTrigger) {
                this._justChanged = false;
              }

              // Allow triggered, simulated change events (#11500)
              jQuery.event.simulate("change", this, event);
            });
          }
          return false;
        }

        // Delegated event; lazy-add a change handler on descendant inputs
        jQuery.event.add(this, "beforeactivate._change", function (e) {
          var elem = e.target;

          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "change")) {
            jQuery.event.add(elem, "change._change", function (event) {
              if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                jQuery.event.simulate("change", this.parentNode, event);
              }
            });
            jQuery._data(elem, "change", true);
          }
        });
      },

      handle: function (event) {
        var elem = event.target;

        // Swallow native change events from checkbox/radio, we already triggered them above
        if (
          this !== elem ||
          event.isSimulated ||
          event.isTrigger ||
          (elem.type !== "radio" && elem.type !== "checkbox")
        ) {
          return event.handleObj.handler.apply(this, arguments);
        }
      },

      teardown: function () {
        jQuery.event.remove(this, "._change");

        return !rformElems.test(this.nodeName);
      },
    };
  }

  // Support: Firefox
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome, Safari
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
  if (!support.focusin) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function () {
          var doc = this.ownerDocument || this,
            attaches = jQuery._data(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          jQuery._data(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this,
            attaches = jQuery._data(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            jQuery._removeData(doc, fix);
          } else {
            jQuery._data(doc, fix, attaches);
          }
        },
      };
    });
  }

  jQuery.fn.extend({
    on: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(
          handleObj.namespace
            ? handleObj.origType + "." + handleObj.namespace
            : handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if (typeof types === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },

    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    },
  });

  var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
    rxhtmlTag =
      /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
    // Support: IE 10-11, Edge 10240+
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    safeFragment = createSafeFragment(document),
    fragmentDiv = safeFragment.appendChild(document.createElement("div"));

  // Support: IE<8
  // Manipulating tables requires a tbody
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") &&
      jQuery.nodeName(
        content.nodeType !== 11 ? content : content.firstChild,
        "tr"
      )
      ? elem.getElementsByTagName("tbody")[0] ||
          elem.appendChild(elem.ownerDocument.createElement("tbody"))
      : elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript(elem) {
    elem.type = (jQuery.find.attr(elem, "type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }

  function cloneCopyEvent(src, dest) {
    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
      return;
    }

    var type,
      i,
      l,
      oldData = jQuery._data(src),
      curData = jQuery._data(dest, oldData),
      events = oldData.events;

    if (events) {
      delete curData.handle;
      curData.events = {};

      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    }

    // make the cloned public data object a copy from the original
    if (curData.data) {
      curData.data = jQuery.extend({}, curData.data);
    }
  }

  function fixCloneNodeIssues(src, dest) {
    var nodeName, e, data;

    // We do not need to do anything for non-Elements
    if (dest.nodeType !== 1) {
      return;
    }

    nodeName = dest.nodeName.toLowerCase();

    // IE6-8 copies events bound via attachEvent when using cloneNode.
    if (!support.noCloneEvent && dest[jQuery.expando]) {
      data = jQuery._data(dest);

      for (e in data.events) {
        jQuery.removeEvent(dest, e, data.handle);
      }

      // Event data gets referenced instead of copied if the expando gets copied too
      dest.removeAttribute(jQuery.expando);
    }

    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
    if (nodeName === "script" && dest.text !== src.text) {
      disableScript(dest).text = src.text;
      restoreScript(dest);

      // IE6-10 improperly clones children of object elements using classid.
      // IE10 throws NoModificationAllowedError if parent is null, #12132.
    } else if (nodeName === "object") {
      if (dest.parentNode) {
        dest.outerHTML = src.outerHTML;
      }

      // This path appears unavoidable for IE9. When cloning an object
      // element in IE9, the outerHTML strategy above is not sufficient.
      // If the src has innerHTML and the destination does not,
      // copy the src.innerHTML into the dest.innerHTML. #10324
      if (support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {
        dest.innerHTML = src.innerHTML;
      }
    } else if (nodeName === "input" && rcheckableType.test(src.type)) {
      // IE6-8 fails to persist the checked state of a cloned checkbox
      // or radio button. Worse, IE6-7 fail to give the cloned element
      // a checked appearance if the defaultChecked value isn't also set

      dest.defaultChecked = dest.checked = src.checked;

      // IE6-7 get confused and end up setting the value of a cloned
      // checkbox/radio button to an empty string instead of "on"
      if (dest.value !== src.value) {
        dest.value = src.value;
      }

      // IE6-8 fails to return the selected option to the default selected
      // state when cloning options
    } else if (nodeName === "option") {
      dest.defaultSelected = dest.selected = src.defaultSelected;

      // IE6-8 fails to set the defaultValue to the correct value when
      // cloning other types of input fields
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = concat.apply([], args);

    var first,
      node,
      hasScripts,
      scripts,
      doc,
      fragment,
      i = 0,
      l = collection.length,
      iNoClone = l - 1,
      value = args[0],
      isFunction = jQuery.isFunction(value);

    // We can't cloneNode fragments that contain checked, in WebKit
    if (
      isFunction ||
      (l > 1 &&
        typeof value === "string" &&
        !support.checkClone &&
        rchecked.test(value))
    ) {
      return collection.each(function (index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(
        args,
        collection[0].ownerDocument,
        false,
        collection,
        ignored
      );
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      }

      // Require either new content or an interest in ignored elements to invoke the callback
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;

        // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);

            // Keep references to cloned scripts for later restoration
            if (hasScripts) {
              // Support: Android<4.1, PhantomJS<2
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;

          // Reenable scripts
          jQuery.map(scripts, restoreScript);

          // Evaluate executable scripts on first document insertion
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (
              rscriptType.test(node.type || "") &&
              !jQuery._data(node, "globalEval") &&
              jQuery.contains(doc, node)
            ) {
              if (node.src) {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                jQuery.globalEval(
                  (
                    node.text ||
                    node.textContent ||
                    node.innerHTML ||
                    ""
                  ).replace(rcleanScript, "")
                );
              }
            }
          }
        }

        // Fix #11809: Avoid leaking memory
        fragment = first = null;
      }
    }

    return collection;
  }

  function remove(elem, selector, keepData) {
    var node,
      elems = selector ? jQuery.filter(selector, elem) : elem,
      i = 0;

    for (; (node = elems[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function (html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },

    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var destElements,
        node,
        clone,
        i,
        srcElements,
        inPage = jQuery.contains(elem.ownerDocument, elem);

      if (
        support.html5Clone ||
        jQuery.isXMLDoc(elem) ||
        !rnoshimcache.test("<" + elem.nodeName + ">")
      ) {
        clone = elem.cloneNode(true);

        // IE<=8 does not properly clone detached, unknown element nodes
      } else {
        fragmentDiv.innerHTML = elem.outerHTML;
        fragmentDiv.removeChild((clone = fragmentDiv.firstChild));
      }

      if (
        (!support.noCloneEvent || !support.noCloneChecked) &&
        (elem.nodeType === 1 || elem.nodeType === 11) &&
        !jQuery.isXMLDoc(elem)
      ) {
        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        // Fix all IE cloning issues
        for (i = 0; (node = srcElements[i]) != null; ++i) {
          // Ensure that the destination node is not null; Fixes #9587
          if (destElements[i]) {
            fixCloneNodeIssues(node, destElements[i]);
          }
        }
      }

      // Copy the events from the original to the clone
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0; (node = srcElements[i]) != null; i++) {
            cloneCopyEvent(node, destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }

      // Preserve script evaluation history
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }

      destElements = srcElements = node = null;

      // Return the cloned set
      return clone;
    },

    cleanData: function (elems, /* internal */ forceAcceptData) {
      var elem,
        type,
        id,
        data,
        i = 0,
        internalKey = jQuery.expando,
        cache = jQuery.cache,
        attributes = support.attributes,
        special = jQuery.event.special;

      for (; (elem = elems[i]) != null; i++) {
        if (forceAcceptData || acceptData(elem)) {
          id = elem[internalKey];
          data = id && cache[id];

          if (data) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);

                  // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }

            // Remove cache only if it was not already removed by jQuery.event.remove
            if (cache[id]) {
              delete cache[id];

              // Support: IE<9
              // IE does not allow us to delete expando properties from nodes
              // IE creates expando attributes along with the property
              // IE does not have a removeAttribute function on Document nodes
              if (!attributes && typeof elem.removeAttribute !== "undefined") {
                elem.removeAttribute(internalKey);

                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://code.google.com/p/chromium/issues/detail?id=378607
              } else {
                elem[internalKey] = undefined;
              }

              deletedIds.push(id);
            }
          }
        }
      }
    },
  });

  jQuery.fn.extend({
    // Keep domManip exposed until 3.0 (gh-2225)
    domManip: domManip,

    detach: function (selector) {
      return remove(this, selector, true);
    },

    remove: function (selector) {
      return remove(this, selector);
    },

    text: function (value) {
      return access(
        this,
        function (value) {
          return value === undefined
            ? jQuery.text(this)
            : this.empty().append(
                ((this[0] && this[0].ownerDocument) || document).createTextNode(
                  value
                )
              );
        },
        null,
        value,
        arguments.length
      );
    },

    append: function () {
      return domManip(this, arguments, function (elem) {
        if (
          this.nodeType === 1 ||
          this.nodeType === 11 ||
          this.nodeType === 9
        ) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },

    prepend: function () {
      return domManip(this, arguments, function (elem) {
        if (
          this.nodeType === 1 ||
          this.nodeType === 11 ||
          this.nodeType === 9
        ) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },

    before: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },

    after: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },

    empty: function () {
      var elem,
        i = 0;

      for (; (elem = this[i]) != null; i++) {
        // Remove element nodes and prevent memory leaks
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
        }

        // Remove any remaining nodes
        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        }

        // If this is a select, ensure that it displays empty (#12336)
        // Support: IE<9
        if (elem.options && jQuery.nodeName(elem, "select")) {
          elem.options.length = 0;
        }
      }

      return this;
    },

    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents =
        deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },

    html: function (value) {
      return access(
        this,
        function (value) {
          var elem = this[0] || {},
            i = 0,
            l = this.length;

          if (value === undefined) {
            return elem.nodeType === 1
              ? elem.innerHTML.replace(rinlinejQuery, "")
              : undefined;
          }

          // See if we can take a shortcut and just use innerHTML
          if (
            typeof value === "string" &&
            !rnoInnerhtml.test(value) &&
            (support.htmlSerialize || !rnoshimcache.test(value)) &&
            (support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]
          ) {
            value = jQuery.htmlPrefilter(value);

            try {
              for (; i < l; i++) {
                // Remove element nodes and prevent memory leaks
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }

              elem = 0;

              // If using innerHTML throws an exception, use the fallback method
            } catch (e) {}
          }

          if (elem) {
            this.empty().append(value);
          }
        },
        null,
        value,
        arguments.length
      );
    },

    replaceWith: function () {
      var ignored = [];

      // Make the changes, replacing each non-ignored context element with the new content
      return domManip(
        this,
        arguments,
        function (elem) {
          var parent = this.parentNode;

          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }

          // Force callback invocation
        },
        ignored
      );
    },
  });

  jQuery.each(
    {
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith",
    },
    function (name, original) {
      jQuery.fn[name] = function (selector) {
        var elems,
          i = 0,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1;

        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);

          // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
          push.apply(ret, elems.get());
        }

        return this.pushStack(ret);
      };
    }
  );

  var iframe,
    elemdisplay = {
      // Support: Firefox
      // We have to pre-define these values for FF (#10227)
      HTML: "block",
      BODY: "block",
    };

  /**
   * Retrieve the actual display of a element
   * @param {String} name nodeName of the element
   * @param {Object} doc Document object
   */

  // Called only from within defaultDisplay
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
      display = jQuery.css(elem[0], "display");

    // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element
    elem.detach();

    return display;
  }

  /**
   * Try to determine the default display value of an element
   * @param {String} nodeName
   */
  function defaultDisplay(nodeName) {
    var doc = document,
      display = elemdisplay[nodeName];

    if (!display) {
      display = actualDisplay(nodeName, doc);

      // If the simple way fails, read from inside an iframe
      if (display === "none" || !display) {
        // Use the already-created iframe if possible
        iframe = (
          iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")
        ).appendTo(doc.documentElement);

        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;

        // Support: IE
        doc.write();
        doc.close();

        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }

      // Store the correct default display
      elemdisplay[nodeName] = display;
    }

    return display;
  }
  var rmargin = /^margin/;

  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var swap = function (elem, options, callback, args) {
    var ret,
      name,
      old = {};

    // Remember the old values, and insert the new ones
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.apply(elem, args || []);

    // Revert the old values
    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var documentElement = document.documentElement;

  (function () {
    var pixelPositionVal,
      pixelMarginRightVal,
      boxSizingReliableVal,
      reliableHiddenOffsetsVal,
      reliableMarginRightVal,
      reliableMarginLeftVal,
      container = document.createElement("div"),
      div = document.createElement("div");

    // Finish early in limited (non-browser) environments
    if (!div.style) {
      return;
    }

    div.style.cssText = "float:left;opacity:.5";

    // Support: IE<9
    // Make sure that element opacity exists (as opposed to filter)
    support.opacity = div.style.opacity === "0.5";

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!div.style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    container = document.createElement("div");
    container.style.cssText =
      "border:0;width:8px;height:0;top:0;left:-9999px;" +
      "padding:0;margin-top:1px;position:absolute";
    div.innerHTML = "";
    container.appendChild(div);

    // Support: Firefox<29, Android 2.3
    // Vendor-prefix box-sizing
    support.boxSizing =
      div.style.boxSizing === "" ||
      div.style.MozBoxSizing === "" ||
      div.style.WebkitBoxSizing === "";

    jQuery.extend(support, {
      reliableHiddenOffsets: function () {
        if (pixelPositionVal == null) {
          computeStyleTests();
        }
        return reliableHiddenOffsetsVal;
      },

      boxSizingReliable: function () {
        // We're checking for pixelPositionVal here instead of boxSizingReliableVal
        // since that compresses better and they're computed together anyway.
        if (pixelPositionVal == null) {
          computeStyleTests();
        }
        return boxSizingReliableVal;
      },

      pixelMarginRight: function () {
        // Support: Android 4.0-4.3
        if (pixelPositionVal == null) {
          computeStyleTests();
        }
        return pixelMarginRightVal;
      },

      pixelPosition: function () {
        if (pixelPositionVal == null) {
          computeStyleTests();
        }
        return pixelPositionVal;
      },

      reliableMarginRight: function () {
        // Support: Android 2.3
        if (pixelPositionVal == null) {
          computeStyleTests();
        }
        return reliableMarginRightVal;
      },

      reliableMarginLeft: function () {
        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
        if (pixelPositionVal == null) {
          computeStyleTests();
        }
        return reliableMarginLeftVal;
      },
    });

    function computeStyleTests() {
      var contents,
        divStyle,
        documentElement = document.documentElement;

      // Setup
      documentElement.appendChild(container);

      div.style.cssText =
        // Support: Android 2.3
        // Vendor-prefix box-sizing
        "-webkit-box-sizing:border-box;box-sizing:border-box;" +
        "position:relative;display:block;" +
        "margin:auto;border:1px;padding:1px;" +
        "top:1%;width:50%";

      // Support: IE<9
      // Assume reasonable values in the absence of getComputedStyle
      pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
      pixelMarginRightVal = reliableMarginRightVal = true;

      // Check for getComputedStyle so that this code is not run in IE<9.
      if (window.getComputedStyle) {
        divStyle = window.getComputedStyle(div);
        pixelPositionVal = (divStyle || {}).top !== "1%";
        reliableMarginLeftVal = (divStyle || {}).marginLeft === "2px";
        boxSizingReliableVal = (divStyle || { width: "4px" }).width === "4px";

        // Support: Android 4.0 - 4.3 only
        // Some styles come back with percentage values, even though they shouldn't
        div.style.marginRight = "50%";
        pixelMarginRightVal =
          (divStyle || { marginRight: "4px" }).marginRight === "4px";

        // Support: Android 2.3 only
        // Div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container (#3333)
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        contents = div.appendChild(document.createElement("div"));

        // Reset CSS: box-sizing; display; margin; border; padding
        contents.style.cssText = div.style.cssText =
          // Support: Android 2.3
          // Vendor-prefix box-sizing
          "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
          "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
        contents.style.marginRight = contents.style.width = "0";
        div.style.width = "1px";

        reliableMarginRightVal = !parseFloat(
          (window.getComputedStyle(contents) || {}).marginRight
        );

        div.removeChild(contents);
      }

      // Support: IE6-8
      // First check that getClientRects works as expected
      // Check if table cells still have offsetWidth/Height when they are set
      // to display:none and there are still other visible table cells in a
      // table row; if so, offsetWidth/Height are not reliable for use when
      // determining if an element has been hidden directly using
      // display:none (it is still safe to use offsets if a parent element is
      // hidden; don safety goggles and see bug #4512 for more information).
      div.style.display = "none";
      reliableHiddenOffsetsVal = div.getClientRects().length === 0;
      if (reliableHiddenOffsetsVal) {
        div.style.display = "";
        div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
        div.childNodes[0].style.borderCollapse = "separate";
        contents = div.getElementsByTagName("td");
        contents[0].style.cssText = "margin:0;border:0;padding:0;display:none";
        reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
        if (reliableHiddenOffsetsVal) {
          contents[0].style.display = "";
          contents[1].style.display = "none";
          reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
        }
      }

      // Teardown
      documentElement.removeChild(container);
    }
  })();

  var getStyles,
    curCSS,
    rposition = /^(top|right|bottom|left)$/;

  if (window.getComputedStyle) {
    getStyles = function (elem) {
      // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      var view = elem.ownerDocument.defaultView;

      if (!view || !view.opener) {
        view = window;
      }

      return view.getComputedStyle(elem);
    };

    curCSS = function (elem, name, computed) {
      var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;

      computed = computed || getStyles(elem);

      // getPropertyValue is only needed for .css('filter') in IE9, see #12537
      ret = computed
        ? computed.getPropertyValue(name) || computed[name]
        : undefined;

      // Support: Opera 12.1x only
      // Fall back to style even without computed
      // computed is undefined for elems on document fragments
      if (
        (ret === "" || ret === undefined) &&
        !jQuery.contains(elem.ownerDocument, elem)
      ) {
        ret = jQuery.style(elem, name);
      }

      if (computed) {
        // A tribute to the "awesome hack by Dean Edwards"
        // Chrome < 17 and Safari 5.0 uses "computed value"
        // instead of "used value" for margin-right
        // Safari 5.1.7 (at least) returns percentage for a larger set of values,
        // but width seems to be reliably pixels
        // this is against the CSSOM draft spec:
        // http://dev.w3.org/csswg/cssom/#resolved-values
        if (
          !support.pixelMarginRight() &&
          rnumnonpx.test(ret) &&
          rmargin.test(name)
        ) {
          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;

          // Put in the new values to get a computed value out
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;

          // Revert the changed values
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }

      // Support: IE
      // IE returns zIndex value as an integer.
      return ret === undefined ? ret : ret + "";
    };
  } else if (documentElement.currentStyle) {
    getStyles = function (elem) {
      return elem.currentStyle;
    };

    curCSS = function (elem, name, computed) {
      var left,
        rs,
        rsLeft,
        ret,
        style = elem.style;

      computed = computed || getStyles(elem);
      ret = computed ? computed[name] : undefined;

      // Avoid setting ret to empty string here
      // so we don't default to auto
      if (ret == null && style && style[name]) {
        ret = style[name];
      }

      // From the awesome hack by Dean Edwards
      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

      // If we're not dealing with a regular pixel number
      // but a number that has a weird ending, we need to convert it to pixels
      // but not position css attributes, as those are
      // proportional to the parent element instead
      // and we can't measure the parent instead because it
      // might trigger a "stacking dolls" problem
      if (rnumnonpx.test(ret) && !rposition.test(name)) {
        // Remember the original values
        left = style.left;
        rs = elem.runtimeStyle;
        rsLeft = rs && rs.left;

        // Put in the new values to get a computed value out
        if (rsLeft) {
          rs.left = elem.currentStyle.left;
        }
        style.left = name === "fontSize" ? "1em" : ret;
        ret = style.pixelLeft + "px";

        // Revert the changed values
        style.left = left;
        if (rsLeft) {
          rs.left = rsLeft;
        }
      }

      // Support: IE
      // IE returns zIndex value as an integer.
      return ret === undefined ? ret : ret + "" || "auto";
    };
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function () {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        }

        // Hook needed; redefine it so that the support test is not executed again.
        return (this.get = hookFn).apply(this, arguments);
      },
    };
  }

  var ralpha = /alpha\([^)]*\)/i,
    ropacity = /opacity\s*=\s*([^)]*)/i,
    // swappable if display is none or starts with table except
    // "table", "table-cell", or "table-caption"
    // see here for display values:
    // https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400",
    },
    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
    emptyStyle = document.createElement("div").style;

  // return a css property mapped to a potentially vendor prefixed property
  function vendorPropName(name) {
    // shortcut for names that are not vendor prefixed
    if (name in emptyStyle) {
      return name;
    }

    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1),
      i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }

  function showHide(elements, show) {
    var display,
      elem,
      hidden,
      values = [],
      index = 0,
      length = elements.length;

    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }

      values[index] = jQuery._data(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        // Reset the inline display of this element to learn if it is
        // being hidden by cascaded rules or not
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }

        // Set elements which have been overridden with display: none
        // in a stylesheet to whatever the default browser style is
        // for such an element
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = jQuery._data(
            elem,
            "olddisplay",
            defaultDisplay(elem.nodeName)
          );
        }
      } else {
        hidden = isHidden(elem);

        if ((display && display !== "none") || !hidden) {
          jQuery._data(
            elem,
            "olddisplay",
            hidden ? display : jQuery.css(elem, "display")
          );
        }
      }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }

    return elements;
  }

  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches
      ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px")
      : value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i =
        extra === (isBorderBox ? "border" : "content")
          ? // If we already have the right measurement, avoid augmentation
            4
          : // Otherwise initialize for horizontal or vertical properties
          name === "width"
          ? 1
          : 0,
      val = 0;

    for (; i < 4; i += 2) {
      // both box models exclude margin, so add it if we want it
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }

      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }

        // at this point, extra isn't border nor margin, so remove border
        if (extra !== "margin") {
          val -= jQuery.css(
            elem,
            "border" + cssExpand[i] + "Width",
            true,
            styles
          );
        }
      } else {
        // at this point, extra isn't content, so add padding
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

        // at this point, extra isn't content nor padding, so add border
        if (extra !== "padding") {
          val += jQuery.css(
            elem,
            "border" + cssExpand[i] + "Width",
            true,
            styles
          );
        }
      }
    }

    return val;
  }

  function getWidthOrHeight(elem, name, extra) {
    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
      val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
      styles = getStyles(elem),
      isBorderBox =
        support.boxSizing &&
        jQuery.css(elem, "boxSizing", false, styles) === "border-box";

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if (val <= 0 || val == null) {
      // Fall back to computed then uncomputed css if necessary
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }

      // Computed unit is not pixels. Stop here and return.
      if (rnumnonpx.test(val)) {
        return val;
      }

      // we need the check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style
      valueIsBorderBox =
        isBorderBox &&
        (support.boxSizingReliable() || val === elem.style[name]);

      // Normalize "", auto, and prepare for extra
      val = parseFloat(val) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return (
      val +
      augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles
      ) +
      "px"
    );
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        },
      },
    },

    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      animationIterationCount: true,
      columnCount: true,
      fillOpacity: true,
      flexGrow: true,
      flexShrink: true,
      fontWeight: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      widows: true,
      zIndex: true,
      zoom: true,
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
      // normalize float css property
      float: support.cssFloat ? "cssFloat" : "styleFloat",
    },

    // Get and set the style property on a DOM Node
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }

      // Make sure that we're working with the right name
      var ret,
        type,
        hooks,
        origName = jQuery.camelCase(name),
        style = elem.style;

      name =
        jQuery.cssProps[origName] ||
        (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

      // gets hook for the prefixed version
      // followed by the unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // Check if we're setting a value
      if (value !== undefined) {
        type = typeof value;

        // Convert "+=" or "-=" to relative numbers (#7345)
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);

          // Fixes bug #9237
          type = "number";
        }

        // Make sure that null and NaN values aren't set. See: #7116
        if (value == null || value !== value) {
          return;
        }

        // If a number was passed in, add the unit (except for certain CSS properties)
        if (type === "number") {
          value += (ret && ret[3]) || (jQuery.cssNumber[origName] ? "" : "px");
        }

        // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
        // but it would mean to define eight
        // (for every problematic property) identical functions
        if (
          !support.clearCloneStyle &&
          value === "" &&
          name.indexOf("background") === 0
        ) {
          style[name] = "inherit";
        }

        // If a hook was provided, use that value, otherwise just set the specified value
        if (
          !hooks ||
          !("set" in hooks) ||
          (value = hooks.set(elem, value, extra)) !== undefined
        ) {
          // Support: IE
          // Swallow errors from 'invalid' CSS values (#5509)
          try {
            style[name] = value;
          } catch (e) {}
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (
          hooks &&
          "get" in hooks &&
          (ret = hooks.get(elem, false, extra)) !== undefined
        ) {
          return ret;
        }

        // Otherwise just get the value from the style object
        return style[name];
      }
    },

    css: function (elem, name, extra, styles) {
      var num,
        val,
        hooks,
        origName = jQuery.camelCase(name);

      // Make sure that we're working with the right name
      name =
        jQuery.cssProps[origName] ||
        (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

      // gets hook for the prefixed version
      // followed by the unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // If a hook was provided get the computed value from there
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }

      // Otherwise, if a way to get the computed value exists, use that
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }

      //convert "normal" to computed value
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }

      // Return, converting to number if forced or a qualifier was provided and val looks numeric
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    },
  });

  jQuery.each(["height", "width"], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // certain elements can have dimension info if we invisibly show them
          // however, it must have a current display style that would benefit from this
          return rdisplayswap.test(jQuery.css(elem, "display")) &&
            elem.offsetWidth === 0
            ? swap(elem, cssShow, function () {
                return getWidthOrHeight(elem, name, extra);
              })
            : getWidthOrHeight(elem, name, extra);
        }
      },

      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(
          elem,
          value,
          extra
            ? augmentWidthOrHeight(
                elem,
                name,
                extra,
                support.boxSizing &&
                  jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                styles
              )
            : 0
        );
      },
    };
  });

  if (!support.opacity) {
    jQuery.cssHooks.opacity = {
      get: function (elem, computed) {
        // IE uses filters for opacity
        return ropacity.test(
          (computed && elem.currentStyle
            ? elem.currentStyle.filter
            : elem.style.filter) || ""
        )
          ? 0.01 * parseFloat(RegExp.$1) + ""
          : computed
          ? "1"
          : "";
      },

      set: function (elem, value) {
        var style = elem.style,
          currentStyle = elem.currentStyle,
          opacity = jQuery.isNumeric(value)
            ? "alpha(opacity=" + value * 100 + ")"
            : "",
          filter = (currentStyle && currentStyle.filter) || style.filter || "";

        // IE has trouble with opacity if it does not have layout
        // Force it by setting the zoom level
        style.zoom = 1;

        // if setting opacity to 1, and no other filters exist -
        // attempt to remove filter attribute #6652
        // if value === "", then remove inline opacity #12685
        if (
          (value >= 1 || value === "") &&
          jQuery.trim(filter.replace(ralpha, "")) === "" &&
          style.removeAttribute
        ) {
          // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
          // if "filter:" is present at all, clearType is disabled, we want to avoid this
          // style.removeAttribute is IE Only, but so apparently is this code path...
          style.removeAttribute("filter");

          // if there is no filter style applied in a css rule
          // or unset inline opacity, we are done
          if (value === "" || (currentStyle && !currentStyle.filter)) {
            return;
          }
        }

        // otherwise, set new filter values
        style.filter = ralpha.test(filter)
          ? filter.replace(ralpha, opacity)
          : filter + " " + opacity;
      },
    };
  }

  jQuery.cssHooks.marginRight = addGetHookIf(
    support.reliableMarginRight,
    function (elem, computed) {
      if (computed) {
        return swap(elem, { display: "inline-block" }, curCSS, [
          elem,
          "marginRight",
        ]);
      }
    }
  );

  jQuery.cssHooks.marginLeft = addGetHookIf(
    support.reliableMarginLeft,
    function (elem, computed) {
      if (computed) {
        return (
          (parseFloat(curCSS(elem, "marginLeft")) ||
            // Support: IE<=11+
            // Running getBoundingClientRect on a disconnected node in IE throws an error
            // Support: IE8 only
            // getClientRects() errors on disconnected elems
            (jQuery.contains(elem.ownerDocument, elem)
              ? elem.getBoundingClientRect().left -
                swap(elem, { marginLeft: 0 }, function () {
                  return elem.getBoundingClientRect().left;
                })
              : 0)) + "px"
        );
      }
    }
  );

  // These hooks are used by animate to expand properties
  jQuery.each(
    {
      margin: "",
      padding: "",
      border: "Width",
    },
    function (prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function (value) {
          var i = 0,
            expanded = {},
            // assumes a single number if not a string
            parts = typeof value === "string" ? value.split(" ") : [value];

          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] =
              parts[i] || parts[i - 2] || parts[0];
          }

          return expanded;
        },
      };

      if (!rmargin.test(prefix)) {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    }
  );

  jQuery.fn.extend({
    css: function (name, value) {
      return access(
        this,
        function (elem, name, value) {
          var styles,
            len,
            map = {},
            i = 0;

          if (jQuery.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;

            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }

            return map;
          }

          return value !== undefined
            ? jQuery.style(elem, name, value)
            : jQuery.css(elem, name);
        },
        name,
        value,
        arguments.length > 1
      );
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    },
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];

      return hooks && hooks.get
        ? hooks.get(this)
        : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](
          percent,
          this.options.duration * percent,
          0,
          1,
          this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    },
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;

        // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.
        if (
          tween.elem.nodeType !== 1 ||
          (tween.elem[tween.prop] != null &&
            tween.elem.style[tween.prop] == null)
        ) {
          return tween.elem[tween.prop];
        }

        // passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails
        // so, simple values such as "10px" are parsed to Float.
        // complex values such as "rotate(1rad)" are returned as is.
        result = jQuery.css(tween.elem, tween.prop, "");

        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === "auto" ? 0 : result;
      },
      set: function (tween) {
        // use step hook for back compat - use cssHook if its there - use .style if its
        // available and use plain properties where available
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (
          tween.elem.nodeType === 1 &&
          (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
            jQuery.cssHooks[tween.prop])
        ) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      },
    },
  };

  // Support: IE <=9
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    },
  };

  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing",
  };

  jQuery.fx = Tween.prototype.init;

  // Back Compat <1.8 extension point
  jQuery.fx.step = {};

  var fxNow,
    timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rrun = /queueHooks$/;

  // Animations created synchronously will run synchronously
  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }

  // Generate parameters to create a standard animation
  function genFx(type, includeWidth) {
    var which,
      attrs = { height: type },
      i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
      collection = (Animation.tweeners[prop] || []).concat(
        Animation.tweeners["*"]
      ),
      index = 0,
      length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        // we're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    /* jshint validthis: true */
    var prop,
      value,
      toggle,
      tween,
      hooks,
      oldfire,
      display,
      checkDisplay,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHidden(elem),
      dataShow = jQuery._data(elem, "fxshow");

    // handle queue: false promises
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;

      anim.always(function () {
        // doing this makes sure that the complete handler will be called
        // before this completes
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }

    // height/width overflow pass
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      // Make sure that nothing sneaks out
      // Record all 3 overflow attributes because IE does not
      // change the overflow attribute when overflowX and
      // overflowY are set to the same value
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];

      // Set display property to inline-block for height/width
      // animations on inline elements that are having width/height animated
      display = jQuery.css(elem, "display");

      // Test default display if display is currently "none"
      checkDisplay =
        display === "none"
          ? jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName)
          : display;

      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        // inline-level elements accept inline-block;
        // block-level elements need to be inline with layout
        if (
          !support.inlineBlockNeedsLayout ||
          defaultDisplay(elem.nodeName) === "inline"
        ) {
          style.display = "inline-block";
        } else {
          style.zoom = 1;
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      if (!support.shrinkWrapBlocks()) {
        anim.always(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
    }

    // show/hide pass
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          // If there is dataShow left over from a stopped hide or show
          // and we are going to proceed with show, we should pretend to be hidden
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop);

        // Any non-fx value stops us from restoring the original display value
      } else {
        display = undefined;
      }
    }

    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = jQuery._data(elem, "fxshow", {});
      }

      // store state if its toggle - enables .stop().toggle() to "reverse"
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        jQuery._removeData(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }

      // If this is a noop like .hide().hide(), restore an overwritten display value
    } else if (
      (display === "none" ? defaultDisplay(elem.nodeName) : display) ===
      "inline"
    ) {
      style.display = display;
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];

        // not quite $.extend, this wont overwrite keys already present.
        // also - reusing 'index' from above because we have the correct "name"
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = Animation.prefilters.length,
      deferred = jQuery.Deferred().always(function () {
        // don't match elem in the :animated selector
        delete tick.elem;
      }),
      tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(
            0,
            animation.startTime + animation.duration - currentTime
          ),
          // Support: Android 2.3
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }

        deferred.notifyWith(elem, [animation, percent, remaining]);

        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(
          true,
          {
            specialEasing: {},
            easing: jQuery.easing._default,
          },
          options
        ),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0,
            // if we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }

          // resolve when we played the last frame
          // otherwise, reject
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        },
      }),
      props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(
        animation,
        elem,
        props,
        animation.opts
      );
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
            jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }

    jQuery.fx.timer(
      jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue,
      })
    );

    // attach callbacks from options
    return animation
      .progress(animation.opts.progress)
      .done(animation.opts.done, animation.opts.complete)
      .fail(animation.opts.fail)
      .always(animation.opts.always);
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [
        function (prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        },
      ],
    },

    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnotwhite);
      }

      var prop,
        index = 0,
        length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },

    prefilters: [defaultPrefilter],

    prefilter: function (callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    },
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt =
      speed && typeof speed === "object"
        ? jQuery.extend({}, speed)
        : {
            complete:
              fn || (!fn && easing) || (jQuery.isFunction(speed) && speed),
            duration: speed,
            easing:
              (fn && easing) ||
              (easing && !jQuery.isFunction(easing) && easing),
          };

    opt.duration = jQuery.fx.off
      ? 0
      : typeof opt.duration === "number"
      ? opt.duration
      : opt.duration in jQuery.fx.speeds
      ? jQuery.fx.speeds[opt.duration]
      : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // show any hidden elements after setting opacity to 0
      return (
        this.filter(isHidden)
          .css("opacity", 0)
          .show()

          // animate to the value specified
          .end()
          .animate({ opacity: to }, speed, easing, callback)
      );
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function () {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall);

          // Empty animations, or finishing resolves immediately
          if (empty || jQuery._data(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;

      return empty || optall.queue === false
        ? this.each(doAnimation)
        : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = jQuery._data(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--; ) {
          if (
            timers[index].elem === this &&
            (type == null || timers[index].queue === type)
          ) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }

        // start the next in the queue if the last step wasn't forced
        // timers currently will call their complete callbacks, which will dequeue
        // but only if they were gotoEnd
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function () {
        var index,
          data = jQuery._data(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;

        // enable finishing flag on private data
        data.finish = true;

        // empty the queue first
        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }

        // look for any active animations, and finish them
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }

        // look for any animations in the old queue and finish them
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }

        // turn off finishing flag
        delete data.finish;
      });
    },
  });

  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean"
        ? cssFn.apply(this, arguments)
        : this.animate(genFx(name, true), speed, easing, callback);
    };
  });

  // Generate shortcuts for custom animations
  jQuery.each(
    {
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" },
    },
    function (name, props) {
      jQuery.fn[name] = function (speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    }
  );

  jQuery.timers = [];
  jQuery.fx.tick = function () {
    var timer,
      timers = jQuery.timers,
      i = 0;

    fxNow = jQuery.now();

    for (; i < timers.length; i++) {
      timer = timers[i];

      // Checks the timer has not already been removed
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };

  jQuery.fx.stop = function () {
    window.clearInterval(timerId);
    timerId = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,

    // Default speed
    _default: 400,
  };

  // Based off of the plugin by Clint Helfers, with permission.
  // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";

    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var a,
      input = document.createElement("input"),
      div = document.createElement("div"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));

    // Setup
    div = document.createElement("div");
    div.setAttribute("className", "t");
    div.innerHTML =
      "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName("a")[0];

    // Support: Windows Web Apps (WWA)
    // `type` must use .setAttribute for WWA (#14901)
    input.setAttribute("type", "checkbox");
    div.appendChild(input);

    a = div.getElementsByTagName("a")[0];

    // First batch of tests.
    a.style.cssText = "top:1px";

    // Test setAttribute on camelCase class.
    // If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    support.getSetAttribute = div.className !== "t";

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    support.style = /top/.test(a.getAttribute("style"));

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    support.hrefNormalized = a.getAttribute("href") === "/a";

    // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
    support.checkOn = !!input.value;

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    support.optSelected = opt.selected;

    // Tests for enctype support on a form (#6743)
    support.enctype = !!document.createElement("form").enctype;

    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Support: IE8 only
    // Check if we can trust getAttribute("value")
    input = document.createElement("input");
    input.setAttribute("value", "");
    support.input = input.getAttribute("value") === "";

    // Check if an input maintains its value after becoming a radio
    input.value = "t";
    input.setAttribute("type", "radio");
    support.radioValue = input.value === "t";
  })();

  var rreturn = /\r/g,
    rspaces = /[\x20\t\r\n\f]+/g;

  jQuery.fn.extend({
    val: function (value) {
      var hooks,
        ret,
        isFunction,
        elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks =
            jQuery.valHooks[elem.type] ||
            jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (
            hooks &&
            "get" in hooks &&
            (ret = hooks.get(elem, "value")) !== undefined
          ) {
            return ret;
          }

          ret = elem.value;

          return typeof ret === "string"
            ? // handle most common string cases
              ret.replace(rreturn, "")
            : // handle cases where value is null/undef or number
            ret == null
            ? ""
            : ret;
        }

        return;
      }

      isFunction = jQuery.isFunction(value);

      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }

        // Treat null/undefined as ""; convert numbers to string
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks =
          jQuery.valHooks[this.type] ||
          jQuery.valHooks[this.nodeName.toLowerCase()];

        // If set returns undefined, fall back to normal setting
        if (
          !hooks ||
          !("set" in hooks) ||
          hooks.set(this, val, "value") === undefined
        ) {
          this.value = val;
        }
      });
    },
  });

  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null
            ? val
            : // Support: IE10-11+
              // option.text throws exceptions (#14686, #14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
        },
      },
      select: {
        get: function (elem) {
          var value,
            option,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one" || index < 0,
            values = one ? null : [],
            max = one ? index + 1 : options.length,
            i = index < 0 ? max : one ? index : 0;

          // Loop through all the selected options
          for (; i < max; i++) {
            option = options[i];

            // oldIE doesn't update selected after form reset (#2551)
            if (
              (option.selected || i === index) &&
              // Don't return options that are disabled or in a disabled optgroup
              (support.optDisabled
                ? !option.disabled
                : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled ||
                !jQuery.nodeName(option.parentNode, "optgroup"))
            ) {
              // Get the specific value for the option
              value = jQuery(option).val();

              // We don't need an array for one selects
              if (one) {
                return value;
              }

              // Multi-Selects return an array
              values.push(value);
            }
          }

          return values;
        },

        set: function (elem, value) {
          var optionSet,
            option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;

          while (i--) {
            option = options[i];

            if (
              jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
            ) {
              // Support: IE6
              // When new option element is added to select box we need to
              // force reflow of newly added node in order to workaround delay
              // of initialization properties
              try {
                option.selected = optionSet = true;
              } catch (_) {
                // Will be executed only in IE6
                option.scrollHeight;
              }
            } else {
              option.selected = false;
            }
          }

          // Force browsers to behave consistently when non-matching value is set
          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return options;
        },
      },
    },
  });

  // Radios and checkboxes getter/setter
  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked =
            jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      },
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });

  var nodeHook,
    boolHook,
    attrHandle = jQuery.expr.attrHandle,
    ruseDefault = /^(?:checked|selected)$/i,
    getSetAttribute = support.getSetAttribute,
    getSetInput = support.input;

  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },

    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
  });

  jQuery.extend({
    attr: function (elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;

      // Don't get/set attributes on text, comment and attribute nodes
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      // Fallback to prop when attributes are not supported
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }

      // All attributes are lowercase
      // Grab necessary hook if one is defined
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks =
          jQuery.attrHooks[name] ||
          (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (
          hooks &&
          "set" in hooks &&
          (ret = hooks.set(elem, value, name)) !== undefined
        ) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name);

      // Non-existent attributes return null, we normalize to undefined
      return ret == null ? undefined : ret;
    },

    attrHooks: {
      type: {
        set: function (elem, value) {
          if (
            !support.radioValue &&
            value === "radio" &&
            jQuery.nodeName(elem, "input")
          ) {
            // Setting the type on a radio button after the value resets the value in IE8-9
            // Reset value to default in case type is set after value during creation
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        },
      },
    },

    removeAttr: function (elem, value) {
      var name,
        propName,
        i = 0,
        attrNames = value && value.match(rnotwhite);

      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;

          // Boolean attributes get special treatment (#10870)
          if (jQuery.expr.match.bool.test(name)) {
            // Set corresponding property to false
            if ((getSetInput && getSetAttribute) || !ruseDefault.test(name)) {
              elem[propName] = false;

              // Support: IE<9
              // Also clear defaultChecked/defaultSelected (if appropriate)
            } else {
              elem[jQuery.camelCase("default-" + name)] = elem[
                propName
              ] = false;
            }

            // See #9699 for explanation of this approach (setting first, then removal)
          } else {
            jQuery.attr(elem, name, "");
          }

          elem.removeAttribute(getSetAttribute ? name : propName);
        }
      }
    },
  });

  // Hooks for boolean attributes
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else if ((getSetInput && getSetAttribute) || !ruseDefault.test(name)) {
        // IE<8 needs the *property* name
        elem.setAttribute(
          (!getSetAttribute && jQuery.propFix[name]) || name,
          name
        );
      } else {
        // Support: IE<9
        // Use defaultChecked and defaultSelected for oldIE
        elem[jQuery.camelCase("default-" + name)] = elem[name] = true;
      }
      return name;
    },
  };

  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    if ((getSetInput && getSetAttribute) || !ruseDefault.test(name)) {
      attrHandle[name] = function (elem, name, isXML) {
        var ret, handle;
        if (!isXML) {
          // Avoid an infinite loop by temporarily removing this function from the getter
          handle = attrHandle[name];
          attrHandle[name] = ret;
          ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
          attrHandle[name] = handle;
        }
        return ret;
      };
    } else {
      attrHandle[name] = function (elem, name, isXML) {
        if (!isXML) {
          return elem[jQuery.camelCase("default-" + name)]
            ? name.toLowerCase()
            : null;
        }
      };
    }
  });

  // fix oldIE attroperties
  if (!getSetInput || !getSetAttribute) {
    jQuery.attrHooks.value = {
      set: function (elem, value, name) {
        if (jQuery.nodeName(elem, "input")) {
          // Does not return so that setAttribute is also used
          elem.defaultValue = value;
        } else {
          // Use nodeHook if defined (#1954); otherwise setAttribute is fine
          return nodeHook && nodeHook.set(elem, value, name);
        }
      },
    };
  }

  // IE6/7 do not support getting/setting some attributes with get/setAttribute
  if (!getSetAttribute) {
    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = {
      set: function (elem, value, name) {
        // Set the existing or create a new attribute node
        var ret = elem.getAttributeNode(name);
        if (!ret) {
          elem.setAttributeNode(
            (ret = elem.ownerDocument.createAttribute(name))
          );
        }

        ret.value = value += "";

        // Break association with cloned elements by also using setAttribute (#9646)
        if (name === "value" || value === elem.getAttribute(name)) {
          return value;
        }
      },
    };

    // Some attributes are constructed with empty-string values when not defined
    attrHandle.id =
      attrHandle.name =
      attrHandle.coords =
        function (elem, name, isXML) {
          var ret;
          if (!isXML) {
            return (ret = elem.getAttributeNode(name)) && ret.value !== ""
              ? ret.value
              : null;
          }
        };

    // Fixing value retrieval on a button requires this module
    jQuery.valHooks.button = {
      get: function (elem, name) {
        var ret = elem.getAttributeNode(name);
        if (ret && ret.specified) {
          return ret.value;
        }
      },
      set: nodeHook.set,
    };

    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery.attrHooks.contenteditable = {
      set: function (elem, value, name) {
        nodeHook.set(elem, value === "" ? false : value, name);
      },
    };

    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery.each(["width", "height"], function (i, name) {
      jQuery.attrHooks[name] = {
        set: function (elem, value) {
          if (value === "") {
            elem.setAttribute(name, "auto");
            return value;
          }
        },
      };
    });
  }

  if (!support.style) {
    jQuery.attrHooks.style = {
      get: function (elem) {
        // Return undefined in the case of empty string
        // Note: IE uppercases css property names, but if we were to .toLowerCase()
        // .cssText, that would destroy case sensitivity in URL's, like in "background"
        return elem.style.cssText || undefined;
      },
      set: function (elem, value) {
        return (elem.style.cssText = value + "");
      },
    };
  }

  var rfocusable = /^(?:input|select|textarea|button|object)$/i,
    rclickable = /^(?:a|area)$/i;

  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },

    removeProp: function (name) {
      name = jQuery.propFix[name] || name;
      return this.each(function () {
        // try/catch handles cases where IE balks (such as removing a property on window)
        try {
          this[name] = undefined;
          delete this[name];
        } catch (e) {}
      });
    },
  });

  jQuery.extend({
    prop: function (elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;

      // Don't get/set properties on text, comment and attribute nodes
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (
          hooks &&
          "set" in hooks &&
          (ret = hooks.set(elem, value, name)) !== undefined
        ) {
          return ret;
        }

        return (elem[name] = value);
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },

    propHooks: {
      tabIndex: {
        get: function (elem) {
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          return tabindex
            ? parseInt(tabindex, 10)
            : rfocusable.test(elem.nodeName) ||
              (rclickable.test(elem.nodeName) && elem.href)
            ? 0
            : -1;
        },
      },
    },

    propFix: {
      for: "htmlFor",
      class: "className",
    },
  });

  // Some attributes require a special call on IE
  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if (!support.hrefNormalized) {
    // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each(["href", "src"], function (i, name) {
      jQuery.propHooks[name] = {
        get: function (elem) {
          return elem.getAttribute(name, 4);
        },
      };
    });
  }

  // Support: Safari, IE9+
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          // Make sure that it also works with optgroups, see #5701
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
        return null;
      },
      set: function (elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      },
    };
  }

  jQuery.each(
    [
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable",
    ],
    function () {
      jQuery.propFix[this.toLowerCase()] = this;
    }
  );

  // IE6/7 call enctype encoding
  if (!support.enctype) {
    jQuery.propFix.enctype = "encoding";
  }

  var rclass = /[\t\r\n\f]/g;

  function getClass(elem) {
    return jQuery.attr(elem, "class") || "";
  }

  jQuery.fn.extend({
    addClass: function (value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;

      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];

        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur =
            elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }

            // only assign if different to avoid unneeded rendering.
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              jQuery.attr(elem, "class", finalValue);
            }
          }
        }
      }

      return this;
    },

    removeClass: function (value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;

      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];

        while ((elem = this[i++])) {
          curValue = getClass(elem);

          // This expression is here for better compressibility (see addClass)
          cur =
            elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }

            // Only assign if different to avoid unneeded rendering.
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              jQuery.attr(elem, "class", finalValue);
            }
          }
        }
      }

      return this;
    },

    toggleClass: function (value, stateVal) {
      var type = typeof value;

      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(
            value.call(this, i, getClass(this), stateVal),
            stateVal
          );
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (type === "string") {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnotwhite) || [];

          while ((className = classNames[i++])) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }

          // Toggle whole class name
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            // store className if set
            jQuery._data(this, "__className__", className);
          }

          // If the element has a class name or if we're passed "false",
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          jQuery.attr(
            this,
            "class",
            className || value === false
              ? ""
              : jQuery._data(this, "__className__") || ""
          );
        }
      });
    },

    hasClass: function (selector) {
      var className,
        elem,
        i = 0;

      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (
          elem.nodeType === 1 &&
          (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) >
            -1
        ) {
          return true;
        }
      }

      return false;
    },
  });

  // Return jQuery for attributes-only inclusion

  jQuery.each(
    (
      "blur focus focusin focusout load resize scroll unload click dblclick " +
      "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
      "change select submit keydown keypress keyup error contextmenu"
    ).split(" "),
    function (i, name) {
      // Handle event binding
      jQuery.fn[name] = function (data, fn) {
        return arguments.length > 0
          ? this.on(name, null, data, fn)
          : this.trigger(name);
      };
    }
  );

  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
  });

  var location = window.location;

  var nonce = jQuery.now();

  var rquery = /\?/;

  var rvalidtokens =
    /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

  jQuery.parseJSON = function (data) {
    // Attempt to parse using the native JSON parser first
    if (window.JSON && window.JSON.parse) {
      // Support: Android 2.3
      // Workaround failure to string-cast null input
      return window.JSON.parse(data + "");
    }

    var requireNonComma,
      depth = null,
      str = jQuery.trim(data + "");

    // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
    // after removing valid tokens
    return str &&
      !jQuery.trim(
        str.replace(rvalidtokens, function (token, comma, open, close) {
          // Force termination if we see a misplaced comma
          if (requireNonComma && comma) {
            depth = 0;
          }

          // Perform no more replacements after returning to outermost depth
          if (depth === 0) {
            return token;
          }

          // Commas must not follow "[", "{", or ","
          requireNonComma = open || comma;

          // Determine new depth
          // array/object open ("[" or "{"): depth += true - false (increment)
          // array/object close ("]" or "}"): depth += false - true (decrement)
          // other cases ("," or primitive): depth += true - true (numeric cast)
          depth += !close - !open;

          // Remove this token
          return "";
        })
      )
      ? Function("return " + str)()
      : jQuery.error("Invalid JSON: " + data);
  };

  // Cross-browser xml parsing
  jQuery.parseXML = function (data) {
    var xml, tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      if (window.DOMParser) {
        // Standard
        tmp = new window.DOMParser();
        xml = tmp.parseFromString(data, "text/xml");
      } else {
        // IE
        xml = new window.ActiveXObject("Microsoft.XMLDOM");
        xml.async = "false";
        xml.loadXML(data);
      }
    } catch (e) {
      xml = undefined;
    }
    if (
      !xml ||
      !xml.documentElement ||
      xml.getElementsByTagName("parsererror").length
    ) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };

  var rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    // IE leaves an \r character at EOL
    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol =
      /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},
    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},
    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),
    // Document location
    ajaxLocation = location.href,
    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

      if (jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while ((dataType = dataTypes[i++])) {
          // Prepend if requested
          if (dataType.charAt(0) === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);

            // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports(
    structure,
    options,
    originalOptions,
    jqXHR
  ) {
    var inspected = {},
      seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(
          options,
          originalOptions,
          jqXHR
        );
        if (
          typeof dataTypeOrTransport === "string" &&
          !seekingTransport &&
          !inspected[dataTypeOrTransport]
        ) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || (!inspected["*"] && inspect("*"));
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend(target, src) {
    var deep,
      key,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses(s, jqXHR, responses) {
    var firstDataType,
      ct,
      finalDataType,
      type,
      contents = s.contents,
      dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }

    // Check if we're dealing with a known content-type
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }

    // Check to see if we have a response for the expected dataType
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }

      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
      current,
      conv,
      tmp,
      prev,
      converters = {},
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }

      // Apply the dataFilter if provided
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev;

          // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current];

          // If none found, seek a pair
          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv =
                  converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2];

                    // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }

          // Apply converter (if not an equivalence)
          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) {
              // jscs:ignore requireDotNotation
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv
                    ? e
                    : "No conversion from " + prev + " to " + current,
                };
              }
            }
          }
        }
      }
    }

    return { state: "success", data: response };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript",
      },

      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/,
      },

      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON",
      },

      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,

        // Text to html (true = no transformation)
        "text html": true,

        // Evaluate text as a json expression
        "text json": jQuery.parseJSON,

        // Parse text as xml
        "text xml": jQuery.parseXML,
      },

      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true,
      },
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function (target, settings) {
      return settings
        ? // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
        : // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target);
    },

    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),

    // Main method
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }

      // Force options to be an object
      options = options || {};

      var // Cross-domain detection vars
        parts,
        // Loop variable
        i,
        // URL without anti-cache param
        cacheURL,
        // Response headers as string
        responseHeadersString,
        // timeout handle
        timeoutTimer,
        // To know if global events are to be dispatched
        fireGlobals,
        transport,
        // Response headers
        responseHeaders,
        // Create the final options object
        s = jQuery.ajaxSetup({}, options),
        // Callbacks context
        callbackContext = s.context || s,
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext =
          s.context && (callbackContext.nodeType || callbackContext.jquery)
            ? jQuery(callbackContext)
            : jQuery.event,
        // Deferreds
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        // Status-dependent callbacks
        statusCode = s.statusCode || {},
        // Headers (they are sent all at once)
        requestHeaders = {},
        requestHeadersNames = {},
        // The jqXHR state
        state = 0,
        // Default abort message
        strAbort = "canceled",
        // Fake xhr
        jqXHR = {
          readyState: 0,

          // Builds headers hashtable if needed
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while ((match = rheaders.exec(responseHeadersString))) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },

          // Raw string
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },

          // Caches the header
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] =
                requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },

          // Overrides response content-type header
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },

          // Status-dependent callbacks
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  // Lazy-add the new callback in a way that preserves old ones
                  statusCode[code] = [statusCode[code], map[code]];
                }
              } else {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },

          // Cancel the request
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          },
        };

      // Attach deferreds
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;

      // Remove hash character (#7531: and string promotion)
      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ((url || s.url || ajaxLocation) + "")
        .replace(rhash, "")
        .replace(rprotocol, ajaxLocParts[1] + "//");

      // Alias method option to type as per ticket #12004
      s.type = options.method || options.type || s.method || s.type;

      // Extract dataTypes list
      s.dataTypes = jQuery
        .trim(s.dataType || "*")
        .toLowerCase()
        .match(rnotwhite) || [""];

      // A cross-domain request is in order when we have a protocol:host:port mismatch
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(
          parts &&
          (parts[1] !== ajaxLocParts[1] ||
            parts[2] !== ajaxLocParts[2] ||
            (parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
              (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
        );
      }

      // Convert data if not already a string
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }

      // Apply prefilters
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

      // If request was aborted inside a prefilter, stop there
      if (state === 2) {
        return jqXHR;
      }

      // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
      fireGlobals = jQuery.event && s.global;

      // Watch for a new set of requests
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }

      // Uppercase the type
      s.type = s.type.toUpperCase();

      // Determine if request has content
      s.hasContent = !rnoContent.test(s.type);

      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      cacheURL = s.url;

      // More options handling for requests with no content
      if (!s.hasContent) {
        // If data is available, append data to url
        if (s.data) {
          cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;

          // #9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }

        // Add anti-cache in url if needed
        if (s.cache === false) {
          s.url = rts.test(cacheURL)
            ? // If there is already a '_' parameter, set its value
              cacheURL.replace(rts, "$1_=" + nonce++)
            : // Otherwise add one to the end
              cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }

      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader(
            "If-Modified-Since",
            jQuery.lastModified[cacheURL]
          );
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }

      // Set the correct header, if data is being sent
      if (
        (s.data && s.hasContent && s.contentType !== false) ||
        options.contentType
      ) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }

      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[0] && s.accepts[s.dataTypes[0]]
          ? s.accepts[s.dataTypes[0]] +
              (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "")
          : s.accepts["*"]
      );

      // Check for headers option
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }

      // Allow custom headers/mimetypes and early abort
      if (
        s.beforeSend &&
        (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)
      ) {
        // Abort if not done already and return
        return jqXHR.abort();
      }

      // aborting is no longer a cancellation
      strAbort = "abort";

      // Install callbacks on deferreds
      for (i in { success: 1, error: 1, complete: 1 }) {
        jqXHR[i](s[i]);
      }

      // Get transport
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

      // If no transport, we auto-abort
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;

        // Send global event
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }

        // If request was aborted inside ajaxSend, stop there
        if (state === 2) {
          return jqXHR;
        }

        // Timeout
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Propagate exception as error if not done
          if (state < 2) {
            done(-1, e);

            // Simply rethrow otherwise
          } else {
            throw e;
          }
        }
      }

      // Callback for when everything is done
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
          success,
          error,
          response,
          modified,
          statusText = nativeStatusText;

        // Called once
        if (state === 2) {
          return;
        }

        // State is "done" now
        state = 2;

        // Clear timeout if it exists
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }

        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;

        // Cache response headers
        responseHeadersString = headers || "";

        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;

        // Determine if successful
        isSuccess = (status >= 200 && status < 300) || status === 304;

        // Get response data
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }

        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert(s, response, jqXHR, isSuccess);

        // If successful, handle type chaining
        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }

          // if no content
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";

            // if not modified
          } else if (status === 304) {
            statusText = "notmodified";

            // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // We extract error from statusText
          // then normalize statusText and status for non-aborts
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }

        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";

        // Success/Error
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }

        // Status-dependent callbacks
        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
            jqXHR,
            s,
            isSuccess ? success : error,
          ]);
        }

        // Complete
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

          // Handle the global AJAX counter
          if (!--jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },

    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },

    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    },
  });

  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // shift arguments if data argument was omitted
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }

      // The url can be an options object (which then must have .url)
      return jQuery.ajax(
        jQuery.extend(
          {
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback,
          },
          jQuery.isPlainObject(url) && url
        )
      );
    };
  });

  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,

      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      throws: true,
    });
  };

  jQuery.fn.extend({
    wrapAll: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }

      if (this[0]) {
        // The elements to wrap the target around
        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap
          .map(function () {
            var elem = this;

            while (elem.firstChild && elem.firstChild.nodeType === 1) {
              elem = elem.firstChild;
            }

            return elem;
          })
          .append(this);
      }

      return this;
    },

    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
          contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },

    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);

      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },

    unwrap: function () {
      return this.parent()
        .each(function () {
          if (!jQuery.nodeName(this, "body")) {
            jQuery(this).replaceWith(this.childNodes);
          }
        })
        .end();
    },
  });

  function getDisplay(elem) {
    return (elem.style && elem.style.display) || jQuery.css(elem, "display");
  }

  function filterHidden(elem) {
    // Disconnected elements are considered hidden
    if (!jQuery.contains(elem.ownerDocument || document, elem)) {
      return true;
    }
    while (elem && elem.nodeType === 1) {
      if (getDisplay(elem) === "none" || elem.type === "hidden") {
        return true;
      }
      elem = elem.parentNode;
    }
    return false;
  }

  jQuery.expr.filters.hidden = function (elem) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return support.reliableHiddenOffsets()
      ? elem.offsetWidth <= 0 &&
          elem.offsetHeight <= 0 &&
          !elem.getClientRects().length
      : filterHidden(elem);
  };

  jQuery.expr.filters.visible = function (elem) {
    return !jQuery.expr.filters.hidden(elem);
  };

  var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (jQuery.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(
            prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
            v,
            traditional,
            add
          );
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function (a, traditional) {
    var prefix,
      s = [],
      add = function (key, value) {
        // If value is a function, invoke it and return its value
        value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
      };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }

    // Return the resulting serialization
    return s.join("&").replace(r20, "+");
  };

  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      })
        .filter(function () {
          var type = this.type;

          // Use .is(":disabled") so that fieldset[disabled] works
          return (
            this.name &&
            !jQuery(this).is(":disabled") &&
            rsubmittable.test(this.nodeName) &&
            !rsubmitterTypes.test(type) &&
            (this.checked || !rcheckableType.test(type))
          );
        })
        .map(function (i, elem) {
          var val = jQuery(this).val();

          return val == null
            ? null
            : jQuery.isArray(val)
            ? jQuery.map(val, function (val) {
                return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
              })
            : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        })
        .get();
    },
  });

  // Create the request object
  // (This is still attached to ajaxSettings for backward compatibility)
  jQuery.ajaxSettings.xhr =
    window.ActiveXObject !== undefined
      ? // Support: IE6-IE8
        function () {
          // XHR cannot access local files, always use ActiveX for that case
          if (this.isLocal) {
            return createActiveXHR();
          }

          // Support: IE 9-11
          // IE seems to error on cross-domain PATCH requests when ActiveX XHR
          // is used. In IE 9+ always use the native XHR.
          // Note: this condition won't catch Edge as it doesn't define
          // document.documentMode but it also doesn't support ActiveX so it won't
          // reach this code.
          if (document.documentMode > 8) {
            return createStandardXHR();
          }

          // Support: IE<9
          // oldIE XHR does not support non-RFC2616 methods (#13240)
          // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
          // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
          // Although this check for six methods instead of eight
          // since IE also does not support "trace" and "connect"
          return (
            (/^(get|post|head|put|delete|options)$/i.test(this.type) &&
              createStandardXHR()) ||
            createActiveXHR()
          );
        }
      : // For all other browsers, use the standard XMLHttpRequest object
        createStandardXHR;

  var xhrId = 0,
    xhrCallbacks = {},
    xhrSupported = jQuery.ajaxSettings.xhr();

  // Support: IE<10
  // Open requests must be manually aborted on unload (#5280)
  // See https://support.microsoft.com/kb/2856746 for more info
  if (window.attachEvent) {
    window.attachEvent("onunload", function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key](undefined, true);
      }
    });
  }

  // Determine support properties
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  xhrSupported = support.ajax = !!xhrSupported;

  // Create transport if the browser can provide an xhr
  if (xhrSupported) {
    jQuery.ajaxTransport(function (options) {
      // Cross domain only allowed if supported through XMLHttpRequest
      if (!options.crossDomain || support.cors) {
        var callback;

        return {
          send: function (headers, complete) {
            var i,
              xhr = options.xhr(),
              id = ++xhrId;

            // Open the socket
            xhr.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );

            // Apply custom fields if provided
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }

            // Override mime type if needed
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }

            // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }

            // Set headers
            for (i in headers) {
              // Support: IE<9
              // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
              // request header to a null-value.
              //
              // To keep consistent with other XHR implementations, cast the value
              // to string and ignore `undefined`.
              if (headers[i] !== undefined) {
                xhr.setRequestHeader(i, headers[i] + "");
              }
            }

            // Do send the request
            // This may raise an exception which is actually
            // handled in jQuery.ajax (so no try/catch here)
            xhr.send((options.hasContent && options.data) || null);

            // Listener
            callback = function (_, isAbort) {
              var status, statusText, responses;

              // Was never called and is aborted or complete
              if (callback && (isAbort || xhr.readyState === 4)) {
                // Clean up
                delete xhrCallbacks[id];
                callback = undefined;
                xhr.onreadystatechange = jQuery.noop;

                // Abort manually if needed
                if (isAbort) {
                  if (xhr.readyState !== 4) {
                    xhr.abort();
                  }
                } else {
                  responses = {};
                  status = xhr.status;

                  // Support: IE<10
                  // Accessing binary-data responseText throws an exception
                  // (#11426)
                  if (typeof xhr.responseText === "string") {
                    responses.text = xhr.responseText;
                  }

                  // Firefox throws an exception when accessing
                  // statusText for faulty cross-domain requests
                  try {
                    statusText = xhr.statusText;
                  } catch (e) {
                    // We normalize with Webkit giving an empty statusText
                    statusText = "";
                  }

                  // Filter status for non standard behaviors

                  // If the request is local and we have data: assume a success
                  // (success with no data won't get notified, that's the best we
                  // can do given current implementations)
                  if (!status && options.isLocal && !options.crossDomain) {
                    status = responses.text ? 200 : 404;

                    // IE - #1450: sometimes returns 1223 when it should be 204
                  } else if (status === 1223) {
                    status = 204;
                  }
                }
              }

              // Call complete if needed
              if (responses) {
                complete(
                  status,
                  statusText,
                  responses,
                  xhr.getAllResponseHeaders()
                );
              }
            };

            // Do send the request
            // `xhr.send` may raise an exception, but it will be
            // handled in jQuery.ajax (so no try/catch here)
            if (!options.async) {
              // If we're in sync mode we fire the callback
              callback();
            } else if (xhr.readyState === 4) {
              // (IE6 & IE7) if it's in cache and has been
              // retrieved directly we need to fire the callback
              window.setTimeout(callback);
            } else {
              // Register the callback, but delay it in case `xhr.send` throws
              // Add to the list of active xhr callbacks
              xhr.onreadystatechange = xhrCallbacks[id] = callback;
            }
          },

          abort: function () {
            if (callback) {
              callback(undefined, true);
            }
          },
        };
      }
    });
  }

  // Functions to create xhrs
  function createStandardXHR() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  }

  function createActiveXHR() {
    try {
      return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch (e) {}
  }

  // Install script dataType
  jQuery.ajaxSetup({
    accepts: {
      script:
        "text/javascript, application/javascript, " +
        "application/ecmascript, application/x-ecmascript",
    },
    contents: {
      script: /\b(?:java|ecma)script\b/,
    },
    converters: {
      "text script": function (text) {
        jQuery.globalEval(text);
        return text;
      },
    },
  });

  // Handle cache's special case and global
  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
      s.global = false;
    }
  });

  // Bind script tag hack transport
  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script,
        head = document.head || jQuery("head")[0] || document.documentElement;

      return {
        send: function (_, callback) {
          script = document.createElement("script");

          script.async = true;

          if (s.scriptCharset) {
            script.charset = s.scriptCharset;
          }

          script.src = s.url;

          // Attach handlers for all browsers
          script.onload = script.onreadystatechange = function (_, isAbort) {
            if (
              isAbort ||
              !script.readyState ||
              /loaded|complete/.test(script.readyState)
            ) {
              // Handle memory leak in IE
              script.onload = script.onreadystatechange = null;

              // Remove the script
              if (script.parentNode) {
                script.parentNode.removeChild(script);
              }

              // Dereference the script
              script = null;

              // Callback if not abort
              if (!isAbort) {
                callback(200, "success");
              }
            }
          };

          // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
          // Use native DOM manipulation to avoid our domManip AJAX trickery
          head.insertBefore(script, head.firstChild);
        },

        abort: function () {
          if (script) {
            script.onload(undefined, true);
          }
        },
      };
    }
  });

  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    },
  });

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
      overwritten,
      responseContainer,
      jsonProp =
        s.jsonp !== false &&
        (rjsonp.test(s.url)
          ? "url"
          : typeof s.data === "string" &&
            (s.contentType || "").indexOf(
              "application/x-www-form-urlencoded"
            ) === 0 &&
            rjsonp.test(s.data) &&
            "data");

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback)
        ? s.jsonpCallback()
        : s.jsonpCallback;

      // Insert callback into url or form data
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url +=
          (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }

      // Use data converter to retrieve json after script execution
      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };

      // force json dataType
      s.dataTypes[0] = "json";

      // Install callback
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };

      // Clean-up function (fires after converters)
      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);

          // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        }

        // Save back as free
        if (s[callbackName]) {
          // make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;

          // save the callback name for future use
          oldCallbacks.push(callbackName);
        }

        // Call if it was a function and we have a response
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      });

      // Delegate to script
      return "script";
    }
  });

  // data: string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function (data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;

    var parsed = rsingleTag.exec(data),
      scripts = !keepScripts && [];

    // Single tag
    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };

  // Keep a copy of the old load method
  var _load = jQuery.fn.load;

  /**
   * Load a url into a page
   */
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }

    var selector,
      type,
      response,
      self = this,
      off = url.indexOf(" ");

    if (off > -1) {
      selector = jQuery.trim(url.slice(off, url.length));
      url = url.slice(0, off);
    }

    // If it's a function
    if (jQuery.isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined;

      // Otherwise, build a param string
    } else if (params && typeof params === "object") {
      type = "POST";
    }

    // If we have elements to modify, make the request
    if (self.length > 0) {
      jQuery
        .ajax({
          url: url,

          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params,
        })
        .done(function (responseText) {
          // Save response for use in complete callback
          response = arguments;

          self.html(
            selector
              ? // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>")
                  .append(jQuery.parseHTML(responseText))
                  .find(selector)
              : // Otherwise use the full result
                responseText
          );

          // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
        })
        .always(
          callback &&
            function (jqXHR, status) {
              self.each(function () {
                callback.apply(
                  this,
                  response || [jqXHR.responseText, status, jqXHR]
                );
              });
            }
        );
    }

    return this;
  };

  // Attach a bunch of functions for handling common AJAX events
  jQuery.each(
    [
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend",
    ],
    function (i, type) {
      jQuery.fn[type] = function (fn) {
        return this.on(type, fn);
      };
    }
  );

  jQuery.expr.filters.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  /**
   * Gets a window from an element
   */
  function getWindow(elem) {
    return jQuery.isWindow(elem)
      ? elem
      : elem.nodeType === 9
      ? elem.defaultView || elem.parentWindow
      : false;
  }

  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition,
        curLeft,
        curCSSTop,
        curTop,
        curOffset,
        curCSSLeft,
        calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};

      // set position first, in-case top/left are set even on static elem
      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition =
        (position === "absolute" || position === "fixed") &&
        jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1;

      // need to be able to calculate position if either top or left
      // is auto and position is either absolute or fixed
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (jQuery.isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    },
  };

  jQuery.fn.extend({
    offset: function (options) {
      if (arguments.length) {
        return options === undefined
          ? this
          : this.each(function (i) {
              jQuery.offset.setOffset(this, options, i);
            });
      }

      var docElem,
        win,
        box = { top: 0, left: 0 },
        elem = this[0],
        doc = elem && elem.ownerDocument;

      if (!doc) {
        return;
      }

      docElem = doc.documentElement;

      // Make sure it's not a disconnected DOM node
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }

      // If we don't have gBCR, just use 0,0 rather than error
      // BlackBerry 5, iOS 3 (original iPhone)
      if (typeof elem.getBoundingClientRect !== "undefined") {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top:
          box.top +
          (win.pageYOffset || docElem.scrollTop) -
          (docElem.clientTop || 0),
        left:
          box.left +
          (win.pageXOffset || docElem.scrollLeft) -
          (docElem.clientLeft || 0),
      };
    },

    position: function () {
      if (!this[0]) {
        return;
      }

      var offsetParent,
        offset,
        parentOffset = { top: 0, left: 0 },
        elem = this[0];

      // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
      // because it is its only offset parent
      if (jQuery.css(elem, "position") === "fixed") {
        // we assume that getBoundingClientRect is available when computed position is fixed
        offset = elem.getBoundingClientRect();
      } else {
        // Get *real* offsetParent
        offsetParent = this.offsetParent();

        // Get correct offsets
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }

        // Add offsetParent borders
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(
          offsetParent[0],
          "borderLeftWidth",
          true
        );
      }

      // Subtract parent offsets and element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      return {
        top:
          offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left:
          offset.left -
          parentOffset.left -
          jQuery.css(elem, "marginLeft", true),
      };
    },

    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (
          offsetParent &&
          !jQuery.nodeName(offsetParent, "html") &&
          jQuery.css(offsetParent, "position") === "static"
        ) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    },
  });

  // Create scrollLeft and scrollTop methods
  jQuery.each(
    { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
    function (method, prop) {
      var top = /Y/.test(prop);

      jQuery.fn[method] = function (val) {
        return access(
          this,
          function (elem, method, val) {
            var win = getWindow(elem);

            if (val === undefined) {
              return win
                ? prop in win
                  ? win[prop]
                  : win.document.documentElement[method]
                : elem[method];
            }

            if (win) {
              win.scrollTo(
                !top ? val : jQuery(win).scrollLeft(),
                top ? val : jQuery(win).scrollTop()
              );
            } else {
              elem[method] = val;
            }
          },
          method,
          val,
          arguments.length,
          null
        );
      };
    }
  );

  // Support: Safari<7-8+, Chrome<37-44+
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // getComputedStyle returns percent when specified for top/left/bottom/right
  // rather than make the css module depend on the offset module, we just check for it here
  jQuery.each(["top", "left"], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(
      support.pixelPosition,
      function (elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);

          // if curCSS returns percentage, fallback to offset
          return rnumnonpx.test(computed)
            ? jQuery(elem).position()[prop] + "px"
            : computed;
        }
      }
    );
  });

  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
    jQuery.each(
      { padding: "inner" + name, content: type, "": "outer" + name },
      function (defaultExtra, funcName) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[funcName] = function (margin, value) {
          var chainable =
              arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra =
              defaultExtra ||
              (margin === true || value === true ? "margin" : "border");

          return access(
            this,
            function (elem, type, value) {
              var doc;

              if (jQuery.isWindow(elem)) {
                // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                // isn't a whole lot we can do. See pull request at this URL for discussion:
                // https://github.com/jquery/jquery/pull/764
                return elem.document.documentElement["client" + name];
              }

              // Get document width or height
              if (elem.nodeType === 9) {
                doc = elem.documentElement;

                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                // whichever is greatest
                // unfortunately, this causes bug #3838 in IE6/8 only,
                // but there is currently no good, small way to fix it.
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }

              return value === undefined
                ? // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery.css(elem, type, extra)
                : // Set width or height on the element
                  jQuery.style(elem, type, value, extra);
            },
            type,
            chainable ? margin : undefined,
            chainable,
            null
          );
        };
      }
    );
  });

  jQuery.fn.extend({
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },

    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1
        ? this.off(selector, "**")
        : this.off(types, selector || "**", fn);
    },
  });

  // The number of elements contained in the matched element set
  jQuery.fn.size = function () {
    return this.length;
  };

  jQuery.fn.andSelf = jQuery.fn.addBack;

  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.

  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return jQuery;
    });
  }

  var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
    // Map over the $ in case of overwrite
    _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  };

  // Expose jQuery and $ identifiers, even in
  // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});
/* jshint node: true */

/**
 * Unobtrusive scripting adapter for jQuery
 * https://github.com/rails/jquery-ujs
 *
 * Requires jQuery 1.8.0 or later.
 *
 * Released under the MIT license
 *
 */

(function () {
  "use strict";

  var jqueryUjsInit = function ($, undefined) {
    // Cut down on the number of issues from people inadvertently including jquery_ujs twice
    // by detecting and raising an error when it happens.
    if ($.rails !== undefined) {
      $.error("jquery-ujs has already been loaded!");
    }

    // Shorthand to make it a little easier to call public rails functions from within rails.js
    var rails;
    var $document = $(document);

    $.rails = rails = {
      // Link elements bound by jquery-ujs
      linkClickSelector:
        "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]",

      // Button elements bound by jquery-ujs
      buttonClickSelector:
        "button[data-remote]:not([form]):not(form button), button[data-confirm]:not([form]):not(form button)",

      // Select elements bound by jquery-ujs
      inputChangeSelector:
        "select[data-remote], input[data-remote], textarea[data-remote]",

      // Form elements bound by jquery-ujs
      formSubmitSelector: "form:not([data-turbo=true])",

      // Form input elements bound by jquery-ujs
      formInputClickSelector:
        "form:not([data-turbo=true]) input[type=submit], form:not([data-turbo=true]) input[type=image], form:not([data-turbo=true]) button[type=submit], form:not([data-turbo=true]) button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])",

      // Form input elements disabled during form submission
      disableSelector:
        "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled",

      // Form input elements re-enabled after form submission
      enableSelector:
        "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled",

      // Form required input elements
      requiredInputSelector:
        "input[name][required]:not([disabled]), textarea[name][required]:not([disabled])",

      // Form file input elements
      fileInputSelector: "input[name][type=file]:not([disabled])",

      // Link onClick disable selector with possible reenable after remote submission
      linkDisableSelector: "a[data-disable-with], a[data-disable]",

      // Button onClick disable selector with possible reenable after remote submission
      buttonDisableSelector:
        "button[data-remote][data-disable-with], button[data-remote][data-disable]",

      // Up-to-date Cross-Site Request Forgery token
      csrfToken: function () {
        return $("meta[name=csrf-token]").attr("content");
      },

      // URL param that must contain the CSRF token
      csrfParam: function () {
        return $("meta[name=csrf-param]").attr("content");
      },

      // Make sure that every Ajax request sends the CSRF token
      CSRFProtection: function (xhr) {
        var token = rails.csrfToken();
        if (token) xhr.setRequestHeader("X-CSRF-Token", token);
      },

      // Make sure that all forms have actual up-to-date tokens (cached forms contain old ones)
      refreshCSRFTokens: function () {
        $('form input[name="' + rails.csrfParam() + '"]').val(
          rails.csrfToken()
        );
      },

      // Triggers an event on an element and returns false if the event result is false
      fire: function (obj, name, data) {
        var event = $.Event(name);
        obj.trigger(event, data);
        return event.result !== false;
      },

      // Default confirm dialog, may be overridden with custom confirm dialog in $.rails.confirm
      confirm: function (message) {
        return confirm(message);
      },

      // Default ajax function, may be overridden with custom function in $.rails.ajax
      ajax: function (options) {
        return $.ajax(options);
      },

      // Default way to get an element's href. May be overridden at $.rails.href.
      href: function (element) {
        return element[0].href;
      },

      // Checks "data-remote" if true to handle the request through a XHR request.
      isRemote: function (element) {
        return (
          element.data("remote") !== undefined &&
          element.data("remote") !== false
        );
      },

      // Submits "remote" forms and links with ajax
      handleRemote: function (element) {
        var method, url, data, withCredentials, dataType, options;

        if (rails.fire(element, "ajax:before")) {
          withCredentials = element.data("with-credentials") || null;
          dataType =
            element.data("type") || ($.ajaxSettings && $.ajaxSettings.dataType);

          if (element.is("form")) {
            method =
              element.data("ujs:submit-button-formmethod") ||
              element.attr("method");
            url =
              element.data("ujs:submit-button-formaction") ||
              element.attr("action");
            data = $(element[0]).serializeArray();
            // memoized value from clicked submit button
            var button = element.data("ujs:submit-button");
            if (button) {
              data.push(button);
              element.data("ujs:submit-button", null);
            }
            element.data("ujs:submit-button-formmethod", null);
            element.data("ujs:submit-button-formaction", null);
          } else if (element.is(rails.inputChangeSelector)) {
            method = element.data("method");
            url = element.data("url");
            data = element.serialize();
            if (element.data("params"))
              data = data + "&" + element.data("params");
          } else if (element.is(rails.buttonClickSelector)) {
            method = element.data("method") || "get";
            url = element.data("url");
            data = element.serialize();
            if (element.data("params"))
              data = data + "&" + element.data("params");
          } else {
            method = element.data("method");
            url = rails.href(element);
            data = element.data("params") || null;
          }

          options = {
            type: method || "GET",
            data: data,
            dataType: dataType,
            // stopping the "ajax:beforeSend" event will cancel the ajax request
            beforeSend: function (xhr, settings) {
              if (settings.dataType === undefined) {
                xhr.setRequestHeader(
                  "accept",
                  "*/*;q=0.5, " + settings.accepts.script
                );
              }
              if (rails.fire(element, "ajax:beforeSend", [xhr, settings])) {
                element.trigger("ajax:send", xhr);
              } else {
                return false;
              }
            },
            success: function (data, status, xhr) {
              element.trigger("ajax:success", [data, status, xhr]);
            },
            complete: function (xhr, status) {
              element.trigger("ajax:complete", [xhr, status]);
            },
            error: function (xhr, status, error) {
              element.trigger("ajax:error", [xhr, status, error]);
            },
            crossDomain: rails.isCrossDomain(url),
          };

          // There is no withCredentials for IE6-8 when
          // "Enable native XMLHTTP support" is disabled
          if (withCredentials) {
            options.xhrFields = {
              withCredentials: withCredentials,
            };
          }

          // Only pass url to `ajax` options if not blank
          if (url) {
            options.url = url;
          }

          return rails.ajax(options);
        } else {
          return false;
        }
      },

      // Determines if the request is a cross domain request.
      isCrossDomain: function (url) {
        var originAnchor = document.createElement("a");
        originAnchor.href = location.href;
        var urlAnchor = document.createElement("a");

        try {
          urlAnchor.href = url;
          // This is a workaround to a IE bug.
          urlAnchor.href = urlAnchor.href;

          // If URL protocol is false or is a string containing a single colon
          // *and* host are false, assume it is not a cross-domain request
          // (should only be the case for IE7 and IE compatibility mode).
          // Otherwise, evaluate protocol and host of the URL against the origin
          // protocol and host.
          return !(
            ((!urlAnchor.protocol || urlAnchor.protocol === ":") &&
              !urlAnchor.host) ||
            originAnchor.protocol + "//" + originAnchor.host ===
              urlAnchor.protocol + "//" + urlAnchor.host
          );
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain.
          return true;
        }
      },

      // Handles "data-method" on links such as:
      // <a href="/users/5" data-method="delete" rel="nofollow" data-confirm="Are you sure?">Delete</a>
      handleMethod: function (link) {
        var href = rails.href(link),
          method = link.data("method"),
          target = link.attr("target"),
          csrfToken = rails.csrfToken(),
          csrfParam = rails.csrfParam(),
          form = $('<form method="post" action="' + href + '"></form>'),
          metadataInput =
            '<input name="_method" value="' + method + '" type="hidden" />';

        if (
          csrfParam !== undefined &&
          csrfToken !== undefined &&
          !rails.isCrossDomain(href)
        ) {
          metadataInput +=
            '<input name="' +
            csrfParam +
            '" value="' +
            csrfToken +
            '" type="hidden" />';
        }

        if (target) {
          form.attr("target", target);
        }

        form.hide().append(metadataInput).appendTo("body");
        form.submit();
      },

      // Helper function that returns form elements that match the specified CSS selector
      // If form is actually a "form" element this will return associated elements outside the from that have
      // the html form attribute set
      formElements: function (form, selector) {
        return form.is("form")
          ? $(form[0].elements).filter(selector)
          : form.find(selector);
      },

      /* Disables form elements:
      - Caches element value in 'ujs:enable-with' data store
      - Replaces element text with value of 'data-disable-with' attribute
      - Sets disabled property to true
    */
      disableFormElements: function (form) {
        rails.formElements(form, rails.disableSelector).each(function () {
          rails.disableFormElement($(this));
        });
      },

      disableFormElement: function (element) {
        var method, replacement;

        method = element.is("button") ? "html" : "val";
        replacement = element.data("disable-with");

        if (replacement !== undefined) {
          element.data("ujs:enable-with", element[method]());
          element[method](replacement);
        }

        element.prop("disabled", true);
        element.data("ujs:disabled", true);
      },

      /* Re-enables disabled form elements:
      - Replaces element text with cached value from 'ujs:enable-with' data store (created in `disableFormElements`)
      - Sets disabled property to false
    */
      enableFormElements: function (form) {
        rails.formElements(form, rails.enableSelector).each(function () {
          rails.enableFormElement($(this));
        });
      },

      enableFormElement: function (element) {
        var method = element.is("button") ? "html" : "val";
        if (element.data("ujs:enable-with") !== undefined) {
          element[method](element.data("ujs:enable-with"));
          element.removeData("ujs:enable-with"); // clean up cache
        }
        element.prop("disabled", false);
        element.removeData("ujs:disabled");
      },

      /* For 'data-confirm' attribute:
      - Fires `confirm` event
      - Shows the confirmation dialog
      - Fires the `confirm:complete` event

      Returns `true` if no function stops the chain and user chose yes; `false` otherwise.
      Attaching a handler to the element's `confirm` event that returns a `falsy` value cancels the confirmation dialog.
      Attaching a handler to the element's `confirm:complete` event that returns a `falsy` value makes this function
      return false. The `confirm:complete` event is fired whether or not the user answered true or false to the dialog.
   */
      allowAction: function (element) {
        var message = element.data("confirm"),
          answer = false,
          callback;
        if (!message) {
          return true;
        }

        if (rails.fire(element, "confirm")) {
          try {
            answer = rails.confirm(message);
          } catch (e) {
            (console.error || console.log).call(console, e.stack || e);
          }
          callback = rails.fire(element, "confirm:complete", [answer]);
        }
        return answer && callback;
      },

      // Helper function which checks for blank inputs in a form that match the specified CSS selector
      blankInputs: function (form, specifiedSelector, nonBlank) {
        var foundInputs = $(),
          input,
          valueToCheck,
          radiosForNameWithNoneSelected,
          radioName,
          selector = specifiedSelector || "input,textarea",
          requiredInputs = form.find(selector),
          checkedRadioButtonNames = {};

        requiredInputs.each(function () {
          input = $(this);
          if (input.is("input[type=radio]")) {
            // Don't count unchecked required radio as blank if other radio with same name is checked,
            // regardless of whether same-name radio input has required attribute or not. The spec
            // states https://www.w3.org/TR/html5/forms.html#the-required-attribute
            radioName = input.attr("name");

            // Skip if we've already seen the radio with this name.
            if (!checkedRadioButtonNames[radioName]) {
              // If none checked
              if (
                form.find('input[type=radio]:checked[name="' + radioName + '"]')
                  .length === 0
              ) {
                radiosForNameWithNoneSelected = form.find(
                  'input[type=radio][name="' + radioName + '"]'
                );
                foundInputs = foundInputs.add(radiosForNameWithNoneSelected);
              }

              // We only need to check each name once.
              checkedRadioButtonNames[radioName] = radioName;
            }
          } else {
            valueToCheck = input.is("input[type=checkbox],input[type=radio]")
              ? input.is(":checked")
              : !!input.val();
            if (valueToCheck === nonBlank) {
              foundInputs = foundInputs.add(input);
            }
          }
        });
        return foundInputs.length ? foundInputs : false;
      },

      // Helper function which checks for non-blank inputs in a form that match the specified CSS selector
      nonBlankInputs: function (form, specifiedSelector) {
        return rails.blankInputs(form, specifiedSelector, true); // true specifies nonBlank
      },

      // Helper function, needed to provide consistent behavior in IE
      stopEverything: function (e) {
        $(e.target).trigger("ujs:everythingStopped");
        e.stopImmediatePropagation();
        return false;
      },

      //  Replace element's html with the 'data-disable-with' after storing original html
      //  and prevent clicking on it
      disableElement: function (element) {
        var replacement = element.data("disable-with");

        if (replacement !== undefined) {
          element.data("ujs:enable-with", element.html()); // store enabled state
          element.html(replacement);
        }

        element.on("click.railsDisable", function (e) {
          // prevent further clicking
          return rails.stopEverything(e);
        });
        element.data("ujs:disabled", true);
      },

      // Restore element to its original state which was disabled by 'disableElement' above
      enableElement: function (element) {
        if (element.data("ujs:enable-with") !== undefined) {
          element.html(element.data("ujs:enable-with")); // set to old enabled state
          element.removeData("ujs:enable-with"); // clean up cache
        }
        element.off("click.railsDisable"); // enable element
        element.removeData("ujs:disabled");
      },
    };

    if (rails.fire($document, "rails:attachBindings")) {
      $.ajaxPrefilter(function (options, originalOptions, xhr) {
        if (!options.crossDomain) {
          rails.CSRFProtection(xhr);
        }
      });

      // This event works the same as the load event, except that it fires every
      // time the page is loaded.
      //
      // See https://github.com/rails/jquery-ujs/issues/357
      // See https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching
      $(window).on("pageshow.rails", function () {
        $($.rails.enableSelector).each(function () {
          var element = $(this);

          if (element.data("ujs:disabled")) {
            $.rails.enableFormElement(element);
          }
        });

        $($.rails.linkDisableSelector).each(function () {
          var element = $(this);

          if (element.data("ujs:disabled")) {
            $.rails.enableElement(element);
          }
        });
      });

      $document.on("ajax:complete", rails.linkDisableSelector, function () {
        rails.enableElement($(this));
      });

      $document.on("ajax:complete", rails.buttonDisableSelector, function () {
        rails.enableFormElement($(this));
      });

      $document.on("click.rails", rails.linkClickSelector, function (e) {
        var link = $(this),
          method = link.data("method"),
          data = link.data("params"),
          metaClick = e.metaKey || e.ctrlKey;
        if (!rails.allowAction(link)) return rails.stopEverything(e);

        if (!metaClick && link.is(rails.linkDisableSelector))
          rails.disableElement(link);

        if (rails.isRemote(link)) {
          if (metaClick && (!method || method === "GET") && !data) {
            return true;
          }

          var handleRemote = rails.handleRemote(link);
          // Response from rails.handleRemote() will either be false or a deferred object promise.
          if (handleRemote === false) {
            rails.enableElement(link);
          } else {
            handleRemote.fail(function () {
              rails.enableElement(link);
            });
          }
          return false;
        } else if (method) {
          rails.handleMethod(link);
          return false;
        }
      });

      $document.on("click.rails", rails.buttonClickSelector, function (e) {
        var button = $(this);

        if (!rails.allowAction(button) || !rails.isRemote(button))
          return rails.stopEverything(e);

        if (button.is(rails.buttonDisableSelector))
          rails.disableFormElement(button);

        var handleRemote = rails.handleRemote(button);
        // Response from rails.handleRemote() will either be false or a deferred object promise.
        if (handleRemote === false) {
          rails.enableFormElement(button);
        } else {
          handleRemote.fail(function () {
            rails.enableFormElement(button);
          });
        }
        return false;
      });

      $document.on("change.rails", rails.inputChangeSelector, function (e) {
        var link = $(this);
        if (!rails.allowAction(link) || !rails.isRemote(link))
          return rails.stopEverything(e);

        rails.handleRemote(link);
        return false;
      });

      $document.on("submit.rails", rails.formSubmitSelector, function (e) {
        var form = $(this),
          remote = rails.isRemote(form),
          blankRequiredInputs,
          nonBlankFileInputs;

        if (!rails.allowAction(form)) return rails.stopEverything(e);

        // Skip other logic when required values are missing or file upload is present
        if (form.attr("novalidate") === undefined) {
          if (form.data("ujs:formnovalidate-button") === undefined) {
            blankRequiredInputs = rails.blankInputs(
              form,
              rails.requiredInputSelector,
              false
            );
            if (
              blankRequiredInputs &&
              rails.fire(form, "ajax:aborted:required", [blankRequiredInputs])
            ) {
              return rails.stopEverything(e);
            }
          } else {
            // Clear the formnovalidate in case the next button click is not on a formnovalidate button
            // Not strictly necessary to do here, since it is also reset on each button click, but just to be certain
            form.data("ujs:formnovalidate-button", undefined);
          }
        }

        if (remote) {
          nonBlankFileInputs = rails.nonBlankInputs(
            form,
            rails.fileInputSelector
          );
          if (nonBlankFileInputs) {
            // Slight timeout so that the submit button gets properly serialized
            // (make it easy for event handler to serialize form without disabled values)
            setTimeout(function () {
              rails.disableFormElements(form);
            }, 13);
            var aborted = rails.fire(form, "ajax:aborted:file", [
              nonBlankFileInputs,
            ]);

            // Re-enable form elements if event bindings return false (canceling normal form submission)
            if (!aborted) {
              setTimeout(function () {
                rails.enableFormElements(form);
              }, 13);
            }

            return aborted;
          }

          rails.handleRemote(form);
          return false;
        } else {
          // Slight timeout so that the submit button gets properly serialized
          setTimeout(function () {
            rails.disableFormElements(form);
          }, 13);
        }
      });

      $document.on(
        "click.rails",
        rails.formInputClickSelector,
        function (event) {
          var button = $(this);

          if (!rails.allowAction(button)) return rails.stopEverything(event);

          // Register the pressed submit button
          var name = button.attr("name"),
            data = name ? { name: name, value: button.val() } : null;

          var form = button.closest("form");
          if (form.length === 0) {
            form = $("#" + button.attr("form"));
          }
          form.data("ujs:submit-button", data);

          // Save attributes from button
          form.data("ujs:formnovalidate-button", button.attr("formnovalidate"));
          form.data("ujs:submit-button-formaction", button.attr("formaction"));
          form.data("ujs:submit-button-formmethod", button.attr("formmethod"));
        }
      );

      $document.on(
        "ajax:send.rails",
        rails.formSubmitSelector,
        function (event) {
          if (this === event.target) rails.disableFormElements($(this));
        }
      );

      $document.on(
        "ajax:complete.rails",
        rails.formSubmitSelector,
        function (event) {
          if (this === event.target) rails.enableFormElements($(this));
        }
      );

      $(function () {
        rails.refreshCSRFTokens();
      });
    }
  };

  if (window.jQuery) {
    jqueryUjsInit(jQuery);
  } else if (typeof exports === "object" && typeof module === "object") {
    module.exports = jqueryUjsInit;
  }
})();
(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  $.ui = $.ui || {};

  return ($.ui.version = "1.13.0");
});

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery", "./version"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  // This file is deprecated
  return ($.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()));
});

/*!
 * jQuery UI Widget 1.13.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery", "./version"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  var widgetUuid = 0;
  var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
  var widgetSlice = Array.prototype.slice;

  $.cleanData = (function (orig) {
    return function (elems) {
      var events, elem, i;
      for (i = 0; (elem = elems[i]) != null; i++) {
        // Only trigger remove when necessary to save time
        events = $._data(elem, "events");
        if (events && events.remove) {
          $(elem).triggerHandler("remove");
        }
      }
      orig(elems);
    };
  })($.cleanData);

  $.widget = function (name, base, prototype) {
    var existingConstructor, constructor, basePrototype;

    // ProxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    var proxiedPrototype = {};

    var namespace = name.split(".")[0];
    name = name.split(".")[1];
    var fullName = namespace + "-" + name;

    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }

    if (Array.isArray(prototype)) {
      prototype = $.extend.apply(null, [{}].concat(prototype));
    }

    // Create selector for plugin
    $.expr.pseudos[fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };

    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // Allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }

      // Allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };

    // Extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,

      // Copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend({}, prototype),

      // Track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: [],
    });

    basePrototype = new base();

    // We need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (typeof value !== "function") {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = (function () {
        function _super() {
          return base.prototype[prop].apply(this, arguments);
        }

        function _superApply(args) {
          return base.prototype[prop].apply(this, args);
        }

        return function () {
          var __super = this._super;
          var __superApply = this._superApply;
          var returnValue;

          this._super = _super;
          this._superApply = _superApply;

          returnValue = value.apply(this, arguments);

          this._super = __super;
          this._superApply = __superApply;

          return returnValue;
        };
      })();
    });
    constructor.prototype = $.widget.extend(
      basePrototype,
      {
        // TODO: remove support for widgetEventPrefix
        // always use the name + a colon as the prefix, e.g., draggable:start
        // don't prefix for widgets that aren't DOM-based
        widgetEventPrefix: existingConstructor
          ? basePrototype.widgetEventPrefix || name
          : name,
      },
      proxiedPrototype,
      {
        constructor: constructor,
        namespace: namespace,
        widgetName: name,
        widgetFullName: fullName,
      }
    );

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;

        // Redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(
          childPrototype.namespace + "." + childPrototype.widgetName,
          constructor,
          child._proto
        );
      });

      // Remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }

    $.widget.bridge(name, constructor);

    return constructor;
  };

  $.widget.extend = function (target) {
    var input = widgetSlice.call(arguments, 1);
    var inputIndex = 0;
    var inputLength = input.length;
    var key;
    var value;

    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (
          widgetHasOwnProperty.call(input[inputIndex], key) &&
          value !== undefined
        ) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key])
              ? $.widget.extend({}, target[key], value)
              : // Don't extend strings, arrays, etc. with objects
                $.widget.extend({}, value);

            // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };

  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === "string";
      var args = widgetSlice.call(arguments, 1);
      var returnValue = this;

      if (isMethodCall) {
        // If this is an empty collection, we need to have the instance method
        // return undefined instead of the jQuery instance
        if (!this.length && options === "instance") {
          returnValue = undefined;
        } else {
          this.each(function () {
            var methodValue;
            var instance = $.data(this, fullName);

            if (options === "instance") {
              returnValue = instance;
              return false;
            }

            if (!instance) {
              return $.error(
                "cannot call methods on " +
                  name +
                  " prior to initialization; " +
                  "attempted to call method '" +
                  options +
                  "'"
              );
            }

            if (
              typeof instance[options] !== "function" ||
              options.charAt(0) === "_"
            ) {
              return $.error(
                "no such method '" +
                  options +
                  "' for " +
                  name +
                  " widget instance"
              );
            }

            methodValue = instance[options].apply(instance, args);

            if (methodValue !== instance && methodValue !== undefined) {
              returnValue =
                methodValue && methodValue.jquery
                  ? returnValue.pushStack(methodValue.get())
                  : methodValue;
              return false;
            }
          });
        }
      } else {
        // Allow multiple hashes to be passed on init
        if (args.length) {
          options = $.widget.extend.apply(null, [options].concat(args));
        }

        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {});
            if (instance._init) {
              instance._init();
            }
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }

      return returnValue;
    };
  };

  $.Widget = function (/* options, element */) {};
  $.Widget._childConstructors = [];

  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",

    options: {
      classes: {},
      disabled: false,

      // Callbacks
      create: null,
    },

    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = widgetUuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;

      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      this.classesElementLookup = {};

      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          },
        });
        this.document = $(
          element.style
            ? // Element within the document
              element.ownerDocument
            : // Element is window or document
              element.document || element
        );
        this.window = $(
          this.document[0].defaultView || this.document[0].parentWindow
        );
      }

      this.options = $.widget.extend(
        {},
        this.options,
        this._getCreateOptions(),
        options
      );

      this._create();

      if (this.options.disabled) {
        this._setOptionDisabled(this.options.disabled);
      }

      this._trigger("create", null, this._getCreateEventData());
      this._init();
    },

    _getCreateOptions: function () {
      return {};
    },

    _getCreateEventData: $.noop,

    _create: $.noop,

    _init: $.noop,

    destroy: function () {
      var that = this;

      this._destroy();
      $.each(this.classesElementLookup, function (key, value) {
        that._removeClass(value, key);
      });

      // We can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element.off(this.eventNamespace).removeData(this.widgetFullName);
      this.widget().off(this.eventNamespace).removeAttr("aria-disabled");

      // Clean up events and states
      this.bindings.off(this.eventNamespace);
    },

    _destroy: $.noop,

    widget: function () {
      return this.element;
    },

    option: function (key, value) {
      var options = key;
      var parts;
      var curOption;
      var i;

      if (arguments.length === 0) {
        // Don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      if (typeof key === "string") {
        // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }

      this._setOptions(options);

      return this;
    },

    _setOptions: function (options) {
      var key;

      for (key in options) {
        this._setOption(key, options[key]);
      }

      return this;
    },

    _setOption: function (key, value) {
      if (key === "classes") {
        this._setOptionClasses(value);
      }

      this.options[key] = value;

      if (key === "disabled") {
        this._setOptionDisabled(value);
      }

      return this;
    },

    _setOptionClasses: function (value) {
      var classKey, elements, currentElements;

      for (classKey in value) {
        currentElements = this.classesElementLookup[classKey];
        if (
          value[classKey] === this.options.classes[classKey] ||
          !currentElements ||
          !currentElements.length
        ) {
          continue;
        }

        // We are doing this to create a new jQuery object because the _removeClass() call
        // on the next line is going to destroy the reference to the current elements being
        // tracked. We need to save a copy of this collection so that we can add the new classes
        // below.
        elements = $(currentElements.get());
        this._removeClass(currentElements, classKey);

        // We don't use _addClass() here, because that uses this.options.classes
        // for generating the string of classes. We want to use the value passed in from
        // _setOption(), this is the new value of the classes option which was passed to
        // _setOption(). We pass this value directly to _classes().
        elements.addClass(
          this._classes({
            element: elements,
            keys: classKey,
            classes: value,
            add: true,
          })
        );
      }
    },

    _setOptionDisabled: function (value) {
      this._toggleClass(
        this.widget(),
        this.widgetFullName + "-disabled",
        null,
        !!value
      );

      // If the widget is becoming disabled, then nothing is interactive
      if (value) {
        this._removeClass(this.hoverable, null, "ui-state-hover");
        this._removeClass(this.focusable, null, "ui-state-focus");
      }
    },

    enable: function () {
      return this._setOptions({ disabled: false });
    },

    disable: function () {
      return this._setOptions({ disabled: true });
    },

    _classes: function (options) {
      var full = [];
      var that = this;

      options = $.extend(
        {
          element: this.element,
          classes: this.options.classes || {},
        },
        options
      );

      function bindRemoveEvent() {
        options.element.each(function (_, element) {
          var isTracked = $.map(that.classesElementLookup, function (elements) {
            return elements;
          }).some(function (elements) {
            return elements.is(element);
          });

          if (!isTracked) {
            that._on($(element), {
              remove: "_untrackClassesElement",
            });
          }
        });
      }

      function processClassString(classes, checkOption) {
        var current, i;
        for (i = 0; i < classes.length; i++) {
          current = that.classesElementLookup[classes[i]] || $();
          if (options.add) {
            bindRemoveEvent();
            current = $(
              $.uniqueSort(current.get().concat(options.element.get()))
            );
          } else {
            current = $(current.not(options.element).get());
          }
          that.classesElementLookup[classes[i]] = current;
          full.push(classes[i]);
          if (checkOption && options.classes[classes[i]]) {
            full.push(options.classes[classes[i]]);
          }
        }
      }

      if (options.keys) {
        processClassString(options.keys.match(/\S+/g) || [], true);
      }
      if (options.extra) {
        processClassString(options.extra.match(/\S+/g) || []);
      }

      return full.join(" ");
    },

    _untrackClassesElement: function (event) {
      var that = this;
      $.each(that.classesElementLookup, function (key, value) {
        if ($.inArray(event.target, value) !== -1) {
          that.classesElementLookup[key] = $(value.not(event.target).get());
        }
      });

      this._off($(event.target));
    },

    _removeClass: function (element, keys, extra) {
      return this._toggleClass(element, keys, extra, false);
    },

    _addClass: function (element, keys, extra) {
      return this._toggleClass(element, keys, extra, true);
    },

    _toggleClass: function (element, keys, extra, add) {
      add = typeof add === "boolean" ? add : extra;
      var shift = typeof element === "string" || element === null,
        options = {
          extra: shift ? keys : extra,
          keys: shift ? element : keys,
          element: shift ? this.element : element,
          add: add,
        };
      options.element.toggleClass(this._classes(options), add);
      return this;
    },

    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement;
      var instance = this;

      // No suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // No element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }

      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // Allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (
            !suppressDisabledCheck &&
            (instance.options.disabled === true ||
              $(this).hasClass("ui-state-disabled"))
          ) {
            return;
          }
          return (
            typeof handler === "string" ? instance[handler] : handler
          ).apply(instance, arguments);
        }

        // Copy the guid so direct unbinding works
        if (typeof handler !== "string") {
          handlerProxy.guid = handler.guid =
            handler.guid || handlerProxy.guid || $.guid++;
        }

        var match = event.match(/^([\w:-]*)\s*(.*)$/);
        var eventName = match[1] + instance.eventNamespace;
        var selector = match[2];

        if (selector) {
          delegateElement.on(eventName, selector, handlerProxy);
        } else {
          element.on(eventName, handlerProxy);
        }
      });
    },

    _off: function (element, eventName) {
      eventName =
        (eventName || "").split(" ").join(this.eventNamespace + " ") +
        this.eventNamespace;
      element.off(eventName);

      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $(this.bindings.not(element).get());
      this.focusable = $(this.focusable.not(element).get());
      this.hoverable = $(this.hoverable.not(element).get());
    },

    _delay: function (handler, delay) {
      function handlerProxy() {
        return (
          typeof handler === "string" ? instance[handler] : handler
        ).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },

    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          this._addClass($(event.currentTarget), null, "ui-state-hover");
        },
        mouseleave: function (event) {
          this._removeClass($(event.currentTarget), null, "ui-state-hover");
        },
      });
    },

    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          this._addClass($(event.currentTarget), null, "ui-state-focus");
        },
        focusout: function (event) {
          this._removeClass($(event.currentTarget), null, "ui-state-focus");
        },
      });
    },

    _trigger: function (type, event, data) {
      var prop, orig;
      var callback = this.options[type];

      data = data || {};
      event = $.Event(event);
      event.type = (
        type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type
      ).toLowerCase();

      // The original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];

      // Copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }

      this.element.trigger(event, data);
      return !(
        (typeof callback === "function" &&
          callback.apply(this.element[0], [event].concat(data)) === false) ||
        event.isDefaultPrevented()
      );
    },
  };

  $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
    $.Widget.prototype["_" + method] = function (element, options, callback) {
      if (typeof options === "string") {
        options = { effect: options };
      }

      var hasOptions;
      var effectName = !options
        ? method
        : options === true || typeof options === "number"
        ? defaultEffect
        : options.effect || defaultEffect;

      options = options || {};
      if (typeof options === "number") {
        options = { duration: options };
      } else if (options === true) {
        options = {};
      }

      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;

      if (options.delay) {
        element.delay(options.delay);
      }

      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });

  return $.widget;
});

/*!
 * jQuery UI Mouse 1.13.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery", "../ie", "../version", "../widget"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  var mouseHandled = false;
  $(document).on("mouseup", function () {
    mouseHandled = false;
  });

  return $.widget("ui.mouse", {
    version: "1.13.0",
    options: {
      cancel: "input, textarea, button, select, option",
      distance: 1,
      delay: 0,
    },
    _mouseInit: function () {
      var that = this;

      this.element
        .on("mousedown." + this.widgetName, function (event) {
          return that._mouseDown(event);
        })
        .on("click." + this.widgetName, function (event) {
          if (
            true ===
            $.data(event.target, that.widgetName + ".preventClickEvent")
          ) {
            $.removeData(event.target, that.widgetName + ".preventClickEvent");
            event.stopImmediatePropagation();
            return false;
          }
        });

      this.started = false;
    },

    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function () {
      this.element.off("." + this.widgetName);
      if (this._mouseMoveDelegate) {
        this.document
          .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
          .off("mouseup." + this.widgetName, this._mouseUpDelegate);
      }
    },

    _mouseDown: function (event) {
      // don't let more than one widget handle mouseStart
      if (mouseHandled) {
        return;
      }

      this._mouseMoved = false;

      // We may have missed mouseup (out of window)
      if (this._mouseStarted) {
        this._mouseUp(event);
      }

      this._mouseDownEvent = event;

      var that = this,
        btnIsLeft = event.which === 1,
        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel =
          typeof this.options.cancel === "string" && event.target.nodeName
            ? $(event.target).closest(this.options.cancel).length
            : false;
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }

      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function () {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }

      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(event) !== false;
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }

      // Click event may never have fired (Gecko & Opera)
      if (
        true === $.data(event.target, this.widgetName + ".preventClickEvent")
      ) {
        $.removeData(event.target, this.widgetName + ".preventClickEvent");
      }

      // These delegates are required to keep context
      this._mouseMoveDelegate = function (event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function (event) {
        return that._mouseUp(event);
      };

      this.document
        .on("mousemove." + this.widgetName, this._mouseMoveDelegate)
        .on("mouseup." + this.widgetName, this._mouseUpDelegate);

      event.preventDefault();

      mouseHandled = true;
      return true;
    },

    _mouseMove: function (event) {
      // Only check for mouseups outside the document if you've moved inside the document
      // at least once. This prevents the firing of mouseup in the case of IE<9, which will
      // fire a mousemove event if content is placed under the cursor. See #7778
      // Support: IE <9
      if (this._mouseMoved) {
        // IE mouseup check - mouseup happened when mouse was out of window
        if (
          $.ui.ie &&
          (!document.documentMode || document.documentMode < 9) &&
          !event.button
        ) {
          return this._mouseUp(event);

          // Iframe mouseup check - mouseup occurred in another document
        } else if (!event.which) {
          // Support: Safari <=8 - 9
          // Safari sets which to 0 if you press any of the following keys
          // during a drag (#14461)
          if (
            event.originalEvent.altKey ||
            event.originalEvent.ctrlKey ||
            event.originalEvent.metaKey ||
            event.originalEvent.shiftKey
          ) {
            this.ignoreMissingWhich = true;
          } else if (!this.ignoreMissingWhich) {
            return this._mouseUp(event);
          }
        }
      }

      if (event.which || event.button) {
        this._mouseMoved = true;
      }

      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }

      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted =
          this._mouseStart(this._mouseDownEvent, event) !== false;
        if (this._mouseStarted) {
          this._mouseDrag(event);
        } else {
          this._mouseUp(event);
        }
      }

      return !this._mouseStarted;
    },

    _mouseUp: function (event) {
      this.document
        .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
        .off("mouseup." + this.widgetName, this._mouseUpDelegate);

      if (this._mouseStarted) {
        this._mouseStarted = false;

        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + ".preventClickEvent", true);
        }

        this._mouseStop(event);
      }

      if (this._mouseDelayTimer) {
        clearTimeout(this._mouseDelayTimer);
        delete this._mouseDelayTimer;
      }

      this.ignoreMissingWhich = false;
      mouseHandled = false;
      event.preventDefault();
    },

    _mouseDistanceMet: function (event) {
      return (
        Math.max(
          Math.abs(this._mouseDownEvent.pageX - event.pageX),
          Math.abs(this._mouseDownEvent.pageY - event.pageY)
        ) >= this.options.distance
      );
    },

    _mouseDelayMet: function (/* event */) {
      return this.mouseDelayMet;
    },

    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function (/* event */) {},
    _mouseDrag: function (/* event */) {},
    _mouseStop: function (/* event */) {},
    _mouseCapture: function (/* event */) {
      return true;
    },
  });
});

/*!
 * jQuery UI :data 1.13.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery", "./version"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  return $.extend($.expr.pseudos, {
    data: $.expr.createPseudo
      ? $.expr.createPseudo(function (dataName) {
          return function (elem) {
            return !!$.data(elem, dataName);
          };
        })
      : // Support: jQuery <1.8
        function (elem, i, match) {
          return !!$.data(elem, match[3]);
        },
  });
});

/*!
 * jQuery UI Scroll Parent 1.13.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery", "./version"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  return ($.fn.scrollParent = function (includeHidden) {
    var position = this.css("position"),
      excludeStaticParent = position === "absolute",
      overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
      scrollParent = this.parents()
        .filter(function () {
          var parent = $(this);
          if (excludeStaticParent && parent.css("position") === "static") {
            return false;
          }
          return overflowRegex.test(
            parent.css("overflow") +
              parent.css("overflow-y") +
              parent.css("overflow-x")
          );
        })
        .eq(0);

    return position === "fixed" || !scrollParent.length
      ? $(this[0].ownerDocument || document)
      : scrollParent;
  });
});

/*!
 * jQuery UI Sortable 1.13.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Sortable
//>>group: Interactions
//>>description: Enables items in a list to be sorted using the mouse.
//>>docs: http://api.jqueryui.com/sortable/
//>>demos: http://jqueryui.com/sortable/
//>>css.structure: ../../themes/base/sortable.css

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define([
      "jquery",
      "./mouse",
      "../data",
      "../ie",
      "../scroll-parent",
      "../version",
      "../widget",
    ], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  return $.widget("ui.sortable", $.ui.mouse, {
    version: "1.13.0",
    widgetEventPrefix: "sort",
    ready: false,
    options: {
      appendTo: "parent",
      axis: false,
      connectWith: false,
      containment: false,
      cursor: "auto",
      cursorAt: false,
      dropOnEmpty: true,
      forcePlaceholderSize: false,
      forceHelperSize: false,
      grid: false,
      handle: false,
      helper: "original",
      items: "> *",
      opacity: false,
      placeholder: false,
      revert: false,
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: "default",
      tolerance: "intersect",
      zIndex: 1000,

      // Callbacks
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null,
    },

    _isOverAxis: function (x, reference, size) {
      return x >= reference && x < reference + size;
    },

    _isFloating: function (item) {
      return (
        /left|right/.test(item.css("float")) ||
        /inline|table-cell/.test(item.css("display"))
      );
    },

    _create: function () {
      this.containerCache = {};
      this._addClass("ui-sortable");

      //Get the items
      this.refresh();

      //Let's determine the parent's offset
      this.offset = this.element.offset();

      //Initialize mouse events for interaction
      this._mouseInit();

      this._setHandleClassName();

      //We're ready to go
      this.ready = true;
    },

    _setOption: function (key, value) {
      this._super(key, value);

      if (key === "handle") {
        this._setHandleClassName();
      }
    },

    _setHandleClassName: function () {
      var that = this;
      this._removeClass(
        this.element.find(".ui-sortable-handle"),
        "ui-sortable-handle"
      );
      $.each(this.items, function () {
        that._addClass(
          this.instance.options.handle
            ? this.item.find(this.instance.options.handle)
            : this.item,
          "ui-sortable-handle"
        );
      });
    },

    _destroy: function () {
      this._mouseDestroy();

      for (var i = this.items.length - 1; i >= 0; i--) {
        this.items[i].item.removeData(this.widgetName + "-item");
      }

      return this;
    },

    _mouseCapture: function (event, overrideHandle) {
      var currentItem = null,
        validHandle = false,
        that = this;

      if (this.reverting) {
        return false;
      }

      if (this.options.disabled || this.options.type === "static") {
        return false;
      }

      //We have to refresh the items data once first
      this._refreshItems(event);

      //Find out if the clicked node (or one of its parents) is a actual item in this.items
      $(event.target)
        .parents()
        .each(function () {
          if ($.data(this, that.widgetName + "-item") === that) {
            currentItem = $(this);
            return false;
          }
        });
      if ($.data(event.target, that.widgetName + "-item") === that) {
        currentItem = $(event.target);
      }

      if (!currentItem) {
        return false;
      }
      if (this.options.handle && !overrideHandle) {
        $(this.options.handle, currentItem)
          .find("*")
          .addBack()
          .each(function () {
            if (this === event.target) {
              validHandle = true;
            }
          });
        if (!validHandle) {
          return false;
        }
      }

      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;
    },

    _mouseStart: function (event, overrideHandle, noActivation) {
      var i,
        body,
        o = this.options;

      this.currentContainer = this;

      //We only need to call refreshPositions, because the refreshItems call has been moved to
      // mouseCapture
      this.refreshPositions();

      //Prepare the dragged items parent
      this.appendTo = $(
        o.appendTo !== "parent" ? o.appendTo : this.currentItem.parent()
      );

      //Create and append the visible helper
      this.helper = this._createHelper(event);

      //Cache the helper size
      this._cacheHelperProportions();

      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */

      //Cache the margins of the original element
      this._cacheMargins();

      //The element's absolute position on the page minus margins
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left,
      };

      $.extend(this.offset, {
        click: {
          //Where the click happened, relative to the element
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top,
        },

        // This is a relative to absolute position minus the actual position calculation -
        // only used for relative positioned helper
        relative: this._getRelativeOffset(),
      });

      // After we get the helper offset, but before we get the parent offset we can
      // change the helper's position to absolute
      // TODO: Still need to figure out a way to make relative sorting possible
      this.helper.css("position", "absolute");
      this.cssPosition = this.helper.css("position");

      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      if (o.cursorAt) {
        this._adjustOffsetFromHelper(o.cursorAt);
      }

      //Cache the former DOM position
      this.domPosition = {
        prev: this.currentItem.prev()[0],
        parent: this.currentItem.parent()[0],
      };

      // If the helper is not the original, hide the original so it's not playing any role during
      // the drag, won't cause anything bad this way
      if (this.helper[0] !== this.currentItem[0]) {
        this.currentItem.hide();
      }

      //Create the placeholder
      this._createPlaceholder();

      //Get the next scrolling parent
      this.scrollParent = this.placeholder.scrollParent();

      $.extend(this.offset, {
        parent: this._getParentOffset(),
      });

      //Set a containment if given in the options
      if (o.containment) {
        this._setContainment();
      }

      if (o.cursor && o.cursor !== "auto") {
        // cursor option
        body = this.document.find("body");

        // Support: IE
        this.storedCursor = body.css("cursor");
        body.css("cursor", o.cursor);

        this.storedStylesheet = $(
          "<style>*{ cursor: " + o.cursor + " !important; }</style>"
        ).appendTo(body);
      }

      // We need to make sure to grab the zIndex before setting the
      // opacity, because setting the opacity to anything lower than 1
      // causes the zIndex to change from "auto" to 0.
      if (o.zIndex) {
        // zIndex option
        if (this.helper.css("zIndex")) {
          this._storedZIndex = this.helper.css("zIndex");
        }
        this.helper.css("zIndex", o.zIndex);
      }

      if (o.opacity) {
        // opacity option
        if (this.helper.css("opacity")) {
          this._storedOpacity = this.helper.css("opacity");
        }
        this.helper.css("opacity", o.opacity);
      }

      //Prepare scrolling
      if (
        this.scrollParent[0] !== this.document[0] &&
        this.scrollParent[0].tagName !== "HTML"
      ) {
        this.overflowOffset = this.scrollParent.offset();
      }

      //Call callbacks
      this._trigger("start", event, this._uiHash());

      //Recache the helper size
      if (!this._preserveHelperProportions) {
        this._cacheHelperProportions();
      }

      //Post "activate" events to possible containers
      if (!noActivation) {
        for (i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger("activate", event, this._uiHash(this));
        }
      }

      //Prepare possible droppables
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }

      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }

      this.dragging = true;

      this._addClass(this.helper, "ui-sortable-helper");

      //Move the helper, if needed
      if (!this.helper.parent().is(this.appendTo)) {
        this.helper.detach().appendTo(this.appendTo);

        //Update position
        this.offset.parent = this._getParentOffset();
      }

      //Generate the original position
      this.position = this.originalPosition = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      this.lastPositionAbs = this.positionAbs =
        this._convertPositionTo("absolute");

      this._mouseDrag(event);

      return true;
    },

    _scroll: function (event) {
      var o = this.options,
        scrolled = false;

      if (
        this.scrollParent[0] !== this.document[0] &&
        this.scrollParent[0].tagName !== "HTML"
      ) {
        if (
          this.overflowOffset.top +
            this.scrollParent[0].offsetHeight -
            event.pageY <
          o.scrollSensitivity
        ) {
          this.scrollParent[0].scrollTop = scrolled =
            this.scrollParent[0].scrollTop + o.scrollSpeed;
        } else if (
          event.pageY - this.overflowOffset.top <
          o.scrollSensitivity
        ) {
          this.scrollParent[0].scrollTop = scrolled =
            this.scrollParent[0].scrollTop - o.scrollSpeed;
        }

        if (
          this.overflowOffset.left +
            this.scrollParent[0].offsetWidth -
            event.pageX <
          o.scrollSensitivity
        ) {
          this.scrollParent[0].scrollLeft = scrolled =
            this.scrollParent[0].scrollLeft + o.scrollSpeed;
        } else if (
          event.pageX - this.overflowOffset.left <
          o.scrollSensitivity
        ) {
          this.scrollParent[0].scrollLeft = scrolled =
            this.scrollParent[0].scrollLeft - o.scrollSpeed;
        }
      } else {
        if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
          scrolled = this.document.scrollTop(
            this.document.scrollTop() - o.scrollSpeed
          );
        } else if (
          this.window.height() - (event.pageY - this.document.scrollTop()) <
          o.scrollSensitivity
        ) {
          scrolled = this.document.scrollTop(
            this.document.scrollTop() + o.scrollSpeed
          );
        }

        if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
          scrolled = this.document.scrollLeft(
            this.document.scrollLeft() - o.scrollSpeed
          );
        } else if (
          this.window.width() - (event.pageX - this.document.scrollLeft()) <
          o.scrollSensitivity
        ) {
          scrolled = this.document.scrollLeft(
            this.document.scrollLeft() + o.scrollSpeed
          );
        }
      }

      return scrolled;
    },

    _mouseDrag: function (event) {
      var i,
        item,
        itemElement,
        intersection,
        o = this.options;

      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo("absolute");

      //Set the helper position
      if (!this.options.axis || this.options.axis !== "y") {
        this.helper[0].style.left = this.position.left + "px";
      }
      if (!this.options.axis || this.options.axis !== "x") {
        this.helper[0].style.top = this.position.top + "px";
      }

      //Post events to containers
      this._contactContainers(event);

      if (this.innermostContainer !== null) {
        //Do scrolling
        if (o.scroll) {
          if (this._scroll(event) !== false) {
            //Update item positions used in position checks
            this._refreshItemPositions(true);

            if ($.ui.ddmanager && !o.dropBehaviour) {
              $.ui.ddmanager.prepareOffsets(this, event);
            }
          }
        }

        this.dragDirection = {
          vertical: this._getDragVerticalDirection(),
          horizontal: this._getDragHorizontalDirection(),
        };

        //Rearrange
        for (i = this.items.length - 1; i >= 0; i--) {
          //Cache variables and intersection, continue if no intersection
          item = this.items[i];
          itemElement = item.item[0];
          intersection = this._intersectsWithPointer(item);
          if (!intersection) {
            continue;
          }

          // Only put the placeholder inside the current Container, skip all
          // items from other containers. This works because when moving
          // an item from one container to another the
          // currentContainer is switched before the placeholder is moved.
          //
          // Without this, moving items in "sub-sortables" can cause
          // the placeholder to jitter between the outer and inner container.
          if (item.instance !== this.currentContainer) {
            continue;
          }

          // Cannot intersect with itself
          // no useless actions that have been done before
          // no action if the item moved is the parent of the item checked
          if (
            itemElement !== this.currentItem[0] &&
            this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !==
              itemElement &&
            !$.contains(this.placeholder[0], itemElement) &&
            (this.options.type === "semi-dynamic"
              ? !$.contains(this.element[0], itemElement)
              : true)
          ) {
            this.direction = intersection === 1 ? "down" : "up";

            if (
              this.options.tolerance === "pointer" ||
              this._intersectsWithSides(item)
            ) {
              this._rearrange(event, item);
            } else {
              break;
            }

            this._trigger("change", event, this._uiHash());
            break;
          }
        }
      }

      //Interconnect with droppables
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }

      //Call callbacks
      this._trigger("sort", event, this._uiHash());

      this.lastPositionAbs = this.positionAbs;
      return false;
    },

    _mouseStop: function (event, noPropagation) {
      if (!event) {
        return;
      }

      //If we are using droppables, inform the manager about the drop
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        $.ui.ddmanager.drop(this, event);
      }

      if (this.options.revert) {
        var that = this,
          cur = this.placeholder.offset(),
          axis = this.options.axis,
          animation = {};

        if (!axis || axis === "x") {
          animation.left =
            cur.left -
            this.offset.parent.left -
            this.margins.left +
            (this.offsetParent[0] === this.document[0].body
              ? 0
              : this.offsetParent[0].scrollLeft);
        }
        if (!axis || axis === "y") {
          animation.top =
            cur.top -
            this.offset.parent.top -
            this.margins.top +
            (this.offsetParent[0] === this.document[0].body
              ? 0
              : this.offsetParent[0].scrollTop);
        }
        this.reverting = true;
        $(this.helper).animate(
          animation,
          parseInt(this.options.revert, 10) || 500,
          function () {
            that._clear(event);
          }
        );
      } else {
        this._clear(event, noPropagation);
      }

      return false;
    },

    cancel: function () {
      if (this.dragging) {
        this._mouseUp(new $.Event("mouseup", { target: null }));

        if (this.options.helper === "original") {
          this.currentItem.css(this._storedCSS);
          this._removeClass(this.currentItem, "ui-sortable-helper");
        } else {
          this.currentItem.show();
        }

        //Post deactivating events to containers
        for (var i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger("deactivate", null, this._uiHash(this));
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger("out", null, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }

      if (this.placeholder) {
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
        // it unbinds ALL events from the original node!
        if (this.placeholder[0].parentNode) {
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        }
        if (
          this.options.helper !== "original" &&
          this.helper &&
          this.helper[0].parentNode
        ) {
          this.helper.remove();
        }

        $.extend(this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null,
        });

        if (this.domPosition.prev) {
          $(this.domPosition.prev).after(this.currentItem);
        } else {
          $(this.domPosition.parent).prepend(this.currentItem);
        }
      }

      return this;
    },

    serialize: function (o) {
      var items = this._getItemsAsjQuery(o && o.connected),
        str = [];
      o = o || {};

      $(items).each(function () {
        var res = ($(o.item || this).attr(o.attribute || "id") || "").match(
          o.expression || /(.+)[\-=_](.+)/
        );
        if (res) {
          str.push(
            (o.key || res[1] + "[]") +
              "=" +
              (o.key && o.expression ? res[1] : res[2])
          );
        }
      });

      if (!str.length && o.key) {
        str.push(o.key + "=");
      }

      return str.join("&");
    },

    toArray: function (o) {
      var items = this._getItemsAsjQuery(o && o.connected),
        ret = [];

      o = o || {};

      items.each(function () {
        ret.push($(o.item || this).attr(o.attribute || "id") || "");
      });
      return ret;
    },

    /* Be careful with the following core functions */
    _intersectsWith: function (item) {
      var x1 = this.positionAbs.left,
        x2 = x1 + this.helperProportions.width,
        y1 = this.positionAbs.top,
        y2 = y1 + this.helperProportions.height,
        l = item.left,
        r = l + item.width,
        t = item.top,
        b = t + item.height,
        dyClick = this.offset.click.top,
        dxClick = this.offset.click.left,
        isOverElementHeight =
          this.options.axis === "x" || (y1 + dyClick > t && y1 + dyClick < b),
        isOverElementWidth =
          this.options.axis === "y" || (x1 + dxClick > l && x1 + dxClick < r),
        isOverElement = isOverElementHeight && isOverElementWidth;

      if (
        this.options.tolerance === "pointer" ||
        this.options.forcePointerForContainers ||
        (this.options.tolerance !== "pointer" &&
          this.helperProportions[this.floating ? "width" : "height"] >
            item[this.floating ? "width" : "height"])
      ) {
        return isOverElement;
      } else {
        return (
          l < x1 + this.helperProportions.width / 2 && // Right Half
          x2 - this.helperProportions.width / 2 < r && // Left Half
          t < y1 + this.helperProportions.height / 2 && // Bottom Half
          y2 - this.helperProportions.height / 2 < b
        ); // Top Half
      }
    },

    _intersectsWithPointer: function (item) {
      var verticalDirection,
        horizontalDirection,
        isOverElementHeight =
          this.options.axis === "x" ||
          this._isOverAxis(
            this.positionAbs.top + this.offset.click.top,
            item.top,
            item.height
          ),
        isOverElementWidth =
          this.options.axis === "y" ||
          this._isOverAxis(
            this.positionAbs.left + this.offset.click.left,
            item.left,
            item.width
          ),
        isOverElement = isOverElementHeight && isOverElementWidth;

      if (!isOverElement) {
        return false;
      }

      verticalDirection = this.dragDirection.vertical;
      horizontalDirection = this.dragDirection.horizontal;

      return this.floating
        ? horizontalDirection === "right" || verticalDirection === "down"
          ? 2
          : 1
        : verticalDirection && (verticalDirection === "down" ? 2 : 1);
    },

    _intersectsWithSides: function (item) {
      var isOverBottomHalf = this._isOverAxis(
          this.positionAbs.top + this.offset.click.top,
          item.top + item.height / 2,
          item.height
        ),
        isOverRightHalf = this._isOverAxis(
          this.positionAbs.left + this.offset.click.left,
          item.left + item.width / 2,
          item.width
        ),
        verticalDirection = this.dragDirection.vertical,
        horizontalDirection = this.dragDirection.horizontal;

      if (this.floating && horizontalDirection) {
        return (
          (horizontalDirection === "right" && isOverRightHalf) ||
          (horizontalDirection === "left" && !isOverRightHalf)
        );
      } else {
        return (
          verticalDirection &&
          ((verticalDirection === "down" && isOverBottomHalf) ||
            (verticalDirection === "up" && !isOverBottomHalf))
        );
      }
    },

    _getDragVerticalDirection: function () {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta !== 0 && (delta > 0 ? "down" : "up");
    },

    _getDragHorizontalDirection: function () {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta !== 0 && (delta > 0 ? "right" : "left");
    },

    refresh: function (event) {
      this._refreshItems(event);
      this._setHandleClassName();
      this.refreshPositions();
      return this;
    },

    _connectWith: function () {
      var options = this.options;
      return options.connectWith.constructor === String
        ? [options.connectWith]
        : options.connectWith;
    },

    _getItemsAsjQuery: function (connected) {
      var i,
        j,
        cur,
        inst,
        items = [],
        queries = [],
        connectWith = this._connectWith();

      if (connectWith && connected) {
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i], this.document[0]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                typeof inst.options.items === "function"
                  ? inst.options.items.call(inst.element)
                  : $(inst.options.items, inst.element)
                      .not(".ui-sortable-helper")
                      .not(".ui-sortable-placeholder"),
                inst,
              ]);
            }
          }
        }
      }

      queries.push([
        typeof this.options.items === "function"
          ? this.options.items.call(this.element, null, {
              options: this.options,
              item: this.currentItem,
            })
          : $(this.options.items, this.element)
              .not(".ui-sortable-helper")
              .not(".ui-sortable-placeholder"),
        this,
      ]);

      function addItems() {
        items.push(this);
      }
      for (i = queries.length - 1; i >= 0; i--) {
        queries[i][0].each(addItems);
      }

      return $(items);
    },

    _removeCurrentsFromItems: function () {
      var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

      this.items = $.grep(this.items, function (item) {
        for (var j = 0; j < list.length; j++) {
          if (list[j] === item.item[0]) {
            return false;
          }
        }
        return true;
      });
    },

    _refreshItems: function (event) {
      this.items = [];
      this.containers = [this];

      var i,
        j,
        cur,
        inst,
        targetData,
        _queries,
        item,
        queriesLength,
        items = this.items,
        queries = [
          [
            typeof this.options.items === "function"
              ? this.options.items.call(this.element[0], event, {
                  item: this.currentItem,
                })
              : $(this.options.items, this.element),
            this,
          ],
        ],
        connectWith = this._connectWith();

      //Shouldn't be run the first time through due to massive slow-down
      if (connectWith && this.ready) {
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i], this.document[0]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                typeof inst.options.items === "function"
                  ? inst.options.items.call(inst.element[0], event, {
                      item: this.currentItem,
                    })
                  : $(inst.options.items, inst.element),
                inst,
              ]);
              this.containers.push(inst);
            }
          }
        }
      }

      for (i = queries.length - 1; i >= 0; i--) {
        targetData = queries[i][1];
        _queries = queries[i][0];

        for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
          item = $(_queries[j]);

          // Data for target checking (mouse manager)
          item.data(this.widgetName + "-item", targetData);

          items.push({
            item: item,
            instance: targetData,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
          });
        }
      }
    },

    _refreshItemPositions: function (fast) {
      var i, item, t, p;

      for (i = this.items.length - 1; i >= 0; i--) {
        item = this.items[i];

        //We ignore calculating positions of all connected containers when we're not over them
        if (
          this.currentContainer &&
          item.instance !== this.currentContainer &&
          item.item[0] !== this.currentItem[0]
        ) {
          continue;
        }

        t = this.options.toleranceElement
          ? $(this.options.toleranceElement, item.item)
          : item.item;

        if (!fast) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }

        p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }
    },

    refreshPositions: function (fast) {
      // Determine whether items are being displayed horizontally
      this.floating = this.items.length
        ? this.options.axis === "x" || this._isFloating(this.items[0].item)
        : false;

      if (this.innermostContainer !== null) {
        this._refreshItemPositions(fast);
      }

      var i, p;

      if (this.options.custom && this.options.custom.refreshContainers) {
        this.options.custom.refreshContainers.call(this);
      } else {
        for (i = this.containers.length - 1; i >= 0; i--) {
          p = this.containers[i].element.offset();
          this.containers[i].containerCache.left = p.left;
          this.containers[i].containerCache.top = p.top;
          this.containers[i].containerCache.width =
            this.containers[i].element.outerWidth();
          this.containers[i].containerCache.height =
            this.containers[i].element.outerHeight();
        }
      }

      return this;
    },

    _createPlaceholder: function (that) {
      that = that || this;
      var className,
        nodeName,
        o = that.options;

      if (!o.placeholder || o.placeholder.constructor === String) {
        className = o.placeholder;
        nodeName = that.currentItem[0].nodeName.toLowerCase();
        o.placeholder = {
          element: function () {
            var element = $("<" + nodeName + ">", that.document[0]);

            that
              ._addClass(
                element,
                "ui-sortable-placeholder",
                className || that.currentItem[0].className
              )
              ._removeClass(element, "ui-sortable-helper");

            if (nodeName === "tbody") {
              that._createTrPlaceholder(
                that.currentItem.find("tr").eq(0),
                $("<tr>", that.document[0]).appendTo(element)
              );
            } else if (nodeName === "tr") {
              that._createTrPlaceholder(that.currentItem, element);
            } else if (nodeName === "img") {
              element.attr("src", that.currentItem.attr("src"));
            }

            if (!className) {
              element.css("visibility", "hidden");
            }

            return element;
          },
          update: function (container, p) {
            // 1. If a className is set as 'placeholder option, we don't force sizes -
            // the class is responsible for that
            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
            // class name is specified
            if (className && !o.forcePlaceholderSize) {
              return;
            }

            // If the element doesn't have a actual height or width by itself (without
            // styles coming from a stylesheet), it receives the inline height and width
            // from the dragged item. Or, if it's a tbody or tr, it's going to have a height
            // anyway since we're populating them with <td>s above, but they're unlikely to
            // be the correct height on their own if the row heights are dynamic, so we'll
            // always assign the height of the dragged item given forcePlaceholderSize
            // is true.
            if (
              !p.height() ||
              (o.forcePlaceholderSize &&
                (nodeName === "tbody" || nodeName === "tr"))
            ) {
              p.height(
                that.currentItem.innerHeight() -
                  parseInt(that.currentItem.css("paddingTop") || 0, 10) -
                  parseInt(that.currentItem.css("paddingBottom") || 0, 10)
              );
            }
            if (!p.width()) {
              p.width(
                that.currentItem.innerWidth() -
                  parseInt(that.currentItem.css("paddingLeft") || 0, 10) -
                  parseInt(that.currentItem.css("paddingRight") || 0, 10)
              );
            }
          },
        };
      }

      //Create the placeholder
      that.placeholder = $(
        o.placeholder.element.call(that.element, that.currentItem)
      );

      //Append it after the actual current item
      that.currentItem.after(that.placeholder);

      //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
      o.placeholder.update(that, that.placeholder);
    },

    _createTrPlaceholder: function (sourceTr, targetTr) {
      var that = this;

      sourceTr.children().each(function () {
        $("<td>&#160;</td>", that.document[0])
          .attr("colspan", $(this).attr("colspan") || 1)
          .appendTo(targetTr);
      });
    },

    _contactContainers: function (event) {
      var i,
        j,
        dist,
        itemWithLeastDistance,
        posProperty,
        sizeProperty,
        cur,
        nearBottom,
        floating,
        axis,
        innermostContainer = null,
        innermostIndex = null;

      // Get innermost container that intersects with item
      for (i = this.containers.length - 1; i >= 0; i--) {
        // Never consider a container that's located within the item itself
        if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
          continue;
        }

        if (this._intersectsWith(this.containers[i].containerCache)) {
          // If we've already found a container and it's more "inner" than this, then continue
          if (
            innermostContainer &&
            $.contains(
              this.containers[i].element[0],
              innermostContainer.element[0]
            )
          ) {
            continue;
          }

          innermostContainer = this.containers[i];
          innermostIndex = i;
        } else {
          // container doesn't intersect. trigger "out" event if necessary
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger("out", event, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }

      this.innermostContainer = innermostContainer;

      // If no intersecting containers found, return
      if (!innermostContainer) {
        return;
      }

      // Move the item into the container if it's not there already
      if (this.containers.length === 1) {
        if (!this.containers[innermostIndex].containerCache.over) {
          this.containers[innermostIndex]._trigger(
            "over",
            event,
            this._uiHash(this)
          );
          this.containers[innermostIndex].containerCache.over = 1;
        }
      } else {
        // When entering a new container, we will find the item with the least distance and
        // append our item near it
        dist = 10000;
        itemWithLeastDistance = null;
        floating =
          innermostContainer.floating || this._isFloating(this.currentItem);
        posProperty = floating ? "left" : "top";
        sizeProperty = floating ? "width" : "height";
        axis = floating ? "pageX" : "pageY";

        for (j = this.items.length - 1; j >= 0; j--) {
          if (
            !$.contains(
              this.containers[innermostIndex].element[0],
              this.items[j].item[0]
            )
          ) {
            continue;
          }
          if (this.items[j].item[0] === this.currentItem[0]) {
            continue;
          }

          cur = this.items[j].item.offset()[posProperty];
          nearBottom = false;
          if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
            nearBottom = true;
          }

          if (Math.abs(event[axis] - cur) < dist) {
            dist = Math.abs(event[axis] - cur);
            itemWithLeastDistance = this.items[j];
            this.direction = nearBottom ? "up" : "down";
          }
        }

        //Check if dropOnEmpty is enabled
        if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
          return;
        }

        if (this.currentContainer === this.containers[innermostIndex]) {
          if (!this.currentContainer.containerCache.over) {
            this.containers[innermostIndex]._trigger(
              "over",
              event,
              this._uiHash()
            );
            this.currentContainer.containerCache.over = 1;
          }
          return;
        }

        if (itemWithLeastDistance) {
          this._rearrange(event, itemWithLeastDistance, null, true);
        } else {
          this._rearrange(
            event,
            null,
            this.containers[innermostIndex].element,
            true
          );
        }
        this._trigger("change", event, this._uiHash());
        this.containers[innermostIndex]._trigger(
          "change",
          event,
          this._uiHash(this)
        );
        this.currentContainer = this.containers[innermostIndex];

        //Update the placeholder
        this.options.placeholder.update(
          this.currentContainer,
          this.placeholder
        );

        //Update scrollParent
        this.scrollParent = this.placeholder.scrollParent();

        //Update overflowOffset
        if (
          this.scrollParent[0] !== this.document[0] &&
          this.scrollParent[0].tagName !== "HTML"
        ) {
          this.overflowOffset = this.scrollParent.offset();
        }

        this.containers[innermostIndex]._trigger(
          "over",
          event,
          this._uiHash(this)
        );
        this.containers[innermostIndex].containerCache.over = 1;
      }
    },

    _createHelper: function (event) {
      var o = this.options,
        helper =
          typeof o.helper === "function"
            ? $(o.helper.apply(this.element[0], [event, this.currentItem]))
            : o.helper === "clone"
            ? this.currentItem.clone()
            : this.currentItem;

      //Add the helper to the DOM if that didn't happen already
      if (!helper.parents("body").length) {
        this.appendTo[0].appendChild(helper[0]);
      }

      if (helper[0] === this.currentItem[0]) {
        this._storedCSS = {
          width: this.currentItem[0].style.width,
          height: this.currentItem[0].style.height,
          position: this.currentItem.css("position"),
          top: this.currentItem.css("top"),
          left: this.currentItem.css("left"),
        };
      }

      if (!helper[0].style.width || o.forceHelperSize) {
        helper.width(this.currentItem.width());
      }
      if (!helper[0].style.height || o.forceHelperSize) {
        helper.height(this.currentItem.height());
      }

      return helper;
    },

    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === "string") {
        obj = obj.split(" ");
      }
      if (Array.isArray(obj)) {
        obj = { left: +obj[0], top: +obj[1] || 0 };
      }
      if ("left" in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ("right" in obj) {
        this.offset.click.left =
          this.helperProportions.width - obj.right + this.margins.left;
      }
      if ("top" in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ("bottom" in obj) {
        this.offset.click.top =
          this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },

    _getParentOffset: function () {
      //Get the offsetParent and cache its position
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();

      // This is a special case where we need to modify a offset calculated on start, since the
      // following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the
      // next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
      // the document, which means that the scroll is included in the initial calculation of the
      // offset of the parent, and never recalculated upon drag
      if (
        this.cssPosition === "absolute" &&
        this.scrollParent[0] !== this.document[0] &&
        $.contains(this.scrollParent[0], this.offsetParent[0])
      ) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }

      // This needs to be actually done for all browsers, since pageX/pageY includes this
      // information with an ugly IE fix
      if (
        this.offsetParent[0] === this.document[0].body ||
        (this.offsetParent[0].tagName &&
          this.offsetParent[0].tagName.toLowerCase() === "html" &&
          $.ui.ie)
      ) {
        po = { top: 0, left: 0 };
      }

      return {
        top:
          po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left:
          po.left +
          (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0),
      };
    },

    _getRelativeOffset: function () {
      if (this.cssPosition === "relative") {
        var p = this.currentItem.position();
        return {
          top:
            p.top -
            (parseInt(this.helper.css("top"), 10) || 0) +
            this.scrollParent.scrollTop(),
          left:
            p.left -
            (parseInt(this.helper.css("left"), 10) || 0) +
            this.scrollParent.scrollLeft(),
        };
      } else {
        return { top: 0, left: 0 };
      }
    },

    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
        top: parseInt(this.currentItem.css("marginTop"), 10) || 0,
      };
    },

    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight(),
      };
    },

    _setContainment: function () {
      var ce,
        co,
        over,
        o = this.options;
      if (o.containment === "parent") {
        o.containment = this.helper[0].parentNode;
      }
      if (o.containment === "document" || o.containment === "window") {
        this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          o.containment === "document"
            ? this.document.width()
            : this.window.width() -
              this.helperProportions.width -
              this.margins.left,
          (o.containment === "document"
            ? this.document.height() || document.body.parentNode.scrollHeight
            : this.window.height() ||
              this.document[0].body.parentNode.scrollHeight) -
            this.helperProportions.height -
            this.margins.top,
        ];
      }

      if (!/^(document|window|parent)$/.test(o.containment)) {
        ce = $(o.containment)[0];
        co = $(o.containment).offset();
        over = $(ce).css("overflow") !== "hidden";

        this.containment = [
          co.left +
            (parseInt($(ce).css("borderLeftWidth"), 10) || 0) +
            (parseInt($(ce).css("paddingLeft"), 10) || 0) -
            this.margins.left,
          co.top +
            (parseInt($(ce).css("borderTopWidth"), 10) || 0) +
            (parseInt($(ce).css("paddingTop"), 10) || 0) -
            this.margins.top,
          co.left +
            (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -
            (parseInt($(ce).css("borderLeftWidth"), 10) || 0) -
            (parseInt($(ce).css("paddingRight"), 10) || 0) -
            this.helperProportions.width -
            this.margins.left,
          co.top +
            (over
              ? Math.max(ce.scrollHeight, ce.offsetHeight)
              : ce.offsetHeight) -
            (parseInt($(ce).css("borderTopWidth"), 10) || 0) -
            (parseInt($(ce).css("paddingBottom"), 10) || 0) -
            this.helperProportions.height -
            this.margins.top,
        ];
      }
    },

    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === "absolute" ? 1 : -1,
        scroll =
          this.cssPosition === "absolute" &&
          !(
            this.scrollParent[0] !== this.document[0] &&
            $.contains(this.scrollParent[0], this.offsetParent[0])
          )
            ? this.offsetParent
            : this.scrollParent,
        scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

      return {
        top:
          // The absolute mouse position
          pos.top +
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.top * mod +
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.top * mod -
          (this.cssPosition === "fixed"
            ? -this.scrollParent.scrollTop()
            : scrollIsRootNode
            ? 0
            : scroll.scrollTop()) *
            mod,
        left:
          // The absolute mouse position
          pos.left +
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.left * mod +
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.left * mod -
          (this.cssPosition === "fixed"
            ? -this.scrollParent.scrollLeft()
            : scrollIsRootNode
            ? 0
            : scroll.scrollLeft()) *
            mod,
      };
    },

    _generatePosition: function (event) {
      var top,
        left,
        o = this.options,
        pageX = event.pageX,
        pageY = event.pageY,
        scroll =
          this.cssPosition === "absolute" &&
          !(
            this.scrollParent[0] !== this.document[0] &&
            $.contains(this.scrollParent[0], this.offsetParent[0])
          )
            ? this.offsetParent
            : this.scrollParent,
        scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

      // This is another very weird special case that only happens for relative elements:
      // 1. If the css position is relative
      // 2. and the scroll parent is the document or similar to the offset parent
      // we have to refresh the relative offset during the scroll so there are no jumps
      if (
        this.cssPosition === "relative" &&
        !(
          this.scrollParent[0] !== this.document[0] &&
          this.scrollParent[0] !== this.offsetParent[0]
        )
      ) {
        this.offset.relative = this._getRelativeOffset();
      }

      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */

      if (this.originalPosition) {
        //If we are not dragging yet, we won't check for options

        if (this.containment) {
          if (event.pageX - this.offset.click.left < this.containment[0]) {
            pageX = this.containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < this.containment[1]) {
            pageY = this.containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > this.containment[2]) {
            pageX = this.containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > this.containment[3]) {
            pageY = this.containment[3] + this.offset.click.top;
          }
        }

        if (o.grid) {
          top =
            this.originalPageY +
            Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
          pageY = this.containment
            ? top - this.offset.click.top >= this.containment[1] &&
              top - this.offset.click.top <= this.containment[3]
              ? top
              : top - this.offset.click.top >= this.containment[1]
              ? top - o.grid[1]
              : top + o.grid[1]
            : top;

          left =
            this.originalPageX +
            Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
          pageX = this.containment
            ? left - this.offset.click.left >= this.containment[0] &&
              left - this.offset.click.left <= this.containment[2]
              ? left
              : left - this.offset.click.left >= this.containment[0]
              ? left - o.grid[0]
              : left + o.grid[0]
            : left;
        }
      }

      return {
        top:
          // The absolute mouse position
          pageY -
          // Click offset (relative to the element)
          this.offset.click.top -
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.top -
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.top +
          (this.cssPosition === "fixed"
            ? -this.scrollParent.scrollTop()
            : scrollIsRootNode
            ? 0
            : scroll.scrollTop()),
        left:
          // The absolute mouse position
          pageX -
          // Click offset (relative to the element)
          this.offset.click.left -
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.left -
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.left +
          (this.cssPosition === "fixed"
            ? -this.scrollParent.scrollLeft()
            : scrollIsRootNode
            ? 0
            : scroll.scrollLeft()),
      };
    },

    _rearrange: function (event, i, a, hardRefresh) {
      if (a) {
        a[0].appendChild(this.placeholder[0]);
      } else {
        i.item[0].parentNode.insertBefore(
          this.placeholder[0],
          this.direction === "down" ? i.item[0] : i.item[0].nextSibling
        );
      }

      //Various things done here to improve the performance:
      // 1. we create a setTimeout, that calls refreshPositions
      // 2. on the instance, we have a counter variable, that get's higher after every append
      // 3. on the local scope, we copy the counter variable, and check in the timeout,
      // if it's still the same
      // 4. this lets only the last addition to the timeout stack through
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;

      this._delay(function () {
        if (counter === this.counter) {
          //Precompute after each DOM insertion, NOT on mousemove
          this.refreshPositions(!hardRefresh);
        }
      });
    },

    _clear: function (event, noPropagation) {
      this.reverting = false;

      // We delay all events that have to be triggered to after the point where the placeholder
      // has been removed and everything else normalized again
      var i,
        delayedTriggers = [];

      // We first have to update the dom position of the actual currentItem
      // Note: don't do it if the current item is already removed (by a user), or it gets
      // reappended (see #4088)
      if (!this._noFinalSort && this.currentItem.parent().length) {
        this.placeholder.before(this.currentItem);
      }
      this._noFinalSort = null;

      if (this.helper[0] === this.currentItem[0]) {
        for (i in this._storedCSS) {
          if (
            this._storedCSS[i] === "auto" ||
            this._storedCSS[i] === "static"
          ) {
            this._storedCSS[i] = "";
          }
        }
        this.currentItem.css(this._storedCSS);
        this._removeClass(this.currentItem, "ui-sortable-helper");
      } else {
        this.currentItem.show();
      }

      if (this.fromOutside && !noPropagation) {
        delayedTriggers.push(function (event) {
          this._trigger("receive", event, this._uiHash(this.fromOutside));
        });
      }
      if (
        (this.fromOutside ||
          this.domPosition.prev !==
            this.currentItem.prev().not(".ui-sortable-helper")[0] ||
          this.domPosition.parent !== this.currentItem.parent()[0]) &&
        !noPropagation
      ) {
        // Trigger update callback if the DOM position has changed
        delayedTriggers.push(function (event) {
          this._trigger("update", event, this._uiHash());
        });
      }

      // Check if the items Container has Changed and trigger appropriate
      // events.
      if (this !== this.currentContainer) {
        if (!noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger("remove", event, this._uiHash());
          });
          delayedTriggers.push(
            function (c) {
              return function (event) {
                c._trigger("receive", event, this._uiHash(this));
              };
            }.call(this, this.currentContainer)
          );
          delayedTriggers.push(
            function (c) {
              return function (event) {
                c._trigger("update", event, this._uiHash(this));
              };
            }.call(this, this.currentContainer)
          );
        }
      }

      //Post events to containers
      function delayEvent(type, instance, container) {
        return function (event) {
          container._trigger(type, event, instance._uiHash(instance));
        };
      }
      for (i = this.containers.length - 1; i >= 0; i--) {
        if (!noPropagation) {
          delayedTriggers.push(
            delayEvent("deactivate", this, this.containers[i])
          );
        }
        if (this.containers[i].containerCache.over) {
          delayedTriggers.push(delayEvent("out", this, this.containers[i]));
          this.containers[i].containerCache.over = 0;
        }
      }

      //Do what was originally in plugins
      if (this.storedCursor) {
        this.document.find("body").css("cursor", this.storedCursor);
        this.storedStylesheet.remove();
      }
      if (this._storedOpacity) {
        this.helper.css("opacity", this._storedOpacity);
      }
      if (this._storedZIndex) {
        this.helper.css(
          "zIndex",
          this._storedZIndex === "auto" ? "" : this._storedZIndex
        );
      }

      this.dragging = false;

      if (!noPropagation) {
        this._trigger("beforeStop", event, this._uiHash());
      }

      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
      // it unbinds ALL events from the original node!
      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

      if (!this.cancelHelperRemoval) {
        if (this.helper[0] !== this.currentItem[0]) {
          this.helper.remove();
        }
        this.helper = null;
      }

      if (!noPropagation) {
        for (i = 0; i < delayedTriggers.length; i++) {
          // Trigger all delayed events
          delayedTriggers[i].call(this, event);
        }
        this._trigger("stop", event, this._uiHash());
      }

      this.fromOutside = false;
      return !this.cancelHelperRemoval;
    },

    _trigger: function () {
      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
        this.cancel();
      }
    },

    _uiHash: function (_inst) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $([]),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null,
      };
    },
  });
});
(function ($) {
  $.fn.railsSortable = function (options) {
    options = options || {};
    var settings = $.extend({}, options);

    settings.baseUrl = settings.baseUrl || "";

    settings.update = function (event, ui) {
      if (typeof options.update === "function") {
        options.update(event, ui);
      }

      $.ajax({
        type: "POST",
        url: settings.baseUrl + "/sortable/reorder",
        dataType: "json",
        contentType: "application/json",
        data: JSON.stringify({
          rails_sortable: $(this).sortable("toArray"),
        }),
      });
    };

    this.sortable(settings);
  };
})(jQuery);
/* @preserve
 * Leaflet 1.9.4+v1.d15112c, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports)
    : typeof define === "function" && define.amd
    ? define(["exports"], factory)
    : ((global =
        typeof globalThis !== "undefined" ? globalThis : global || self),
      factory((global.leaflet = {})));
})(this, function (exports) {
  "use strict";

  var version = "1.9.4";

  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */

  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
  function extend(dest) {
    var i, j, len, src;

    for (j = 1, len = arguments.length; j < len; j++) {
      src = arguments[j];
      for (i in src) {
        dest[i] = src[i];
      }
    }
    return dest;
  }

  // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  var create$2 =
    Object.create ||
    (function () {
      function F() {}
      return function (proto) {
        F.prototype = proto;
        return new F();
      };
    })();

  // @function bind(fn: Function, â¦): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.
  function bind(fn, obj) {
    var slice = Array.prototype.slice;

    if (fn.bind) {
      return fn.bind.apply(fn, slice.call(arguments, 1));
    }

    var args = slice.call(arguments, 2);

    return function () {
      return fn.apply(
        obj,
        args.length ? args.concat(slice.call(arguments)) : arguments
      );
    };
  }

  // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)
  var lastId = 0;

  // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.
  function stamp(obj) {
    if (!("_leaflet_id" in obj)) {
      obj["_leaflet_id"] = ++lastId;
    }
    return obj._leaflet_id;
  }

  // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.
  function throttle(fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
      // reset lock and call if queued
      lock = false;
      if (args) {
        wrapperFn.apply(context, args);
        args = false;
      }
    };

    wrapperFn = function () {
      if (lock) {
        // called too soon, queue to call later
        args = arguments;
      } else {
        // call and lock until later
        fn.apply(context, arguments);
        setTimeout(later, time);
        lock = true;
      }
    };

    return wrapperFn;
  }

  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.
  function wrapNum(x, range, includeMax) {
    var max = range[1],
      min = range[0],
      d = max - min;
    return x === max && includeMax ? x : ((((x - min) % d) + d) % d) + min;
  }

  // @function falseFn(): Function
  // Returns a function which always returns `false`.
  function falseFn() {
    return false;
  }

  // @function formatNum(num: Number, precision?: Number|false): Number
  // Returns the number `num` rounded with specified `precision`.
  // The default `precision` value is 6 decimal places.
  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).
  function formatNum(num, precision) {
    if (precision === false) {
      return num;
    }
    var pow = Math.pow(10, precision === undefined ? 6 : precision);
    return Math.round(num * pow) / pow;
  }

  // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }

  // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.
  function splitWords(str) {
    return trim(str).split(/\s+/);
  }

  // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
  function setOptions(obj, options) {
    if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
      obj.options = obj.options ? create$2(obj.options) : {};
    }
    for (var i in options) {
      obj.options[i] = options[i];
    }
    return obj.options;
  }

  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
    var params = [];
    for (var i in obj) {
      params.push(
        encodeURIComponent(uppercase ? i.toUpperCase() : i) +
          "=" +
          encodeURIComponent(obj[i])
      );
    }
    return (
      (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") +
      params.join("&")
    );
  }

  var templateRe = /\{ *([\w_ -]+) *\}/g;

  // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values â they will be evaluated passing `data` as an argument.
  function template(str, data) {
    return str.replace(templateRe, function (str, key) {
      var value = data[key];

      if (value === undefined) {
        throw new Error("No value provided for variable " + str);
      } else if (typeof value === "function") {
        value = value(data);
      }
      return value;
    });
  }

  // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  var isArray =
    Array.isArray ||
    function (obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };

  // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  function indexOf(array, el) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === el) {
        return i;
      }
    }
    return -1;
  }

  // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).
  var emptyImageUrl =
    "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
    return (
      window["webkit" + name] || window["moz" + name] || window["ms" + name]
    );
  }

  var lastTime = 0;

  // fallback for IE 7-8
  function timeoutDefer(fn) {
    var time = +new Date(),
      timeToCall = Math.max(0, 16 - (time - lastTime));

    lastTime = time + timeToCall;
    return window.setTimeout(fn, timeToCall);
  }

  var requestFn =
    window.requestAnimationFrame ||
    getPrefixed("RequestAnimationFrame") ||
    timeoutDefer;
  var cancelFn =
    window.cancelAnimationFrame ||
    getPrefixed("CancelAnimationFrame") ||
    getPrefixed("CancelRequestAnimationFrame") ||
    function (id) {
      window.clearTimeout(id);
    };

  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
  function requestAnimFrame(fn, context, immediate) {
    if (immediate && requestFn === timeoutDefer) {
      fn.call(context);
    } else {
      return requestFn.call(window, bind(fn, context));
    }
  }

  // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
  function cancelAnimFrame(id) {
    if (id) {
      cancelFn.call(window, id);
    }
  }

  var Util = {
    __proto__: null,
    extend: extend,
    create: create$2,
    bind: bind,
    get lastId() {
      return lastId;
    },
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame,
  };

  // @class Class
  // @aka L.Class

  // @section
  // @uninheritable

  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {
    // @function extend(props: Object): Function
    // [Extends the current class](#class-inheritance) given the properties to be included.
    // Returns a Javascript function that is a class constructor (to be called with `new`).
    var NewClass = function () {
      setOptions(this);

      // call the constructor
      if (this.initialize) {
        this.initialize.apply(this, arguments);
      }

      // call all constructor hooks
      this.callInitHooks();
    };

    var parentProto = (NewClass.__super__ = this.prototype);

    var proto = create$2(parentProto);
    proto.constructor = NewClass;

    NewClass.prototype = proto;

    // inherit parent's statics
    for (var i in this) {
      if (
        Object.prototype.hasOwnProperty.call(this, i) &&
        i !== "prototype" &&
        i !== "__super__"
      ) {
        NewClass[i] = this[i];
      }
    }

    // mix static properties into the class
    if (props.statics) {
      extend(NewClass, props.statics);
    }

    // mix includes into the prototype
    if (props.includes) {
      checkDeprecatedMixinEvents(props.includes);
      extend.apply(null, [proto].concat(props.includes));
    }

    // mix given properties into the prototype
    extend(proto, props);
    delete proto.statics;
    delete proto.includes;

    // merge options
    if (proto.options) {
      proto.options = parentProto.options ? create$2(parentProto.options) : {};
      extend(proto.options, props.options);
    }

    proto._initHooks = [];

    // add method for calling all hooks
    proto.callInitHooks = function () {
      if (this._initHooksCalled) {
        return;
      }

      if (parentProto.callInitHooks) {
        parentProto.callInitHooks.call(this);
      }

      this._initHooksCalled = true;

      for (var i = 0, len = proto._initHooks.length; i < len; i++) {
        proto._initHooks[i].call(this);
      }
    };

    return NewClass;
  };

  // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.
  Class.include = function (props) {
    var parentOptions = this.prototype.options;
    extend(this.prototype, props);
    if (props.options) {
      this.prototype.options = parentOptions;
      this.mergeOptions(props.options);
    }
    return this;
  };

  // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.
  Class.mergeOptions = function (options) {
    extend(this.prototype.options, options);
    return this;
  };

  // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.
  Class.addInitHook = function (fn) {
    // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);

    var init =
      typeof fn === "function"
        ? fn
        : function () {
            this[fn].apply(this, args);
          };

    this.prototype._initHooks = this.prototype._initHooks || [];
    this.prototype._initHooks.push(init);
    return this;
  };

  function checkDeprecatedMixinEvents(includes) {
    /* global L: true */
    if (typeof L === "undefined" || !L || !L.Mixin) {
      return;
    }

    includes = isArray(includes) ? includes : [includes];

    for (var i = 0; i < includes.length; i++) {
      if (includes[i] === L.Mixin.Events) {
        console.warn(
          "Deprecated include of L.Mixin.Events: " +
            "this property will be removed in future releases, " +
            "please inherit from L.Evented instead.",
          new Error().stack
        );
      }
    }
  }

  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */

  var Events = {
    /* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */
    on: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === "object") {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      }

      return this;
    },

    /* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object. This includes implicitly attached events.
     */
    off: function (types, fn, context) {
      if (!arguments.length) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (typeof types === "object") {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        var removeAll = arguments.length === 1;
        for (var i = 0, len = types.length; i < len; i++) {
          if (removeAll) {
            this._off(types[i]);
          } else {
            this._off(types[i], fn, context);
          }
        }
      }

      return this;
    },

    // attach listener (without syntactic sugar now)
    _on: function (type, fn, context, _once) {
      if (typeof fn !== "function") {
        console.warn("wrong listener type: " + typeof fn);
        return;
      }

      // check if fn already there
      if (this._listens(type, fn, context) !== false) {
        return;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }

      var newListener = { fn: fn, ctx: context };
      if (_once) {
        newListener.once = true;
      }

      this._events = this._events || {};
      this._events[type] = this._events[type] || [];
      this._events[type].push(newListener);
    },

    _off: function (type, fn, context) {
      var listeners, i, len;

      if (!this._events) {
        return;
      }

      listeners = this._events[type];
      if (!listeners) {
        return;
      }

      if (arguments.length === 1) {
        // remove all
        if (this._firingCount) {
          // Set all removed listeners to noop
          // so they are not called if remove happens in fire
          for (i = 0, len = listeners.length; i < len; i++) {
            listeners[i].fn = falseFn;
          }
        }
        // clear all listeners for a type if function isn't specified
        delete this._events[type];
        return;
      }

      if (typeof fn !== "function") {
        console.warn("wrong listener type: " + typeof fn);
        return;
      }

      // find fn and remove it
      var index = this._listens(type, fn, context);
      if (index !== false) {
        var listener = listeners[index];
        if (this._firingCount) {
          // set the removed listener to noop so that's not called if remove happens in fire
          listener.fn = falseFn;

          /* copy array in case events are being fired */
          this._events[type] = listeners = listeners.slice();
        }
        listeners.splice(index, 1);
      }
    },

    // @method fire(type: String, data?: Object, propagate?: Boolean): this
    // Fires an event of the specified type. You can optionally provide a data
    // object â the first argument of the listener function will contain its
    // properties. The event can optionally be propagated to event parents.
    fire: function (type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }

      var event = extend({}, data, {
        type: type,
        target: this,
        sourceTarget: (data && data.sourceTarget) || this,
      });

      if (this._events) {
        var listeners = this._events[type];
        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;
          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            // off overwrites l.fn, so we need to copy fn to a var
            var fn = l.fn;
            if (l.once) {
              this.off(type, fn, l.ctx);
            }
            fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }

      return this;
    },

    // @method listens(type: String, propagate?: Boolean): Boolean
    // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
    // Returns `true` if a particular event type has any listeners attached to it.
    // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
    listens: function (type, fn, context, propagate) {
      if (typeof type !== "string") {
        console.warn('"string" type argument expected');
      }

      // we don't overwrite the input `fn` value, because we need to use it for propagation
      var _fn = fn;
      if (typeof fn !== "function") {
        propagate = !!fn;
        _fn = undefined;
        context = undefined;
      }

      var listeners = this._events && this._events[type];
      if (listeners && listeners.length) {
        if (this._listens(type, _fn, context) !== false) {
          return true;
        }
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, fn, context, propagate)) {
            return true;
          }
        }
      }
      return false;
    },

    // returns the index (number) or false
    _listens: function (type, fn, context) {
      if (!this._events) {
        return false;
      }

      var listeners = this._events[type] || [];
      if (!fn) {
        return !!listeners.length;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }

      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return i;
        }
      }
      return false;
    },

    // @method once(â¦): this
    // Behaves as [`on(â¦)`](#evented-on), except the listener will only get fired once and then removed.
    once: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === "object") {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn, true);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context, true);
        }
      }

      return this;
    },

    // @method addEventParent(obj: Evented): this
    // Adds an event parent - an `Evented` that will receive propagated events
    addEventParent: function (obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    },

    // @method removeEventParent(obj: Evented): this
    // Removes an event parent, so it will stop receiving propagated events
    removeEventParent: function (obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }
      return this;
    },

    _propagateEvent: function (e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(
          e.type,
          extend(
            {
              layer: e.target,
              propagatedFrom: e.target,
            },
            e
          ),
          true
        );
      }
    },
  };

  // aliases; we should ditch those eventually

  // @method addEventListener(â¦): this
  // Alias to [`on(â¦)`](#evented-on)
  Events.addEventListener = Events.on;

  // @method removeEventListener(â¦): this
  // Alias to [`off(â¦)`](#evented-off)

  // @method clearAllEventListeners(â¦): this
  // Alias to [`off()`](#evented-off)
  Events.removeEventListener = Events.clearAllEventListeners = Events.off;

  // @method addOneTimeEventListener(â¦): this
  // Alias to [`once(â¦)`](#evented-once)
  Events.addOneTimeEventListener = Events.once;

  // @method fireEvent(â¦): this
  // Alias to [`fire(â¦)`](#evented-fire)
  Events.fireEvent = Events.fire;

  // @method hasEventListeners(â¦): Boolean
  // Alias to [`listens(â¦)`](#evented-listens)
  Events.hasEventListeners = Events.listens;

  var Evented = Class.extend(Events);

  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
    // @property x: Number; The `x` coordinate of the point
    this.x = round ? Math.round(x) : x;
    // @property y: Number; The `y` coordinate of the point
    this.y = round ? Math.round(y) : y;
  }

  var trunc =
    Math.trunc ||
    function (v) {
      return v > 0 ? Math.floor(v) : Math.ceil(v);
    };

  Point.prototype = {
    // @method clone(): Point
    // Returns a copy of the current point.
    clone: function () {
      return new Point(this.x, this.y);
    },

    // @method add(otherPoint: Point): Point
    // Returns the result of addition of the current and the given points.
    add: function (point) {
      // non-destructive, returns a new point
      return this.clone()._add(toPoint(point));
    },

    _add: function (point) {
      // destructive, used directly for performance in situations where it's safe to modify existing point
      this.x += point.x;
      this.y += point.y;
      return this;
    },

    // @method subtract(otherPoint: Point): Point
    // Returns the result of subtraction of the given point from the current.
    subtract: function (point) {
      return this.clone()._subtract(toPoint(point));
    },

    _subtract: function (point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    },

    // @method divideBy(num: Number): Point
    // Returns the result of division of the current point by the given number.
    divideBy: function (num) {
      return this.clone()._divideBy(num);
    },

    _divideBy: function (num) {
      this.x /= num;
      this.y /= num;
      return this;
    },

    // @method multiplyBy(num: Number): Point
    // Returns the result of multiplication of the current point by the given number.
    multiplyBy: function (num) {
      return this.clone()._multiplyBy(num);
    },

    _multiplyBy: function (num) {
      this.x *= num;
      this.y *= num;
      return this;
    },

    // @method scaleBy(scale: Point): Point
    // Multiply each coordinate of the current point by each coordinate of
    // `scale`. In linear algebra terms, multiply the point by the
    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
    // defined by `scale`.
    scaleBy: function (point) {
      return new Point(this.x * point.x, this.y * point.y);
    },

    // @method unscaleBy(scale: Point): Point
    // Inverse of `scaleBy`. Divide each coordinate of the current point by
    // each coordinate of `scale`.
    unscaleBy: function (point) {
      return new Point(this.x / point.x, this.y / point.y);
    },

    // @method round(): Point
    // Returns a copy of the current point with rounded coordinates.
    round: function () {
      return this.clone()._round();
    },

    _round: function () {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },

    // @method floor(): Point
    // Returns a copy of the current point with floored coordinates (rounded down).
    floor: function () {
      return this.clone()._floor();
    },

    _floor: function () {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },

    // @method ceil(): Point
    // Returns a copy of the current point with ceiled coordinates (rounded up).
    ceil: function () {
      return this.clone()._ceil();
    },

    _ceil: function () {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },

    // @method trunc(): Point
    // Returns a copy of the current point with truncated coordinates (rounded towards zero).
    trunc: function () {
      return this.clone()._trunc();
    },

    _trunc: function () {
      this.x = trunc(this.x);
      this.y = trunc(this.y);
      return this;
    },

    // @method distanceTo(otherPoint: Point): Number
    // Returns the cartesian distance between the current and the given points.
    distanceTo: function (point) {
      point = toPoint(point);

      var x = point.x - this.x,
        y = point.y - this.y;

      return Math.sqrt(x * x + y * y);
    },

    // @method equals(otherPoint: Point): Boolean
    // Returns `true` if the given point has the same coordinates.
    equals: function (point) {
      point = toPoint(point);

      return point.x === this.x && point.y === this.y;
    },

    // @method contains(otherPoint: Point): Boolean
    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
    contains: function (point) {
      point = toPoint(point);

      return (
        Math.abs(point.x) <= Math.abs(this.x) &&
        Math.abs(point.y) <= Math.abs(this.y)
      );
    },

    // @method toString(): String
    // Returns a string representation of the point for debugging purposes.
    toString: function () {
      return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
    },
  };

  // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.

  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.
  function toPoint(x, y, round) {
    if (x instanceof Point) {
      return x;
    }
    if (isArray(x)) {
      return new Point(x[0], x[1]);
    }
    if (x === undefined || x === null) {
      return x;
    }
    if (typeof x === "object" && "x" in x && "y" in x) {
      return new Point(x.x, x.y);
    }
    return new Point(x, y, round);
  }

  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Bounds(a, b) {
    if (!a) {
      return;
    }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
      this.extend(points[i]);
    }
  }

  Bounds.prototype = {
    // @method extend(point: Point): this
    // Extends the bounds to contain the given point.

    // @alternative
    // @method extend(otherBounds: Bounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var min2, max2;
      if (!obj) {
        return this;
      }

      if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
        min2 = max2 = toPoint(obj);
      } else {
        obj = toBounds(obj);
        min2 = obj.min;
        max2 = obj.max;

        if (!min2 || !max2) {
          return this;
        }
      }

      // @property min: Point
      // The top left corner of the rectangle.
      // @property max: Point
      // The bottom right corner of the rectangle.
      if (!this.min && !this.max) {
        this.min = min2.clone();
        this.max = max2.clone();
      } else {
        this.min.x = Math.min(min2.x, this.min.x);
        this.max.x = Math.max(max2.x, this.max.x);
        this.min.y = Math.min(min2.y, this.min.y);
        this.max.y = Math.max(max2.y, this.max.y);
      }
      return this;
    },

    // @method getCenter(round?: Boolean): Point
    // Returns the center point of the bounds.
    getCenter: function (round) {
      return toPoint(
        (this.min.x + this.max.x) / 2,
        (this.min.y + this.max.y) / 2,
        round
      );
    },

    // @method getBottomLeft(): Point
    // Returns the bottom-left point of the bounds.
    getBottomLeft: function () {
      return toPoint(this.min.x, this.max.y);
    },

    // @method getTopRight(): Point
    // Returns the top-right point of the bounds.
    getTopRight: function () {
      // -> Point
      return toPoint(this.max.x, this.min.y);
    },

    // @method getTopLeft(): Point
    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
    getTopLeft: function () {
      return this.min; // left, top
    },

    // @method getBottomRight(): Point
    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
    getBottomRight: function () {
      return this.max; // right, bottom
    },

    // @method getSize(): Point
    // Returns the size of the given bounds
    getSize: function () {
      return this.max.subtract(this.min);
    },

    // @method contains(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains(point: Point): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      var min, max;

      if (typeof obj[0] === "number" || obj instanceof Point) {
        obj = toPoint(obj);
      } else {
        obj = toBounds(obj);
      }

      if (obj instanceof Bounds) {
        min = obj.min;
        max = obj.max;
      } else {
        min = max = obj;
      }

      return (
        min.x >= this.min.x &&
        max.x <= this.max.x &&
        min.y >= this.min.y &&
        max.y <= this.max.y
      );
    },

    // @method intersects(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds
    // intersect if they have at least one point in common.
    intersects: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);

      var min = this.min,
        max = this.max,
        min2 = bounds.min,
        max2 = bounds.max,
        xIntersects = max2.x >= min.x && min2.x <= max.x,
        yIntersects = max2.y >= min.y && min2.y <= max.y;

      return xIntersects && yIntersects;
    },

    // @method overlaps(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds
    // overlap if their intersection is an area.
    overlaps: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);

      var min = this.min,
        max = this.max,
        min2 = bounds.min,
        max2 = bounds.max,
        xOverlaps = max2.x > min.x && min2.x < max.x,
        yOverlaps = max2.y > min.y && min2.y < max.y;

      return xOverlaps && yOverlaps;
    },

    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this.min && this.max);
    },

    // @method pad(bufferRatio: Number): Bounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var min = this.min,
        max = this.max,
        heightBuffer = Math.abs(min.x - max.x) * bufferRatio,
        widthBuffer = Math.abs(min.y - max.y) * bufferRatio;

      return toBounds(
        toPoint(min.x - heightBuffer, min.y - widthBuffer),
        toPoint(max.x + heightBuffer, max.y + widthBuffer)
      );
    },

    // @method equals(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle is equivalent to the given bounds.
    equals: function (bounds) {
      if (!bounds) {
        return false;
      }

      bounds = toBounds(bounds);

      return (
        this.min.equals(bounds.getTopLeft()) &&
        this.max.equals(bounds.getBottomRight())
      );
    },
  };

  // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.
  function toBounds(a, b) {
    if (!a || a instanceof Bounds) {
      return a;
    }
    return new Bounds(a, b);
  }

  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLngBounds(corner1, corner2) {
    // (LatLng, LatLng) or (LatLng[])
    if (!corner1) {
      return;
    }

    var latlngs = corner2 ? [corner1, corner2] : corner1;

    for (var i = 0, len = latlngs.length; i < len; i++) {
      this.extend(latlngs[i]);
    }
  }

  LatLngBounds.prototype = {
    // @method extend(latlng: LatLng): this
    // Extend the bounds to contain the given point

    // @alternative
    // @method extend(otherBounds: LatLngBounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var sw = this._southWest,
        ne = this._northEast,
        sw2,
        ne2;

      if (obj instanceof LatLng) {
        sw2 = obj;
        ne2 = obj;
      } else if (obj instanceof LatLngBounds) {
        sw2 = obj._southWest;
        ne2 = obj._northEast;

        if (!sw2 || !ne2) {
          return this;
        }
      } else {
        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
      }

      if (!sw && !ne) {
        this._southWest = new LatLng(sw2.lat, sw2.lng);
        this._northEast = new LatLng(ne2.lat, ne2.lng);
      } else {
        sw.lat = Math.min(sw2.lat, sw.lat);
        sw.lng = Math.min(sw2.lng, sw.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
      }

      return this;
    },

    // @method pad(bufferRatio: Number): LatLngBounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var sw = this._southWest,
        ne = this._northEast,
        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

      return new LatLngBounds(
        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
      );
    },

    // @method getCenter(): LatLng
    // Returns the center point of the bounds.
    getCenter: function () {
      return new LatLng(
        (this._southWest.lat + this._northEast.lat) / 2,
        (this._southWest.lng + this._northEast.lng) / 2
      );
    },

    // @method getSouthWest(): LatLng
    // Returns the south-west point of the bounds.
    getSouthWest: function () {
      return this._southWest;
    },

    // @method getNorthEast(): LatLng
    // Returns the north-east point of the bounds.
    getNorthEast: function () {
      return this._northEast;
    },

    // @method getNorthWest(): LatLng
    // Returns the north-west point of the bounds.
    getNorthWest: function () {
      return new LatLng(this.getNorth(), this.getWest());
    },

    // @method getSouthEast(): LatLng
    // Returns the south-east point of the bounds.
    getSouthEast: function () {
      return new LatLng(this.getSouth(), this.getEast());
    },

    // @method getWest(): Number
    // Returns the west longitude of the bounds
    getWest: function () {
      return this._southWest.lng;
    },

    // @method getSouth(): Number
    // Returns the south latitude of the bounds
    getSouth: function () {
      return this._southWest.lat;
    },

    // @method getEast(): Number
    // Returns the east longitude of the bounds
    getEast: function () {
      return this._northEast.lng;
    },

    // @method getNorth(): Number
    // Returns the north latitude of the bounds
    getNorth: function () {
      return this._northEast.lat;
    },

    // @method contains(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle contains the given one.

    // @alternative
    // @method contains (latlng: LatLng): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      // (LatLngBounds) or (LatLng) -> Boolean
      if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
        obj = toLatLng(obj);
      } else {
        obj = toLatLngBounds(obj);
      }

      var sw = this._southWest,
        ne = this._northEast,
        sw2,
        ne2;

      if (obj instanceof LatLngBounds) {
        sw2 = obj.getSouthWest();
        ne2 = obj.getNorthEast();
      } else {
        sw2 = ne2 = obj;
      }

      return (
        sw2.lat >= sw.lat &&
        ne2.lat <= ne.lat &&
        sw2.lng >= sw.lng &&
        ne2.lng <= ne.lng
      );
    },

    // @method intersects(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
    intersects: function (bounds) {
      bounds = toLatLngBounds(bounds);

      var sw = this._southWest,
        ne = this._northEast,
        sw2 = bounds.getSouthWest(),
        ne2 = bounds.getNorthEast(),
        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;

      return latIntersects && lngIntersects;
    },

    // @method overlaps(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
    overlaps: function (bounds) {
      bounds = toLatLngBounds(bounds);

      var sw = this._southWest,
        ne = this._northEast,
        sw2 = bounds.getSouthWest(),
        ne2 = bounds.getNorthEast(),
        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;

      return latOverlaps && lngOverlaps;
    },

    // @method toBBoxString(): String
    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
    toBBoxString: function () {
      return [
        this.getWest(),
        this.getSouth(),
        this.getEast(),
        this.getNorth(),
      ].join(",");
    },

    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (bounds, maxMargin) {
      if (!bounds) {
        return false;
      }

      bounds = toLatLngBounds(bounds);

      return (
        this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
        this._northEast.equals(bounds.getNorthEast(), maxMargin)
      );
    },

    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this._southWest && this._northEast);
    },
  };

  // TODO International date line?

  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
  function toLatLngBounds(a, b) {
    if (a instanceof LatLngBounds) {
      return a;
    }
    return new LatLngBounds(a, b);
  }

  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLng(lat, lng, alt) {
    if (isNaN(lat) || isNaN(lng)) {
      throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
    }

    // @property lat: Number
    // Latitude in degrees
    this.lat = +lat;

    // @property lng: Number
    // Longitude in degrees
    this.lng = +lng;

    // @property alt: Number
    // Altitude in meters (optional)
    if (alt !== undefined) {
      this.alt = +alt;
    }
  }

  LatLng.prototype = {
    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (obj, maxMargin) {
      if (!obj) {
        return false;
      }

      obj = toLatLng(obj);

      var margin = Math.max(
        Math.abs(this.lat - obj.lat),
        Math.abs(this.lng - obj.lng)
      );

      return margin <= (maxMargin === undefined ? 1.0e-9 : maxMargin);
    },

    // @method toString(): String
    // Returns a string representation of the point (for debugging purposes).
    toString: function (precision) {
      return (
        "LatLng(" +
        formatNum(this.lat, precision) +
        ", " +
        formatNum(this.lng, precision) +
        ")"
      );
    },

    // @method distanceTo(otherLatLng: LatLng): Number
    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
    distanceTo: function (other) {
      return Earth.distance(this, toLatLng(other));
    },

    // @method wrap(): LatLng
    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
    wrap: function () {
      return Earth.wrapLatLng(this);
    },

    // @method toBounds(sizeInMeters: Number): LatLngBounds
    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
    toBounds: function (sizeInMeters) {
      var latAccuracy = (180 * sizeInMeters) / 40075017,
        lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

      return toLatLngBounds(
        [this.lat - latAccuracy, this.lng - lngAccuracy],
        [this.lat + latAccuracy, this.lng + lngAccuracy]
      );
    },

    clone: function () {
      return new LatLng(this.lat, this.lng, this.alt);
    },
  };

  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
    if (a instanceof LatLng) {
      return a;
    }
    if (isArray(a) && typeof a[0] !== "object") {
      if (a.length === 3) {
        return new LatLng(a[0], a[1], a[2]);
      }
      if (a.length === 2) {
        return new LatLng(a[0], a[1]);
      }
      return null;
    }
    if (a === undefined || a === null) {
      return a;
    }
    if (typeof a === "object" && "lat" in a) {
      return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
    }
    if (b === undefined) {
      return null;
    }
    return new LatLng(a, b, c);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */

  var CRS = {
    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
    // Projects geographical coordinates into pixel coordinates for a given zoom.
    latLngToPoint: function (latlng, zoom) {
      var projectedPoint = this.projection.project(latlng),
        scale = this.scale(zoom);

      return this.transformation._transform(projectedPoint, scale);
    },

    // @method pointToLatLng(point: Point, zoom: Number): LatLng
    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
    // zoom into geographical coordinates.
    pointToLatLng: function (point, zoom) {
      var scale = this.scale(zoom),
        untransformedPoint = this.transformation.untransform(point, scale);

      return this.projection.unproject(untransformedPoint);
    },

    // @method project(latlng: LatLng): Point
    // Projects geographical coordinates into coordinates in units accepted for
    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
    project: function (latlng) {
      return this.projection.project(latlng);
    },

    // @method unproject(point: Point): LatLng
    // Given a projected coordinate returns the corresponding LatLng.
    // The inverse of `project`.
    unproject: function (point) {
      return this.projection.unproject(point);
    },

    // @method scale(zoom: Number): Number
    // Returns the scale used when transforming projected coordinates into
    // pixel coordinates for a particular zoom. For example, it returns
    // `256 * 2^zoom` for Mercator-based CRS.
    scale: function (zoom) {
      return 256 * Math.pow(2, zoom);
    },

    // @method zoom(scale: Number): Number
    // Inverse of `scale()`, returns the zoom level corresponding to a scale
    // factor of `scale`.
    zoom: function (scale) {
      return Math.log(scale / 256) / Math.LN2;
    },

    // @method getProjectedBounds(zoom: Number): Bounds
    // Returns the projection's bounds scaled and transformed for the provided `zoom`.
    getProjectedBounds: function (zoom) {
      if (this.infinite) {
        return null;
      }

      var b = this.projection.bounds,
        s = this.scale(zoom),
        min = this.transformation.transform(b.min, s),
        max = this.transformation.transform(b.max, s);

      return new Bounds(min, max);
    },

    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates.

    // @property code: String
    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
    //
    // @property wrapLng: Number[]
    // An array of two numbers defining whether the longitude (horizontal) coordinate
    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
    //
    // @property wrapLat: Number[]
    // Like `wrapLng`, but for the latitude (vertical) axis.

    // wrapLng: [min, max],
    // wrapLat: [min, max],

    // @property infinite: Boolean
    // If true, the coordinate space will be unbounded (infinite in both axes)
    infinite: false,

    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where lat and lng has been wrapped according to the
    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
    wrapLatLng: function (latlng) {
      var lng = this.wrapLng
          ? wrapNum(latlng.lng, this.wrapLng, true)
          : latlng.lng,
        lat = this.wrapLat
          ? wrapNum(latlng.lat, this.wrapLat, true)
          : latlng.lat,
        alt = latlng.alt;

      return new LatLng(lat, lng, alt);
    },

    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring
    // that its center is within the CRS's bounds.
    // Only accepts actual `L.LatLngBounds` instances, not arrays.
    wrapLatLngBounds: function (bounds) {
      var center = bounds.getCenter(),
        newCenter = this.wrapLatLng(center),
        latShift = center.lat - newCenter.lat,
        lngShift = center.lng - newCenter.lng;

      if (latShift === 0 && lngShift === 0) {
        return bounds;
      }

      var sw = bounds.getSouthWest(),
        ne = bounds.getNorthEast(),
        newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
        newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

      return new LatLngBounds(newSw, newNe);
    },
  };

  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
    wrapLng: [-180, 180],

    // Mean Earth Radius, as recommended for use by
    // the International Union of Geodesy and Geophysics,
    // see https://rosettacode.org/wiki/Haversine_formula
    R: 6371000,

    // distance between two geographical points using spherical law of cosines approximation
    distance: function (latlng1, latlng2) {
      var rad = Math.PI / 180,
        lat1 = latlng1.lat * rad,
        lat2 = latlng2.lat * rad,
        sinDLat = Math.sin(((latlng2.lat - latlng1.lat) * rad) / 2),
        sinDLon = Math.sin(((latlng2.lng - latlng1.lng) * rad) / 2),
        a =
          sinDLat * sinDLat +
          Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return this.R * c;
    },
  });

  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection â the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;

  var SphericalMercator = {
    R: earthRadius,
    MAX_LATITUDE: 85.0511287798,

    project: function (latlng) {
      var d = Math.PI / 180,
        max = this.MAX_LATITUDE,
        lat = Math.max(Math.min(max, latlng.lat), -max),
        sin = Math.sin(lat * d);

      return new Point(
        this.R * latlng.lng * d,
        (this.R * Math.log((1 + sin) / (1 - sin))) / 2
      );
    },

    unproject: function (point) {
      var d = 180 / Math.PI;

      return new LatLng(
        (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
        (point.x * d) / this.R
      );
    },

    bounds: (function () {
      var d = earthRadius * Math.PI;
      return new Bounds([-d, -d], [d, d]);
    })(),
  };

  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */

  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.
  function Transformation(a, b, c, d) {
    if (isArray(a)) {
      // use array properties
      this._a = a[0];
      this._b = a[1];
      this._c = a[2];
      this._d = a[3];
      return;
    }
    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
  }

  Transformation.prototype = {
    // @method transform(point: Point, scale?: Number): Point
    // Returns a transformed point, optionally multiplied by the given scale.
    // Only accepts actual `L.Point` instances, not arrays.
    transform: function (point, scale) {
      // (Point, Number) -> Point
      return this._transform(point.clone(), scale);
    },

    // destructive transform (faster)
    _transform: function (point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    },

    // @method untransform(point: Point, scale?: Number): Point
    // Returns the reverse transformation of the given point, optionally divided
    // by the given scale. Only accepts actual `L.Point` instances, not arrays.
    untransform: function (point, scale) {
      scale = scale || 1;
      return new Point(
        (point.x / scale - this._b) / this._a,
        (point.y / scale - this._d) / this._c
      );
    },
  };

  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)

  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.

  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
    return new Transformation(a, b, c, d);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */

  var EPSG3857 = extend({}, Earth, {
    code: "EPSG:3857",
    projection: SphericalMercator,

    transformation: (function () {
      var scale = 0.5 / (Math.PI * SphericalMercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    })(),
  });

  var EPSG900913 = extend({}, EPSG3857, {
    code: "EPSG:900913",
  });

  // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:

  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
  function svgCreate(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }

  // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions
  function pointsToPath(rings, closed) {
    var str = "",
      i,
      j,
      len,
      len2,
      points,
      p;

    for (i = 0, len = rings.length; i < len; i++) {
      points = rings[i];

      for (j = 0, len2 = points.length; j < len2; j++) {
        p = points[j];
        str += (j ? "L" : "M") + p.x + " " + p.y;
      }

      // closes the ring for polygons; "x" is VML syntax
      str += closed ? (Browser.svg ? "z" : "x") : "";
    }

    // SVG complains about empty path strings
    return str || "M0 0";
  }

  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */

  var style = document.documentElement.style;

  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
  var ie = "ActiveXObject" in window;

  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
  var ielt9 = ie && !document.addEventListener;

  // @property edge: Boolean; `true` for the Edge web browser.
  var edge = "msLaunchUri" in navigator && !("documentMode" in document);

  // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
  var webkit = userAgentContains("webkit");

  // @property android: Boolean
  // **Deprecated.** `true` for any browser running on an Android platform.
  var android = userAgentContains("android");

  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.
  var android23 =
    userAgentContains("android 2") || userAgentContains("android 3");

  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
  var webkitVer = parseInt(
    /WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],
    10
  ); // also matches AppleWebKit
  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)
  var androidStock =
    android &&
    userAgentContains("Google") &&
    webkitVer < 537 &&
    !("AudioNode" in window);

  // @property opera: Boolean; `true` for the Opera browser
  var opera = !!window.opera;

  // @property chrome: Boolean; `true` for the Chrome browser.
  var chrome = !edge && userAgentContains("chrome");

  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
  var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;

  // @property safari: Boolean; `true` for the Safari browser.
  var safari = !chrome && userAgentContains("safari");

  var phantom = userAgentContains("phantom");

  // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).
  var opera12 = "OTransition" in style;

  // @property win: Boolean; `true` when the browser is running in a Windows platform
  var win = navigator.platform.indexOf("Win") === 0;

  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
  var ie3d = ie && "transition" in style;

  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
  var webkit3d =
    "WebKitCSSMatrix" in window &&
    "m11" in new window.WebKitCSSMatrix() &&
    !android23;

  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
  var gecko3d = "MozPerspective" in style;

  // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.
  var any3d =
    !window.L_DISABLE_3D &&
    (ie3d || webkit3d || gecko3d) &&
    !opera12 &&
    !phantom;

  // @property mobile: Boolean; `true` for all browsers running in a mobile device.
  var mobile =
    typeof orientation !== "undefined" || userAgentContains("mobile");

  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
  var mobileWebkit = mobile && webkit;

  // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
  var mobileWebkit3d = mobile && webkit3d;

  // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).
  var msPointer = !window.PointerEvent && window.MSPointerEvent;

  // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
  var pointer = !!(window.PointerEvent || msPointer);

  // @property touchNative: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // **This does not necessarily mean** that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.
  var touchNative = "ontouchstart" in window || !!window.TouchEvent;

  // @property touch: Boolean
  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.
  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.
  var touch = !window.L_NO_TOUCH && (touchNative || pointer);

  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
  var mobileOpera = mobile && opera;

  // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.
  var mobileGecko = mobile && gecko;

  // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
  var retina =
    (window.devicePixelRatio ||
      window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

  // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.
  var passiveEvents = (function () {
    var supportsPassiveOption = false;
    try {
      var opts = Object.defineProperty({}, "passive", {
        get: function () {
          // eslint-disable-line getter-return
          supportsPassiveOption = true;
        },
      });
      window.addEventListener("testPassiveEventSupport", falseFn, opts);
      window.removeEventListener("testPassiveEventSupport", falseFn, opts);
    } catch (e) {
      // Errors can safely be ignored since this is only a browser support test.
    }
    return supportsPassiveOption;
  })();

  // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
  var canvas$1 = (function () {
    return !!document.createElement("canvas").getContext;
  })();

  // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
  var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);

  var inlineSvg =
    !!svg$1 &&
    (function () {
      var div = document.createElement("div");
      div.innerHTML = "<svg/>";
      return (
        (div.firstChild && div.firstChild.namespaceURI) ===
        "http://www.w3.org/2000/svg"
      );
    })();

  // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
  var vml =
    !svg$1 &&
    (function () {
      try {
        var div = document.createElement("div");
        div.innerHTML = '<v:shape adj="1"/>';

        var shape = div.firstChild;
        shape.style.behavior = "url(#default#VML)";

        return shape && typeof shape.adj === "object";
      } catch (e) {
        return false;
      }
    })();

  // @property mac: Boolean; `true` when the browser is running in a Mac platform
  var mac = navigator.platform.indexOf("Mac") === 0;

  // @property mac: Boolean; `true` when the browser is running in a Linux platform
  var linux = navigator.platform.indexOf("Linux") === 0;

  function userAgentContains(str) {
    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }

  var Browser = {
    ie: ie,
    ielt9: ielt9,
    edge: edge,
    webkit: webkit,
    android: android,
    android23: android23,
    androidStock: androidStock,
    opera: opera,
    chrome: chrome,
    gecko: gecko,
    safari: safari,
    phantom: phantom,
    opera12: opera12,
    win: win,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobileWebkit,
    mobileWebkit3d: mobileWebkit3d,
    msPointer: msPointer,
    pointer: pointer,
    touch: touch,
    touchNative: touchNative,
    mobileOpera: mobileOpera,
    mobileGecko: mobileGecko,
    retina: retina,
    passiveEvents: passiveEvents,
    canvas: canvas$1,
    svg: svg$1,
    vml: vml,
    inlineSvg: inlineSvg,
    mac: mac,
    linux: linux,
  };

  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
  var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
  var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
  var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
  var pEvent = {
    touchstart: POINTER_DOWN,
    touchmove: POINTER_MOVE,
    touchend: POINTER_UP,
    touchcancel: POINTER_CANCEL,
  };
  var handle = {
    touchstart: _onPointerStart,
    touchmove: _handlePointer,
    touchend: _handlePointer,
    touchcancel: _handlePointer,
  };
  var _pointers = {};
  var _pointerDocListener = false;

  // Provides a touch events wrapper for (ms)pointer events.
  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler) {
    if (type === "touchstart") {
      _addPointerDocListener();
    }
    if (!handle[type]) {
      console.warn("wrong event specified:", type);
      return falseFn;
    }
    handler = handle[type].bind(this, handler);
    obj.addEventListener(pEvent[type], handler, false);
    return handler;
  }

  function removePointerListener(obj, type, handler) {
    if (!pEvent[type]) {
      console.warn("wrong event specified:", type);
      return;
    }
    obj.removeEventListener(pEvent[type], handler, false);
  }

  function _globalPointerDown(e) {
    _pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
    if (_pointers[e.pointerId]) {
      _pointers[e.pointerId] = e;
    }
  }

  function _globalPointerUp(e) {
    delete _pointers[e.pointerId];
  }

  function _addPointerDocListener() {
    // need to keep track of what pointers and how many are active to provide e.touches emulation
    if (!_pointerDocListener) {
      // we listen document as any drags that end by moving the touch off the screen get fired there
      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
      document.addEventListener(POINTER_UP, _globalPointerUp, true);
      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

      _pointerDocListener = true;
    }
  }

  function _handlePointer(handler, e) {
    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
      return;
    }

    e.touches = [];
    for (var i in _pointers) {
      e.touches.push(_pointers[i]);
    }
    e.changedTouches = [e];

    handler(e);
  }

  function _onPointerStart(handler, e) {
    // IE10 specific: MsTouch needs preventDefault. See #2000
    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
      preventDefault(e);
    }
    _handlePointer(handler, e);
  }

  /*
   * Extends the event handling code with double tap support for mobile browsers.
   *
   * Note: currently most browsers fire native dblclick, with only a few exceptions
   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)
   */

  function makeDblclick(event) {
    // in modern browsers `type` cannot be just overridden:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only
    var newEvent = {},
      prop,
      i;
    for (i in event) {
      prop = event[i];
      newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
    }
    event = newEvent;
    newEvent.type = "dblclick";
    newEvent.detail = 2;
    newEvent.isTrusted = false;
    newEvent._simulated = true; // for debug purposes
    return newEvent;
  }

  var delay = 200;
  function addDoubleTapListener(obj, handler) {
    // Most browsers handle double tap natively
    obj.addEventListener("dblclick", handler);

    // On some platforms the browser doesn't fire native dblclicks for touch events.
    // It seems that in all such cases `detail` property of `click` event is always `1`.
    // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.
    var last = 0,
      detail;
    function simDblclick(e) {
      if (e.detail !== 1) {
        detail = e.detail; // keep in sync to avoid false dblclick in some cases
        return;
      }

      if (
        e.pointerType === "mouse" ||
        (e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)
      ) {
        return;
      }

      // When clicking on an <input>, the browser generates a click on its
      // <label> (and vice versa) triggering two clicks in quick succession.
      // This ignores clicks on elements which are a label with a 'for'
      // attribute (or children of such a label), but not children of
      // a <input>.
      var path = getPropagationPath(e);
      if (
        path.some(function (el) {
          return el instanceof HTMLLabelElement && el.attributes.for;
        }) &&
        !path.some(function (el) {
          return (
            el instanceof HTMLInputElement || el instanceof HTMLSelectElement
          );
        })
      ) {
        return;
      }

      var now = Date.now();
      if (now - last <= delay) {
        detail++;
        if (detail === 2) {
          handler(makeDblclick(e));
        }
      } else {
        detail = 1;
      }
      last = now;
    }

    obj.addEventListener("click", simDblclick);

    return {
      dblclick: handler,
      simDblclick: simDblclick,
    };
  }

  function removeDoubleTapListener(obj, handlers) {
    obj.removeEventListener("dblclick", handlers.dblclick);
    obj.removeEventListener("click", handlers.simDblclick);
  }

  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */

  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
  var TRANSFORM = testProp([
    "transform",
    "webkitTransform",
    "OTransform",
    "MozTransform",
    "msTransform",
  ]);

  // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser

  // @property TRANSITION: String
  // Vendor-prefixed transition style name.
  var TRANSITION = testProp([
    "webkitTransition",
    "transition",
    "OTransition",
    "MozTransition",
    "msTransition",
  ]);

  // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.
  var TRANSITION_END =
    TRANSITION === "webkitTransition" || TRANSITION === "OTransition"
      ? TRANSITION + "End"
      : "transitionend";

  // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.
  function get(id) {
    return typeof id === "string" ? document.getElementById(id) : id;
  }

  // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.
  function getStyle(el, style) {
    var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

    if ((!value || value === "auto") && document.defaultView) {
      var css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }
    return value === "auto" ? null : value;
  }

  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
  function create$1(tagName, className, container) {
    var el = document.createElement(tagName);
    el.className = className || "";

    if (container) {
      container.appendChild(el);
    }
    return el;
  }

  // @function remove(el: HTMLElement)
  // Removes `el` from its parent element
  function remove(el) {
    var parent = el.parentNode;
    if (parent) {
      parent.removeChild(el);
    }
  }

  // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`
  function empty(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }

  // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.
  function toFront(el) {
    var parent = el.parentNode;
    if (parent && parent.lastChild !== el) {
      parent.appendChild(el);
    }
  }

  // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.
  function toBack(el) {
    var parent = el.parentNode;
    if (parent && parent.firstChild !== el) {
      parent.insertBefore(el, parent.firstChild);
    }
  }

  // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.
  function hasClass(el, name) {
    if (el.classList !== undefined) {
      return el.classList.contains(name);
    }
    var className = getClass(el);
    return (
      className.length > 0 &&
      new RegExp("(^|\\s)" + name + "(\\s|$)").test(className)
    );
  }

  // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.
  function addClass(el, name) {
    if (el.classList !== undefined) {
      var classes = splitWords(name);
      for (var i = 0, len = classes.length; i < len; i++) {
        el.classList.add(classes[i]);
      }
    } else if (!hasClass(el, name)) {
      var className = getClass(el);
      setClass(el, (className ? className + " " : "") + name);
    }
  }

  // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.
  function removeClass(el, name) {
    if (el.classList !== undefined) {
      el.classList.remove(name);
    } else {
      setClass(
        el,
        trim((" " + getClass(el) + " ").replace(" " + name + " ", " "))
      );
    }
  }

  // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.
  function setClass(el, name) {
    if (el.className.baseVal === undefined) {
      el.className = name;
    } else {
      // in case of SVG element
      el.className.baseVal = name;
    }
  }

  // @function getClass(el: HTMLElement): String
  // Returns the element's class.
  function getClass(el) {
    // Check if the element is an SVGElementInstance and use the correspondingElement instead
    // (Required for linked SVG elements in IE11.)
    if (el.correspondingElement) {
      el = el.correspondingElement;
    }
    return el.className.baseVal === undefined
      ? el.className
      : el.className.baseVal;
  }

  // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.
  function setOpacity(el, value) {
    if ("opacity" in el.style) {
      el.style.opacity = value;
    } else if ("filter" in el.style) {
      _setOpacityIE(el, value);
    }
  }

  function _setOpacityIE(el, value) {
    var filter = false,
      filterName = "DXImageTransform.Microsoft.Alpha";

    // filters collection throws an error if we try to retrieve a filter that doesn't exist
    try {
      filter = el.filters.item(filterName);
    } catch (e) {
      // don't set opacity to 1 if we haven't already set an opacity,
      // it isn't needed and breaks transparent pngs.
      if (value === 1) {
        return;
      }
    }

    value = Math.round(value * 100);

    if (filter) {
      filter.Enabled = value !== 100;
      filter.Opacity = value;
    } else {
      el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
    }
  }

  // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.
  function testProp(props) {
    var style = document.documentElement.style;

    for (var i = 0; i < props.length; i++) {
      if (props[i] in style) {
        return props[i];
      }
    }
    return false;
  }

  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.
  function setTransform(el, offset, scale) {
    var pos = offset || new Point(0, 0);

    el.style[TRANSFORM] =
      (Browser.ie3d
        ? "translate(" + pos.x + "px," + pos.y + "px)"
        : "translate3d(" + pos.x + "px," + pos.y + "px,0)") +
      (scale ? " scale(" + scale + ")" : "");
  }

  // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).
  function setPosition(el, point) {
    /*eslint-disable */
    el._leaflet_pos = point;
    /* eslint-enable */

    if (Browser.any3d) {
      setTransform(el, point);
    } else {
      el.style.left = point.x + "px";
      el.style.top = point.y + "px";
    }
  }

  // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.
  function getPosition(el) {
    // this method is only used for elements previously positioned using setPosition,
    // so it's safe to cache the position for performance

    return el._leaflet_pos || new Point(0, 0);
  }

  // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.

  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
  var disableTextSelection;
  var enableTextSelection;
  var _userSelect;
  if ("onselectstart" in document) {
    disableTextSelection = function () {
      on(window, "selectstart", preventDefault);
    };
    enableTextSelection = function () {
      off(window, "selectstart", preventDefault);
    };
  } else {
    var userSelectProperty = testProp([
      "userSelect",
      "WebkitUserSelect",
      "OUserSelect",
      "MozUserSelect",
      "msUserSelect",
    ]);

    disableTextSelection = function () {
      if (userSelectProperty) {
        var style = document.documentElement.style;
        _userSelect = style[userSelectProperty];
        style[userSelectProperty] = "none";
      }
    };
    enableTextSelection = function () {
      if (userSelectProperty) {
        document.documentElement.style[userSelectProperty] = _userSelect;
        _userSelect = undefined;
      }
    };
  }

  // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.
  function disableImageDrag() {
    on(window, "dragstart", preventDefault);
  }

  // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
  function enableImageDrag() {
    off(window, "dragstart", preventDefault);
  }

  var _outlineElement, _outlineStyle;
  // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.
  function preventOutline(element) {
    while (element.tabIndex === -1) {
      element = element.parentNode;
    }
    if (!element.style) {
      return;
    }
    restoreOutline();
    _outlineElement = element;
    _outlineStyle = element.style.outlineStyle;
    element.style.outlineStyle = "none";
    on(window, "keydown", restoreOutline);
  }

  // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
  function restoreOutline() {
    if (!_outlineElement) {
      return;
    }
    _outlineElement.style.outlineStyle = _outlineStyle;
    _outlineElement = undefined;
    _outlineStyle = undefined;
    off(window, "keydown", restoreOutline);
  }

  // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.
  function getSizedParentNode(element) {
    do {
      element = element.parentNode;
    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
    return element;
  }

  // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  function getScale(element) {
    var rect = element.getBoundingClientRect(); // Read-only in old browsers.

    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect,
    };
  }

  var DomUtil = {
    __proto__: null,
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    get disableTextSelection() {
      return disableTextSelection;
    },
    get enableTextSelection() {
      return enableTextSelection;
    },
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale,
  };

  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */

  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).

  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function on(obj, types, fn, context) {
    if (types && typeof types === "object") {
      for (var type in types) {
        addOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        addOne(obj, types[i], fn, context);
      }
    }

    return this;
  }

  var eventsKey = "_leaflet_events";

  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.

  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  // @alternative
  // @function off(el: HTMLElement, types: String): this
  // Removes all previously added listeners of given types.

  // @alternative
  // @function off(el: HTMLElement): this
  // Removes all previously added listeners from given HTMLElement
  function off(obj, types, fn, context) {
    if (arguments.length === 1) {
      batchRemove(obj);
      delete obj[eventsKey];
    } else if (types && typeof types === "object") {
      for (var type in types) {
        removeOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);

      if (arguments.length === 2) {
        batchRemove(obj, function (type) {
          return indexOf(types, type) !== -1;
        });
      } else {
        for (var i = 0, len = types.length; i < len; i++) {
          removeOne(obj, types[i], fn, context);
        }
      }
    }

    return this;
  }

  function batchRemove(obj, filterFn) {
    for (var id in obj[eventsKey]) {
      var type = id.split(/\d/)[0];
      if (!filterFn || filterFn(type)) {
        removeOne(obj, type, null, null, id);
      }
    }
  }

  var mouseSubst = {
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    wheel: !("onwheel" in window) && "mousewheel",
  };

  function addOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");

    if (obj[eventsKey] && obj[eventsKey][id]) {
      return this;
    }

    var handler = function (e) {
      return fn.call(context || obj, e || window.event);
    };

    var originalHandler = handler;

    if (
      !Browser.touchNative &&
      Browser.pointer &&
      type.indexOf("touch") === 0
    ) {
      // Needs DomEvent.Pointer.js
      handler = addPointerListener(obj, type, handler);
    } else if (Browser.touch && type === "dblclick") {
      handler = addDoubleTapListener(obj, handler);
    } else if ("addEventListener" in obj) {
      if (
        type === "touchstart" ||
        type === "touchmove" ||
        type === "wheel" ||
        type === "mousewheel"
      ) {
        obj.addEventListener(
          mouseSubst[type] || type,
          handler,
          Browser.passiveEvents ? { passive: false } : false
        );
      } else if (type === "mouseenter" || type === "mouseleave") {
        handler = function (e) {
          e = e || window.event;
          if (isExternalTarget(obj, e)) {
            originalHandler(e);
          }
        };
        obj.addEventListener(mouseSubst[type], handler, false);
      } else {
        obj.addEventListener(type, originalHandler, false);
      }
    } else {
      obj.attachEvent("on" + type, handler);
    }

    obj[eventsKey] = obj[eventsKey] || {};
    obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context, id) {
    id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
    var handler = obj[eventsKey] && obj[eventsKey][id];

    if (!handler) {
      return this;
    }

    if (
      !Browser.touchNative &&
      Browser.pointer &&
      type.indexOf("touch") === 0
    ) {
      removePointerListener(obj, type, handler);
    } else if (Browser.touch && type === "dblclick") {
      removeDoubleTapListener(obj, handler);
    } else if ("removeEventListener" in obj) {
      obj.removeEventListener(mouseSubst[type] || type, handler, false);
    } else {
      obj.detachEvent("on" + type, handler);
    }

    obj[eventsKey][id] = null;
  }

  // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```
  function stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else if (e.originalEvent) {
      // In case of Leaflet event.
      e.originalEvent._stopped = true;
    } else {
      e.cancelBubble = true;
    }

    return this;
  }

  // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
  function disableScrollPropagation(el) {
    addOne(el, "wheel", stopPropagation);
    return this;
  }

  // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).
  function disableClickPropagation(el) {
    on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
    el["_leaflet_disable_click"] = true;
    return this;
  }

  // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.
  function preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
    return this;
  }

  // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.
  function stop(e) {
    preventDefault(e);
    stopPropagation(e);
    return this;
  }

  // @function getPropagationPath(ev: DOMEvent): Array
  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).
  // Returns an array containing the `HTMLElement`s that the given DOM event
  // should propagate to (if not stopped).
  function getPropagationPath(ev) {
    if (ev.composedPath) {
      return ev.composedPath();
    }

    var path = [];
    var el = ev.target;

    while (el) {
      path.push(el);
      el = el.parentNode;
    }
    return path;
  }

  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.
  function getMousePosition(e, container) {
    if (!container) {
      return new Point(e.clientX, e.clientY);
    }

    var scale = getScale(container),
      offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

    return new Point(
      // offset.left/top values are in page scale (like clientX/Y),
      // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
      (e.clientX - offset.left) / scale.x - container.clientLeft,
      (e.clientY - offset.top) / scale.y - container.clientTop
    );
  }

  //  except , Safari and
  // We need double the scroll pixels (see #7403 and #4538) for all Browsers
  // except OSX (Mac) -> 3x, Chrome running on Linux 1x

  var wheelPxFactor =
    Browser.linux && Browser.chrome
      ? window.devicePixelRatio
      : Browser.mac
      ? window.devicePixelRatio * 3
      : window.devicePixelRatio > 0
      ? 2 * window.devicePixelRatio
      : 1;
  // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.
  function getWheelDelta(e) {
    return Browser.edge
      ? e.wheelDeltaY / 2 // Don't trust window-geometry-based delta
      : e.deltaY && e.deltaMode === 0
      ? -e.deltaY / wheelPxFactor // Pixels
      : e.deltaY && e.deltaMode === 1
      ? -e.deltaY * 20 // Lines
      : e.deltaY && e.deltaMode === 2
      ? -e.deltaY * 60 // Pages
      : e.deltaX || e.deltaZ
      ? 0 // Skip horizontal/depth wheel events
      : e.wheelDelta
      ? (e.wheelDeltaY || e.wheelDelta) / 2 // Legacy IE pixels
      : e.detail && Math.abs(e.detail) < 32765
      ? -e.detail * 20 // Legacy Moz lines
      : e.detail
      ? (e.detail / -32765) * 60 // Legacy Moz pages
      : 0;
  }

  // check if element really left/entered the event target (for mouseenter/mouseleave)
  function isExternalTarget(el, e) {
    var related = e.relatedTarget;

    if (!related) {
      return true;
    }

    try {
      while (related && related !== el) {
        related = related.parentNode;
      }
    } catch (err) {
      return false;
    }
    return related !== el;
  }

  var DomEvent = {
    __proto__: null,
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getPropagationPath: getPropagationPath,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off,
  };

  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);
   *
   * myPositionMarker.on("click", function() {
   * 	var pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());
   * 	pos.y -= 25;
   * 	var fx = new L.PosAnimation();
   *
   * 	fx.once('end',function() {
   * 		pos.y += 25;
   * 		fx.run(myPositionMarker._icon, pos, 0.8);
   * 	});
   *
   * 	fx.run(myPositionMarker._icon, pos, 0.3);
   * });
   *
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({
    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
    // Run an animation of a given element to a new position, optionally setting
    // duration in seconds (`0.25` by default) and easing linearity factor (3rd
    // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
    // `0.5` by default).
    run: function (el, newPos, duration, easeLinearity) {
      this.stop();

      this._el = el;
      this._inProgress = true;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

      this._startPos = getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date();

      // @event start: Event
      // Fired when the animation starts
      this.fire("start");

      this._animate();
    },

    // @method stop()
    // Stops the animation (if currently running).
    stop: function () {
      if (!this._inProgress) {
        return;
      }

      this._step(true);
      this._complete();
    },

    _animate: function () {
      // animation loop
      this._animId = requestAnimFrame(this._animate, this);
      this._step();
    },

    _step: function (round) {
      var elapsed = +new Date() - this._startTime,
        duration = this._duration * 1000;

      if (elapsed < duration) {
        this._runFrame(this._easeOut(elapsed / duration), round);
      } else {
        this._runFrame(1);
        this._complete();
      }
    },

    _runFrame: function (progress, round) {
      var pos = this._startPos.add(this._offset.multiplyBy(progress));
      if (round) {
        pos._round();
      }
      setPosition(this._el, pos);

      // @event step: Event
      // Fired continuously during the animation.
      this.fire("step");
    },

    _complete: function () {
      cancelAnimFrame(this._animId);

      this._inProgress = false;
      // @event end: Event
      // Fired when the animation ends.
      this.fire("end");
    },

    _easeOut: function (t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    },
  });

  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API â it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({
    options: {
      // @section Map State Options
      // @option crs: CRS = L.CRS.EPSG3857
      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
      // sure what it means.
      crs: EPSG3857,

      // @option center: LatLng = undefined
      // Initial geographic center of the map
      center: undefined,

      // @option zoom: Number = undefined
      // Initial map zoom level
      zoom: undefined,

      // @option minZoom: Number = *
      // Minimum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the lowest of their `minZoom` options will be used instead.
      minZoom: undefined,

      // @option maxZoom: Number = *
      // Maximum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the highest of their `maxZoom` options will be used instead.
      maxZoom: undefined,

      // @option layers: Layer[] = []
      // Array of layers that will be added to the map initially
      layers: [],

      // @option maxBounds: LatLngBounds = null
      // When this option is set, the map restricts the view to the given
      // geographical bounds, bouncing the user back if the user tries to pan
      // outside the view. To set the restriction dynamically, use
      // [`setMaxBounds`](#map-setmaxbounds) method.
      maxBounds: undefined,

      // @option renderer: Renderer = *
      // The default method for drawing vector layers on the map. `L.SVG`
      // or `L.Canvas` by default depending on browser support.
      renderer: undefined,

      // @section Animation Options
      // @option zoomAnimation: Boolean = true
      // Whether the map zoom animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      zoomAnimation: true,

      // @option zoomAnimationThreshold: Number = 4
      // Won't animate zoom if the zoom difference exceeds this value.
      zoomAnimationThreshold: 4,

      // @option fadeAnimation: Boolean = true
      // Whether the tile fade animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      fadeAnimation: true,

      // @option markerZoomAnimation: Boolean = true
      // Whether markers animate their zoom with the zoom animation, if disabled
      // they will disappear for the length of the animation. By default it's
      // enabled in all browsers that support CSS3 Transitions except Android.
      markerZoomAnimation: true,

      // @option transform3DLimit: Number = 2^23
      // Defines the maximum size of a CSS translation transform. The default
      // value should not be changed unless a web browser positions layers in
      // the wrong place after doing a large `panBy`.
      transform3DLimit: 8388608, // Precision limit of a 32-bit float

      // @section Interaction Options
      // @option zoomSnap: Number = 1
      // Forces the map's zoom level to always be a multiple of this, particularly
      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
      // By default, the zoom level snaps to the nearest integer; lower values
      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
      zoomSnap: 1,

      // @option zoomDelta: Number = 1
      // Controls how much the map's zoom level will change after a
      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
      zoomDelta: 1,

      // @option trackResize: Boolean = true
      // Whether the map automatically handles browser window resize to update itself.
      trackResize: true,
    },

    initialize: function (id, options) {
      // (HTMLElement or String, Object)
      options = setOptions(this, options);

      // Make sure to assign internal flags at the beginning,
      // to avoid inconsistent state in some edge cases.
      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._sizeChanged = true;

      this._initContainer(id);
      this._initLayout();

      // hack for https://github.com/Leaflet/Leaflet/issues/1980
      this._onResize = bind(this._onResize, this);

      this._initEvents();

      if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
      }

      if (options.zoom !== undefined) {
        this._zoom = this._limitZoom(options.zoom);
      }

      if (options.center && options.zoom !== undefined) {
        this.setView(toLatLng(options.center), options.zoom, { reset: true });
      }

      this.callInitHooks();

      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
      this._zoomAnimated =
        TRANSITION &&
        Browser.any3d &&
        !Browser.mobileOpera &&
        this.options.zoomAnimation;

      // zoom transitions run with the same duration for all layers, so if one of transitionend events
      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
      if (this._zoomAnimated) {
        this._createAnimProxy();
        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
      }

      this._addLayers(this.options.layers);
    },

    // @section Methods for modifying map state

    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) with the given
    // animation options.
    setView: function (center, zoom, options) {
      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(
        toLatLng(center),
        zoom,
        this.options.maxBounds
      );
      options = options || {};

      this._stop();

      if (this._loaded && !options.reset && options !== true) {
        if (options.animate !== undefined) {
          options.zoom = extend({ animate: options.animate }, options.zoom);
          options.pan = extend(
            { animate: options.animate, duration: options.duration },
            options.pan
          );
        }

        // try animating pan or zoom
        var moved =
          this._zoom !== zoom
            ? this._tryAnimatedZoom &&
              this._tryAnimatedZoom(center, zoom, options.zoom)
            : this._tryAnimatedPan(center, options.pan);

        if (moved) {
          // prevent resize handler call, the view will refresh after animation anyway
          clearTimeout(this._sizeTimer);
          return this;
        }
      }

      // animation didn't start, just reset the map view
      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);

      return this;
    },

    // @method setZoom(zoom: Number, options?: Zoom/pan options): this
    // Sets the zoom of the map.
    setZoom: function (zoom, options) {
      if (!this._loaded) {
        this._zoom = zoom;
        return this;
      }
      return this.setView(this.getCenter(), zoom, { zoom: options });
    },

    // @method zoomIn(delta?: Number, options?: Zoom options): this
    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomIn: function (delta, options) {
      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom + delta, options);
    },

    // @method zoomOut(delta?: Number, options?: Zoom options): this
    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomOut: function (delta, options) {
      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom - delta, options);
    },

    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified geographical point on the map
    // stationary (e.g. used internally for scroll zoom and double-click zoom).
    // @alternative
    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
    setZoomAround: function (latlng, zoom, options) {
      var scale = this.getZoomScale(zoom),
        viewHalf = this.getSize().divideBy(2),
        containerPoint =
          latlng instanceof Point
            ? latlng
            : this.latLngToContainerPoint(latlng),
        centerOffset = containerPoint
          .subtract(viewHalf)
          .multiplyBy(1 - 1 / scale),
        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

      return this.setView(newCenter, zoom, { zoom: options });
    },

    _getBoundsCenterZoom: function (bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

      var paddingTL = toPoint(
          options.paddingTopLeft || options.padding || [0, 0]
        ),
        paddingBR = toPoint(
          options.paddingBottomRight || options.padding || [0, 0]
        ),
        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

      zoom =
        typeof options.maxZoom === "number"
          ? Math.min(options.maxZoom, zoom)
          : zoom;

      if (zoom === Infinity) {
        return {
          center: bounds.getCenter(),
          zoom: zoom,
        };
      }

      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
        swPoint = this.project(bounds.getSouthWest(), zoom),
        nePoint = this.project(bounds.getNorthEast(), zoom),
        center = this.unproject(
          swPoint.add(nePoint).divideBy(2).add(paddingOffset),
          zoom
        );

      return {
        center: center,
        zoom: zoom,
      };
    },

    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets a map view that contains the given geographical bounds with the
    // maximum zoom level possible.
    fitBounds: function (bounds, options) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        throw new Error("Bounds are not valid.");
      }

      var target = this._getBoundsCenterZoom(bounds, options);
      return this.setView(target.center, target.zoom, options);
    },

    // @method fitWorld(options?: fitBounds options): this
    // Sets a map view that mostly contains the whole world with the maximum
    // zoom level possible.
    fitWorld: function (options) {
      return this.fitBounds(
        [
          [-90, -180],
          [90, 180],
        ],
        options
      );
    },

    // @method panTo(latlng: LatLng, options?: Pan options): this
    // Pans the map to a given center.
    panTo: function (center, options) {
      // (LatLng)
      return this.setView(center, this._zoom, { pan: options });
    },

    // @method panBy(offset: Point, options?: Pan options): this
    // Pans the map by a given number of pixels (animated).
    panBy: function (offset, options) {
      offset = toPoint(offset).round();
      options = options || {};

      if (!offset.x && !offset.y) {
        return this.fire("moveend");
      }
      // If we pan too far, Chrome gets issues with tiles
      // and makes them disappear or appear in the wrong place (slightly offset) #2602
      if (options.animate !== true && !this.getSize().contains(offset)) {
        this._resetView(
          this.unproject(this.project(this.getCenter()).add(offset)),
          this.getZoom()
        );
        return this;
      }

      if (!this._panAnim) {
        this._panAnim = new PosAnimation();

        this._panAnim.on(
          {
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd,
          },
          this
        );
      }

      // don't fire movestart if animating inertia
      if (!options.noMoveStart) {
        this.fire("movestart");
      }

      // animate pan unless animate: false specified
      if (options.animate !== false) {
        addClass(this._mapPane, "leaflet-pan-anim");

        var newPos = this._getMapPanePos().subtract(offset).round();
        this._panAnim.run(
          this._mapPane,
          newPos,
          options.duration || 0.25,
          options.easeLinearity
        );
      } else {
        this._rawPanBy(offset);
        this.fire("move").fire("moveend");
      }

      return this;
    },

    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) performing a smooth
    // pan-zoom animation.
    flyTo: function (targetCenter, targetZoom, options) {
      options = options || {};
      if (options.animate === false || !Browser.any3d) {
        return this.setView(targetCenter, targetZoom, options);
      }

      this._stop();

      var from = this.project(this.getCenter()),
        to = this.project(targetCenter),
        size = this.getSize(),
        startZoom = this._zoom;

      targetCenter = toLatLng(targetCenter);
      targetZoom = targetZoom === undefined ? startZoom : targetZoom;

      var w0 = Math.max(size.x, size.y),
        w1 = w0 * this.getZoomScale(startZoom, targetZoom),
        u1 = to.distanceTo(from) || 1,
        rho = 1.42,
        rho2 = rho * rho;

      function r(i) {
        var s1 = i ? -1 : 1,
          s2 = i ? w1 : w0,
          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
          b1 = 2 * s2 * rho2 * u1,
          b = t1 / b1,
          sq = Math.sqrt(b * b + 1) - b;

        // workaround for floating point precision bug when sq = 0, log = -Infinite,
        // thus triggering an infinite loop in flyTo
        var log = sq < 0.000000001 ? -18 : Math.log(sq);

        return log;
      }

      function sinh(n) {
        return (Math.exp(n) - Math.exp(-n)) / 2;
      }
      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }
      function tanh(n) {
        return sinh(n) / cosh(n);
      }

      var r0 = r(0);

      function w(s) {
        return w0 * (cosh(r0) / cosh(r0 + rho * s));
      }
      function u(s) {
        return (w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0))) / rho2;
      }

      function easeOut(t) {
        return 1 - Math.pow(1 - t, 1.5);
      }

      var start = Date.now(),
        S = (r(1) - r0) / rho,
        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

      function frame() {
        var t = (Date.now() - start) / duration,
          s = easeOut(t) * S;

        if (t <= 1) {
          this._flyToFrame = requestAnimFrame(frame, this);

          this._move(
            this.unproject(
              from.add(to.subtract(from).multiplyBy(u(s) / u1)),
              startZoom
            ),
            this.getScaleZoom(w0 / w(s), startZoom),
            { flyTo: true }
          );
        } else {
          this._move(targetCenter, targetZoom)._moveEnd(true);
        }
      }

      this._moveStart(true, options.noMoveStart);

      frame.call(this);
      return this;
    },

    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    flyToBounds: function (bounds, options) {
      var target = this._getBoundsCenterZoom(bounds, options);
      return this.flyTo(target.center, target.zoom, options);
    },

    // @method setMaxBounds(bounds: LatLngBounds): this
    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
    setMaxBounds: function (bounds) {
      bounds = toLatLngBounds(bounds);

      if (this.listens("moveend", this._panInsideMaxBounds)) {
        this.off("moveend", this._panInsideMaxBounds);
      }

      if (!bounds.isValid()) {
        this.options.maxBounds = null;
        return this;
      }

      this.options.maxBounds = bounds;

      if (this._loaded) {
        this._panInsideMaxBounds();
      }

      return this.on("moveend", this._panInsideMaxBounds);
    },

    // @method setMinZoom(zoom: Number): this
    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
    setMinZoom: function (zoom) {
      var oldZoom = this.options.minZoom;
      this.options.minZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire("zoomlevelschange");

        if (this.getZoom() < this.options.minZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },

    // @method setMaxZoom(zoom: Number): this
    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
    setMaxZoom: function (zoom) {
      var oldZoom = this.options.maxZoom;
      this.options.maxZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire("zoomlevelschange");

        if (this.getZoom() > this.options.maxZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },

    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
    panInsideBounds: function (bounds, options) {
      this._enforcingBounds = true;
      var center = this.getCenter(),
        newCenter = this._limitCenter(
          center,
          this._zoom,
          toLatLngBounds(bounds)
        );

      if (!center.equals(newCenter)) {
        this.panTo(newCenter, options);
      }

      this._enforcingBounds = false;
      return this;
    },

    // @method panInside(latlng: LatLng, options?: padding options): this
    // Pans the map the minimum amount to make the `latlng` visible. Use
    // padding options to fit the display to more restricted bounds.
    // If `latlng` is already within the (optionally padded) display bounds,
    // the map will not be panned.
    panInside: function (latlng, options) {
      options = options || {};

      var paddingTL = toPoint(
          options.paddingTopLeft || options.padding || [0, 0]
        ),
        paddingBR = toPoint(
          options.paddingBottomRight || options.padding || [0, 0]
        ),
        pixelCenter = this.project(this.getCenter()),
        pixelPoint = this.project(latlng),
        pixelBounds = this.getPixelBounds(),
        paddedBounds = toBounds([
          pixelBounds.min.add(paddingTL),
          pixelBounds.max.subtract(paddingBR),
        ]),
        paddedSize = paddedBounds.getSize();

      if (!paddedBounds.contains(pixelPoint)) {
        this._enforcingBounds = true;
        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
        var offset = paddedBounds
          .extend(pixelPoint)
          .getSize()
          .subtract(paddedSize);
        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
        this.panTo(this.unproject(pixelCenter), options);
        this._enforcingBounds = false;
      }
      return this;
    },

    // @method invalidateSize(options: Zoom/pan options): this
    // Checks if the map container size changed and updates the map if so â
    // call it after you've changed the map size dynamically, also animating
    // pan by default. If `options.pan` is `false`, panning will not occur.
    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
    // that it doesn't happen often even if the method is called many
    // times in a row.

    // @alternative
    // @method invalidateSize(animate: Boolean): this
    // Checks if the map container size changed and updates the map if so â
    // call it after you've changed the map size dynamically, also animating
    // pan by default.
    invalidateSize: function (options) {
      if (!this._loaded) {
        return this;
      }

      options = extend(
        {
          animate: false,
          pan: true,
        },
        options === true ? { animate: true } : options
      );

      var oldSize = this.getSize();
      this._sizeChanged = true;
      this._lastCenter = null;

      var newSize = this.getSize(),
        oldCenter = oldSize.divideBy(2).round(),
        newCenter = newSize.divideBy(2).round(),
        offset = oldCenter.subtract(newCenter);

      if (!offset.x && !offset.y) {
        return this;
      }

      if (options.animate && options.pan) {
        this.panBy(offset);
      } else {
        if (options.pan) {
          this._rawPanBy(offset);
        }

        this.fire("move");

        if (options.debounceMoveend) {
          clearTimeout(this._sizeTimer);
          this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
        } else {
          this.fire("moveend");
        }
      }

      // @section Map state change events
      // @event resize: ResizeEvent
      // Fired when the map is resized.
      return this.fire("resize", {
        oldSize: oldSize,
        newSize: newSize,
      });
    },

    // @section Methods for modifying map state
    // @method stop(): this
    // Stops the currently running `panTo` or `flyTo` animation, if any.
    stop: function () {
      this.setZoom(this._limitZoom(this._zoom));
      if (!this.options.zoomSnap) {
        this.fire("viewreset");
      }
      return this._stop();
    },

    // @section Geolocation methods
    // @method locate(options?: Locate options): this
    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
    // and optionally sets the map view to the user's location with respect to
    // detection accuracy (or to the world view if geolocation failed).
    // Note that, if your page doesn't use HTTPS, this method will fail in
    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
    // See `Locate options` for more details.
    locate: function (options) {
      options = this._locateOptions = extend(
        {
          timeout: 10000,
          watch: false,
          // setView: false
          // maxZoom: <Number>
          // maximumAge: 0
          // enableHighAccuracy: false
        },
        options
      );

      if (!("geolocation" in navigator)) {
        this._handleGeolocationError({
          code: 0,
          message: "Geolocation not supported.",
        });
        return this;
      }

      var onResponse = bind(this._handleGeolocationResponse, this),
        onError = bind(this._handleGeolocationError, this);

      if (options.watch) {
        this._locationWatchId = navigator.geolocation.watchPosition(
          onResponse,
          onError,
          options
        );
      } else {
        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      }
      return this;
    },

    // @method stopLocate(): this
    // Stops watching location previously initiated by `map.locate({watch: true})`
    // and aborts resetting the map view if map.locate was called with
    // `{setView: true}`.
    stopLocate: function () {
      if (navigator.geolocation && navigator.geolocation.clearWatch) {
        navigator.geolocation.clearWatch(this._locationWatchId);
      }
      if (this._locateOptions) {
        this._locateOptions.setView = false;
      }
      return this;
    },

    _handleGeolocationError: function (error) {
      if (!this._container._leaflet_id) {
        return;
      }

      var c = error.code,
        message =
          error.message ||
          (c === 1
            ? "permission denied"
            : c === 2
            ? "position unavailable"
            : "timeout");

      if (this._locateOptions.setView && !this._loaded) {
        this.fitWorld();
      }

      // @section Location events
      // @event locationerror: ErrorEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.
      this.fire("locationerror", {
        code: c,
        message: "Geolocation error: " + message + ".",
      });
    },

    _handleGeolocationResponse: function (pos) {
      if (!this._container._leaflet_id) {
        return;
      }

      var lat = pos.coords.latitude,
        lng = pos.coords.longitude,
        latlng = new LatLng(lat, lng),
        bounds = latlng.toBounds(pos.coords.accuracy * 2),
        options = this._locateOptions;

      if (options.setView) {
        var zoom = this.getBoundsZoom(bounds);
        this.setView(
          latlng,
          options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom
        );
      }

      var data = {
        latlng: latlng,
        bounds: bounds,
        timestamp: pos.timestamp,
      };

      for (var i in pos.coords) {
        if (typeof pos.coords[i] === "number") {
          data[i] = pos.coords[i];
        }
      }

      // @event locationfound: LocationEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method)
      // went successfully.
      this.fire("locationfound", data);
    },

    // TODO Appropriate docs section?
    // @section Other Methods
    // @method addHandler(name: String, HandlerClass: Function): this
    // Adds a new `Handler` to the map, given its name and constructor function.
    addHandler: function (name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }

      var handler = (this[name] = new HandlerClass(this));

      this._handlers.push(handler);

      if (this.options[name]) {
        handler.enable();
      }

      return this;
    },

    // @method remove(): this
    // Destroys the map and clears all related event listeners.
    remove: function () {
      this._initEvents(true);
      if (this.options.maxBounds) {
        this.off("moveend", this._panInsideMaxBounds);
      }

      if (this._containerId !== this._container._leaflet_id) {
        throw new Error("Map container is being reused by another instance");
      }

      try {
        // throws error in IE6-8
        delete this._container._leaflet_id;
        delete this._containerId;
      } catch (e) {
        /*eslint-disable */
        this._container._leaflet_id = undefined;
        /* eslint-enable */
        this._containerId = undefined;
      }

      if (this._locationWatchId !== undefined) {
        this.stopLocate();
      }

      this._stop();

      remove(this._mapPane);

      if (this._clearControlPos) {
        this._clearControlPos();
      }
      if (this._resizeRequest) {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = null;
      }

      this._clearHandlers();

      if (this._loaded) {
        // @section Map state change events
        // @event unload: Event
        // Fired when the map is destroyed with [remove](#map-remove) method.
        this.fire("unload");
      }

      var i;
      for (i in this._layers) {
        this._layers[i].remove();
      }
      for (i in this._panes) {
        remove(this._panes[i]);
      }

      this._layers = [];
      this._panes = [];
      delete this._mapPane;
      delete this._renderer;

      return this;
    },

    // @section Other Methods
    // @method createPane(name: String, container?: HTMLElement): HTMLElement
    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
    // then returns it. The pane is created as a child of `container`, or
    // as a child of the main map pane if not set.
    createPane: function (name, container) {
      var className =
          "leaflet-pane" +
          (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""),
        pane = create$1("div", className, container || this._mapPane);

      if (name) {
        this._panes[name] = pane;
      }
      return pane;
    },

    // @section Methods for Getting Map State

    // @method getCenter(): LatLng
    // Returns the geographical center of the map view
    getCenter: function () {
      this._checkIfLoaded();

      if (this._lastCenter && !this._moved()) {
        return this._lastCenter.clone();
      }
      return this.layerPointToLatLng(this._getCenterLayerPoint());
    },

    // @method getZoom(): Number
    // Returns the current zoom level of the map view
    getZoom: function () {
      return this._zoom;
    },

    // @method getBounds(): LatLngBounds
    // Returns the geographical bounds visible in the current map view
    getBounds: function () {
      var bounds = this.getPixelBounds(),
        sw = this.unproject(bounds.getBottomLeft()),
        ne = this.unproject(bounds.getTopRight());

      return new LatLngBounds(sw, ne);
    },

    // @method getMinZoom(): Number
    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
    getMinZoom: function () {
      return this.options.minZoom === undefined
        ? this._layersMinZoom || 0
        : this.options.minZoom;
    },

    // @method getMaxZoom(): Number
    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
    getMaxZoom: function () {
      return this.options.maxZoom === undefined
        ? this._layersMaxZoom === undefined
          ? Infinity
          : this._layersMaxZoom
        : this.options.maxZoom;
    },

    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
    // Returns the maximum zoom level on which the given bounds fit to the map
    // view in its entirety. If `inside` (optional) is set to `true`, the method
    // instead returns the minimum zoom level on which the map view fits into
    // the given bounds in its entirety.
    getBoundsZoom: function (bounds, inside, padding) {
      // (LatLngBounds[, Boolean, Point]) -> Number
      bounds = toLatLngBounds(bounds);
      padding = toPoint(padding || [0, 0]);

      var zoom = this.getZoom() || 0,
        min = this.getMinZoom(),
        max = this.getMaxZoom(),
        nw = bounds.getNorthWest(),
        se = bounds.getSouthEast(),
        size = this.getSize().subtract(padding),
        boundsSize = toBounds(
          this.project(se, zoom),
          this.project(nw, zoom)
        ).getSize(),
        snap = Browser.any3d ? this.options.zoomSnap : 1,
        scalex = size.x / boundsSize.x,
        scaley = size.y / boundsSize.y,
        scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

      zoom = this.getScaleZoom(scale, zoom);

      if (snap) {
        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
        zoom = inside
          ? Math.ceil(zoom / snap) * snap
          : Math.floor(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },

    // @method getSize(): Point
    // Returns the current size of the map container (in pixels).
    getSize: function () {
      if (!this._size || this._sizeChanged) {
        this._size = new Point(
          this._container.clientWidth || 0,
          this._container.clientHeight || 0
        );

        this._sizeChanged = false;
      }
      return this._size.clone();
    },

    // @method getPixelBounds(): Bounds
    // Returns the bounds of the current map view in projected pixel
    // coordinates (sometimes useful in layer and overlay implementations).
    getPixelBounds: function (center, zoom) {
      var topLeftPoint = this._getTopLeftPoint(center, zoom);
      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    },

    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
    // the map pane? "left point of the map layer" can be confusing, specially
    // since there can be negative offsets.
    // @method getPixelOrigin(): Point
    // Returns the projected pixel coordinates of the top left point of
    // the map layer (useful in custom layer and overlay implementations).
    getPixelOrigin: function () {
      this._checkIfLoaded();
      return this._pixelOrigin;
    },

    // @method getPixelWorldBounds(zoom?: Number): Bounds
    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
    // If `zoom` is omitted, the map's current zoom level is used.
    getPixelWorldBounds: function (zoom) {
      return this.options.crs.getProjectedBounds(
        zoom === undefined ? this.getZoom() : zoom
      );
    },

    // @section Other Methods

    // @method getPane(pane: String|HTMLElement): HTMLElement
    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
    getPane: function (pane) {
      return typeof pane === "string" ? this._panes[pane] : pane;
    },

    // @method getPanes(): Object
    // Returns a plain object containing the names of all [panes](#map-pane) as keys and
    // the panes as values.
    getPanes: function () {
      return this._panes;
    },

    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the map.
    getContainer: function () {
      return this._container;
    },

    // @section Conversion Methods

    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
    // Returns the scale factor to be applied to a map transition from zoom level
    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
    getZoomScale: function (toZoom, fromZoom) {
      // TODO replace with universal implementation after refactoring projections
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      return crs.scale(toZoom) / crs.scale(fromZoom);
    },

    // @method getScaleZoom(scale: Number, fromZoom: Number): Number
    // Returns the zoom level that the map would end up at, if it is at `fromZoom`
    // level and everything is scaled by a factor of `scale`. Inverse of
    // [`getZoomScale`](#map-getZoomScale).
    getScaleZoom: function (scale, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      var zoom = crs.zoom(scale * crs.scale(fromZoom));
      return isNaN(zoom) ? Infinity : zoom;
    },

    // @method project(latlng: LatLng, zoom: Number): Point
    // Projects a geographical coordinate `LatLng` according to the projection
    // of the map's CRS, then scales it according to `zoom` and the CRS's
    // `Transformation`. The result is pixel coordinate relative to
    // the CRS origin.
    project: function (latlng, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
    },

    // @method unproject(point: Point, zoom: Number): LatLng
    // Inverse of [`project`](#map-project).
    unproject: function (point, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(toPoint(point), zoom);
    },

    // @method layerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding geographical coordinate (for the current zoom level).
    layerPointToLatLng: function (point) {
      var projectedPoint = toPoint(point).add(this.getPixelOrigin());
      return this.unproject(projectedPoint);
    },

    // @method latLngToLayerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the [origin pixel](#map-getpixelorigin).
    latLngToLayerPoint: function (latlng) {
      var projectedPoint = this.project(toLatLng(latlng))._round();
      return projectedPoint._subtract(this.getPixelOrigin());
    },

    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
    // CRS's bounds.
    // By default this means longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees.
    wrapLatLng: function (latlng) {
      return this.options.crs.wrapLatLng(toLatLng(latlng));
    },

    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring that
    // its center is within the CRS's bounds.
    // By default this means the center longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees, and the majority of the bounds
    // overlaps the CRS's bounds.
    wrapLatLngBounds: function (latlng) {
      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
    },

    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates according to
    // the map's CRS. By default this measures distance in meters.
    distance: function (latlng1, latlng2) {
      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
    },

    // @method containerPointToLayerPoint(point: Point): Point
    // Given a pixel coordinate relative to the map container, returns the corresponding
    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
    containerPointToLayerPoint: function (point) {
      // (Point)
      return toPoint(point).subtract(this._getMapPanePos());
    },

    // @method layerPointToContainerPoint(point: Point): Point
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding pixel coordinate relative to the map container.
    layerPointToContainerPoint: function (point) {
      // (Point)
      return toPoint(point).add(this._getMapPanePos());
    },

    // @method containerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the map container, returns
    // the corresponding geographical coordinate (for the current zoom level).
    containerPointToLatLng: function (point) {
      var layerPoint = this.containerPointToLayerPoint(toPoint(point));
      return this.layerPointToLatLng(layerPoint);
    },

    // @method latLngToContainerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the map container.
    latLngToContainerPoint: function (latlng) {
      return this.layerPointToContainerPoint(
        this.latLngToLayerPoint(toLatLng(latlng))
      );
    },

    // @method mouseEventToContainerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to the
    // map container where the event took place.
    mouseEventToContainerPoint: function (e) {
      return getMousePosition(e, this._container);
    },

    // @method mouseEventToLayerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to
    // the [origin pixel](#map-getpixelorigin) where the event took place.
    mouseEventToLayerPoint: function (e) {
      return this.containerPointToLayerPoint(
        this.mouseEventToContainerPoint(e)
      );
    },

    // @method mouseEventToLatLng(ev: MouseEvent): LatLng
    // Given a MouseEvent object, returns geographical coordinate where the
    // event took place.
    mouseEventToLatLng: function (e) {
      // (MouseEvent)
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    },

    // map initialization methods

    _initContainer: function (id) {
      var container = (this._container = get(id));

      if (!container) {
        throw new Error("Map container not found.");
      } else if (container._leaflet_id) {
        throw new Error("Map container is already initialized.");
      }

      on(container, "scroll", this._onScroll, this);
      this._containerId = stamp(container);
    },

    _initLayout: function () {
      var container = this._container;

      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

      addClass(
        container,
        "leaflet-container" +
          (Browser.touch ? " leaflet-touch" : "") +
          (Browser.retina ? " leaflet-retina" : "") +
          (Browser.ielt9 ? " leaflet-oldie" : "") +
          (Browser.safari ? " leaflet-safari" : "") +
          (this._fadeAnimated ? " leaflet-fade-anim" : "")
      );

      var position = getStyle(container, "position");

      if (
        position !== "absolute" &&
        position !== "relative" &&
        position !== "fixed" &&
        position !== "sticky"
      ) {
        container.style.position = "relative";
      }

      this._initPanes();

      if (this._initControlPos) {
        this._initControlPos();
      }
    },

    _initPanes: function () {
      var panes = (this._panes = {});
      this._paneRenderers = {};

      // @section
      //
      // Panes are DOM elements used to control the ordering of layers on the map. You
      // can access panes with [`map.getPane`](#map-getpane) or
      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
      // [`map.createPane`](#map-createpane) method.
      //
      // Every map has the following default panes that differ only in zIndex.
      //
      // @pane mapPane: HTMLElement = 'auto'
      // Pane that contains all other map panes

      this._mapPane = this.createPane("mapPane", this._container);
      setPosition(this._mapPane, new Point(0, 0));

      // @pane tilePane: HTMLElement = 200
      // Pane for `GridLayer`s and `TileLayer`s
      this.createPane("tilePane");
      // @pane overlayPane: HTMLElement = 400
      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
      this.createPane("overlayPane");
      // @pane shadowPane: HTMLElement = 500
      // Pane for overlay shadows (e.g. `Marker` shadows)
      this.createPane("shadowPane");
      // @pane markerPane: HTMLElement = 600
      // Pane for `Icon`s of `Marker`s
      this.createPane("markerPane");
      // @pane tooltipPane: HTMLElement = 650
      // Pane for `Tooltip`s.
      this.createPane("tooltipPane");
      // @pane popupPane: HTMLElement = 700
      // Pane for `Popup`s.
      this.createPane("popupPane");

      if (!this.options.markerZoomAnimation) {
        addClass(panes.markerPane, "leaflet-zoom-hide");
        addClass(panes.shadowPane, "leaflet-zoom-hide");
      }
    },

    // private methods that modify map state

    // @section Map state change events
    _resetView: function (center, zoom, noMoveStart) {
      setPosition(this._mapPane, new Point(0, 0));

      var loading = !this._loaded;
      this._loaded = true;
      zoom = this._limitZoom(zoom);

      this.fire("viewprereset");

      var zoomChanged = this._zoom !== zoom;
      this._moveStart(zoomChanged, noMoveStart)
        ._move(center, zoom)
        ._moveEnd(zoomChanged);

      // @event viewreset: Event
      // Fired when the map needs to redraw its content (this usually happens
      // on map zoom or load). Very useful for creating custom overlays.
      this.fire("viewreset");

      // @event load: Event
      // Fired when the map is initialized (when its center and zoom are set
      // for the first time).
      if (loading) {
        this.fire("load");
      }
    },

    _moveStart: function (zoomChanged, noMoveStart) {
      // @event zoomstart: Event
      // Fired when the map zoom is about to change (e.g. before zoom animation).
      // @event movestart: Event
      // Fired when the view of the map starts changing (e.g. user starts dragging the map).
      if (zoomChanged) {
        this.fire("zoomstart");
      }
      if (!noMoveStart) {
        this.fire("movestart");
      }
      return this;
    },

    _move: function (center, zoom, data, supressEvent) {
      if (zoom === undefined) {
        zoom = this._zoom;
      }
      var zoomChanged = this._zoom !== zoom;

      this._zoom = zoom;
      this._lastCenter = center;
      this._pixelOrigin = this._getNewPixelOrigin(center);

      if (!supressEvent) {
        // @event zoom: Event
        // Fired repeatedly during any change in zoom level,
        // including zoom and fly animations.
        if (zoomChanged || (data && data.pinch)) {
          // Always fire 'zoom' if pinching because #3530
          this.fire("zoom", data);
        }

        // @event move: Event
        // Fired repeatedly during any movement of the map,
        // including pan and fly animations.
        this.fire("move", data);
      } else if (data && data.pinch) {
        // Always fire 'zoom' if pinching because #3530
        this.fire("zoom", data);
      }
      return this;
    },

    _moveEnd: function (zoomChanged) {
      // @event zoomend: Event
      // Fired when the map zoom changed, after any animations.
      if (zoomChanged) {
        this.fire("zoomend");
      }

      // @event moveend: Event
      // Fired when the center of the map stops changing
      // (e.g. user stopped dragging the map or after non-centered zoom).
      return this.fire("moveend");
    },

    _stop: function () {
      cancelAnimFrame(this._flyToFrame);
      if (this._panAnim) {
        this._panAnim.stop();
      }
      return this;
    },

    _rawPanBy: function (offset) {
      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    },

    _getZoomSpan: function () {
      return this.getMaxZoom() - this.getMinZoom();
    },

    _panInsideMaxBounds: function () {
      if (!this._enforcingBounds) {
        this.panInsideBounds(this.options.maxBounds);
      }
    },

    _checkIfLoaded: function () {
      if (!this._loaded) {
        throw new Error("Set map center and zoom first.");
      }
    },

    // DOM event handling

    // @section Interaction events
    _initEvents: function (remove) {
      this._targets = {};
      this._targets[stamp(this._container)] = this;

      var onOff = remove ? off : on;

      // @event click: MouseEvent
      // Fired when the user clicks (or taps) the map.
      // @event dblclick: MouseEvent
      // Fired when the user double-clicks (or double-taps) the map.
      // @event mousedown: MouseEvent
      // Fired when the user pushes the mouse button on the map.
      // @event mouseup: MouseEvent
      // Fired when the user releases the mouse button on the map.
      // @event mouseover: MouseEvent
      // Fired when the mouse enters the map.
      // @event mouseout: MouseEvent
      // Fired when the mouse leaves the map.
      // @event mousemove: MouseEvent
      // Fired while the mouse moves over the map.
      // @event contextmenu: MouseEvent
      // Fired when the user pushes the right mouse button on the map, prevents
      // default browser context menu from showing if there are listeners on
      // this event. Also fired on mobile when the user holds a single touch
      // for a second (also called long press).
      // @event keypress: KeyboardEvent
      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
      // @event keydown: KeyboardEvent
      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
      // the `keydown` event is fired for keys that produce a character value and for keys
      // that do not produce a character value.
      // @event keyup: KeyboardEvent
      // Fired when the user releases a key from the keyboard while the map is focused.
      onOff(
        this._container,
        "click dblclick mousedown mouseup " +
          "mouseover mouseout mousemove contextmenu keypress keydown keyup",
        this._handleDOMEvent,
        this
      );

      if (this.options.trackResize) {
        onOff(window, "resize", this._onResize, this);
      }

      if (Browser.any3d && this.options.transform3DLimit) {
        (remove ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
      }
    },

    _onResize: function () {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = requestAnimFrame(function () {
        this.invalidateSize({ debounceMoveend: true });
      }, this);
    },

    _onScroll: function () {
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
    },

    _onMoveEnd: function () {
      var pos = this._getMapPanePos();
      if (
        Math.max(Math.abs(pos.x), Math.abs(pos.y)) >=
        this.options.transform3DLimit
      ) {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
        // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/
        this._resetView(this.getCenter(), this.getZoom());
      }
    },

    _findEventTargets: function (e, type) {
      var targets = [],
        target,
        isHover = type === "mouseout" || type === "mouseover",
        src = e.target || e.srcElement,
        dragging = false;

      while (src) {
        target = this._targets[stamp(src)];
        if (
          target &&
          (type === "click" || type === "preclick") &&
          this._draggableMoved(target)
        ) {
          // Prevent firing click after you just dragged an object.
          dragging = true;
          break;
        }
        if (target && target.listens(type, true)) {
          if (isHover && !isExternalTarget(src, e)) {
            break;
          }
          targets.push(target);
          if (isHover) {
            break;
          }
        }
        if (src === this._container) {
          break;
        }
        src = src.parentNode;
      }
      if (
        !targets.length &&
        !dragging &&
        !isHover &&
        this.listens(type, true)
      ) {
        targets = [this];
      }
      return targets;
    },

    _isClickDisabled: function (el) {
      while (el && el !== this._container) {
        if (el["_leaflet_disable_click"]) {
          return true;
        }
        el = el.parentNode;
      }
    },

    _handleDOMEvent: function (e) {
      var el = e.target || e.srcElement;
      if (
        !this._loaded ||
        el["_leaflet_disable_events"] ||
        (e.type === "click" && this._isClickDisabled(el))
      ) {
        return;
      }

      var type = e.type;

      if (type === "mousedown") {
        // prevents outline when clicking on keyboard-focusable element
        preventOutline(el);
      }

      this._fireDOMEvent(e, type);
    },

    _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],

    _fireDOMEvent: function (e, type, canvasTargets) {
      if (e.type === "click") {
        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
        // @event preclick: MouseEvent
        // Fired before mouse click on the map (sometimes useful when you
        // want something to happen on click before any existing click
        // handlers start running).
        var synth = extend({}, e);
        synth.type = "preclick";
        this._fireDOMEvent(synth, synth.type, canvasTargets);
      }

      // Find the layer the event is propagating from and its parents.
      var targets = this._findEventTargets(e, type);

      if (canvasTargets) {
        var filtered = []; // pick only targets with listeners
        for (var i = 0; i < canvasTargets.length; i++) {
          if (canvasTargets[i].listens(type, true)) {
            filtered.push(canvasTargets[i]);
          }
        }
        targets = filtered.concat(targets);
      }

      if (!targets.length) {
        return;
      }

      if (type === "contextmenu") {
        preventDefault(e);
      }

      var target = targets[0];
      var data = {
        originalEvent: e,
      };

      if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
        var isMarker =
          target.getLatLng && (!target._radius || target._radius <= 10);
        data.containerPoint = isMarker
          ? this.latLngToContainerPoint(target.getLatLng())
          : this.mouseEventToContainerPoint(e);
        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
        data.latlng = isMarker
          ? target.getLatLng()
          : this.layerPointToLatLng(data.layerPoint);
      }

      for (i = 0; i < targets.length; i++) {
        targets[i].fire(type, data, true);
        if (
          data.originalEvent._stopped ||
          (targets[i].options.bubblingMouseEvents === false &&
            indexOf(this._mouseEvents, type) !== -1)
        ) {
          return;
        }
      }
    },

    _draggableMoved: function (obj) {
      obj = obj.dragging && obj.dragging.enabled() ? obj : this;
      return (
        (obj.dragging && obj.dragging.moved()) ||
        (this.boxZoom && this.boxZoom.moved())
      );
    },

    _clearHandlers: function () {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    },

    // @section Other Methods

    // @method whenReady(fn: Function, context?: Object): this
    // Runs the given function `fn` when the map gets initialized with
    // a view (center and zoom) and at least one layer, or immediately
    // if it's already initialized, optionally passing a function context.
    whenReady: function (callback, context) {
      if (this._loaded) {
        callback.call(context || this, { target: this });
      } else {
        this.on("load", callback, context);
      }
      return this;
    },

    // private methods for getting map state

    _getMapPanePos: function () {
      return getPosition(this._mapPane) || new Point(0, 0);
    },

    _moved: function () {
      var pos = this._getMapPanePos();
      return pos && !pos.equals([0, 0]);
    },

    _getTopLeftPoint: function (center, zoom) {
      var pixelOrigin =
        center && zoom !== undefined
          ? this._getNewPixelOrigin(center, zoom)
          : this.getPixelOrigin();
      return pixelOrigin.subtract(this._getMapPanePos());
    },

    _getNewPixelOrigin: function (center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);
      return this.project(center, zoom)
        ._subtract(viewHalf)
        ._add(this._getMapPanePos())
        ._round();
    },

    _latLngToNewLayerPoint: function (latlng, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);
      return this.project(latlng, zoom)._subtract(topLeft);
    },

    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);
      return toBounds([
        this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
        this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
        this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
        this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft),
      ]);
    },

    // layer point of the current center
    _getCenterLayerPoint: function () {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    },

    // offset of the specified place to the current center in pixels
    _getCenterOffset: function (latlng) {
      return this.latLngToLayerPoint(latlng).subtract(
        this._getCenterLayerPoint()
      );
    },

    // adjust center for view to get inside bounds
    _limitCenter: function (center, zoom, bounds) {
      if (!bounds) {
        return center;
      }

      var centerPoint = this.project(center, zoom),
        viewHalf = this.getSize().divideBy(2),
        viewBounds = new Bounds(
          centerPoint.subtract(viewHalf),
          centerPoint.add(viewHalf)
        ),
        offset = this._getBoundsOffset(viewBounds, bounds, zoom);

      // If offset is less than a pixel, ignore.
      // This prevents unstable projections from getting into
      // an infinite loop of tiny offsets.
      if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
        return center;
      }

      return this.unproject(centerPoint.add(offset), zoom);
    },

    // adjust offset for view to get inside bounds
    _limitOffset: function (offset, bounds) {
      if (!bounds) {
        return offset;
      }

      var viewBounds = this.getPixelBounds(),
        newBounds = new Bounds(
          viewBounds.min.add(offset),
          viewBounds.max.add(offset)
        );

      return offset.add(this._getBoundsOffset(newBounds, bounds));
    },

    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
      var projectedMaxBounds = toBounds(
          this.project(maxBounds.getNorthEast(), zoom),
          this.project(maxBounds.getSouthWest(), zoom)
        ),
        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
        dx = this._rebound(minOffset.x, -maxOffset.x),
        dy = this._rebound(minOffset.y, -maxOffset.y);

      return new Point(dx, dy);
    },

    _rebound: function (left, right) {
      return left + right > 0
        ? Math.round(left - right) / 2
        : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    },

    _limitZoom: function (zoom) {
      var min = this.getMinZoom(),
        max = this.getMaxZoom(),
        snap = Browser.any3d ? this.options.zoomSnap : 1;
      if (snap) {
        zoom = Math.round(zoom / snap) * snap;
      }
      return Math.max(min, Math.min(max, zoom));
    },

    _onPanTransitionStep: function () {
      this.fire("move");
    },

    _onPanTransitionEnd: function () {
      removeClass(this._mapPane, "leaflet-pan-anim");
      this.fire("moveend");
    },

    _tryAnimatedPan: function (center, options) {
      // difference between the new and current centers in pixels
      var offset = this._getCenterOffset(center)._trunc();

      // don't animate too far unless animate: true specified in options
      if (
        (options && options.animate) !== true &&
        !this.getSize().contains(offset)
      ) {
        return false;
      }

      this.panBy(offset, options);

      return true;
    },

    _createAnimProxy: function () {
      var proxy = (this._proxy = create$1(
        "div",
        "leaflet-proxy leaflet-zoom-animated"
      ));
      this._panes.mapPane.appendChild(proxy);

      this.on(
        "zoomanim",
        function (e) {
          var prop = TRANSFORM,
            transform = this._proxy.style[prop];

          setTransform(
            this._proxy,
            this.project(e.center, e.zoom),
            this.getZoomScale(e.zoom, 1)
          );

          // workaround for case when transform is the same and so transitionend event is not fired
          if (transform === this._proxy.style[prop] && this._animatingZoom) {
            this._onZoomTransitionEnd();
          }
        },
        this
      );

      this.on("load moveend", this._animMoveEnd, this);

      this._on("unload", this._destroyAnimProxy, this);
    },

    _destroyAnimProxy: function () {
      remove(this._proxy);
      this.off("load moveend", this._animMoveEnd, this);
      delete this._proxy;
    },

    _animMoveEnd: function () {
      var c = this.getCenter(),
        z = this.getZoom();
      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
    },

    _catchTransitionEnd: function (e) {
      if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
        this._onZoomTransitionEnd();
      }
    },

    _nothingToAnimate: function () {
      return !this._container.getElementsByClassName("leaflet-zoom-animated")
        .length;
    },

    _tryAnimatedZoom: function (center, zoom, options) {
      if (this._animatingZoom) {
        return true;
      }

      options = options || {};

      // don't animate if disabled, not supported or zoom difference is too large
      if (
        !this._zoomAnimated ||
        options.animate === false ||
        this._nothingToAnimate() ||
        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold
      ) {
        return false;
      }

      // offset is the pixel coords of the zoom origin relative to the current center
      var scale = this.getZoomScale(zoom),
        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

      // don't animate if the zoom origin isn't within one screen from the current center, unless forced
      if (options.animate !== true && !this.getSize().contains(offset)) {
        return false;
      }

      requestAnimFrame(function () {
        this._moveStart(true, options.noMoveStart || false)._animateZoom(
          center,
          zoom,
          true
        );
      }, this);

      return true;
    },

    _animateZoom: function (center, zoom, startAnim, noUpdate) {
      if (!this._mapPane) {
        return;
      }

      if (startAnim) {
        this._animatingZoom = true;

        // remember what center/zoom to set after animation
        this._animateToCenter = center;
        this._animateToZoom = zoom;

        addClass(this._mapPane, "leaflet-zoom-anim");
      }

      // @section Other Events
      // @event zoomanim: ZoomAnimEvent
      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
      this.fire("zoomanim", {
        center: center,
        zoom: zoom,
        noUpdate: noUpdate,
      });

      if (!this._tempFireZoomEvent) {
        this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
      }

      this._move(this._animateToCenter, this._animateToZoom, undefined, true);

      // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
      setTimeout(bind(this._onZoomTransitionEnd, this), 250);
    },

    _onZoomTransitionEnd: function () {
      if (!this._animatingZoom) {
        return;
      }

      if (this._mapPane) {
        removeClass(this._mapPane, "leaflet-zoom-anim");
      }

      this._animatingZoom = false;

      this._move(this._animateToCenter, this._animateToZoom, undefined, true);

      if (this._tempFireZoomEvent) {
        this.fire("zoom");
      }
      delete this._tempFireZoomEvent;

      this.fire("move");

      this._moveEnd(true);
    },
  });

  // @section

  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.
  function createMap(id, options) {
    return new Map(id, options);
  }

  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */

  var Control = Class.extend({
    // @section
    // @aka Control Options
    options: {
      // @option position: String = 'topright'
      // The position of the control (one of the map corners). Possible values are `'topleft'`,
      // `'topright'`, `'bottomleft'` or `'bottomright'`
      position: "topright",
    },

    initialize: function (options) {
      setOptions(this, options);
    },

    /* @section
     * Classes extending L.Control will inherit the following methods:
     *
     * @method getPosition: string
     * Returns the position of the control.
     */
    getPosition: function () {
      return this.options.position;
    },

    // @method setPosition(position: string): this
    // Sets the position of the control.
    setPosition: function (position) {
      var map = this._map;

      if (map) {
        map.removeControl(this);
      }

      this.options.position = position;

      if (map) {
        map.addControl(this);
      }

      return this;
    },

    // @method getContainer: HTMLElement
    // Returns the HTMLElement that contains the control.
    getContainer: function () {
      return this._container;
    },

    // @method addTo(map: Map): this
    // Adds the control to the given map.
    addTo: function (map) {
      this.remove();
      this._map = map;

      var container = (this._container = this.onAdd(map)),
        pos = this.getPosition(),
        corner = map._controlCorners[pos];

      addClass(container, "leaflet-control");

      if (pos.indexOf("bottom") !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }

      this._map.on("unload", this.remove, this);

      return this;
    },

    // @method remove: this
    // Removes the control from the map it is currently active on.
    remove: function () {
      if (!this._map) {
        return this;
      }

      remove(this._container);

      if (this.onRemove) {
        this.onRemove(this._map);
      }

      this._map.off("unload", this.remove, this);
      this._map = null;

      return this;
    },

    _refocusOnMap: function (e) {
      // if map exists and event is not a keyboard event
      if (this._map && e && e.screenX > 0 && e.screenY > 0) {
        this._map.getContainer().focus();
      }
    },
  });

  var control = function (options) {
    return new Control(options);
  };

  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */
  Map.include({
    // @method addControl(control: Control): this
    // Adds the given control to the map
    addControl: function (control) {
      control.addTo(this);
      return this;
    },

    // @method removeControl(control: Control): this
    // Removes the given control from the map
    removeControl: function (control) {
      control.remove();
      return this;
    },

    _initControlPos: function () {
      var corners = (this._controlCorners = {}),
        l = "leaflet-",
        container = (this._controlContainer = create$1(
          "div",
          l + "control-container",
          this._container
        ));

      function createCorner(vSide, hSide) {
        var className = l + vSide + " " + l + hSide;

        corners[vSide + hSide] = create$1("div", className, container);
      }

      createCorner("top", "left");
      createCorner("top", "right");
      createCorner("bottom", "left");
      createCorner("bottom", "right");
    },

    _clearControlPos: function () {
      for (var i in this._controlCorners) {
        remove(this._controlCorners[i]);
      }
      remove(this._controlContainer);
      delete this._controlCorners;
      delete this._controlContainer;
    },
  });

  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
    // @section
    // @aka Control.Layers options
    options: {
      // @option collapsed: Boolean = true
      // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
      collapsed: true,
      position: "topright",

      // @option autoZIndex: Boolean = true
      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
      autoZIndex: true,

      // @option hideSingleBase: Boolean = false
      // If `true`, the base layers in the control will be hidden when there is only one.
      hideSingleBase: false,

      // @option sortLayers: Boolean = false
      // Whether to sort the layers. When `false`, layers will keep the order
      // in which they were added to the control.
      sortLayers: false,

      // @option sortFunction: Function = *
      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
      // that will be used for sorting the layers, when `sortLayers` is `true`.
      // The function receives both the `L.Layer` instances and their names, as in
      // `sortFunction(layerA, layerB, nameA, nameB)`.
      // By default, it sorts layers alphabetically by their name.
      sortFunction: function (layerA, layerB, nameA, nameB) {
        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
      },
    },

    initialize: function (baseLayers, overlays, options) {
      setOptions(this, options);

      this._layerControlInputs = [];
      this._layers = [];
      this._lastZIndex = 0;
      this._handlingClick = false;
      this._preventClick = false;

      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }

      for (i in overlays) {
        this._addLayer(overlays[i], i, true);
      }
    },

    onAdd: function (map) {
      this._initLayout();
      this._update();

      this._map = map;
      map.on("zoomend", this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.on("add remove", this._onLayerChange, this);
      }

      return this._container;
    },

    addTo: function (map) {
      Control.prototype.addTo.call(this, map);
      // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
      return this._expandIfNotCollapsed();
    },

    onRemove: function () {
      this._map.off("zoomend", this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.off("add remove", this._onLayerChange, this);
      }
    },

    // @method addBaseLayer(layer: Layer, name: String): this
    // Adds a base layer (radio button entry) with the given name to the control.
    addBaseLayer: function (layer, name) {
      this._addLayer(layer, name);
      return this._map ? this._update() : this;
    },

    // @method addOverlay(layer: Layer, name: String): this
    // Adds an overlay (checkbox entry) with the given name to the control.
    addOverlay: function (layer, name) {
      this._addLayer(layer, name, true);
      return this._map ? this._update() : this;
    },

    // @method removeLayer(layer: Layer): this
    // Remove the given layer from the control.
    removeLayer: function (layer) {
      layer.off("add remove", this._onLayerChange, this);

      var obj = this._getLayer(stamp(layer));
      if (obj) {
        this._layers.splice(this._layers.indexOf(obj), 1);
      }
      return this._map ? this._update() : this;
    },

    // @method expand(): this
    // Expand the control container if collapsed.
    expand: function () {
      addClass(this._container, "leaflet-control-layers-expanded");
      this._section.style.height = null;
      var acceptableHeight =
        this._map.getSize().y - (this._container.offsetTop + 50);
      if (acceptableHeight < this._section.clientHeight) {
        addClass(this._section, "leaflet-control-layers-scrollbar");
        this._section.style.height = acceptableHeight + "px";
      } else {
        removeClass(this._section, "leaflet-control-layers-scrollbar");
      }
      this._checkDisabledLayers();
      return this;
    },

    // @method collapse(): this
    // Collapse the control container if expanded.
    collapse: function () {
      removeClass(this._container, "leaflet-control-layers-expanded");
      return this;
    },

    _initLayout: function () {
      var className = "leaflet-control-layers",
        container = (this._container = create$1("div", className)),
        collapsed = this.options.collapsed;

      // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
      container.setAttribute("aria-haspopup", true);

      disableClickPropagation(container);
      disableScrollPropagation(container);

      var section = (this._section = create$1("section", className + "-list"));

      if (collapsed) {
        this._map.on("click", this.collapse, this);

        on(
          container,
          {
            mouseenter: this._expandSafely,
            mouseleave: this.collapse,
          },
          this
        );
      }

      var link = (this._layersLink = create$1(
        "a",
        className + "-toggle",
        container
      ));
      link.href = "#";
      link.title = "Layers";
      link.setAttribute("role", "button");

      on(
        link,
        {
          keydown: function (e) {
            if (e.keyCode === 13) {
              this._expandSafely();
            }
          },
          // Certain screen readers intercept the key event and instead send a click event
          click: function (e) {
            preventDefault(e);
            this._expandSafely();
          },
        },
        this
      );

      if (!collapsed) {
        this.expand();
      }

      this._baseLayersList = create$1("div", className + "-base", section);
      this._separator = create$1("div", className + "-separator", section);
      this._overlaysList = create$1("div", className + "-overlays", section);

      container.appendChild(section);
    },

    _getLayer: function (id) {
      for (var i = 0; i < this._layers.length; i++) {
        if (this._layers[i] && stamp(this._layers[i].layer) === id) {
          return this._layers[i];
        }
      }
    },

    _addLayer: function (layer, name, overlay) {
      if (this._map) {
        layer.on("add remove", this._onLayerChange, this);
      }

      this._layers.push({
        layer: layer,
        name: name,
        overlay: overlay,
      });

      if (this.options.sortLayers) {
        this._layers.sort(
          bind(function (a, b) {
            return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
          }, this)
        );
      }

      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
      }

      this._expandIfNotCollapsed();
    },

    _update: function () {
      if (!this._container) {
        return this;
      }

      empty(this._baseLayersList);
      empty(this._overlaysList);

      this._layerControlInputs = [];
      var baseLayersPresent,
        overlaysPresent,
        i,
        obj,
        baseLayersCount = 0;

      for (i = 0; i < this._layers.length; i++) {
        obj = this._layers[i];
        this._addItem(obj);
        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += !obj.overlay ? 1 : 0;
      }

      // Hide base layers section if there's only one layer.
      if (this.options.hideSingleBase) {
        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
        this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
      }

      this._separator.style.display =
        overlaysPresent && baseLayersPresent ? "" : "none";

      return this;
    },

    _onLayerChange: function (e) {
      if (!this._handlingClick) {
        this._update();
      }

      var obj = this._getLayer(stamp(e.target));

      // @namespace Map
      // @section Layer events
      // @event baselayerchange: LayersControlEvent
      // Fired when the base layer is changed through the [layers control](#control-layers).
      // @event overlayadd: LayersControlEvent
      // Fired when an overlay is selected through the [layers control](#control-layers).
      // @event overlayremove: LayersControlEvent
      // Fired when an overlay is deselected through the [layers control](#control-layers).
      // @namespace Control.Layers
      var type = obj.overlay
        ? e.type === "add"
          ? "overlayadd"
          : "overlayremove"
        : e.type === "add"
        ? "baselayerchange"
        : null;

      if (type) {
        this._map.fire(type, obj);
      }
    },

    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
    _createRadioElement: function (name, checked) {
      var radioHtml =
        '<input type="radio" class="leaflet-control-layers-selector" name="' +
        name +
        '"' +
        (checked ? ' checked="checked"' : "") +
        "/>";

      var radioFragment = document.createElement("div");
      radioFragment.innerHTML = radioHtml;

      return radioFragment.firstChild;
    },

    _addItem: function (obj) {
      var label = document.createElement("label"),
        checked = this._map.hasLayer(obj.layer),
        input;

      if (obj.overlay) {
        input = document.createElement("input");
        input.type = "checkbox";
        input.className = "leaflet-control-layers-selector";
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement(
          "leaflet-base-layers_" + stamp(this),
          checked
        );
      }

      this._layerControlInputs.push(input);
      input.layerId = stamp(obj.layer);

      on(input, "click", this._onInputClick, this);

      var name = document.createElement("span");
      name.innerHTML = " " + obj.name;

      // Helps from preventing layer control flicker when checkboxes are disabled
      // https://github.com/Leaflet/Leaflet/issues/2771
      var holder = document.createElement("span");

      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(name);

      var container = obj.overlay ? this._overlaysList : this._baseLayersList;
      container.appendChild(label);

      this._checkDisabledLayers();
      return label;
    },

    _onInputClick: function () {
      // expanding the control on mobile with a click can cause adding a layer - we don't want this
      if (this._preventClick) {
        return;
      }

      var inputs = this._layerControlInputs,
        input,
        layer;
      var addedLayers = [],
        removedLayers = [];

      this._handlingClick = true;

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;

        if (input.checked) {
          addedLayers.push(layer);
        } else if (!input.checked) {
          removedLayers.push(layer);
        }
      }

      // Bugfix issue 2318: Should remove all old layers before readding new ones
      for (i = 0; i < removedLayers.length; i++) {
        if (this._map.hasLayer(removedLayers[i])) {
          this._map.removeLayer(removedLayers[i]);
        }
      }
      for (i = 0; i < addedLayers.length; i++) {
        if (!this._map.hasLayer(addedLayers[i])) {
          this._map.addLayer(addedLayers[i]);
        }
      }

      this._handlingClick = false;

      this._refocusOnMap();
    },

    _checkDisabledLayers: function () {
      var inputs = this._layerControlInputs,
        input,
        layer,
        zoom = this._map.getZoom();

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;
        input.disabled =
          (layer.options.minZoom !== undefined &&
            zoom < layer.options.minZoom) ||
          (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);
      }
    },

    _expandIfNotCollapsed: function () {
      if (this._map && !this.options.collapsed) {
        this.expand();
      }
      return this;
    },

    _expandSafely: function () {
      var section = this._section;
      this._preventClick = true;
      on(section, "click", preventDefault);
      this.expand();
      var that = this;
      setTimeout(function () {
        off(section, "click", preventDefault);
        that._preventClick = false;
      });
    },
  });

  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
  var layers = function (baseLayers, overlays, options) {
    return new Layers(baseLayers, overlays, options);
  };

  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */

  var Zoom = Control.extend({
    // @section
    // @aka Control.Zoom options
    options: {
      position: "topleft",

      // @option zoomInText: String = '<span aria-hidden="true">+</span>'
      // The text set on the 'zoom in' button.
      zoomInText: '<span aria-hidden="true">+</span>',

      // @option zoomInTitle: String = 'Zoom in'
      // The title set on the 'zoom in' button.
      zoomInTitle: "Zoom in",

      // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
      // The text set on the 'zoom out' button.
      zoomOutText: '<span aria-hidden="true">&#x2212;</span>',

      // @option zoomOutTitle: String = 'Zoom out'
      // The title set on the 'zoom out' button.
      zoomOutTitle: "Zoom out",
    },

    onAdd: function (map) {
      var zoomName = "leaflet-control-zoom",
        container = create$1("div", zoomName + " leaflet-bar"),
        options = this.options;

      this._zoomInButton = this._createButton(
        options.zoomInText,
        options.zoomInTitle,
        zoomName + "-in",
        container,
        this._zoomIn
      );
      this._zoomOutButton = this._createButton(
        options.zoomOutText,
        options.zoomOutTitle,
        zoomName + "-out",
        container,
        this._zoomOut
      );

      this._updateDisabled();
      map.on("zoomend zoomlevelschange", this._updateDisabled, this);

      return container;
    },

    onRemove: function (map) {
      map.off("zoomend zoomlevelschange", this._updateDisabled, this);
    },

    disable: function () {
      this._disabled = true;
      this._updateDisabled();
      return this;
    },

    enable: function () {
      this._disabled = false;
      this._updateDisabled();
      return this;
    },

    _zoomIn: function (e) {
      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },

    _zoomOut: function (e) {
      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },

    _createButton: function (html, title, className, container, fn) {
      var link = create$1("a", className, container);
      link.innerHTML = html;
      link.href = "#";
      link.title = title;

      /*
       * Will force screen readers like VoiceOver to read this as "Zoom in - button"
       */
      link.setAttribute("role", "button");
      link.setAttribute("aria-label", title);

      disableClickPropagation(link);
      on(link, "click", stop);
      on(link, "click", fn, this);
      on(link, "click", this._refocusOnMap, this);

      return link;
    },

    _updateDisabled: function () {
      var map = this._map,
        className = "leaflet-disabled";

      removeClass(this._zoomInButton, className);
      removeClass(this._zoomOutButton, className);
      this._zoomInButton.setAttribute("aria-disabled", "false");
      this._zoomOutButton.setAttribute("aria-disabled", "false");

      if (this._disabled || map._zoom === map.getMinZoom()) {
        addClass(this._zoomOutButton, className);
        this._zoomOutButton.setAttribute("aria-disabled", "true");
      }
      if (this._disabled || map._zoom === map.getMaxZoom()) {
        addClass(this._zoomInButton, className);
        this._zoomInButton.setAttribute("aria-disabled", "true");
      }
    },
  });

  // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.
  Map.mergeOptions({
    zoomControl: true,
  });

  Map.addInitHook(function () {
    if (this.options.zoomControl) {
      // @section Controls
      // @property zoomControl: Control.Zoom
      // The default zoom control (only available if the
      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
      this.zoomControl = new Zoom();
      this.addControl(this.zoomControl);
    }
  });

  // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control
  var zoom = function (options) {
    return new Zoom(options);
  };

  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */

  var Scale = Control.extend({
    // @section
    // @aka Control.Scale options
    options: {
      position: "bottomleft",

      // @option maxWidth: Number = 100
      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
      maxWidth: 100,

      // @option metric: Boolean = True
      // Whether to show the metric scale line (m/km).
      metric: true,

      // @option imperial: Boolean = True
      // Whether to show the imperial scale line (mi/ft).
      imperial: true,

      // @option updateWhenIdle: Boolean = false
      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
    },

    onAdd: function (map) {
      var className = "leaflet-control-scale",
        container = create$1("div", className),
        options = this.options;

      this._addScales(options, className + "-line", container);

      map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
      map.whenReady(this._update, this);

      return container;
    },

    onRemove: function (map) {
      map.off(
        this.options.updateWhenIdle ? "moveend" : "move",
        this._update,
        this
      );
    },

    _addScales: function (options, className, container) {
      if (options.metric) {
        this._mScale = create$1("div", className, container);
      }
      if (options.imperial) {
        this._iScale = create$1("div", className, container);
      }
    },

    _update: function () {
      var map = this._map,
        y = map.getSize().y / 2;

      var maxMeters = map.distance(
        map.containerPointToLatLng([0, y]),
        map.containerPointToLatLng([this.options.maxWidth, y])
      );

      this._updateScales(maxMeters);
    },

    _updateScales: function (maxMeters) {
      if (this.options.metric && maxMeters) {
        this._updateMetric(maxMeters);
      }
      if (this.options.imperial && maxMeters) {
        this._updateImperial(maxMeters);
      }
    },

    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters),
        label = meters < 1000 ? meters + " m" : meters / 1000 + " km";

      this._updateScale(this._mScale, label, meters / maxMeters);
    },

    _updateImperial: function (maxMeters) {
      var maxFeet = maxMeters * 3.2808399,
        maxMiles,
        miles,
        feet;

      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this._getRoundNum(maxMiles);
        this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
      } else {
        feet = this._getRoundNum(maxFeet);
        this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
      }
    },

    _updateScale: function (scale, text, ratio) {
      scale.style.width = Math.round(this.options.maxWidth * ratio) + "px";
      scale.innerHTML = text;
    },

    _getRoundNum: function (num) {
      var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1),
        d = num / pow10;

      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

      return pow10 * d;
    },
  });

  // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.
  var scale = function (options) {
    return new Scale(options);
  };

  var ukrainianFlag =
    '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';

  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */

  var Attribution = Control.extend({
    // @section
    // @aka Control.Attribution options
    options: {
      position: "bottomright",

      // @option prefix: String|false = 'Leaflet'
      // The HTML text shown before the attributions. Pass `false` to disable.
      prefix:
        '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' +
        (Browser.inlineSvg ? ukrainianFlag + " " : "") +
        "Leaflet</a>",
    },

    initialize: function (options) {
      setOptions(this, options);

      this._attributions = {};
    },

    onAdd: function (map) {
      map.attributionControl = this;
      this._container = create$1("div", "leaflet-control-attribution");
      disableClickPropagation(this._container);

      // TODO ugly, refactor
      for (var i in map._layers) {
        if (map._layers[i].getAttribution) {
          this.addAttribution(map._layers[i].getAttribution());
        }
      }

      this._update();

      map.on("layeradd", this._addAttribution, this);

      return this._container;
    },

    onRemove: function (map) {
      map.off("layeradd", this._addAttribution, this);
    },

    _addAttribution: function (ev) {
      if (ev.layer.getAttribution) {
        this.addAttribution(ev.layer.getAttribution());
        ev.layer.once(
          "remove",
          function () {
            this.removeAttribution(ev.layer.getAttribution());
          },
          this
        );
      }
    },

    // @method setPrefix(prefix: String|false): this
    // The HTML text shown before the attributions. Pass `false` to disable.
    setPrefix: function (prefix) {
      this.options.prefix = prefix;
      this._update();
      return this;
    },

    // @method addAttribution(text: String): this
    // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
    addAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (!this._attributions[text]) {
        this._attributions[text] = 0;
      }
      this._attributions[text]++;

      this._update();

      return this;
    },

    // @method removeAttribution(text: String): this
    // Removes an attribution text.
    removeAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (this._attributions[text]) {
        this._attributions[text]--;
        this._update();
      }

      return this;
    },

    _update: function () {
      if (!this._map) {
        return;
      }

      var attribs = [];

      for (var i in this._attributions) {
        if (this._attributions[i]) {
          attribs.push(i);
        }
      }

      var prefixAndAttribs = [];

      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }
      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(", "));
      }

      this._container.innerHTML = prefixAndAttribs.join(
        ' <span aria-hidden="true">|</span> '
      );
    },
  });

  // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.
  Map.mergeOptions({
    attributionControl: true,
  });

  Map.addInitHook(function () {
    if (this.options.attributionControl) {
      new Attribution().addTo(this);
    }
  });

  // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.
  var attribution = function (options) {
    return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;

  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;

  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */

  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
    initialize: function (map) {
      this._map = map;
    },

    // @method enable(): this
    // Enables the handler
    enable: function () {
      if (this._enabled) {
        return this;
      }

      this._enabled = true;
      this.addHooks();
      return this;
    },

    // @method disable(): this
    // Disables the handler
    disable: function () {
      if (!this._enabled) {
        return this;
      }

      this._enabled = false;
      this.removeHooks();
      return this;
    },

    // @method enabled(): Boolean
    // Returns `true` if the handler is enabled
    enabled: function () {
      return !!this._enabled;
    },

    // @section Extension methods
    // Classes inheriting from `Handler` must implement the two following methods:
    // @method addHooks()
    // Called when the handler is enabled, should add event hooks.
    // @method removeHooks()
    // Called when the handler is disabled, should remove the event hooks added previously.
  });

  // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.
  Handler.addTo = function (map, name) {
    map.addHandler(name, this);
    return this;
  };

  var Mixin = { Events: Events };

  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = Browser.touch ? "touchstart mousedown" : "mousedown";

  var Draggable = Evented.extend({
    options: {
      // @section
      // @aka Draggable options
      // @option clickTolerance: Number = 3
      // The max number of pixels a user can shift the mouse pointer during a click
      // for it to be considered a valid click (as opposed to a mouse drag).
      clickTolerance: 3,
    },

    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
    initialize: function (element, dragStartTarget, preventOutline, options) {
      setOptions(this, options);

      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
      this._preventOutline = preventOutline;
    },

    // @method enable()
    // Enables the dragging ability
    enable: function () {
      if (this._enabled) {
        return;
      }

      on(this._dragStartTarget, START, this._onDown, this);

      this._enabled = true;
    },

    // @method disable()
    // Disables the dragging ability
    disable: function () {
      if (!this._enabled) {
        return;
      }

      // If we're currently dragging this draggable,
      // disabling it counts as first ending the drag.
      if (Draggable._dragging === this) {
        this.finishDrag(true);
      }

      off(this._dragStartTarget, START, this._onDown, this);

      this._enabled = false;
      this._moved = false;
    },

    _onDown: function (e) {
      // Ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (!this._enabled) {
        return;
      }

      this._moved = false;

      if (hasClass(this._element, "leaflet-zoom-anim")) {
        return;
      }

      if (e.touches && e.touches.length !== 1) {
        // Finish dragging to avoid conflict with touchZoom
        if (Draggable._dragging === this) {
          this.finishDrag();
        }
        return;
      }

      if (
        Draggable._dragging ||
        e.shiftKey ||
        (e.which !== 1 && e.button !== 1 && !e.touches)
      ) {
        return;
      }
      Draggable._dragging = this; // Prevent dragging multiple objects at once.

      if (this._preventOutline) {
        preventOutline(this._element);
      }

      disableImageDrag();
      disableTextSelection();

      if (this._moving) {
        return;
      }

      // @event down: Event
      // Fired when a drag is about to start.
      this.fire("down");

      var first = e.touches ? e.touches[0] : e,
        sizedParent = getSizedParentNode(this._element);

      this._startPoint = new Point(first.clientX, first.clientY);
      this._startPos = getPosition(this._element);

      // Cache the scale, so that we can continuously compensate for it during drag (_onMove).
      this._parentScale = getScale(sizedParent);

      var mouseevent = e.type === "mousedown";
      on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
      on(
        document,
        mouseevent ? "mouseup" : "touchend touchcancel",
        this._onUp,
        this
      );
    },

    _onMove: function (e) {
      // Ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (!this._enabled) {
        return;
      }

      if (e.touches && e.touches.length > 1) {
        this._moved = true;
        return;
      }

      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
        offset = new Point(first.clientX, first.clientY)._subtract(
          this._startPoint
        );

      if (!offset.x && !offset.y) {
        return;
      }
      if (
        Math.abs(offset.x) + Math.abs(offset.y) <
        this.options.clickTolerance
      ) {
        return;
      }

      // We assume that the parent container's position, border and scale do not change for the duration of the drag.
      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
      // and we can use the cached value for the scale.
      offset.x /= this._parentScale.x;
      offset.y /= this._parentScale.y;

      preventDefault(e);

      if (!this._moved) {
        // @event dragstart: Event
        // Fired when a drag starts
        this.fire("dragstart");

        this._moved = true;

        addClass(document.body, "leaflet-dragging");

        this._lastTarget = e.target || e.srcElement;
        // IE and Edge do not give the <use> element, so fetch it
        // if necessary
        if (
          window.SVGElementInstance &&
          this._lastTarget instanceof window.SVGElementInstance
        ) {
          this._lastTarget = this._lastTarget.correspondingUseElement;
        }
        addClass(this._lastTarget, "leaflet-drag-target");
      }

      this._newPos = this._startPos.add(offset);
      this._moving = true;

      this._lastEvent = e;
      this._updatePosition();
    },

    _updatePosition: function () {
      var e = { originalEvent: this._lastEvent };

      // @event predrag: Event
      // Fired continuously during dragging *before* each corresponding
      // update of the element's position.
      this.fire("predrag", e);
      setPosition(this._element, this._newPos);

      // @event drag: Event
      // Fired continuously during dragging.
      this.fire("drag", e);
    },

    _onUp: function () {
      // Ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (!this._enabled) {
        return;
      }
      this.finishDrag();
    },

    finishDrag: function (noInertia) {
      removeClass(document.body, "leaflet-dragging");

      if (this._lastTarget) {
        removeClass(this._lastTarget, "leaflet-drag-target");
        this._lastTarget = null;
      }

      off(document, "mousemove touchmove", this._onMove, this);
      off(document, "mouseup touchend touchcancel", this._onUp, this);

      enableImageDrag();
      enableTextSelection();

      var fireDragend = this._moved && this._moving;

      this._moving = false;
      Draggable._dragging = false;

      if (fireDragend) {
        // @event dragend: DragEndEvent
        // Fired when the drag ends.
        this.fire("dragend", {
          noInertia: noInertia,
          distance: this._newPos.distanceTo(this._startPos),
        });
      }
    },
  });

  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */
  function clipPolygon(points, bounds, round) {
    var clippedPoints,
      edges = [1, 4, 2, 8],
      i,
      j,
      k,
      a,
      b,
      len,
      edge,
      p;

    for (i = 0, len = points.length; i < len; i++) {
      points[i]._code = _getBitCode(points[i], bounds);
    }

    // for each edge (left, bottom, right, top)
    for (k = 0; k < 4; k++) {
      edge = edges[k];
      clippedPoints = [];

      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        a = points[i];
        b = points[j];

        // if a is inside the clip window
        if (!(a._code & edge)) {
          // if b is outside the clip window (a->b goes out of screen)
          if (b._code & edge) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }
          clippedPoints.push(a);

          // else if b is inside the clip window (a->b enters the screen)
        } else if (!(b._code & edge)) {
          p = _getEdgeIntersection(b, a, edge, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }
      }
      points = clippedPoints;
    }

    return points;
  }

  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.
   */
  function polygonCenter(latlngs, crs) {
    var i, j, p1, p2, f, area, x, y, center;

    if (!latlngs || latlngs.length === 0) {
      throw new Error("latlngs not passed");
    }

    if (!isFlat(latlngs)) {
      console.warn("latlngs are not flat! Only the first ring will be used");
      latlngs = latlngs[0];
    }

    var centroidLatLng = toLatLng([0, 0]);

    var bounds = toLatLngBounds(latlngs);
    var areaBounds =
      bounds.getNorthWest().distanceTo(bounds.getSouthWest()) *
      bounds.getNorthEast().distanceTo(bounds.getNorthWest());
    // tests showed that below 1700 rounding errors are happening
    if (areaBounds < 1700) {
      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
      centroidLatLng = centroid(latlngs);
    }

    var len = latlngs.length;
    var points = [];
    for (i = 0; i < len; i++) {
      var latlng = toLatLng(latlngs[i]);
      points.push(
        crs.project(
          toLatLng([
            latlng.lat - centroidLatLng.lat,
            latlng.lng - centroidLatLng.lng,
          ])
        )
      );
    }

    area = x = y = 0;

    // polygon centroid algorithm;
    for (i = 0, j = len - 1; i < len; j = i++) {
      p1 = points[i];
      p2 = points[j];

      f = p1.y * p2.x - p2.y * p1.x;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
      area += f * 3;
    }

    if (area === 0) {
      // Polygon is so small that all points are on same pixel.
      center = points[0];
    } else {
      center = [x / area, y / area];
    }

    var latlngCenter = crs.unproject(toPoint(center));
    return toLatLng([
      latlngCenter.lat + centroidLatLng.lat,
      latlngCenter.lng + centroidLatLng.lng,
    ]);
  }

  /* @function centroid(latlngs: LatLng[]): LatLng
   * Returns the 'center of mass' of the passed LatLngs.
   */
  function centroid(coords) {
    var latSum = 0;
    var lngSum = 0;
    var len = 0;
    for (var i = 0; i < coords.length; i++) {
      var latlng = toLatLng(coords[i]);
      latSum += latlng.lat;
      lngSum += latlng.lng;
      len++;
    }
    return toLatLng([latSum / len, lngSum / len]);
  }

  var PolyUtil = {
    __proto__: null,
    clipPolygon: clipPolygon,
    polygonCenter: polygonCenter,
    centroid: centroid,
  };

  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */

  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.

  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).
  function simplify(points, tolerance) {
    if (!tolerance || !points.length) {
      return points.slice();
    }

    var sqTolerance = tolerance * tolerance;

    // stage 1: vertex reduction
    points = _reducePoints(points, sqTolerance);

    // stage 2: Douglas-Peucker simplification
    points = _simplifyDP(points, sqTolerance);

    return points;
  }

  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.
  function pointToSegmentDistance(p, p1, p2) {
    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  }

  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.
  function closestPointOnSegment(p, p1, p2) {
    return _sqClosestPointOnSegment(p, p1, p2);
  }

  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
  function _simplifyDP(points, sqTolerance) {
    var len = points.length,
      ArrayConstructor =
        typeof Uint8Array !== undefined + "" ? Uint8Array : Array,
      markers = new ArrayConstructor(len);

    markers[0] = markers[len - 1] = 1;

    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

    var i,
      newPoints = [];

    for (i = 0; i < len; i++) {
      if (markers[i]) {
        newPoints.push(points[i]);
      }
    }

    return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {
    var maxSqDist = 0,
      index,
      i,
      sqDist;

    for (i = first + 1; i <= last - 1; i++) {
      sqDist = _sqClosestPointOnSegment(
        points[i],
        points[first],
        points[last],
        true
      );

      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }

    if (maxSqDist > sqTolerance) {
      markers[index] = 1;

      _simplifyDPStep(points, markers, sqTolerance, first, index);
      _simplifyDPStep(points, markers, sqTolerance, index, last);
    }
  }

  // reduce points that are too close to each other to a single point
  function _reducePoints(points, sqTolerance) {
    var reducedPoints = [points[0]];

    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
      if (_sqDist(points[i], points[prev]) > sqTolerance) {
        reducedPoints.push(points[i]);
        prev = i;
      }
    }
    if (prev < len - 1) {
      reducedPoints.push(points[len - 1]);
    }
    return reducedPoints;
  }

  var _lastCode;

  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  function clipSegment(a, b, bounds, useLastCode, round) {
    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
      codeB = _getBitCode(b, bounds),
      codeOut,
      p,
      newCode;

    // save 2nd code to avoid calculating it on the next segment
    _lastCode = codeB;

    while (true) {
      // if a,b is inside the clip window (trivial accept)
      if (!(codeA | codeB)) {
        return [a, b];
      }

      // if a,b is outside the clip window (trivial reject)
      if (codeA & codeB) {
        return false;
      }

      // other cases
      codeOut = codeA || codeB;
      p = _getEdgeIntersection(a, b, codeOut, bounds, round);
      newCode = _getBitCode(p, bounds);

      if (codeOut === codeA) {
        a = p;
        codeA = newCode;
      } else {
        b = p;
        codeB = newCode;
      }
    }
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
    var dx = b.x - a.x,
      dy = b.y - a.y,
      min = bounds.min,
      max = bounds.max,
      x,
      y;

    if (code & 8) {
      // top
      x = a.x + (dx * (max.y - a.y)) / dy;
      y = max.y;
    } else if (code & 4) {
      // bottom
      x = a.x + (dx * (min.y - a.y)) / dy;
      y = min.y;
    } else if (code & 2) {
      // right
      x = max.x;
      y = a.y + (dy * (max.x - a.x)) / dx;
    } else if (code & 1) {
      // left
      x = min.x;
      y = a.y + (dy * (min.x - a.x)) / dx;
    }

    return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
    var code = 0;

    if (p.x < bounds.min.x) {
      // left
      code |= 1;
    } else if (p.x > bounds.max.x) {
      // right
      code |= 2;
    }

    if (p.y < bounds.min.y) {
      // bottom
      code |= 4;
    } else if (p.y > bounds.max.y) {
      // top
      code |= 8;
    }

    return code;
  }

  // square distance (to avoid unnecessary Math.sqrt calls)
  function _sqDist(p1, p2) {
    var dx = p2.x - p1.x,
      dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  }

  // return closest point on segment or distance to that point
  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
    var x = p1.x,
      y = p1.y,
      dx = p2.x - x,
      dy = p2.y - y,
      dot = dx * dx + dy * dy,
      t;

    if (dot > 0) {
      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;

    return sqDist ? dx * dx + dy * dy : new Point(x, y);
  }

  // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.
  function isFlat(latlngs) {
    return (
      !isArray(latlngs[0]) ||
      (typeof latlngs[0][0] !== "object" &&
        typeof latlngs[0][0] !== "undefined")
    );
  }

  function _flat(latlngs) {
    console.warn(
      "Deprecated use of _flat, please use L.LineUtil.isFlat instead."
    );
    return isFlat(latlngs);
  }

  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.
   */
  function polylineCenter(latlngs, crs) {
    var i, halfDist, segDist, dist, p1, p2, ratio, center;

    if (!latlngs || latlngs.length === 0) {
      throw new Error("latlngs not passed");
    }

    if (!isFlat(latlngs)) {
      console.warn("latlngs are not flat! Only the first ring will be used");
      latlngs = latlngs[0];
    }

    var centroidLatLng = toLatLng([0, 0]);

    var bounds = toLatLngBounds(latlngs);
    var areaBounds =
      bounds.getNorthWest().distanceTo(bounds.getSouthWest()) *
      bounds.getNorthEast().distanceTo(bounds.getNorthWest());
    // tests showed that below 1700 rounding errors are happening
    if (areaBounds < 1700) {
      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
      centroidLatLng = centroid(latlngs);
    }

    var len = latlngs.length;
    var points = [];
    for (i = 0; i < len; i++) {
      var latlng = toLatLng(latlngs[i]);
      points.push(
        crs.project(
          toLatLng([
            latlng.lat - centroidLatLng.lat,
            latlng.lng - centroidLatLng.lng,
          ])
        )
      );
    }

    for (i = 0, halfDist = 0; i < len - 1; i++) {
      halfDist += points[i].distanceTo(points[i + 1]) / 2;
    }

    // The line is so small in the current view that all points are on the same pixel.
    if (halfDist === 0) {
      center = points[0];
    } else {
      for (i = 0, dist = 0; i < len - 1; i++) {
        p1 = points[i];
        p2 = points[i + 1];
        segDist = p1.distanceTo(p2);
        dist += segDist;

        if (dist > halfDist) {
          ratio = (dist - halfDist) / segDist;
          center = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];
          break;
        }
      }
    }

    var latlngCenter = crs.unproject(toPoint(center));
    return toLatLng([
      latlngCenter.lat + centroidLatLng.lat,
      latlngCenter.lng + centroidLatLng.lng,
    ]);
  }

  var LineUtil = {
    __proto__: null,
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat,
    polylineCenter: polylineCenter,
  };

  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection â the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
    project: function (latlng) {
      return new Point(latlng.lng, latlng.lat);
    },

    unproject: function (point) {
      return new LatLng(point.y, point.x);
    },

    bounds: new Bounds([-180, -90], [180, 90]),
  };

  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection â more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
    R: 6378137,
    R_MINOR: 6356752.314245179,

    bounds: new Bounds(
      [-20037508.34279, -15496570.73972],
      [20037508.34279, 18764656.23138]
    ),

    project: function (latlng) {
      var d = Math.PI / 180,
        r = this.R,
        y = latlng.lat * d,
        tmp = this.R_MINOR / r,
        e = Math.sqrt(1 - tmp * tmp),
        con = e * Math.sin(y);

      var ts =
        Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
      y = -r * Math.log(Math.max(ts, 1e-10));

      return new Point(latlng.lng * d * r, y);
    },

    unproject: function (point) {
      var d = 180 / Math.PI,
        r = this.R,
        tmp = this.R_MINOR / r,
        e = Math.sqrt(1 - tmp * tmp),
        ts = Math.exp(-point.y / r),
        phi = Math.PI / 2 - 2 * Math.atan(ts);

      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
        con = e * Math.sin(phi);
        con = Math.pow((1 - con) / (1 + con), e / 2);
        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
        phi += dphi;
      }

      return new LatLng(phi * d, (point.x * d) / r);
    },
  };

  /*
   * @class Projection

   * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).

   * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid

   * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.

   * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.

   * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.

   */

  var index = {
    __proto__: null,
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator,
  };

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */
  var EPSG3395 = extend({}, Earth, {
    code: "EPSG:3395",
    projection: Mercator,

    transformation: (function () {
      var scale = 0.5 / (Math.PI * Mercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    })(),
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
    code: "EPSG:4326",
    projection: LonLat,
    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5),
  });

  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
    projection: LonLat,
    transformation: toTransformation(1, 0, -1, 0),

    scale: function (zoom) {
      return Math.pow(2, zoom);
    },

    zoom: function (scale) {
      return Math.log(scale) / Math.LN2;
    },

    distance: function (latlng1, latlng2) {
      var dx = latlng2.lng - latlng1.lng,
        dy = latlng2.lat - latlng1.lat;

      return Math.sqrt(dx * dx + dy * dy);
    },

    infinite: true,
  });

  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;

  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */

  var Layer = Evented.extend({
    // Classes extending `L.Layer` will inherit the following options:
    options: {
      // @option pane: String = 'overlayPane'
      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
      pane: "overlayPane",

      // @option attribution: String = null
      // String to be shown in the attribution control, e.g. "Â© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
      attribution: null,

      bubblingMouseEvents: true,
    },

    /* @section
     * Classes extending `L.Layer` will inherit the following methods:
     *
     * @method addTo(map: Map|LayerGroup): this
     * Adds the layer to the given map or layer group.
     */
    addTo: function (map) {
      map.addLayer(this);
      return this;
    },

    // @method remove: this
    // Removes the layer from the map it is currently active on.
    remove: function () {
      return this.removeFrom(this._map || this._mapToAdd);
    },

    // @method removeFrom(map: Map): this
    // Removes the layer from the given map
    //
    // @alternative
    // @method removeFrom(group: LayerGroup): this
    // Removes the layer from the given `LayerGroup`
    removeFrom: function (obj) {
      if (obj) {
        obj.removeLayer(this);
      }
      return this;
    },

    // @method getPane(name? : String): HTMLElement
    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
    getPane: function (name) {
      return this._map.getPane(
        name ? this.options[name] || name : this.options.pane
      );
    },

    addInteractiveTarget: function (targetEl) {
      this._map._targets[stamp(targetEl)] = this;
      return this;
    },

    removeInteractiveTarget: function (targetEl) {
      delete this._map._targets[stamp(targetEl)];
      return this;
    },

    // @method getAttribution: String
    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
    getAttribution: function () {
      return this.options.attribution;
    },

    _layerAdd: function (e) {
      var map = e.target;

      // check in case layer gets added and then removed before the map is ready
      if (!map.hasLayer(this)) {
        return;
      }

      this._map = map;
      this._zoomAnimated = map._zoomAnimated;

      if (this.getEvents) {
        var events = this.getEvents();
        map.on(events, this);
        this.once(
          "remove",
          function () {
            map.off(events, this);
          },
          this
        );
      }

      this.onAdd(map);

      this.fire("add");
      map.fire("layeradd", { layer: this });
    },
  });

  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */

  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */
  Map.include({
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the map
    addLayer: function (layer) {
      if (!layer._layerAdd) {
        throw new Error("The provided object is not a Layer.");
      }

      var id = stamp(layer);
      if (this._layers[id]) {
        return this;
      }
      this._layers[id] = layer;

      layer._mapToAdd = this;

      if (layer.beforeAdd) {
        layer.beforeAdd(this);
      }

      this.whenReady(layer._layerAdd, layer);

      return this;
    },

    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the map.
    removeLayer: function (layer) {
      var id = stamp(layer);

      if (!this._layers[id]) {
        return this;
      }

      if (this._loaded) {
        layer.onRemove(this);
      }

      delete this._layers[id];

      if (this._loaded) {
        this.fire("layerremove", { layer: layer });
        layer.fire("remove");
      }

      layer._map = layer._mapToAdd = null;

      return this;
    },

    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the map
    hasLayer: function (layer) {
      return stamp(layer) in this._layers;
    },

    /* @method eachLayer(fn: Function, context?: Object): this
     * Iterates over the layers of the map, optionally specifying context of the iterator function.
     * ```
     * map.eachLayer(function(layer){
     *     layer.bindPopup('Hello');
     * });
     * ```
     */
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    },

    _addLayers: function (layers) {
      layers = layers ? (isArray(layers) ? layers : [layers]) : [];

      for (var i = 0, len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    },

    _addZoomLimit: function (layer) {
      if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
        this._zoomBoundLayers[stamp(layer)] = layer;
        this._updateZoomLevels();
      }
    },

    _removeZoomLimit: function (layer) {
      var id = stamp(layer);

      if (this._zoomBoundLayers[id]) {
        delete this._zoomBoundLayers[id];
        this._updateZoomLevels();
      }
    },

    _updateZoomLevels: function () {
      var minZoom = Infinity,
        maxZoom = -Infinity,
        oldZoomSpan = this._getZoomSpan();

      for (var i in this._zoomBoundLayers) {
        var options = this._zoomBoundLayers[i].options;

        minZoom =
          options.minZoom === undefined
            ? minZoom
            : Math.min(minZoom, options.minZoom);
        maxZoom =
          options.maxZoom === undefined
            ? maxZoom
            : Math.max(maxZoom, options.maxZoom);
      }

      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

      // @section Map state change events
      // @event zoomlevelschange: Event
      // Fired when the number of zoomlevels on the map is changed due
      // to adding or removing a layer.
      if (oldZoomSpan !== this._getZoomSpan()) {
        this.fire("zoomlevelschange");
      }

      if (
        this.options.maxZoom === undefined &&
        this._layersMaxZoom &&
        this.getZoom() > this._layersMaxZoom
      ) {
        this.setZoom(this._layersMaxZoom);
      }
      if (
        this.options.minZoom === undefined &&
        this._layersMinZoom &&
        this.getZoom() < this._layersMinZoom
      ) {
        this.setZoom(this._layersMinZoom);
      }
    },
  });

  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Interactive layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({
    initialize: function (layers, options) {
      setOptions(this, options);

      this._layers = {};

      var i, len;

      if (layers) {
        for (i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      }
    },

    // @method addLayer(layer: Layer): this
    // Adds the given layer to the group.
    addLayer: function (layer) {
      var id = this.getLayerId(layer);

      this._layers[id] = layer;

      if (this._map) {
        this._map.addLayer(layer);
      }

      return this;
    },

    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the group.
    // @alternative
    // @method removeLayer(id: Number): this
    // Removes the layer with the given internal ID from the group.
    removeLayer: function (layer) {
      var id = layer in this._layers ? layer : this.getLayerId(layer);

      if (this._map && this._layers[id]) {
        this._map.removeLayer(this._layers[id]);
      }

      delete this._layers[id];

      return this;
    },

    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the group.
    // @alternative
    // @method hasLayer(id: Number): Boolean
    // Returns `true` if the given internal ID is currently added to the group.
    hasLayer: function (layer) {
      var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
      return layerId in this._layers;
    },

    // @method clearLayers(): this
    // Removes all the layers from the group.
    clearLayers: function () {
      return this.eachLayer(this.removeLayer, this);
    },

    // @method invoke(methodName: String, â¦): this
    // Calls `methodName` on every layer contained in this group, passing any
    // additional parameters. Has no effect if the layers contained do not
    // implement `methodName`.
    invoke: function (methodName) {
      var args = Array.prototype.slice.call(arguments, 1),
        i,
        layer;

      for (i in this._layers) {
        layer = this._layers[i];

        if (layer[methodName]) {
          layer[methodName].apply(layer, args);
        }
      }

      return this;
    },

    onAdd: function (map) {
      this.eachLayer(map.addLayer, map);
    },

    onRemove: function (map) {
      this.eachLayer(map.removeLayer, map);
    },

    // @method eachLayer(fn: Function, context?: Object): this
    // Iterates over the layers of the group, optionally specifying context of the iterator function.
    // ```js
    // group.eachLayer(function (layer) {
    // 	layer.bindPopup('Hello');
    // });
    // ```
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    },

    // @method getLayer(id: Number): Layer
    // Returns the layer with the given internal ID.
    getLayer: function (id) {
      return this._layers[id];
    },

    // @method getLayers(): Layer[]
    // Returns an array of all the layers added to the group.
    getLayers: function () {
      var layers = [];
      this.eachLayer(layers.push, layers);
      return layers;
    },

    // @method setZIndex(zIndex: Number): this
    // Calls `setZIndex` on every layer contained in this group, passing the z-index.
    setZIndex: function (zIndex) {
      return this.invoke("setZIndex", zIndex);
    },

    // @method getLayerId(layer: Layer): Number
    // Returns the internal ID for a layer
    getLayerId: function (layer) {
      return stamp(layer);
    },
  });

  // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.
  var layerGroup = function (layers, options) {
    return new LayerGroup(layers, options);
  };

  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */

  var FeatureGroup = LayerGroup.extend({
    addLayer: function (layer) {
      if (this.hasLayer(layer)) {
        return this;
      }

      layer.addEventParent(this);

      LayerGroup.prototype.addLayer.call(this, layer);

      // @event layeradd: LayerEvent
      // Fired when a layer is added to this `FeatureGroup`
      return this.fire("layeradd", { layer: layer });
    },

    removeLayer: function (layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }
      if (layer in this._layers) {
        layer = this._layers[layer];
      }

      layer.removeEventParent(this);

      LayerGroup.prototype.removeLayer.call(this, layer);

      // @event layerremove: LayerEvent
      // Fired when a layer is removed from this `FeatureGroup`
      return this.fire("layerremove", { layer: layer });
    },

    // @method setStyle(style: Path options): this
    // Sets the given path options to each layer of the group that has a `setStyle` method.
    setStyle: function (style) {
      return this.invoke("setStyle", style);
    },

    // @method bringToFront(): this
    // Brings the layer group to the top of all other layers
    bringToFront: function () {
      return this.invoke("bringToFront");
    },

    // @method bringToBack(): this
    // Brings the layer group to the back of all other layers
    bringToBack: function () {
      return this.invoke("bringToBack");
    },

    // @method getBounds(): LatLngBounds
    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
    getBounds: function () {
      var bounds = new LatLngBounds();

      for (var id in this._layers) {
        var layer = this._layers[id];
        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
      }
      return bounds;
    },
  });

  // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.
  var featureGroup = function (layers, options) {
    return new FeatureGroup(layers, options);
  };

  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */

  var Icon = Class.extend({
    /* @section
     * @aka Icon options
     *
     * @option iconUrl: String = null
     * **(required)** The URL to the icon image (absolute or relative to your script path).
     *
     * @option iconRetinaUrl: String = null
     * The URL to a retina sized version of the icon image (absolute or relative to your
     * script path). Used for Retina screen devices.
     *
     * @option iconSize: Point = null
     * Size of the icon image in pixels.
     *
     * @option iconAnchor: Point = null
     * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
     * will be aligned so that this point is at the marker's geographical location. Centered
     * by default if size is specified, also can be set in CSS with negative margins.
     *
     * @option popupAnchor: Point = [0, 0]
     * The coordinates of the point from which popups will "open", relative to the icon anchor.
     *
     * @option tooltipAnchor: Point = [0, 0]
     * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
     *
     * @option shadowUrl: String = null
     * The URL to the icon shadow image. If not specified, no shadow image will be created.
     *
     * @option shadowRetinaUrl: String = null
     *
     * @option shadowSize: Point = null
     * Size of the shadow image in pixels.
     *
     * @option shadowAnchor: Point = null
     * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
     * as iconAnchor if not specified).
     *
     * @option className: String = ''
     * A custom class name to assign to both icon and shadow images. Empty by default.
     */

    options: {
      popupAnchor: [0, 0],
      tooltipAnchor: [0, 0],

      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,
    },

    initialize: function (options) {
      setOptions(this, options);
    },

    // @method createIcon(oldIcon?: HTMLElement): HTMLElement
    // Called internally when the icon has to be shown, returns a `<img>` HTML element
    // styled according to the options.
    createIcon: function (oldIcon) {
      return this._createIcon("icon", oldIcon);
    },

    // @method createShadow(oldIcon?: HTMLElement): HTMLElement
    // As `createIcon`, but for the shadow beneath it.
    createShadow: function (oldIcon) {
      return this._createIcon("shadow", oldIcon);
    },

    _createIcon: function (name, oldIcon) {
      var src = this._getIconUrl(name);

      if (!src) {
        if (name === "icon") {
          throw new Error("iconUrl not set in Icon options (see the docs).");
        }
        return null;
      }

      var img = this._createImg(
        src,
        oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null
      );
      this._setIconStyles(img, name);

      if (this.options.crossOrigin || this.options.crossOrigin === "") {
        img.crossOrigin =
          this.options.crossOrigin === true ? "" : this.options.crossOrigin;
      }

      return img;
    },

    _setIconStyles: function (img, name) {
      var options = this.options;
      var sizeOption = options[name + "Size"];

      if (typeof sizeOption === "number") {
        sizeOption = [sizeOption, sizeOption];
      }

      var size = toPoint(sizeOption),
        anchor = toPoint(
          (name === "shadow" && options.shadowAnchor) ||
            options.iconAnchor ||
            (size && size.divideBy(2, true))
        );

      img.className =
        "leaflet-marker-" + name + " " + (options.className || "");

      if (anchor) {
        img.style.marginLeft = -anchor.x + "px";
        img.style.marginTop = -anchor.y + "px";
      }

      if (size) {
        img.style.width = size.x + "px";
        img.style.height = size.y + "px";
      }
    },

    _createImg: function (src, el) {
      el = el || document.createElement("img");
      el.src = src;
      return el;
    },

    _getIconUrl: function (name) {
      return (
        (Browser.retina && this.options[name + "RetinaUrl"]) ||
        this.options[name + "Url"]
      );
    },
  });

  // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.
  function icon(options) {
    return new Icon(options);
  }

  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */

  var IconDefault = Icon.extend({
    options: {
      iconUrl: "marker-icon.png",
      iconRetinaUrl: "marker-icon-2x.png",
      shadowUrl: "marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      tooltipAnchor: [16, -28],
      shadowSize: [41, 41],
    },

    _getIconUrl: function (name) {
      if (typeof IconDefault.imagePath !== "string") {
        // Deprecated, backwards-compatibility only
        IconDefault.imagePath = this._detectIconPath();
      }

      // @option imagePath: String
      // `Icon.Default` will try to auto-detect the location of the
      // blue icon images. If you are placing these images in a non-standard
      // way, set this option to point to the right path.
      return (
        (this.options.imagePath || IconDefault.imagePath) +
        Icon.prototype._getIconUrl.call(this, name)
      );
    },

    _stripUrl: function (path) {
      // separate function to use in tests
      var strip = function (str, re, idx) {
        var match = re.exec(str);
        return match && match[idx];
      };
      path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
      return path && strip(path, /^(.*)marker-icon\.png$/, 1);
    },

    _detectIconPath: function () {
      var el = create$1("div", "leaflet-default-icon-path", document.body);
      var path =
        getStyle(el, "background-image") || getStyle(el, "backgroundImage"); // IE8

      document.body.removeChild(el);
      path = this._stripUrl(path);
      if (path) {
        return path;
      }
      var link = document.querySelector('link[href$="leaflet.css"]');
      if (!link) {
        return "";
      }
      return link.href.substring(
        0,
        link.href.length - "leaflet.css".length - 1
      );
    },
  });

  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */

  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
    initialize: function (marker) {
      this._marker = marker;
    },

    addHooks: function () {
      var icon = this._marker._icon;

      if (!this._draggable) {
        this._draggable = new Draggable(icon, icon, true);
      }

      this._draggable
        .on(
          {
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd,
          },
          this
        )
        .enable();

      addClass(icon, "leaflet-marker-draggable");
    },

    removeHooks: function () {
      this._draggable
        .off(
          {
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd,
          },
          this
        )
        .disable();

      if (this._marker._icon) {
        removeClass(this._marker._icon, "leaflet-marker-draggable");
      }
    },

    moved: function () {
      return this._draggable && this._draggable._moved;
    },

    _adjustPan: function (e) {
      var marker = this._marker,
        map = marker._map,
        speed = this._marker.options.autoPanSpeed,
        padding = this._marker.options.autoPanPadding,
        iconPos = getPosition(marker._icon),
        bounds = map.getPixelBounds(),
        origin = map.getPixelOrigin();

      var panBounds = toBounds(
        bounds.min._subtract(origin).add(padding),
        bounds.max._subtract(origin).subtract(padding)
      );

      if (!panBounds.contains(iconPos)) {
        // Compute incremental movement
        var movement = toPoint(
          (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) /
            (bounds.max.x - panBounds.max.x) -
            (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) /
              (bounds.min.x - panBounds.min.x),

          (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) /
            (bounds.max.y - panBounds.max.y) -
            (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) /
              (bounds.min.y - panBounds.min.y)
        ).multiplyBy(speed);

        map.panBy(movement, { animate: false });

        this._draggable._newPos._add(movement);
        this._draggable._startPos._add(movement);

        setPosition(marker._icon, this._draggable._newPos);
        this._onDrag(e);

        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },

    _onDragStart: function () {
      // @section Dragging events
      // @event dragstart: Event
      // Fired when the user starts dragging the marker.

      // @event movestart: Event
      // Fired when the marker starts moving (because of dragging).

      this._oldLatLng = this._marker.getLatLng();

      // When using ES6 imports it could not be set when `Popup` was not imported as well
      this._marker.closePopup && this._marker.closePopup();

      this._marker.fire("movestart").fire("dragstart");
    },

    _onPreDrag: function (e) {
      if (this._marker.options.autoPan) {
        cancelAnimFrame(this._panRequest);
        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },

    _onDrag: function (e) {
      var marker = this._marker,
        shadow = marker._shadow,
        iconPos = getPosition(marker._icon),
        latlng = marker._map.layerPointToLatLng(iconPos);

      // update shadow position
      if (shadow) {
        setPosition(shadow, iconPos);
      }

      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng;

      // @event drag: Event
      // Fired repeatedly while the user drags the marker.
      marker.fire("move", e).fire("drag", e);
    },

    _onDragEnd: function (e) {
      // @event dragend: DragEndEvent
      // Fired when the user stops dragging the marker.

      cancelAnimFrame(this._panRequest);

      // @event moveend: Event
      // Fired when the marker stops moving (because of dragging).
      delete this._oldLatLng;
      this._marker.fire("moveend").fire("dragend", e);
    },
  });

  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({
    // @section
    // @aka Marker options
    options: {
      // @option icon: Icon = *
      // Icon instance to use for rendering the marker.
      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
      // If not specified, a common instance of `L.Icon.Default` is used.
      icon: new IconDefault(),

      // Option inherited from "Interactive layer" abstract class
      interactive: true,

      // @option keyboard: Boolean = true
      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
      keyboard: true,

      // @option title: String = ''
      // Text for the browser tooltip that appear on marker hover (no tooltip by default).
      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
      title: "",

      // @option alt: String = 'Marker'
      // Text for the `alt` attribute of the icon image.
      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
      alt: "Marker",

      // @option zIndexOffset: Number = 0
      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
      zIndexOffset: 0,

      // @option opacity: Number = 1.0
      // The opacity of the marker.
      opacity: 1,

      // @option riseOnHover: Boolean = false
      // If `true`, the marker will get on top of others when you hover the mouse over it.
      riseOnHover: false,

      // @option riseOffset: Number = 250
      // The z-index offset used for the `riseOnHover` feature.
      riseOffset: 250,

      // @option pane: String = 'markerPane'
      // `Map pane` where the markers icon will be added.
      pane: "markerPane",

      // @option shadowPane: String = 'shadowPane'
      // `Map pane` where the markers shadow will be added.
      shadowPane: "shadowPane",

      // @option bubblingMouseEvents: Boolean = false
      // When `true`, a mouse event on this marker will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: false,

      // @option autoPanOnFocus: Boolean = true
      // When `true`, the map will pan whenever the marker is focused (via
      // e.g. pressing `tab` on the keyboard) to ensure the marker is
      // visible within the map's bounds
      autoPanOnFocus: true,

      // @section Draggable marker options
      // @option draggable: Boolean = false
      // Whether the marker is draggable with mouse/touch or not.
      draggable: false,

      // @option autoPan: Boolean = false
      // Whether to pan the map when dragging this marker near its edge or not.
      autoPan: false,

      // @option autoPanPadding: Point = Point(50, 50)
      // Distance (in pixels to the left/right and to the top/bottom) of the
      // map edge to start panning the map.
      autoPanPadding: [50, 50],

      // @option autoPanSpeed: Number = 10
      // Number of pixels the map should pan by.
      autoPanSpeed: 10,
    },

    /* @section
     *
     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
     */

    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
    },

    onAdd: function (map) {
      this._zoomAnimated =
        this._zoomAnimated && map.options.markerZoomAnimation;

      if (this._zoomAnimated) {
        map.on("zoomanim", this._animateZoom, this);
      }

      this._initIcon();
      this.update();
    },

    onRemove: function (map) {
      if (this.dragging && this.dragging.enabled()) {
        this.options.draggable = true;
        this.dragging.removeHooks();
      }
      delete this.dragging;

      if (this._zoomAnimated) {
        map.off("zoomanim", this._animateZoom, this);
      }

      this._removeIcon();
      this._removeShadow();
    },

    getEvents: function () {
      return {
        zoom: this.update,
        viewreset: this.update,
      };
    },

    // @method getLatLng: LatLng
    // Returns the current geographical position of the marker.
    getLatLng: function () {
      return this._latlng;
    },

    // @method setLatLng(latlng: LatLng): this
    // Changes the marker position to the given point.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.update();

      // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
      return this.fire("move", { oldLatLng: oldLatLng, latlng: this._latlng });
    },

    // @method setZIndexOffset(offset: Number): this
    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
    setZIndexOffset: function (offset) {
      this.options.zIndexOffset = offset;
      return this.update();
    },

    // @method getIcon: Icon
    // Returns the current icon used by the marker
    getIcon: function () {
      return this.options.icon;
    },

    // @method setIcon(icon: Icon): this
    // Changes the marker icon.
    setIcon: function (icon) {
      this.options.icon = icon;

      if (this._map) {
        this._initIcon();
        this.update();
      }

      if (this._popup) {
        this.bindPopup(this._popup, this._popup.options);
      }

      return this;
    },

    getElement: function () {
      return this._icon;
    },

    update: function () {
      if (this._icon && this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();
        this._setPos(pos);
      }

      return this;
    },

    _initIcon: function () {
      var options = this.options,
        classToAdd =
          "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");

      var icon = options.icon.createIcon(this._icon),
        addIcon = false;

      // if we're not reusing the icon, remove the old one and init new one
      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }
        addIcon = true;

        if (options.title) {
          icon.title = options.title;
        }

        if (icon.tagName === "IMG") {
          icon.alt = options.alt || "";
        }
      }

      addClass(icon, classToAdd);

      if (options.keyboard) {
        icon.tabIndex = "0";
        icon.setAttribute("role", "button");
      }

      this._icon = icon;

      if (options.riseOnHover) {
        this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex,
        });
      }

      if (this.options.autoPanOnFocus) {
        on(icon, "focus", this._panOnFocus, this);
      }

      var newShadow = options.icon.createShadow(this._shadow),
        addShadow = false;

      if (newShadow !== this._shadow) {
        this._removeShadow();
        addShadow = true;
      }

      if (newShadow) {
        addClass(newShadow, classToAdd);
        newShadow.alt = "";
      }
      this._shadow = newShadow;

      if (options.opacity < 1) {
        this._updateOpacity();
      }

      if (addIcon) {
        this.getPane().appendChild(this._icon);
      }
      this._initInteraction();
      if (newShadow && addShadow) {
        this.getPane(options.shadowPane).appendChild(this._shadow);
      }
    },

    _removeIcon: function () {
      if (this.options.riseOnHover) {
        this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex,
        });
      }

      if (this.options.autoPanOnFocus) {
        off(this._icon, "focus", this._panOnFocus, this);
      }

      remove(this._icon);
      this.removeInteractiveTarget(this._icon);

      this._icon = null;
    },

    _removeShadow: function () {
      if (this._shadow) {
        remove(this._shadow);
      }
      this._shadow = null;
    },

    _setPos: function (pos) {
      if (this._icon) {
        setPosition(this._icon, pos);
      }

      if (this._shadow) {
        setPosition(this._shadow, pos);
      }

      this._zIndex = pos.y + this.options.zIndexOffset;

      this._resetZIndex();
    },

    _updateZIndex: function (offset) {
      if (this._icon) {
        this._icon.style.zIndex = this._zIndex + offset;
      }
    },

    _animateZoom: function (opt) {
      var pos = this._map
        ._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center)
        .round();

      this._setPos(pos);
    },

    _initInteraction: function () {
      if (!this.options.interactive) {
        return;
      }

      addClass(this._icon, "leaflet-interactive");

      this.addInteractiveTarget(this._icon);

      if (MarkerDrag) {
        var draggable = this.options.draggable;
        if (this.dragging) {
          draggable = this.dragging.enabled();
          this.dragging.disable();
        }

        this.dragging = new MarkerDrag(this);

        if (draggable) {
          this.dragging.enable();
        }
      }
    },

    // @method setOpacity(opacity: Number): this
    // Changes the opacity of the marker.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;
      if (this._map) {
        this._updateOpacity();
      }

      return this;
    },

    _updateOpacity: function () {
      var opacity = this.options.opacity;

      if (this._icon) {
        setOpacity(this._icon, opacity);
      }

      if (this._shadow) {
        setOpacity(this._shadow, opacity);
      }
    },

    _bringToFront: function () {
      this._updateZIndex(this.options.riseOffset);
    },

    _resetZIndex: function () {
      this._updateZIndex(0);
    },

    _panOnFocus: function () {
      var map = this._map;
      if (!map) {
        return;
      }

      var iconOpts = this.options.icon.options;
      var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
      var anchor = iconOpts.iconAnchor
        ? toPoint(iconOpts.iconAnchor)
        : toPoint(0, 0);

      map.panInside(this._latlng, {
        paddingTopLeft: anchor,
        paddingBottomRight: size.subtract(anchor),
      });
    },

    _getPopupAnchor: function () {
      return this.options.icon.options.popupAnchor;
    },

    _getTooltipAnchor: function () {
      return this.options.icon.options.tooltipAnchor;
    },
  });

  // factory L.marker(latlng: LatLng, options? : Marker options)

  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.
  function marker(latlng, options) {
    return new Marker(latlng, options);
  }

  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */

  var Path = Layer.extend({
    // @section
    // @aka Path options
    options: {
      // @option stroke: Boolean = true
      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
      stroke: true,

      // @option color: String = '#3388ff'
      // Stroke color
      color: "#3388ff",

      // @option weight: Number = 3
      // Stroke width in pixels
      weight: 3,

      // @option opacity: Number = 1.0
      // Stroke opacity
      opacity: 1,

      // @option lineCap: String= 'round'
      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
      lineCap: "round",

      // @option lineJoin: String = 'round'
      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
      lineJoin: "round",

      // @option dashArray: String = null
      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashArray: null,

      // @option dashOffset: String = null
      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashOffset: null,

      // @option fill: Boolean = depends
      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
      fill: false,

      // @option fillColor: String = *
      // Fill color. Defaults to the value of the [`color`](#path-color) option
      fillColor: null,

      // @option fillOpacity: Number = 0.2
      // Fill opacity.
      fillOpacity: 0.2,

      // @option fillRule: String = 'evenodd'
      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
      fillRule: "evenodd",

      // className: '',

      // Option inherited from "Interactive layer" abstract class
      interactive: true,

      // @option bubblingMouseEvents: Boolean = true
      // When `true`, a mouse event on this path will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: true,
    },

    beforeAdd: function (map) {
      // Renderer is set here because we need to call renderer.getEvents
      // before this.getEvents.
      this._renderer = map.getRenderer(this);
    },

    onAdd: function () {
      this._renderer._initPath(this);
      this._reset();
      this._renderer._addPath(this);
    },

    onRemove: function () {
      this._renderer._removePath(this);
    },

    // @method redraw(): this
    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
    redraw: function () {
      if (this._map) {
        this._renderer._updatePath(this);
      }
      return this;
    },

    // @method setStyle(style: Path options): this
    // Changes the appearance of a Path based on the options in the `Path options` object.
    setStyle: function (style) {
      setOptions(this, style);
      if (this._renderer) {
        this._renderer._updateStyle(this);
        if (
          this.options.stroke &&
          style &&
          Object.prototype.hasOwnProperty.call(style, "weight")
        ) {
          this._updateBounds();
        }
      }
      return this;
    },

    // @method bringToFront(): this
    // Brings the layer to the top of all path layers.
    bringToFront: function () {
      if (this._renderer) {
        this._renderer._bringToFront(this);
      }
      return this;
    },

    // @method bringToBack(): this
    // Brings the layer to the bottom of all path layers.
    bringToBack: function () {
      if (this._renderer) {
        this._renderer._bringToBack(this);
      }
      return this;
    },

    getElement: function () {
      return this._path;
    },

    _reset: function () {
      // defined in child classes
      this._project();
      this._update();
    },

    _clickTolerance: function () {
      // used when doing hit detection for Canvas layers
      return (
        (this.options.stroke ? this.options.weight / 2 : 0) +
        (this._renderer.options.tolerance || 0)
      );
    },
  });

  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({
    // @section
    // @aka CircleMarker options
    options: {
      fill: true,

      // @option radius: Number = 10
      // Radius of the circle marker, in pixels
      radius: 10,
    },

    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      this._radius = this.options.radius;
    },

    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.redraw();

      // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
      return this.fire("move", { oldLatLng: oldLatLng, latlng: this._latlng });
    },

    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function () {
      return this._latlng;
    },

    // @method setRadius(radius: Number): this
    // Sets the radius of a circle marker. Units are in pixels.
    setRadius: function (radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    },

    // @method getRadius(): Number
    // Returns the current radius of the circle
    getRadius: function () {
      return this._radius;
    },

    setStyle: function (options) {
      var radius = (options && options.radius) || this._radius;
      Path.prototype.setStyle.call(this, options);
      this.setRadius(radius);
      return this;
    },

    _project: function () {
      this._point = this._map.latLngToLayerPoint(this._latlng);
      this._updateBounds();
    },

    _updateBounds: function () {
      var r = this._radius,
        r2 = this._radiusY || r,
        w = this._clickTolerance(),
        p = [r + w, r2 + w];
      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
    },

    _update: function () {
      if (this._map) {
        this._updatePath();
      }
    },

    _updatePath: function () {
      this._renderer._updateCircle(this);
    },

    _empty: function () {
      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
    },

    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
    },
  });

  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.
  function circleMarker(latlng, options) {
    return new CircleMarker(latlng, options);
  }

  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */

  var Circle = CircleMarker.extend({
    initialize: function (latlng, options, legacyOptions) {
      if (typeof options === "number") {
        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
        options = extend({}, legacyOptions, { radius: options });
      }
      setOptions(this, options);
      this._latlng = toLatLng(latlng);

      if (isNaN(this.options.radius)) {
        throw new Error("Circle radius cannot be NaN");
      }

      // @section
      // @aka Circle options
      // @option radius: Number; Radius of the circle, in meters.
      this._mRadius = this.options.radius;
    },

    // @method setRadius(radius: Number): this
    // Sets the radius of a circle. Units are in meters.
    setRadius: function (radius) {
      this._mRadius = radius;
      return this.redraw();
    },

    // @method getRadius(): Number
    // Returns the current radius of a circle. Units are in meters.
    getRadius: function () {
      return this._mRadius;
    },

    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      var half = [this._radius, this._radiusY || this._radius];

      return new LatLngBounds(
        this._map.layerPointToLatLng(this._point.subtract(half)),
        this._map.layerPointToLatLng(this._point.add(half))
      );
    },

    setStyle: Path.prototype.setStyle,

    _project: function () {
      var lng = this._latlng.lng,
        lat = this._latlng.lat,
        map = this._map,
        crs = map.options.crs;

      if (crs.distance === Earth.distance) {
        var d = Math.PI / 180,
          latR = this._mRadius / Earth.R / d,
          top = map.project([lat + latR, lng]),
          bottom = map.project([lat - latR, lng]),
          p = top.add(bottom).divideBy(2),
          lat2 = map.unproject(p).lat,
          lngR =
            Math.acos(
              (Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
                (Math.cos(lat * d) * Math.cos(lat2 * d))
            ) / d;

        if (isNaN(lngR) || lngR === 0) {
          lngR = latR / Math.cos((Math.PI / 180) * lat); // Fallback for edge case, #2425
        }

        this._point = p.subtract(map.getPixelOrigin());
        this._radius = isNaN(lngR)
          ? 0
          : p.x - map.project([lat2, lng - lngR]).x;
        this._radiusY = p.y - top.y;
      } else {
        var latlng2 = crs.unproject(
          crs.project(this._latlng).subtract([this._mRadius, 0])
        );

        this._point = map.latLngToLayerPoint(this._latlng);
        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
      }

      this._updateBounds();
    },
  });

  // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.
  function circle(latlng, options, legacyOptions) {
    return new Circle(latlng, options, legacyOptions);
  }

  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */

  var Polyline = Path.extend({
    // @section
    // @aka Polyline options
    options: {
      // @option smoothFactor: Number = 1.0
      // How much to simplify the polyline on each zoom level. More means
      // better performance and smoother look, and less means more accurate representation.
      smoothFactor: 1.0,

      // @option noClip: Boolean = false
      // Disable polyline clipping.
      noClip: false,
    },

    initialize: function (latlngs, options) {
      setOptions(this, options);
      this._setLatLngs(latlngs);
    },

    // @method getLatLngs(): LatLng[]
    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
    getLatLngs: function () {
      return this._latlngs;
    },

    // @method setLatLngs(latlngs: LatLng[]): this
    // Replaces all the points in the polyline with the given array of geographical points.
    setLatLngs: function (latlngs) {
      this._setLatLngs(latlngs);
      return this.redraw();
    },

    // @method isEmpty(): Boolean
    // Returns `true` if the Polyline has no LatLngs.
    isEmpty: function () {
      return !this._latlngs.length;
    },

    // @method closestLayerPoint(p: Point): Point
    // Returns the point closest to `p` on the Polyline.
    closestLayerPoint: function (p) {
      var minDistance = Infinity,
        minPoint = null,
        closest = _sqClosestPointOnSegment,
        p1,
        p2;

      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
        var points = this._parts[j];

        for (var i = 1, len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];

          var sqDist = closest(p, p1, p2, true);

          if (sqDist < minDistance) {
            minDistance = sqDist;
            minPoint = closest(p, p1, p2);
          }
        }
      }
      if (minPoint) {
        minPoint.distance = Math.sqrt(minDistance);
      }
      return minPoint;
    },

    // @method getCenter(): LatLng
    // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error("Must add layer to map before using getCenter()");
      }
      return polylineCenter(this._defaultShape(), this._map.options.crs);
    },

    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      return this._bounds;
    },

    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
    // Adds a given point to the polyline. By default, adds to the first ring of
    // the polyline in case of a multi-polyline, but can be overridden by passing
    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
    addLatLng: function (latlng, latlngs) {
      latlngs = latlngs || this._defaultShape();
      latlng = toLatLng(latlng);
      latlngs.push(latlng);
      this._bounds.extend(latlng);
      return this.redraw();
    },

    _setLatLngs: function (latlngs) {
      this._bounds = new LatLngBounds();
      this._latlngs = this._convertLatLngs(latlngs);
    },

    _defaultShape: function () {
      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
    },

    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
    _convertLatLngs: function (latlngs) {
      var result = [],
        flat = isFlat(latlngs);

      for (var i = 0, len = latlngs.length; i < len; i++) {
        if (flat) {
          result[i] = toLatLng(latlngs[i]);
          this._bounds.extend(result[i]);
        } else {
          result[i] = this._convertLatLngs(latlngs[i]);
        }
      }

      return result;
    },

    _project: function () {
      var pxBounds = new Bounds();
      this._rings = [];
      this._projectLatlngs(this._latlngs, this._rings, pxBounds);

      if (this._bounds.isValid() && pxBounds.isValid()) {
        this._rawPxBounds = pxBounds;
        this._updateBounds();
      }
    },

    _updateBounds: function () {
      var w = this._clickTolerance(),
        p = new Point(w, w);

      if (!this._rawPxBounds) {
        return;
      }

      this._pxBounds = new Bounds([
        this._rawPxBounds.min.subtract(p),
        this._rawPxBounds.max.add(p),
      ]);
    },

    // recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs, result, projectedBounds) {
      var flat = latlngs[0] instanceof LatLng,
        len = latlngs.length,
        i,
        ring;

      if (flat) {
        ring = [];
        for (i = 0; i < len; i++) {
          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
          projectedBounds.extend(ring[i]);
        }
        result.push(ring);
      } else {
        for (i = 0; i < len; i++) {
          this._projectLatlngs(latlngs[i], result, projectedBounds);
        }
      }
    },

    // clip polyline by renderer bounds so that we have less to render for performance
    _clipPoints: function () {
      var bounds = this._renderer._bounds;

      this._parts = [];
      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      var parts = this._parts,
        i,
        j,
        k,
        len,
        len2,
        segment,
        points;

      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
        points = this._rings[i];

        for (j = 0, len2 = points.length; j < len2 - 1; j++) {
          segment = clipSegment(points[j], points[j + 1], bounds, j, true);

          if (!segment) {
            continue;
          }

          parts[k] = parts[k] || [];
          parts[k].push(segment[0]);

          // if segment goes out of screen, or it's the last one, it's the end of the line part
          if (segment[1] !== points[j + 1] || j === len2 - 2) {
            parts[k].push(segment[1]);
            k++;
          }
        }
      }
    },

    // simplify each clipped part of the polyline for performance
    _simplifyPoints: function () {
      var parts = this._parts,
        tolerance = this.options.smoothFactor;

      for (var i = 0, len = parts.length; i < len; i++) {
        parts[i] = simplify(parts[i], tolerance);
      }
    },

    _update: function () {
      if (!this._map) {
        return;
      }

      this._clipPoints();
      this._simplifyPoints();
      this._updatePath();
    },

    _updatePath: function () {
      this._renderer._updatePoly(this);
    },

    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p, closed) {
      var i,
        j,
        k,
        len,
        len2,
        part,
        w = this._clickTolerance();

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      }

      // hit detection for polylines
      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          if (!closed && j === 0) {
            continue;
          }

          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
            return true;
          }
        }
      }
      return false;
    },
  });

  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.
  function polyline(latlngs, options) {
    return new Polyline(latlngs, options);
  }

  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
  Polyline._flat = _flat;

  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one â it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({
    options: {
      fill: true,
    },

    isEmpty: function () {
      return !this._latlngs.length || !this._latlngs[0].length;
    },

    // @method getCenter(): LatLng
    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error("Must add layer to map before using getCenter()");
      }
      return polygonCenter(this._defaultShape(), this._map.options.crs);
    },

    _convertLatLngs: function (latlngs) {
      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
        len = result.length;

      // remove last point if it equals first one
      if (
        len >= 2 &&
        result[0] instanceof LatLng &&
        result[0].equals(result[len - 1])
      ) {
        result.pop();
      }
      return result;
    },

    _setLatLngs: function (latlngs) {
      Polyline.prototype._setLatLngs.call(this, latlngs);
      if (isFlat(this._latlngs)) {
        this._latlngs = [this._latlngs];
      }
    },

    _defaultShape: function () {
      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
    },

    _clipPoints: function () {
      // polygons need a different clipping algorithm so we redefine that

      var bounds = this._renderer._bounds,
        w = this.options.weight,
        p = new Point(w, w);

      // increase clip padding by stroke width to avoid stroke on clip edges
      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

      this._parts = [];
      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
        clipped = clipPolygon(this._rings[i], bounds, true);
        if (clipped.length) {
          this._parts.push(clipped);
        }
      }
    },

    _updatePath: function () {
      this._renderer._updatePoly(this, true);
    },

    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      var inside = false,
        part,
        p1,
        p2,
        i,
        j,
        k,
        len,
        len2;

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      }

      // ray casting algorithm for detecting if point is in polygon
      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          p1 = part[j];
          p2 = part[k];

          if (
            p1.y > p.y !== p2.y > p.y &&
            p.x < ((p2.x - p1.x) * (p.y - p1.y)) / (p2.y - p1.y) + p1.x
          ) {
            inside = !inside;
          }
        }
      }

      // also check if it's on polygon stroke
      return inside || Polyline.prototype._containsPoint.call(this, p, true);
    },
  });

  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
  function polygon(latlngs, options) {
    return new Polygon(latlngs, options);
  }

  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */

  var GeoJSON = FeatureGroup.extend({
    /* @section
     * @aka GeoJSON options
     *
     * @option pointToLayer: Function = *
     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
     * called when data is added, passing the GeoJSON point feature and its `LatLng`.
     * The default is to spawn a default `Marker`:
     * ```js
     * function(geoJsonPoint, latlng) {
     * 	return L.marker(latlng);
     * }
     * ```
     *
     * @option style: Function = *
     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
     * called internally when data is added.
     * The default value is to not override any defaults:
     * ```js
     * function (geoJsonFeature) {
     * 	return {}
     * }
     * ```
     *
     * @option onEachFeature: Function = *
     * A `Function` that will be called once for each created `Feature`, after it has
     * been created and styled. Useful for attaching events and popups to features.
     * The default is to do nothing with the newly created layers:
     * ```js
     * function (feature, layer) {}
     * ```
     *
     * @option filter: Function = *
     * A `Function` that will be used to decide whether to include a feature or not.
     * The default is to include all features:
     * ```js
     * function (geoJsonFeature) {
     * 	return true;
     * }
     * ```
     * Note: dynamically changing the `filter` option will have effect only on newly
     * added data. It will _not_ re-evaluate already included features.
     *
     * @option coordsToLatLng: Function = *
     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
     * The default is the `coordsToLatLng` static method.
     *
     * @option markersInheritOptions: Boolean = false
     * Whether default Markers for "Point" type Features inherit from group options.
     */

    initialize: function (geojson, options) {
      setOptions(this, options);

      this._layers = {};

      if (geojson) {
        this.addData(geojson);
      }
    },

    // @method addData( <GeoJSON> data ): this
    // Adds a GeoJSON object to the layer.
    addData: function (geojson) {
      var features = isArray(geojson) ? geojson : geojson.features,
        i,
        len,
        feature;

      if (features) {
        for (i = 0, len = features.length; i < len; i++) {
          // only add this if geometry or geometries are set and not null
          feature = features[i];
          if (
            feature.geometries ||
            feature.geometry ||
            feature.features ||
            feature.coordinates
          ) {
            this.addData(feature);
          }
        }
        return this;
      }

      var options = this.options;

      if (options.filter && !options.filter(geojson)) {
        return this;
      }

      var layer = geometryToLayer(geojson, options);
      if (!layer) {
        return this;
      }
      layer.feature = asFeature(geojson);

      layer.defaultOptions = layer.options;
      this.resetStyle(layer);

      if (options.onEachFeature) {
        options.onEachFeature(geojson, layer);
      }

      return this.addLayer(layer);
    },

    // @method resetStyle( <Path> layer? ): this
    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
    // If `layer` is omitted, the style of all features in the current layer is reset.
    resetStyle: function (layer) {
      if (layer === undefined) {
        return this.eachLayer(this.resetStyle, this);
      }
      // reset any custom styles
      layer.options = extend({}, layer.defaultOptions);
      this._setLayerStyle(layer, this.options.style);
      return this;
    },

    // @method setStyle( <Function> style ): this
    // Changes styles of GeoJSON vector layers with the given style function.
    setStyle: function (style) {
      return this.eachLayer(function (layer) {
        this._setLayerStyle(layer, style);
      }, this);
    },

    _setLayerStyle: function (layer, style) {
      if (layer.setStyle) {
        if (typeof style === "function") {
          style = style(layer.feature);
        }
        layer.setStyle(style);
      }
    },
  });

  // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:

  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.
  function geometryToLayer(geojson, options) {
    var geometry = geojson.type === "Feature" ? geojson.geometry : geojson,
      coords = geometry ? geometry.coordinates : null,
      layers = [],
      pointToLayer = options && options.pointToLayer,
      _coordsToLatLng = (options && options.coordsToLatLng) || coordsToLatLng,
      latlng,
      latlngs,
      i,
      len;

    if (!coords && !geometry) {
      return null;
    }

    switch (geometry.type) {
      case "Point":
        latlng = _coordsToLatLng(coords);
        return _pointToLayer(pointToLayer, geojson, latlng, options);

      case "MultiPoint":
        for (i = 0, len = coords.length; i < len; i++) {
          latlng = _coordsToLatLng(coords[i]);
          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
        }
        return new FeatureGroup(layers);

      case "LineString":
      case "MultiLineString":
        latlngs = coordsToLatLngs(
          coords,
          geometry.type === "LineString" ? 0 : 1,
          _coordsToLatLng
        );
        return new Polyline(latlngs, options);

      case "Polygon":
      case "MultiPolygon":
        latlngs = coordsToLatLngs(
          coords,
          geometry.type === "Polygon" ? 1 : 2,
          _coordsToLatLng
        );
        return new Polygon(latlngs, options);

      case "GeometryCollection":
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          var geoLayer = geometryToLayer(
            {
              geometry: geometry.geometries[i],
              type: "Feature",
              properties: geojson.properties,
            },
            options
          );

          if (geoLayer) {
            layers.push(geoLayer);
          }
        }
        return new FeatureGroup(layers);

      case "FeatureCollection":
        for (i = 0, len = geometry.features.length; i < len; i++) {
          var featureLayer = geometryToLayer(geometry.features[i], options);

          if (featureLayer) {
            layers.push(featureLayer);
          }
        }
        return new FeatureGroup(layers);

      default:
        throw new Error("Invalid GeoJSON object.");
    }
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
    return pointToLayerFn
      ? pointToLayerFn(geojson, latlng)
      : new Marker(latlng, options && options.markersInheritOptions && options);
  }

  // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
  function coordsToLatLng(coords) {
    return new LatLng(coords[1], coords[0], coords[2]);
  }

  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
    var latlngs = [];

    for (var i = 0, len = coords.length, latlng; i < len; i++) {
      latlng = levelsDeep
        ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng)
        : (_coordsToLatLng || coordsToLatLng)(coords[i]);

      latlngs.push(latlng);
    }

    return latlngs;
  }

  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngToCoords(latlng, precision) {
    latlng = toLatLng(latlng);
    return latlng.alt !== undefined
      ? [
          formatNum(latlng.lng, precision),
          formatNum(latlng.lat, precision),
          formatNum(latlng.alt, precision),
        ]
      : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  }

  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
    var coords = [];

    for (var i = 0, len = latlngs.length; i < len; i++) {
      // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion
      coords.push(
        levelsDeep
          ? latLngsToCoords(
              latlngs[i],
              isFlat(latlngs[i]) ? 0 : levelsDeep - 1,
              closed,
              precision
            )
          : latLngToCoords(latlngs[i], precision)
      );
    }

    if (!levelsDeep && closed && coords.length > 0) {
      coords.push(coords[0].slice());
    }

    return coords;
  }

  function getFeature(layer, newGeometry) {
    return layer.feature
      ? extend({}, layer.feature, { geometry: newGeometry })
      : asFeature(newGeometry);
  }

  // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.
  function asFeature(geojson) {
    if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
      return geojson;
    }

    return {
      type: "Feature",
      properties: {},
      geometry: geojson,
    };
  }

  var PointToGeoJSON = {
    toGeoJSON: function (precision) {
      return getFeature(this, {
        type: "Point",
        coordinates: latLngToCoords(this.getLatLng(), precision),
      });
    },
  };

  // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
  Marker.include(PointToGeoJSON);

  // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON);

  // @namespace Polyline
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
  Polyline.include({
    toGeoJSON: function (precision) {
      var multi = !isFlat(this._latlngs);

      var coords = latLngsToCoords(
        this._latlngs,
        multi ? 1 : 0,
        false,
        precision
      );

      return getFeature(this, {
        type: (multi ? "Multi" : "") + "LineString",
        coordinates: coords,
      });
    },
  });

  // @namespace Polygon
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
  Polygon.include({
    toGeoJSON: function (precision) {
      var holes = !isFlat(this._latlngs),
        multi = holes && !isFlat(this._latlngs[0]);

      var coords = latLngsToCoords(
        this._latlngs,
        multi ? 2 : holes ? 1 : 0,
        true,
        precision
      );

      if (!holes) {
        coords = [coords];
      }

      return getFeature(this, {
        type: (multi ? "Multi" : "") + "Polygon",
        coordinates: coords,
      });
    },
  });

  // @namespace LayerGroup
  LayerGroup.include({
    toMultiPoint: function (precision) {
      var coords = [];

      this.eachLayer(function (layer) {
        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
      });

      return getFeature(this, {
        type: "MultiPoint",
        coordinates: coords,
      });
    },

    // @method toGeoJSON(precision?: Number|false): Object
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
    toGeoJSON: function (precision) {
      var type =
        this.feature && this.feature.geometry && this.feature.geometry.type;

      if (type === "MultiPoint") {
        return this.toMultiPoint(precision);
      }

      var isGeometryCollection = type === "GeometryCollection",
        jsons = [];

      this.eachLayer(function (layer) {
        if (layer.toGeoJSON) {
          var json = layer.toGeoJSON(precision);
          if (isGeometryCollection) {
            jsons.push(json.geometry);
          } else {
            var feature = asFeature(json);
            // Squash nested feature collections
            if (feature.type === "FeatureCollection") {
              jsons.push.apply(jsons, feature.features);
            } else {
              jsons.push(feature);
            }
          }
        }
      });

      if (isGeometryCollection) {
        return getFeature(this, {
          geometries: jsons,
          type: "GeometryCollection",
        });
      }

      return {
        type: "FeatureCollection",
        features: jsons,
      };
    },
  });

  // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.
  function geoJSON(geojson, options) {
    return new GeoJSON(geojson, options);
  }

  // Backward compatibility.
  var geoJson = geoJSON;

  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({
    // @section
    // @aka ImageOverlay options
    options: {
      // @option opacity: Number = 1.0
      // The opacity of the image overlay.
      opacity: 1,

      // @option alt: String = ''
      // Text for the `alt` attribute of the image (useful for accessibility).
      alt: "",

      // @option interactive: Boolean = false
      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
      interactive: false,

      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the image.
      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,

      // @option errorOverlayUrl: String = ''
      // URL to the overlay image to show in place of the overlay that failed to load.
      errorOverlayUrl: "",

      // @option zIndex: Number = 1
      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
      zIndex: 1,

      // @option className: String = ''
      // A custom class name to assign to the image. Empty by default.
      className: "",
    },

    initialize: function (url, bounds, options) {
      // (String, LatLngBounds, Object)
      this._url = url;
      this._bounds = toLatLngBounds(bounds);

      setOptions(this, options);
    },

    onAdd: function () {
      if (!this._image) {
        this._initImage();

        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
      }

      if (this.options.interactive) {
        addClass(this._image, "leaflet-interactive");
        this.addInteractiveTarget(this._image);
      }

      this.getPane().appendChild(this._image);
      this._reset();
    },

    onRemove: function () {
      remove(this._image);
      if (this.options.interactive) {
        this.removeInteractiveTarget(this._image);
      }
    },

    // @method setOpacity(opacity: Number): this
    // Sets the opacity of the overlay.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._image) {
        this._updateOpacity();
      }
      return this;
    },

    setStyle: function (styleOpts) {
      if (styleOpts.opacity) {
        this.setOpacity(styleOpts.opacity);
      }
      return this;
    },

    // @method bringToFront(): this
    // Brings the layer to the top of all overlays.
    bringToFront: function () {
      if (this._map) {
        toFront(this._image);
      }
      return this;
    },

    // @method bringToBack(): this
    // Brings the layer to the bottom of all overlays.
    bringToBack: function () {
      if (this._map) {
        toBack(this._image);
      }
      return this;
    },

    // @method setUrl(url: String): this
    // Changes the URL of the image.
    setUrl: function (url) {
      this._url = url;

      if (this._image) {
        this._image.src = url;
      }
      return this;
    },

    // @method setBounds(bounds: LatLngBounds): this
    // Update the bounds that this ImageOverlay covers
    setBounds: function (bounds) {
      this._bounds = toLatLngBounds(bounds);

      if (this._map) {
        this._reset();
      }
      return this;
    },

    getEvents: function () {
      var events = {
        zoom: this._reset,
        viewreset: this._reset,
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },

    // @method setZIndex(value: Number): this
    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
    setZIndex: function (value) {
      this.options.zIndex = value;
      this._updateZIndex();
      return this;
    },

    // @method getBounds(): LatLngBounds
    // Get the bounds that this ImageOverlay covers
    getBounds: function () {
      return this._bounds;
    },

    // @method getElement(): HTMLElement
    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
    // used by this overlay.
    getElement: function () {
      return this._image;
    },

    _initImage: function () {
      var wasElementSupplied = this._url.tagName === "IMG";
      var img = (this._image = wasElementSupplied
        ? this._url
        : create$1("img"));

      addClass(img, "leaflet-image-layer");
      if (this._zoomAnimated) {
        addClass(img, "leaflet-zoom-animated");
      }
      if (this.options.className) {
        addClass(img, this.options.className);
      }

      img.onselectstart = falseFn;
      img.onmousemove = falseFn;

      // @event load: Event
      // Fired when the ImageOverlay layer has loaded its image
      img.onload = bind(this.fire, this, "load");
      img.onerror = bind(this._overlayOnError, this, "error");

      if (this.options.crossOrigin || this.options.crossOrigin === "") {
        img.crossOrigin =
          this.options.crossOrigin === true ? "" : this.options.crossOrigin;
      }

      if (this.options.zIndex) {
        this._updateZIndex();
      }

      if (wasElementSupplied) {
        this._url = img.src;
        return;
      }

      img.src = this._url;
      img.alt = this.options.alt;
    },

    _animateZoom: function (e) {
      var scale = this._map.getZoomScale(e.zoom),
        offset = this._map._latLngBoundsToNewLayerBounds(
          this._bounds,
          e.zoom,
          e.center
        ).min;

      setTransform(this._image, offset, scale);
    },

    _reset: function () {
      var image = this._image,
        bounds = new Bounds(
          this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
          this._map.latLngToLayerPoint(this._bounds.getSouthEast())
        ),
        size = bounds.getSize();

      setPosition(image, bounds.min);

      image.style.width = size.x + "px";
      image.style.height = size.y + "px";
    },

    _updateOpacity: function () {
      setOpacity(this._image, this.options.opacity);
    },

    _updateZIndex: function () {
      if (
        this._image &&
        this.options.zIndex !== undefined &&
        this.options.zIndex !== null
      ) {
        this._image.style.zIndex = this.options.zIndex;
      }
    },

    _overlayOnError: function () {
      // @event error: Event
      // Fired when the ImageOverlay layer fails to load its image
      this.fire("error");

      var errorUrl = this.options.errorOverlayUrl;
      if (errorUrl && this._url !== errorUrl) {
        this._url = errorUrl;
        this._image.src = errorUrl;
      }
    },

    // @method getCenter(): LatLng
    // Returns the center of the ImageOverlay.
    getCenter: function () {
      return this._bounds.getCenter();
    },
  });

  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.
  var imageOverlay = function (url, bounds, options) {
    return new ImageOverlay(url, bounds, options);
  };

  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */

  var VideoOverlay = ImageOverlay.extend({
    // @section
    // @aka VideoOverlay options
    options: {
      // @option autoplay: Boolean = true
      // Whether the video starts playing automatically when loaded.
      // On some browsers autoplay will only work with `muted: true`
      autoplay: true,

      // @option loop: Boolean = true
      // Whether the video will loop back to the beginning when played.
      loop: true,

      // @option keepAspectRatio: Boolean = true
      // Whether the video will save aspect ratio after the projection.
      // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
      keepAspectRatio: true,

      // @option muted: Boolean = false
      // Whether the video starts on mute when loaded.
      muted: false,

      // @option playsInline: Boolean = true
      // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
      playsInline: true,
    },

    _initImage: function () {
      var wasElementSupplied = this._url.tagName === "VIDEO";
      var vid = (this._image = wasElementSupplied
        ? this._url
        : create$1("video"));

      addClass(vid, "leaflet-image-layer");
      if (this._zoomAnimated) {
        addClass(vid, "leaflet-zoom-animated");
      }
      if (this.options.className) {
        addClass(vid, this.options.className);
      }

      vid.onselectstart = falseFn;
      vid.onmousemove = falseFn;

      // @event load: Event
      // Fired when the video has finished loading the first frame
      vid.onloadeddata = bind(this.fire, this, "load");

      if (wasElementSupplied) {
        var sourceElements = vid.getElementsByTagName("source");
        var sources = [];
        for (var j = 0; j < sourceElements.length; j++) {
          sources.push(sourceElements[j].src);
        }

        this._url = sourceElements.length > 0 ? sources : [vid.src];
        return;
      }

      if (!isArray(this._url)) {
        this._url = [this._url];
      }

      if (
        !this.options.keepAspectRatio &&
        Object.prototype.hasOwnProperty.call(vid.style, "objectFit")
      ) {
        vid.style["objectFit"] = "fill";
      }
      vid.autoplay = !!this.options.autoplay;
      vid.loop = !!this.options.loop;
      vid.muted = !!this.options.muted;
      vid.playsInline = !!this.options.playsInline;
      for (var i = 0; i < this._url.length; i++) {
        var source = create$1("source");
        source.src = this._url[i];
        vid.appendChild(source);
      }
    },

    // @method getElement(): HTMLVideoElement
    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
    // used by this overlay.
  });

  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
    return new VideoOverlay(video, bounds, options);
  }

  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */

  var SVGOverlay = ImageOverlay.extend({
    _initImage: function () {
      var el = (this._image = this._url);

      addClass(el, "leaflet-image-layer");
      if (this._zoomAnimated) {
        addClass(el, "leaflet-zoom-animated");
      }
      if (this.options.className) {
        addClass(el, this.options.className);
      }

      el.onselectstart = falseFn;
      el.onmousemove = falseFn;
    },

    // @method getElement(): SVGElement
    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
    // used by this overlay.
  });

  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
    return new SVGOverlay(el, bounds, options);
  }

  /*
   * @class DivOverlay
   * @inherits Interactive layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.
   */

  // @namespace DivOverlay
  var DivOverlay = Layer.extend({
    // @section
    // @aka DivOverlay options
    options: {
      // @option interactive: Boolean = false
      // If true, the popup/tooltip will listen to the mouse events.
      interactive: false,

      // @option offset: Point = Point(0, 0)
      // The offset of the overlay position.
      offset: [0, 0],

      // @option className: String = ''
      // A custom CSS class name to assign to the overlay.
      className: "",

      // @option pane: String = undefined
      // `Map pane` where the overlay will be added.
      pane: undefined,

      // @option content: String|HTMLElement|Function = ''
      // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
      // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
      content: "",
    },

    initialize: function (options, source) {
      if (options && (options instanceof LatLng || isArray(options))) {
        this._latlng = toLatLng(options);
        setOptions(this, source);
      } else {
        setOptions(this, options);
        this._source = source;
      }
      if (this.options.content) {
        this._content = this.options.content;
      }
    },

    // @method openOn(map: Map): this
    // Adds the overlay to the map.
    // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
    openOn: function (map) {
      map = arguments.length ? map : this._source._map; // experimental, not the part of public api
      if (!map.hasLayer(this)) {
        map.addLayer(this);
      }
      return this;
    },

    // @method close(): this
    // Closes the overlay.
    // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
    // and `layer.closePopup()`/`.closeTooltip()`.
    close: function () {
      if (this._map) {
        this._map.removeLayer(this);
      }
      return this;
    },

    // @method toggle(layer?: Layer): this
    // Opens or closes the overlay bound to layer depending on its current state.
    // Argument may be omitted only for overlay bound to layer.
    // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
    toggle: function (layer) {
      if (this._map) {
        this.close();
      } else {
        if (arguments.length) {
          this._source = layer;
        } else {
          layer = this._source;
        }
        this._prepareOpen();

        // open the overlay on the map
        this.openOn(layer._map);
      }
      return this;
    },

    onAdd: function (map) {
      this._zoomAnimated = map._zoomAnimated;

      if (!this._container) {
        this._initLayout();
      }

      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
      }

      clearTimeout(this._removeTimeout);
      this.getPane().appendChild(this._container);
      this.update();

      if (map._fadeAnimated) {
        setOpacity(this._container, 1);
      }

      this.bringToFront();

      if (this.options.interactive) {
        addClass(this._container, "leaflet-interactive");
        this.addInteractiveTarget(this._container);
      }
    },

    onRemove: function (map) {
      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
        this._removeTimeout = setTimeout(
          bind(remove, undefined, this._container),
          200
        );
      } else {
        remove(this._container);
      }

      if (this.options.interactive) {
        removeClass(this._container, "leaflet-interactive");
        this.removeInteractiveTarget(this._container);
      }
    },

    // @namespace DivOverlay
    // @method getLatLng: LatLng
    // Returns the geographical point of the overlay.
    getLatLng: function () {
      return this._latlng;
    },

    // @method setLatLng(latlng: LatLng): this
    // Sets the geographical point where the overlay will open.
    setLatLng: function (latlng) {
      this._latlng = toLatLng(latlng);
      if (this._map) {
        this._updatePosition();
        this._adjustPan();
      }
      return this;
    },

    // @method getContent: String|HTMLElement
    // Returns the content of the overlay.
    getContent: function () {
      return this._content;
    },

    // @method setContent(htmlContent: String|HTMLElement|Function): this
    // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
    // The function should return a `String` or `HTMLElement` to be used in the overlay.
    setContent: function (content) {
      this._content = content;
      this.update();
      return this;
    },

    // @method getElement: String|HTMLElement
    // Returns the HTML container of the overlay.
    getElement: function () {
      return this._container;
    },

    // @method update: null
    // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
    update: function () {
      if (!this._map) {
        return;
      }

      this._container.style.visibility = "hidden";

      this._updateContent();
      this._updateLayout();
      this._updatePosition();

      this._container.style.visibility = "";

      this._adjustPan();
    },

    getEvents: function () {
      var events = {
        zoom: this._updatePosition,
        viewreset: this._updatePosition,
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }
      return events;
    },

    // @method isOpen: Boolean
    // Returns `true` when the overlay is visible on the map.
    isOpen: function () {
      return !!this._map && this._map.hasLayer(this);
    },

    // @method bringToFront: this
    // Brings this overlay in front of other overlays (in the same map pane).
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
      }
      return this;
    },

    // @method bringToBack: this
    // Brings this overlay to the back of other overlays (in the same map pane).
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
      }
      return this;
    },

    // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
    _prepareOpen: function (latlng) {
      var source = this._source;
      if (!source._map) {
        return false;
      }

      if (source instanceof FeatureGroup) {
        source = null;
        var layers = this._source._layers;
        for (var id in layers) {
          if (layers[id]._map) {
            source = layers[id];
            break;
          }
        }
        if (!source) {
          return false;
        } // Unable to get source layer.

        // set overlay source to this layer
        this._source = source;
      }

      if (!latlng) {
        if (source.getCenter) {
          latlng = source.getCenter();
        } else if (source.getLatLng) {
          latlng = source.getLatLng();
        } else if (source.getBounds) {
          latlng = source.getBounds().getCenter();
        } else {
          throw new Error("Unable to get source layer LatLng.");
        }
      }
      this.setLatLng(latlng);

      if (this._map) {
        // update the overlay (content, layout, etc...)
        this.update();
      }

      return true;
    },

    _updateContent: function () {
      if (!this._content) {
        return;
      }

      var node = this._contentNode;
      var content =
        typeof this._content === "function"
          ? this._content(this._source || this)
          : this._content;

      if (typeof content === "string") {
        node.innerHTML = content;
      } else {
        while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
        }
        node.appendChild(content);
      }

      // @namespace DivOverlay
      // @section DivOverlay events
      // @event contentupdate: Event
      // Fired when the content of the overlay is updated
      this.fire("contentupdate");
    },

    _updatePosition: function () {
      if (!this._map) {
        return;
      }

      var pos = this._map.latLngToLayerPoint(this._latlng),
        offset = toPoint(this.options.offset),
        anchor = this._getAnchor();

      if (this._zoomAnimated) {
        setPosition(this._container, pos.add(anchor));
      } else {
        offset = offset.add(pos).add(anchor);
      }

      var bottom = (this._containerBottom = -offset.y),
        left = (this._containerLeft =
          -Math.round(this._containerWidth / 2) + offset.x);

      // bottom position the overlay in case the height of the overlay changes (images loading etc)
      this._container.style.bottom = bottom + "px";
      this._container.style.left = left + "px";
    },

    _getAnchor: function () {
      return [0, 0];
    },
  });

  Map.include({
    _initOverlay: function (OverlayClass, content, latlng, options) {
      var overlay = content;
      if (!(overlay instanceof OverlayClass)) {
        overlay = new OverlayClass(options).setContent(content);
      }
      if (latlng) {
        overlay.setLatLng(latlng);
      }
      return overlay;
    },
  });

  Layer.include({
    _initOverlay: function (OverlayClass, old, content, options) {
      var overlay = content;
      if (overlay instanceof OverlayClass) {
        setOptions(overlay, options);
        overlay._source = this;
      } else {
        overlay = old && !options ? old : new OverlayClass(options, this);
        overlay.setContent(content);
      }
      return overlay;
    },
  });

  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   *
   * A popup can be also standalone:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   * or
   * ```js
   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */

  // @namespace Popup
  var Popup = DivOverlay.extend({
    // @section
    // @aka Popup options
    options: {
      // @option pane: String = 'popupPane'
      // `Map pane` where the popup will be added.
      pane: "popupPane",

      // @option offset: Point = Point(0, 7)
      // The offset of the popup position.
      offset: [0, 7],

      // @option maxWidth: Number = 300
      // Max width of the popup, in pixels.
      maxWidth: 300,

      // @option minWidth: Number = 50
      // Min width of the popup, in pixels.
      minWidth: 50,

      // @option maxHeight: Number = null
      // If set, creates a scrollable container of the given height
      // inside a popup if its content exceeds it.
      // The scrollable container can be styled using the
      // `leaflet-popup-scrolled` CSS class selector.
      maxHeight: null,

      // @option autoPan: Boolean = true
      // Set it to `false` if you don't want the map to do panning animation
      // to fit the opened popup.
      autoPan: true,

      // @option autoPanPaddingTopLeft: Point = null
      // The margin between the popup and the top left corner of the map
      // view after autopanning was performed.
      autoPanPaddingTopLeft: null,

      // @option autoPanPaddingBottomRight: Point = null
      // The margin between the popup and the bottom right corner of the map
      // view after autopanning was performed.
      autoPanPaddingBottomRight: null,

      // @option autoPanPadding: Point = Point(5, 5)
      // Equivalent of setting both top left and bottom right autopan padding to the same value.
      autoPanPadding: [5, 5],

      // @option keepInView: Boolean = false
      // Set it to `true` if you want to prevent users from panning the popup
      // off of the screen while it is open.
      keepInView: false,

      // @option closeButton: Boolean = true
      // Controls the presence of a close button in the popup.
      closeButton: true,

      // @option autoClose: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the popup closing when another popup is opened.
      autoClose: true,

      // @option closeOnEscapeKey: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the ESC key for closing of the popup.
      closeOnEscapeKey: true,

      // @option closeOnClick: Boolean = *
      // Set it if you want to override the default behavior of the popup closing when user clicks
      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: "",
    },

    // @namespace Popup
    // @method openOn(map: Map): this
    // Alternative to `map.openPopup(popup)`.
    // Adds the popup to the map and closes the previous one.
    openOn: function (map) {
      map = arguments.length ? map : this._source._map; // experimental, not the part of public api

      if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
        map.removeLayer(map._popup);
      }
      map._popup = this;

      return DivOverlay.prototype.openOn.call(this, map);
    },

    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);

      // @namespace Map
      // @section Popup events
      // @event popupopen: PopupEvent
      // Fired when a popup is opened in the map
      map.fire("popupopen", { popup: this });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupopen: PopupEvent
        // Fired when a popup bound to this layer is opened
        this._source.fire("popupopen", { popup: this }, true);
        // For non-path layers, we toggle the popup when clicking
        // again the layer, so prevent the map to reopen it.
        if (!(this._source instanceof Path)) {
          this._source.on("preclick", stopPropagation);
        }
      }
    },

    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map);

      // @namespace Map
      // @section Popup events
      // @event popupclose: PopupEvent
      // Fired when a popup in the map is closed
      map.fire("popupclose", { popup: this });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupclose: PopupEvent
        // Fired when a popup bound to this layer is closed
        this._source.fire("popupclose", { popup: this }, true);
        if (!(this._source instanceof Path)) {
          this._source.off("preclick", stopPropagation);
        }
      }
    },

    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (
        this.options.closeOnClick !== undefined
          ? this.options.closeOnClick
          : this._map.options.closePopupOnClick
      ) {
        events.preclick = this.close;
      }

      if (this.options.keepInView) {
        events.moveend = this._adjustPan;
      }

      return events;
    },

    _initLayout: function () {
      var prefix = "leaflet-popup",
        container = (this._container = create$1(
          "div",
          prefix +
            " " +
            (this.options.className || "") +
            " leaflet-zoom-animated"
        ));

      var wrapper = (this._wrapper = create$1(
        "div",
        prefix + "-content-wrapper",
        container
      ));
      this._contentNode = create$1("div", prefix + "-content", wrapper);

      disableClickPropagation(container);
      disableScrollPropagation(this._contentNode);
      on(container, "contextmenu", stopPropagation);

      this._tipContainer = create$1(
        "div",
        prefix + "-tip-container",
        container
      );
      this._tip = create$1("div", prefix + "-tip", this._tipContainer);

      if (this.options.closeButton) {
        var closeButton = (this._closeButton = create$1(
          "a",
          prefix + "-close-button",
          container
        ));
        closeButton.setAttribute("role", "button"); // overrides the implicit role=link of <a> elements #7399
        closeButton.setAttribute("aria-label", "Close popup");
        closeButton.href = "#close";
        closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';

        on(
          closeButton,
          "click",
          function (ev) {
            preventDefault(ev);
            this.close();
          },
          this
        );
      }
    },

    _updateLayout: function () {
      var container = this._contentNode,
        style = container.style;

      style.width = "";
      style.whiteSpace = "nowrap";

      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);

      style.width = width + 1 + "px";
      style.whiteSpace = "";

      style.height = "";

      var height = container.offsetHeight,
        maxHeight = this.options.maxHeight,
        scrolledClass = "leaflet-popup-scrolled";

      if (maxHeight && height > maxHeight) {
        style.height = maxHeight + "px";
        addClass(container, scrolledClass);
      } else {
        removeClass(container, scrolledClass);
      }

      this._containerWidth = this._container.offsetWidth;
    },

    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(
          this._latlng,
          e.zoom,
          e.center
        ),
        anchor = this._getAnchor();
      setPosition(this._container, pos.add(anchor));
    },

    _adjustPan: function () {
      if (!this.options.autoPan) {
        return;
      }
      if (this._map._panAnim) {
        this._map._panAnim.stop();
      }

      // We can endlessly recurse if keepInView is set and the view resets.
      // Let's guard against that by exiting early if we're responding to our own autopan.
      if (this._autopanning) {
        this._autopanning = false;
        return;
      }

      var map = this._map,
        marginBottom =
          parseInt(getStyle(this._container, "marginBottom"), 10) || 0,
        containerHeight = this._container.offsetHeight + marginBottom,
        containerWidth = this._containerWidth,
        layerPos = new Point(
          this._containerLeft,
          -containerHeight - this._containerBottom
        );

      layerPos._add(getPosition(this._container));

      var containerPos = map.layerPointToContainerPoint(layerPos),
        padding = toPoint(this.options.autoPanPadding),
        paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
        paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
        size = map.getSize(),
        dx = 0,
        dy = 0;

      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        // right
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }
      if (containerPos.x - dx - paddingTL.x < 0) {
        // left
        dx = containerPos.x - paddingTL.x;
      }
      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        // bottom
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }
      if (containerPos.y - dy - paddingTL.y < 0) {
        // top
        dy = containerPos.y - paddingTL.y;
      }

      // @namespace Map
      // @section Popup events
      // @event autopanstart: Event
      // Fired when the map starts autopanning when opening a popup.
      if (dx || dy) {
        // Track that we're autopanning, as this function will be re-ran on moveend
        if (this.options.keepInView) {
          this._autopanning = true;
        }

        map.fire("autopanstart").panBy([dx, dy]);
      }
    },

    _getAnchor: function () {
      // Where should we anchor the popup on the source layer?
      return toPoint(
        this._source && this._source._getPopupAnchor
          ? this._source._getPopupAnchor()
          : [0, 0]
      );
    },
  });

  // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.popup(latlng: LatLng, options?: Popup options)
  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.
  var popup = function (options, source) {
    return new Popup(options, source);
  };

  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */
  Map.mergeOptions({
    closePopupOnClick: true,
  });

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
    // @method openPopup(popup: Popup): this
    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
    // @alternative
    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
    // Creates a popup with the specified content and options and opens it in the given point on a map.
    openPopup: function (popup, latlng, options) {
      this._initOverlay(Popup, popup, latlng, options).openOn(this);

      return this;
    },

    // @method closePopup(popup?: Popup): this
    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
    closePopup: function (popup) {
      popup = arguments.length ? popup : this._popup;
      if (popup) {
        popup.close();
      }
      return this;
    },
  });

  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */

  // @section Popup methods
  Layer.include({
    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
    // Binds a popup to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindPopup: function (content, options) {
      this._popup = this._initOverlay(Popup, this._popup, content, options);
      if (!this._popupHandlersAdded) {
        this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup,
        });
        this._popupHandlersAdded = true;
      }

      return this;
    },

    // @method unbindPopup(): this
    // Removes the popup previously bound with `bindPopup`.
    unbindPopup: function () {
      if (this._popup) {
        this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup,
        });
        this._popupHandlersAdded = false;
        this._popup = null;
      }
      return this;
    },

    // @method openPopup(latlng?: LatLng): this
    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
    openPopup: function (latlng) {
      if (this._popup) {
        if (!(this instanceof FeatureGroup)) {
          this._popup._source = this;
        }
        if (this._popup._prepareOpen(latlng || this._latlng)) {
          // open the popup on the map
          this._popup.openOn(this._map);
        }
      }
      return this;
    },

    // @method closePopup(): this
    // Closes the popup bound to this layer if it is open.
    closePopup: function () {
      if (this._popup) {
        this._popup.close();
      }
      return this;
    },

    // @method togglePopup(): this
    // Opens or closes the popup bound to this layer depending on its current state.
    togglePopup: function () {
      if (this._popup) {
        this._popup.toggle(this);
      }
      return this;
    },

    // @method isPopupOpen(): boolean
    // Returns `true` if the popup bound to this layer is currently open.
    isPopupOpen: function () {
      return this._popup ? this._popup.isOpen() : false;
    },

    // @method setPopupContent(content: String|HTMLElement|Popup): this
    // Sets the content of the popup bound to this layer.
    setPopupContent: function (content) {
      if (this._popup) {
        this._popup.setContent(content);
      }
      return this;
    },

    // @method getPopup(): Popup
    // Returns the popup bound to this layer.
    getPopup: function () {
      return this._popup;
    },

    _openPopup: function (e) {
      if (!this._popup || !this._map) {
        return;
      }
      // prevent map click
      stop(e);

      var target = e.layer || e.target;
      if (this._popup._source === target && !(target instanceof Path)) {
        // treat it like a marker and figure out
        // if we should toggle it open/closed
        if (this._map.hasLayer(this._popup)) {
          this.closePopup();
        } else {
          this.openPopup(e.latlng);
        }
        return;
      }
      this._popup._source = target;
      this.openPopup(e.latlng);
    },

    _movePopup: function (e) {
      this._popup.setLatLng(e.latlng);
    },

    _onKeyPress: function (e) {
      if (e.originalEvent.keyCode === 13) {
        this._openPopup(e);
      }
    },
  });

  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   * If you want to just bind a tooltip to marker:
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Path overlays like polylines also have a `bindTooltip` method.
   *
   * A tooltip can be also standalone:
   *
   * ```js
   * var tooltip = L.tooltip()
   * 	.setLatLng(latlng)
   * 	.setContent('Hello world!<br />This is a nice tooltip.')
   * 	.addTo(map);
   * ```
   * or
   * ```js
   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})
   * 	.addTo(map);
   * ```
   *
   *
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */

  // @namespace Tooltip
  var Tooltip = DivOverlay.extend({
    // @section
    // @aka Tooltip options
    options: {
      // @option pane: String = 'tooltipPane'
      // `Map pane` where the tooltip will be added.
      pane: "tooltipPane",

      // @option offset: Point = Point(0, 0)
      // Optional offset of the tooltip position.
      offset: [0, 0],

      // @option direction: String = 'auto'
      // Direction where to open the tooltip. Possible values are: `right`, `left`,
      // `top`, `bottom`, `center`, `auto`.
      // `auto` will dynamically switch between `right` and `left` according to the tooltip
      // position on the map.
      direction: "auto",

      // @option permanent: Boolean = false
      // Whether to open the tooltip permanently or only on mouseover.
      permanent: false,

      // @option sticky: Boolean = false
      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
      sticky: false,

      // @option opacity: Number = 0.9
      // Tooltip container opacity.
      opacity: 0.9,
    },

    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);
      this.setOpacity(this.options.opacity);

      // @namespace Map
      // @section Tooltip events
      // @event tooltipopen: TooltipEvent
      // Fired when a tooltip is opened in the map.
      map.fire("tooltipopen", { tooltip: this });

      if (this._source) {
        this.addEventParent(this._source);

        // @namespace Layer
        // @section Tooltip events
        // @event tooltipopen: TooltipEvent
        // Fired when a tooltip bound to this layer is opened.
        this._source.fire("tooltipopen", { tooltip: this }, true);
      }
    },

    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map);

      // @namespace Map
      // @section Tooltip events
      // @event tooltipclose: TooltipEvent
      // Fired when a tooltip in the map is closed.
      map.fire("tooltipclose", { tooltip: this });

      if (this._source) {
        this.removeEventParent(this._source);

        // @namespace Layer
        // @section Tooltip events
        // @event tooltipclose: TooltipEvent
        // Fired when a tooltip bound to this layer is closed.
        this._source.fire("tooltipclose", { tooltip: this }, true);
      }
    },

    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (!this.options.permanent) {
        events.preclick = this.close;
      }

      return events;
    },

    _initLayout: function () {
      var prefix = "leaflet-tooltip",
        className =
          prefix +
          " " +
          (this.options.className || "") +
          " leaflet-zoom-" +
          (this._zoomAnimated ? "animated" : "hide");

      this._contentNode = this._container = create$1("div", className);

      this._container.setAttribute("role", "tooltip");
      this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
    },

    _updateLayout: function () {},

    _adjustPan: function () {},

    _setPosition: function (pos) {
      var subX,
        subY,
        map = this._map,
        container = this._container,
        centerPoint = map.latLngToContainerPoint(map.getCenter()),
        tooltipPoint = map.layerPointToContainerPoint(pos),
        direction = this.options.direction,
        tooltipWidth = container.offsetWidth,
        tooltipHeight = container.offsetHeight,
        offset = toPoint(this.options.offset),
        anchor = this._getAnchor();

      if (direction === "top") {
        subX = tooltipWidth / 2;
        subY = tooltipHeight;
      } else if (direction === "bottom") {
        subX = tooltipWidth / 2;
        subY = 0;
      } else if (direction === "center") {
        subX = tooltipWidth / 2;
        subY = tooltipHeight / 2;
      } else if (direction === "right") {
        subX = 0;
        subY = tooltipHeight / 2;
      } else if (direction === "left") {
        subX = tooltipWidth;
        subY = tooltipHeight / 2;
      } else if (tooltipPoint.x < centerPoint.x) {
        direction = "right";
        subX = 0;
        subY = tooltipHeight / 2;
      } else {
        direction = "left";
        subX = tooltipWidth + (offset.x + anchor.x) * 2;
        subY = tooltipHeight / 2;
      }

      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);

      removeClass(container, "leaflet-tooltip-right");
      removeClass(container, "leaflet-tooltip-left");
      removeClass(container, "leaflet-tooltip-top");
      removeClass(container, "leaflet-tooltip-bottom");
      addClass(container, "leaflet-tooltip-" + direction);
      setPosition(container, pos);
    },

    _updatePosition: function () {
      var pos = this._map.latLngToLayerPoint(this._latlng);
      this._setPosition(pos);
    },

    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._container) {
        setOpacity(this._container, opacity);
      }
    },

    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(
        this._latlng,
        e.zoom,
        e.center
      );
      this._setPosition(pos);
    },

    _getAnchor: function () {
      // Where should we anchor the tooltip on the source layer?
      return toPoint(
        this._source && this._source._getTooltipAnchor && !this.options.sticky
          ? this._source._getTooltipAnchor()
          : [0, 0]
      );
    },
  });

  // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)
  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.
  var tooltip = function (options, source) {
    return new Tooltip(options, source);
  };

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
    // @method openTooltip(tooltip: Tooltip): this
    // Opens the specified tooltip.
    // @alternative
    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
    // Creates a tooltip with the specified content and options and open it.
    openTooltip: function (tooltip, latlng, options) {
      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);

      return this;
    },

    // @method closeTooltip(tooltip: Tooltip): this
    // Closes the tooltip given as parameter.
    closeTooltip: function (tooltip) {
      tooltip.close();
      return this;
    },
  });

  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */

  // @section Tooltip methods
  Layer.include({
    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
    // Binds a tooltip to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindTooltip: function (content, options) {
      if (this._tooltip && this.isTooltipOpen()) {
        this.unbindTooltip();
      }

      this._tooltip = this._initOverlay(
        Tooltip,
        this._tooltip,
        content,
        options
      );
      this._initTooltipInteractions();

      if (
        this._tooltip.options.permanent &&
        this._map &&
        this._map.hasLayer(this)
      ) {
        this.openTooltip();
      }

      return this;
    },

    // @method unbindTooltip(): this
    // Removes the tooltip previously bound with `bindTooltip`.
    unbindTooltip: function () {
      if (this._tooltip) {
        this._initTooltipInteractions(true);
        this.closeTooltip();
        this._tooltip = null;
      }
      return this;
    },

    _initTooltipInteractions: function (remove) {
      if (!remove && this._tooltipHandlersAdded) {
        return;
      }
      var onOff = remove ? "off" : "on",
        events = {
          remove: this.closeTooltip,
          move: this._moveTooltip,
        };
      if (!this._tooltip.options.permanent) {
        events.mouseover = this._openTooltip;
        events.mouseout = this.closeTooltip;
        events.click = this._openTooltip;
        if (this._map) {
          this._addFocusListeners();
        } else {
          events.add = this._addFocusListeners;
        }
      } else {
        events.add = this._openTooltip;
      }
      if (this._tooltip.options.sticky) {
        events.mousemove = this._moveTooltip;
      }
      this[onOff](events);
      this._tooltipHandlersAdded = !remove;
    },

    // @method openTooltip(latlng?: LatLng): this
    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
    openTooltip: function (latlng) {
      if (this._tooltip) {
        if (!(this instanceof FeatureGroup)) {
          this._tooltip._source = this;
        }
        if (this._tooltip._prepareOpen(latlng)) {
          // open the tooltip on the map
          this._tooltip.openOn(this._map);

          if (this.getElement) {
            this._setAriaDescribedByOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._setAriaDescribedByOnLayer, this);
          }
        }
      }
      return this;
    },

    // @method closeTooltip(): this
    // Closes the tooltip bound to this layer if it is open.
    closeTooltip: function () {
      if (this._tooltip) {
        return this._tooltip.close();
      }
    },

    // @method toggleTooltip(): this
    // Opens or closes the tooltip bound to this layer depending on its current state.
    toggleTooltip: function () {
      if (this._tooltip) {
        this._tooltip.toggle(this);
      }
      return this;
    },

    // @method isTooltipOpen(): boolean
    // Returns `true` if the tooltip bound to this layer is currently open.
    isTooltipOpen: function () {
      return this._tooltip.isOpen();
    },

    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
    // Sets the content of the tooltip bound to this layer.
    setTooltipContent: function (content) {
      if (this._tooltip) {
        this._tooltip.setContent(content);
      }
      return this;
    },

    // @method getTooltip(): Tooltip
    // Returns the tooltip bound to this layer.
    getTooltip: function () {
      return this._tooltip;
    },

    _addFocusListeners: function () {
      if (this.getElement) {
        this._addFocusListenersOnLayer(this);
      } else if (this.eachLayer) {
        this.eachLayer(this._addFocusListenersOnLayer, this);
      }
    },

    _addFocusListenersOnLayer: function (layer) {
      var el = typeof layer.getElement === "function" && layer.getElement();
      if (el) {
        on(
          el,
          "focus",
          function () {
            this._tooltip._source = layer;
            this.openTooltip();
          },
          this
        );
        on(el, "blur", this.closeTooltip, this);
      }
    },

    _setAriaDescribedByOnLayer: function (layer) {
      var el = typeof layer.getElement === "function" && layer.getElement();
      if (el) {
        el.setAttribute("aria-describedby", this._tooltip._container.id);
      }
    },

    _openTooltip: function (e) {
      if (!this._tooltip || !this._map) {
        return;
      }

      // If the map is moving, we will show the tooltip after it's done.
      if (
        this._map.dragging &&
        this._map.dragging.moving() &&
        !this._openOnceFlag
      ) {
        this._openOnceFlag = true;
        var that = this;
        this._map.once("moveend", function () {
          that._openOnceFlag = false;
          that._openTooltip(e);
        });
        return;
      }

      this._tooltip._source = e.layer || e.target;

      this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);
    },

    _moveTooltip: function (e) {
      var latlng = e.latlng,
        containerPoint,
        layerPoint;
      if (this._tooltip.options.sticky && e.originalEvent) {
        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
        layerPoint = this._map.containerPointToLayerPoint(containerPoint);
        latlng = this._map.layerPointToLatLng(layerPoint);
      }
      this._tooltip.setLatLng(latlng);
    },
  });

  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
    options: {
      // @section
      // @aka DivIcon options
      iconSize: [12, 12], // also can be set through CSS

      // iconAnchor: (Point),
      // popupAnchor: (Point),

      // @option html: String|HTMLElement = ''
      // Custom HTML code to put inside the div element, empty by default. Alternatively,
      // an instance of `HTMLElement`.
      html: false,

      // @option bgPos: Point = [0, 0]
      // Optional relative position of the background, in pixels
      bgPos: null,

      className: "leaflet-div-icon",
    },

    createIcon: function (oldIcon) {
      var div =
          oldIcon && oldIcon.tagName === "DIV"
            ? oldIcon
            : document.createElement("div"),
        options = this.options;

      if (options.html instanceof Element) {
        empty(div);
        div.appendChild(options.html);
      } else {
        div.innerHTML = options.html !== false ? options.html : "";
      }

      if (options.bgPos) {
        var bgPos = toPoint(options.bgPos);
        div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
      }
      this._setIconStyles(div, "icon");

      return div;
    },

    createShadow: function () {
      return null;
    },
  });

  // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.
  function divIcon(options) {
    return new DivIcon(options);
  }

  Icon.Default = IconDefault;

  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */

  var GridLayer = Layer.extend({
    // @section
    // @aka GridLayer options
    options: {
      // @option tileSize: Number|Point = 256
      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
      tileSize: 256,

      // @option opacity: Number = 1.0
      // Opacity of the tiles. Can be used in the `createTile()` function.
      opacity: 1,

      // @option updateWhenIdle: Boolean = (depends)
      // Load new tiles only when panning ends.
      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
      updateWhenIdle: Browser.mobile,

      // @option updateWhenZooming: Boolean = true
      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
      updateWhenZooming: true,

      // @option updateInterval: Number = 200
      // Tiles will not update more than once every `updateInterval` milliseconds when panning.
      updateInterval: 200,

      // @option zIndex: Number = 1
      // The explicit zIndex of the tile layer.
      zIndex: 1,

      // @option bounds: LatLngBounds = undefined
      // If set, tiles will only be loaded inside the set `LatLngBounds`.
      bounds: null,

      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,

      // @option maxZoom: Number = undefined
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: undefined,

      // @option maxNativeZoom: Number = undefined
      // Maximum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
      // from `maxNativeZoom` level and auto-scaled.
      maxNativeZoom: undefined,

      // @option minNativeZoom: Number = undefined
      // Minimum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
      // from `minNativeZoom` level and auto-scaled.
      minNativeZoom: undefined,

      // @option noWrap: Boolean = false
      // Whether the layer is wrapped around the antimeridian. If `true`, the
      // GridLayer will only be displayed once at low zoom levels. Has no
      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
      // tiles outside the CRS limits.
      noWrap: false,

      // @option pane: String = 'tilePane'
      // `Map pane` where the grid layer will be added.
      pane: "tilePane",

      // @option className: String = ''
      // A custom class name to assign to the tile layer. Empty by default.
      className: "",

      // @option keepBuffer: Number = 2
      // When panning the map, keep this many rows and columns of tiles before unloading them.
      keepBuffer: 2,
    },

    initialize: function (options) {
      setOptions(this, options);
    },

    onAdd: function () {
      this._initContainer();

      this._levels = {};
      this._tiles = {};

      this._resetView(); // implicit _update() call
    },

    beforeAdd: function (map) {
      map._addZoomLimit(this);
    },

    onRemove: function (map) {
      this._removeAllTiles();
      remove(this._container);
      map._removeZoomLimit(this);
      this._container = null;
      this._tileZoom = undefined;
    },

    // @method bringToFront: this
    // Brings the tile layer to the top of all tile layers.
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
        this._setAutoZIndex(Math.max);
      }
      return this;
    },

    // @method bringToBack: this
    // Brings the tile layer to the bottom of all tile layers.
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
        this._setAutoZIndex(Math.min);
      }
      return this;
    },

    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the tiles for this layer.
    getContainer: function () {
      return this._container;
    },

    // @method setOpacity(opacity: Number): this
    // Changes the [opacity](#gridlayer-opacity) of the grid layer.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;
      this._updateOpacity();
      return this;
    },

    // @method setZIndex(zIndex: Number): this
    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
    setZIndex: function (zIndex) {
      this.options.zIndex = zIndex;
      this._updateZIndex();

      return this;
    },

    // @method isLoading: Boolean
    // Returns `true` if any tile in the grid layer has not finished loading.
    isLoading: function () {
      return this._loading;
    },

    // @method redraw: this
    // Causes the layer to clear all the tiles and request them again.
    redraw: function () {
      if (this._map) {
        this._removeAllTiles();
        var tileZoom = this._clampZoom(this._map.getZoom());
        if (tileZoom !== this._tileZoom) {
          this._tileZoom = tileZoom;
          this._updateLevels();
        }
        this._update();
      }
      return this;
    },

    getEvents: function () {
      var events = {
        viewprereset: this._invalidateAll,
        viewreset: this._resetView,
        zoom: this._resetView,
        moveend: this._onMoveEnd,
      };

      if (!this.options.updateWhenIdle) {
        // update tiles on move, but not more often than once per given interval
        if (!this._onMove) {
          this._onMove = throttle(
            this._onMoveEnd,
            this.options.updateInterval,
            this
          );
        }

        events.move = this._onMove;
      }

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },

    // @section Extension methods
    // Layers extending `GridLayer` shall reimplement the following method.
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, must be overridden by classes extending `GridLayer`.
    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
    // is specified, it must be called when the tile has finished loading and drawing.
    createTile: function () {
      return document.createElement("div");
    },

    // @section
    // @method getTileSize: Point
    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
    getTileSize: function () {
      var s = this.options.tileSize;
      return s instanceof Point ? s : new Point(s, s);
    },

    _updateZIndex: function () {
      if (
        this._container &&
        this.options.zIndex !== undefined &&
        this.options.zIndex !== null
      ) {
        this._container.style.zIndex = this.options.zIndex;
      }
    },

    _setAutoZIndex: function (compare) {
      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

      var layers = this.getPane().children,
        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

      for (var i = 0, len = layers.length, zIndex; i < len; i++) {
        zIndex = layers[i].style.zIndex;

        if (layers[i] !== this._container && zIndex) {
          edgeZIndex = compare(edgeZIndex, +zIndex);
        }
      }

      if (isFinite(edgeZIndex)) {
        this.options.zIndex = edgeZIndex + compare(-1, 1);
        this._updateZIndex();
      }
    },

    _updateOpacity: function () {
      if (!this._map) {
        return;
      }

      // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
      if (Browser.ielt9) {
        return;
      }

      setOpacity(this._container, this.options.opacity);

      var now = +new Date(),
        nextFrame = false,
        willPrune = false;

      for (var key in this._tiles) {
        var tile = this._tiles[key];
        if (!tile.current || !tile.loaded) {
          continue;
        }

        var fade = Math.min(1, (now - tile.loaded) / 200);

        setOpacity(tile.el, fade);
        if (fade < 1) {
          nextFrame = true;
        } else {
          if (tile.active) {
            willPrune = true;
          } else {
            this._onOpaqueTile(tile);
          }
          tile.active = true;
        }
      }

      if (willPrune && !this._noPrune) {
        this._pruneTiles();
      }

      if (nextFrame) {
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      }
    },

    _onOpaqueTile: falseFn,

    _initContainer: function () {
      if (this._container) {
        return;
      }

      this._container = create$1(
        "div",
        "leaflet-layer " + (this.options.className || "")
      );
      this._updateZIndex();

      if (this.options.opacity < 1) {
        this._updateOpacity();
      }

      this.getPane().appendChild(this._container);
    },

    _updateLevels: function () {
      var zoom = this._tileZoom,
        maxZoom = this.options.maxZoom;

      if (zoom === undefined) {
        return undefined;
      }

      for (var z in this._levels) {
        z = Number(z);
        if (this._levels[z].el.children.length || z === zoom) {
          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
          this._onUpdateLevel(z);
        } else {
          remove(this._levels[z].el);
          this._removeTilesAtZoom(z);
          this._onRemoveLevel(z);
          delete this._levels[z];
        }
      }

      var level = this._levels[zoom],
        map = this._map;

      if (!level) {
        level = this._levels[zoom] = {};

        level.el = create$1(
          "div",
          "leaflet-tile-container leaflet-zoom-animated",
          this._container
        );
        level.el.style.zIndex = maxZoom;

        level.origin = map
          .project(map.unproject(map.getPixelOrigin()), zoom)
          .round();
        level.zoom = zoom;

        this._setZoomTransform(level, map.getCenter(), map.getZoom());

        // force the browser to consider the newly added element for transition
        falseFn(level.el.offsetWidth);

        this._onCreateLevel(level);
      }

      this._level = level;

      return level;
    },

    _onUpdateLevel: falseFn,

    _onRemoveLevel: falseFn,

    _onCreateLevel: falseFn,

    _pruneTiles: function () {
      if (!this._map) {
        return;
      }

      var key, tile;

      var zoom = this._map.getZoom();
      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        this._removeAllTiles();
        return;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];
        tile.retain = tile.current;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];
        if (tile.current && !tile.active) {
          var coords = tile.coords;
          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
          }
        }
      }

      for (key in this._tiles) {
        if (!this._tiles[key].retain) {
          this._removeTile(key);
        }
      }
    },

    _removeTilesAtZoom: function (zoom) {
      for (var key in this._tiles) {
        if (this._tiles[key].coords.z !== zoom) {
          continue;
        }
        this._removeTile(key);
      }
    },

    _removeAllTiles: function () {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
    },

    _invalidateAll: function () {
      for (var z in this._levels) {
        remove(this._levels[z].el);
        this._onRemoveLevel(Number(z));
        delete this._levels[z];
      }
      this._removeAllTiles();

      this._tileZoom = undefined;
    },

    _retainParent: function (x, y, z, minZoom) {
      var x2 = Math.floor(x / 2),
        y2 = Math.floor(y / 2),
        z2 = z - 1,
        coords2 = new Point(+x2, +y2);
      coords2.z = +z2;

      var key = this._tileCoordsToKey(coords2),
        tile = this._tiles[key];

      if (tile && tile.active) {
        tile.retain = true;
        return true;
      } else if (tile && tile.loaded) {
        tile.retain = true;
      }

      if (z2 > minZoom) {
        return this._retainParent(x2, y2, z2, minZoom);
      }

      return false;
    },

    _retainChildren: function (x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var coords = new Point(i, j);
          coords.z = z + 1;

          var key = this._tileCoordsToKey(coords),
            tile = this._tiles[key];

          if (tile && tile.active) {
            tile.retain = true;
            continue;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }

          if (z + 1 < maxZoom) {
            this._retainChildren(i, j, z + 1, maxZoom);
          }
        }
      }
    },

    _resetView: function (e) {
      var animating = e && (e.pinch || e.flyTo);
      this._setView(
        this._map.getCenter(),
        this._map.getZoom(),
        animating,
        animating
      );
    },

    _animateZoom: function (e) {
      this._setView(e.center, e.zoom, true, e.noUpdate);
    },

    _clampZoom: function (zoom) {
      var options = this.options;

      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
        return options.minNativeZoom;
      }

      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
        return options.maxNativeZoom;
      }

      return zoom;
    },

    _setView: function (center, zoom, noPrune, noUpdate) {
      var tileZoom = Math.round(zoom);
      if (
        (this.options.maxZoom !== undefined &&
          tileZoom > this.options.maxZoom) ||
        (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)
      ) {
        tileZoom = undefined;
      } else {
        tileZoom = this._clampZoom(tileZoom);
      }

      var tileZoomChanged =
        this.options.updateWhenZooming && tileZoom !== this._tileZoom;

      if (!noUpdate || tileZoomChanged) {
        this._tileZoom = tileZoom;

        if (this._abortLoading) {
          this._abortLoading();
        }

        this._updateLevels();
        this._resetGrid();

        if (tileZoom !== undefined) {
          this._update(center);
        }

        if (!noPrune) {
          this._pruneTiles();
        }

        // Flag to prevent _updateOpacity from pruning tiles during
        // a zoom anim or a pinch gesture
        this._noPrune = !!noPrune;
      }

      this._setZoomTransforms(center, zoom);
    },

    _setZoomTransforms: function (center, zoom) {
      for (var i in this._levels) {
        this._setZoomTransform(this._levels[i], center, zoom);
      }
    },

    _setZoomTransform: function (level, center, zoom) {
      var scale = this._map.getZoomScale(zoom, level.zoom),
        translate = level.origin
          .multiplyBy(scale)
          .subtract(this._map._getNewPixelOrigin(center, zoom))
          .round();

      if (Browser.any3d) {
        setTransform(level.el, translate, scale);
      } else {
        setPosition(level.el, translate);
      }
    },

    _resetGrid: function () {
      var map = this._map,
        crs = map.options.crs,
        tileSize = (this._tileSize = this.getTileSize()),
        tileZoom = this._tileZoom;

      var bounds = this._map.getPixelWorldBounds(this._tileZoom);
      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }

      this._wrapX = crs.wrapLng &&
        !this.options.noWrap && [
          Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
          Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y),
        ];
      this._wrapY = crs.wrapLat &&
        !this.options.noWrap && [
          Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
          Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y),
        ];
    },

    _onMoveEnd: function () {
      if (!this._map || this._map._animatingZoom) {
        return;
      }

      this._update();
    },

    _getTiledPixelBounds: function (center) {
      var map = this._map,
        mapZoom = map._animatingZoom
          ? Math.max(map._animateToZoom, map.getZoom())
          : map.getZoom(),
        scale = map.getZoomScale(mapZoom, this._tileZoom),
        pixelCenter = map.project(center, this._tileZoom).floor(),
        halfSize = map.getSize().divideBy(scale * 2);

      return new Bounds(
        pixelCenter.subtract(halfSize),
        pixelCenter.add(halfSize)
      );
    },

    // Private method to load tiles in the grid's active zoom level according to map bounds
    _update: function (center) {
      var map = this._map;
      if (!map) {
        return;
      }
      var zoom = this._clampZoom(map.getZoom());

      if (center === undefined) {
        center = map.getCenter();
      }
      if (this._tileZoom === undefined) {
        return;
      } // if out of minzoom/maxzoom

      var pixelBounds = this._getTiledPixelBounds(center),
        tileRange = this._pxBoundsToTileRange(pixelBounds),
        tileCenter = tileRange.getCenter(),
        queue = [],
        margin = this.options.keepBuffer,
        noPruneRange = new Bounds(
          tileRange.getBottomLeft().subtract([margin, -margin]),
          tileRange.getTopRight().add([margin, -margin])
        );

      // Sanity check: panic if the tile range contains Infinity somewhere.
      if (
        !(
          isFinite(tileRange.min.x) &&
          isFinite(tileRange.min.y) &&
          isFinite(tileRange.max.x) &&
          isFinite(tileRange.max.y)
        )
      ) {
        throw new Error("Attempted to load an infinite number of tiles");
      }

      for (var key in this._tiles) {
        var c = this._tiles[key].coords;
        if (
          c.z !== this._tileZoom ||
          !noPruneRange.contains(new Point(c.x, c.y))
        ) {
          this._tiles[key].current = false;
        }
      }

      // _update just loads more tiles. If the tile zoom level differs too much
      // from the map's, let _setView reset levels and prune old tiles.
      if (Math.abs(zoom - this._tileZoom) > 1) {
        this._setView(center, zoom);
        return;
      }

      // create a queue of coordinates to load tiles from
      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
          var coords = new Point(i, j);
          coords.z = this._tileZoom;

          if (!this._isValidTile(coords)) {
            continue;
          }

          var tile = this._tiles[this._tileCoordsToKey(coords)];
          if (tile) {
            tile.current = true;
          } else {
            queue.push(coords);
          }
        }
      }

      // sort tile queue to load tiles in order of their distance to center
      queue.sort(function (a, b) {
        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
      });

      if (queue.length !== 0) {
        // if it's the first batch of tiles to load
        if (!this._loading) {
          this._loading = true;
          // @event loading: Event
          // Fired when the grid layer starts loading tiles.
          this.fire("loading");
        }

        // create DOM fragment to append tiles in one batch
        var fragment = document.createDocumentFragment();

        for (i = 0; i < queue.length; i++) {
          this._addTile(queue[i], fragment);
        }

        this._level.el.appendChild(fragment);
      }
    },

    _isValidTile: function (coords) {
      var crs = this._map.options.crs;

      if (!crs.infinite) {
        // don't load tile if it's out of bounds and not wrapped
        var bounds = this._globalTileRange;
        if (
          (!crs.wrapLng &&
            (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
          (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))
        ) {
          return false;
        }
      }

      if (!this.options.bounds) {
        return true;
      }

      // don't load tile if it doesn't intersect the bounds in options
      var tileBounds = this._tileCoordsToBounds(coords);
      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
    },

    _keyToBounds: function (key) {
      return this._tileCoordsToBounds(this._keyToTileCoords(key));
    },

    _tileCoordsToNwSe: function (coords) {
      var map = this._map,
        tileSize = this.getTileSize(),
        nwPoint = coords.scaleBy(tileSize),
        sePoint = nwPoint.add(tileSize),
        nw = map.unproject(nwPoint, coords.z),
        se = map.unproject(sePoint, coords.z);
      return [nw, se];
    },

    // converts tile coordinates to its geographical bounds
    _tileCoordsToBounds: function (coords) {
      var bp = this._tileCoordsToNwSe(coords),
        bounds = new LatLngBounds(bp[0], bp[1]);

      if (!this.options.noWrap) {
        bounds = this._map.wrapLatLngBounds(bounds);
      }
      return bounds;
    },
    // converts tile coordinates to key for the tile cache
    _tileCoordsToKey: function (coords) {
      return coords.x + ":" + coords.y + ":" + coords.z;
    },

    // converts tile cache key to coordinates
    _keyToTileCoords: function (key) {
      var k = key.split(":"),
        coords = new Point(+k[0], +k[1]);
      coords.z = +k[2];
      return coords;
    },

    _removeTile: function (key) {
      var tile = this._tiles[key];
      if (!tile) {
        return;
      }

      remove(tile.el);

      delete this._tiles[key];

      // @event tileunload: TileEvent
      // Fired when a tile is removed (e.g. when a tile goes off the screen).
      this.fire("tileunload", {
        tile: tile.el,
        coords: this._keyToTileCoords(key),
      });
    },

    _initTile: function (tile) {
      addClass(tile, "leaflet-tile");

      var tileSize = this.getTileSize();
      tile.style.width = tileSize.x + "px";
      tile.style.height = tileSize.y + "px";

      tile.onselectstart = falseFn;
      tile.onmousemove = falseFn;

      // update opacity on tiles in IE7-8 because of filter inheritance problems
      if (Browser.ielt9 && this.options.opacity < 1) {
        setOpacity(tile, this.options.opacity);
      }
    },

    _addTile: function (coords, container) {
      var tilePos = this._getTilePos(coords),
        key = this._tileCoordsToKey(coords);

      var tile = this.createTile(
        this._wrapCoords(coords),
        bind(this._tileReady, this, coords)
      );

      this._initTile(tile);

      // if createTile is defined with a second argument ("done" callback),
      // we know that tile is async and will be ready later; otherwise
      if (this.createTile.length < 2) {
        // mark tile as ready, but delay one frame for opacity animation to happen
        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
      }

      setPosition(tile, tilePos);

      // save tile in cache
      this._tiles[key] = {
        el: tile,
        coords: coords,
        current: true,
      };

      container.appendChild(tile);
      // @event tileloadstart: TileEvent
      // Fired when a tile is requested and starts loading.
      this.fire("tileloadstart", {
        tile: tile,
        coords: coords,
      });
    },

    _tileReady: function (coords, err, tile) {
      if (err) {
        // @event tileerror: TileErrorEvent
        // Fired when there is an error loading a tile.
        this.fire("tileerror", {
          error: err,
          tile: tile,
          coords: coords,
        });
      }

      var key = this._tileCoordsToKey(coords);

      tile = this._tiles[key];
      if (!tile) {
        return;
      }

      tile.loaded = +new Date();
      if (this._map._fadeAnimated) {
        setOpacity(tile.el, 0);
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      } else {
        tile.active = true;
        this._pruneTiles();
      }

      if (!err) {
        addClass(tile.el, "leaflet-tile-loaded");

        // @event tileload: TileEvent
        // Fired when a tile loads.
        this.fire("tileload", {
          tile: tile.el,
          coords: coords,
        });
      }

      if (this._noTilesToLoad()) {
        this._loading = false;
        // @event load: Event
        // Fired when the grid layer loaded all visible tiles.
        this.fire("load");

        if (Browser.ielt9 || !this._map._fadeAnimated) {
          requestAnimFrame(this._pruneTiles, this);
        } else {
          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
          // to trigger a pruning.
          setTimeout(bind(this._pruneTiles, this), 250);
        }
      }
    },

    _getTilePos: function (coords) {
      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
    },

    _wrapCoords: function (coords) {
      var newCoords = new Point(
        this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
        this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
      );
      newCoords.z = coords.z;
      return newCoords;
    },

    _pxBoundsToTileRange: function (bounds) {
      var tileSize = this.getTileSize();
      return new Bounds(
        bounds.min.unscaleBy(tileSize).floor(),
        bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
      );
    },

    _noTilesToLoad: function () {
      for (var key in this._tiles) {
        if (!this._tiles[key].loaded) {
          return false;
        }
      }
      return true;
    },
  });

  // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.
  function gridLayer(options) {
    return new GridLayer(options);
  }

  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` â zoom level, `{x}` and `{y}` â tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */

  var TileLayer = GridLayer.extend({
    // @section
    // @aka TileLayer options
    options: {
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,

      // @option maxZoom: Number = 18
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: 18,

      // @option subdomains: String|String[] = 'abc'
      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
      subdomains: "abc",

      // @option errorTileUrl: String = ''
      // URL to the tile image to show in place of the tile that failed to load.
      errorTileUrl: "",

      // @option zoomOffset: Number = 0
      // The zoom number used in tile URLs will be offset with this value.
      zoomOffset: 0,

      // @option tms: Boolean = false
      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
      tms: false,

      // @option zoomReverse: Boolean = false
      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
      zoomReverse: false,

      // @option detectRetina: Boolean = false
      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
      detectRetina: false,

      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,

      // @option referrerPolicy: Boolean|String = false
      // Whether the referrerPolicy attribute will be added to the tiles.
      // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
      // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
      // (e.g. to validate an API token).
      // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
      referrerPolicy: false,
    },

    initialize: function (url, options) {
      this._url = url;

      options = setOptions(this, options);

      // detecting retina displays, adjusting tileSize and zoom levels
      if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);

        if (!options.zoomReverse) {
          options.zoomOffset++;
          options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
        } else {
          options.zoomOffset--;
          options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
        }

        options.minZoom = Math.max(0, options.minZoom);
      } else if (!options.zoomReverse) {
        // make sure maxZoom is gte minZoom
        options.maxZoom = Math.max(options.minZoom, options.maxZoom);
      } else {
        // make sure minZoom is lte maxZoom
        options.minZoom = Math.min(options.maxZoom, options.minZoom);
      }

      if (typeof options.subdomains === "string") {
        options.subdomains = options.subdomains.split("");
      }

      this.on("tileunload", this._onTileRemove);
    },

    // @method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    // If the URL does not change, the layer will not be redrawn unless
    // the noRedraw parameter is set to false.
    setUrl: function (url, noRedraw) {
      if (this._url === url && noRedraw === undefined) {
        noRedraw = true;
      }

      this._url = url;

      if (!noRedraw) {
        this.redraw();
      }
      return this;
    },

    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
    // callback is called when the tile has been loaded.
    createTile: function (coords, done) {
      var tile = document.createElement("img");

      on(tile, "load", bind(this._tileOnLoad, this, done, tile));
      on(tile, "error", bind(this._tileOnError, this, done, tile));

      if (this.options.crossOrigin || this.options.crossOrigin === "") {
        tile.crossOrigin =
          this.options.crossOrigin === true ? "" : this.options.crossOrigin;
      }

      // for this new option we follow the documented behavior
      // more closely by only setting the property when string
      if (typeof this.options.referrerPolicy === "string") {
        tile.referrerPolicy = this.options.referrerPolicy;
      }

      // The alt attribute is set to the empty string,
      // allowing screen readers to ignore the decorative image tiles.
      // https://www.w3.org/WAI/tutorials/images/decorative/
      // https://www.w3.org/TR/html-aria/#el-img-empty-alt
      tile.alt = "";

      tile.src = this.getTileUrl(coords);

      return tile;
    },

    // @section Extension methods
    // @uninheritable
    // Layers extending `TileLayer` might reimplement the following method.
    // @method getTileUrl(coords: Object): String
    // Called only internally, returns the URL for a tile given its coordinates.
    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
    getTileUrl: function (coords) {
      var data = {
        r: Browser.retina ? "@2x" : "",
        s: this._getSubdomain(coords),
        x: coords.x,
        y: coords.y,
        z: this._getZoomForUrl(),
      };
      if (this._map && !this._map.options.crs.infinite) {
        var invertedY = this._globalTileRange.max.y - coords.y;
        if (this.options.tms) {
          data["y"] = invertedY;
        }
        data["-y"] = invertedY;
      }

      return template(this._url, extend(data, this.options));
    },

    _tileOnLoad: function (done, tile) {
      // For https://github.com/Leaflet/Leaflet/issues/3332
      if (Browser.ielt9) {
        setTimeout(bind(done, this, null, tile), 0);
      } else {
        done(null, tile);
      }
    },

    _tileOnError: function (done, tile, e) {
      var errorUrl = this.options.errorTileUrl;
      if (errorUrl && tile.getAttribute("src") !== errorUrl) {
        tile.src = errorUrl;
      }
      done(e, tile);
    },

    _onTileRemove: function (e) {
      e.tile.onload = null;
    },

    _getZoomForUrl: function () {
      var zoom = this._tileZoom,
        maxZoom = this.options.maxZoom,
        zoomReverse = this.options.zoomReverse,
        zoomOffset = this.options.zoomOffset;

      if (zoomReverse) {
        zoom = maxZoom - zoom;
      }

      return zoom + zoomOffset;
    },

    _getSubdomain: function (tilePoint) {
      var index =
        Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
      return this.options.subdomains[index];
    },

    // stops loading all tiles in the background layer
    _abortLoading: function () {
      var i, tile;
      for (i in this._tiles) {
        if (this._tiles[i].coords.z !== this._tileZoom) {
          tile = this._tiles[i].el;

          tile.onload = falseFn;
          tile.onerror = falseFn;

          if (!tile.complete) {
            tile.src = emptyImageUrl;
            var coords = this._tiles[i].coords;
            remove(tile);
            delete this._tiles[i];
            // @event tileabort: TileEvent
            // Fired when a tile was loading but is now not wanted.
            this.fire("tileabort", {
              tile: tile,
              coords: coords,
            });
          }
        }
      }
    },

    _removeTile: function (key) {
      var tile = this._tiles[key];
      if (!tile) {
        return;
      }

      // Cancels any pending http requests associated with the tile
      tile.el.setAttribute("src", emptyImageUrl);

      return GridLayer.prototype._removeTile.call(this, key);
    },

    _tileReady: function (coords, err, tile) {
      if (!this._map || (tile && tile.getAttribute("src") === emptyImageUrl)) {
        return;
      }

      return GridLayer.prototype._tileReady.call(this, coords, err, tile);
    },
  });

  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
    return new TileLayer(url, options);
  }

  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data Â© 2012 IEM Nexrad"
   * });
   * ```
   */

  var TileLayerWMS = TileLayer.extend({
    // @section
    // @aka TileLayer.WMS options
    // If any custom options not documented here are used, they will be sent to the
    // WMS server as extra parameters in each request URL. This can be useful for
    // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
    defaultWmsParams: {
      service: "WMS",
      request: "GetMap",

      // @option layers: String = ''
      // **(required)** Comma-separated list of WMS layers to show.
      layers: "",

      // @option styles: String = ''
      // Comma-separated list of WMS styles.
      styles: "",

      // @option format: String = 'image/jpeg'
      // WMS image format (use `'image/png'` for layers with transparency).
      format: "image/jpeg",

      // @option transparent: Boolean = false
      // If `true`, the WMS service will return images with transparency.
      transparent: false,

      // @option version: String = '1.1.1'
      // Version of the WMS service to use
      version: "1.1.1",
    },

    options: {
      // @option crs: CRS = null
      // Coordinate Reference System to use for the WMS requests, defaults to
      // map CRS. Don't change this if you're not sure what it means.
      crs: null,

      // @option uppercase: Boolean = false
      // If `true`, WMS request parameter keys will be uppercase.
      uppercase: false,
    },

    initialize: function (url, options) {
      this._url = url;

      var wmsParams = extend({}, this.defaultWmsParams);

      // all keys that are not TileLayer options go to WMS params
      for (var i in options) {
        if (!(i in this.options)) {
          wmsParams[i] = options[i];
        }
      }

      options = setOptions(this, options);

      var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
      var tileSize = this.getTileSize();
      wmsParams.width = tileSize.x * realRetina;
      wmsParams.height = tileSize.y * realRetina;

      this.wmsParams = wmsParams;
    },

    onAdd: function (map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);

      var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
      this.wmsParams[projectionKey] = this._crs.code;

      TileLayer.prototype.onAdd.call(this, map);
    },

    getTileUrl: function (coords) {
      var tileBounds = this._tileCoordsToNwSe(coords),
        crs = this._crs,
        bounds = toBounds(
          crs.project(tileBounds[0]),
          crs.project(tileBounds[1])
        ),
        min = bounds.min,
        max = bounds.max,
        bbox = (
          this._wmsVersion >= 1.3 && this._crs === EPSG4326
            ? [min.y, min.x, max.y, max.x]
            : [min.x, min.y, max.x, max.y]
        ).join(","),
        url = TileLayer.prototype.getTileUrl.call(this, coords);
      return (
        url +
        getParamString(this.wmsParams, url, this.options.uppercase) +
        (this.options.uppercase ? "&BBOX=" : "&bbox=") +
        bbox
      );
    },

    // @method setParams(params: Object, noRedraw?: Boolean): this
    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
    setParams: function (params, noRedraw) {
      extend(this.wmsParams, params);

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    },
  });

  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
  function tileLayerWMS(url, options) {
    return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;

  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({
    // @section
    // @aka Renderer options
    options: {
      // @option padding: Number = 0.1
      // How much to extend the clip area around the map view (relative to its size)
      // e.g. 0.1 would be 10% of map view in each direction
      padding: 0.1,
    },

    initialize: function (options) {
      setOptions(this, options);
      stamp(this);
      this._layers = this._layers || {};
    },

    onAdd: function () {
      if (!this._container) {
        this._initContainer(); // defined by renderer implementations

        // always keep transform-origin as 0 0
        addClass(this._container, "leaflet-zoom-animated");
      }

      this.getPane().appendChild(this._container);
      this._update();
      this.on("update", this._updatePaths, this);
    },

    onRemove: function () {
      this.off("update", this._updatePaths, this);
      this._destroyContainer();
    },

    getEvents: function () {
      var events = {
        viewreset: this._reset,
        zoom: this._onZoom,
        moveend: this._update,
        zoomend: this._onZoomEnd,
      };
      if (this._zoomAnimated) {
        events.zoomanim = this._onAnimZoom;
      }
      return events;
    },

    _onAnimZoom: function (ev) {
      this._updateTransform(ev.center, ev.zoom);
    },

    _onZoom: function () {
      this._updateTransform(this._map.getCenter(), this._map.getZoom());
    },

    _updateTransform: function (center, zoom) {
      var scale = this._map.getZoomScale(zoom, this._zoom),
        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
        currentCenterPoint = this._map.project(this._center, zoom),
        topLeftOffset = viewHalf
          .multiplyBy(-scale)
          .add(currentCenterPoint)
          .subtract(this._map._getNewPixelOrigin(center, zoom));

      if (Browser.any3d) {
        setTransform(this._container, topLeftOffset, scale);
      } else {
        setPosition(this._container, topLeftOffset);
      }
    },

    _reset: function () {
      this._update();
      this._updateTransform(this._center, this._zoom);

      for (var id in this._layers) {
        this._layers[id]._reset();
      }
    },

    _onZoomEnd: function () {
      for (var id in this._layers) {
        this._layers[id]._project();
      }
    },

    _updatePaths: function () {
      for (var id in this._layers) {
        this._layers[id]._update();
      }
    },

    _update: function () {
      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
      // Subclasses are responsible of firing the 'update' event.
      var p = this.options.padding,
        size = this._map.getSize(),
        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

      this._bounds = new Bounds(
        min,
        min.add(size.multiplyBy(1 + p * 2)).round()
      );

      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    },
  });

  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({
    // @section
    // @aka Canvas options
    options: {
      // @option tolerance: Number = 0
      // How much to extend the click tolerance around a path/object on the map.
      tolerance: 0,
    },

    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.viewprereset = this._onViewPreReset;
      return events;
    },

    _onViewPreReset: function () {
      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
      this._postponeUpdatePaths = true;
    },

    onAdd: function () {
      Renderer.prototype.onAdd.call(this);

      // Redraw vectors since canvas is cleared upon removal,
      // in case of removing the renderer itself from the map.
      this._draw();
    },

    _initContainer: function () {
      var container = (this._container = document.createElement("canvas"));

      on(container, "mousemove", this._onMouseMove, this);
      on(
        container,
        "click dblclick mousedown mouseup contextmenu",
        this._onClick,
        this
      );
      on(container, "mouseout", this._handleMouseOut, this);
      container["_leaflet_disable_events"] = true;

      this._ctx = container.getContext("2d");
    },

    _destroyContainer: function () {
      cancelAnimFrame(this._redrawRequest);
      delete this._ctx;
      remove(this._container);
      off(this._container);
      delete this._container;
    },

    _updatePaths: function () {
      if (this._postponeUpdatePaths) {
        return;
      }

      var layer;
      this._redrawBounds = null;
      for (var id in this._layers) {
        layer = this._layers[id];
        layer._update();
      }
      this._redraw();
    },

    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
        container = this._container,
        size = b.getSize(),
        m = Browser.retina ? 2 : 1;

      setPosition(container, b.min);

      // set canvas size (also clearing it); use double size on retina
      container.width = m * size.x;
      container.height = m * size.y;
      container.style.width = size.x + "px";
      container.style.height = size.y + "px";

      if (Browser.retina) {
        this._ctx.scale(2, 2);
      }

      // translate so we use the same path coordinates after canvas element moves
      this._ctx.translate(-b.min.x, -b.min.y);

      // Tell paths to redraw themselves
      this.fire("update");
    },

    _reset: function () {
      Renderer.prototype._reset.call(this);

      if (this._postponeUpdatePaths) {
        this._postponeUpdatePaths = false;
        this._updatePaths();
      }
    },

    _initPath: function (layer) {
      this._updateDashArray(layer);
      this._layers[stamp(layer)] = layer;

      var order = (layer._order = {
        layer: layer,
        prev: this._drawLast,
        next: null,
      });
      if (this._drawLast) {
        this._drawLast.next = order;
      }
      this._drawLast = order;
      this._drawFirst = this._drawFirst || this._drawLast;
    },

    _addPath: function (layer) {
      this._requestRedraw(layer);
    },

    _removePath: function (layer) {
      var order = layer._order;
      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        this._drawLast = prev;
      }
      if (prev) {
        prev.next = next;
      } else {
        this._drawFirst = next;
      }

      delete layer._order;

      delete this._layers[stamp(layer)];

      this._requestRedraw(layer);
    },

    _updatePath: function (layer) {
      // Redraw the union of the layer's old pixel
      // bounds and the new pixel bounds.
      this._extendRedrawBounds(layer);
      layer._project();
      layer._update();
      // The redraw will extend the redraw bounds
      // with the new pixel bounds.
      this._requestRedraw(layer);
    },

    _updateStyle: function (layer) {
      this._updateDashArray(layer);
      this._requestRedraw(layer);
    },

    _updateDashArray: function (layer) {
      if (typeof layer.options.dashArray === "string") {
        var parts = layer.options.dashArray.split(/[, ]+/),
          dashArray = [],
          dashValue,
          i;
        for (i = 0; i < parts.length; i++) {
          dashValue = Number(parts[i]);
          // Ignore dash array containing invalid lengths
          if (isNaN(dashValue)) {
            return;
          }
          dashArray.push(dashValue);
        }
        layer.options._dashArray = dashArray;
      } else {
        layer.options._dashArray = layer.options.dashArray;
      }
    },

    _requestRedraw: function (layer) {
      if (!this._map) {
        return;
      }

      this._extendRedrawBounds(layer);
      this._redrawRequest =
        this._redrawRequest || requestAnimFrame(this._redraw, this);
    },

    _extendRedrawBounds: function (layer) {
      if (layer._pxBounds) {
        var padding = (layer.options.weight || 0) + 1;
        this._redrawBounds = this._redrawBounds || new Bounds();
        this._redrawBounds.extend(
          layer._pxBounds.min.subtract([padding, padding])
        );
        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
      }
    },

    _redraw: function () {
      this._redrawRequest = null;

      if (this._redrawBounds) {
        this._redrawBounds.min._floor();
        this._redrawBounds.max._ceil();
      }

      this._clear(); // clear layers in redraw bounds
      this._draw(); // draw layers

      this._redrawBounds = null;
    },

    _clear: function () {
      var bounds = this._redrawBounds;
      if (bounds) {
        var size = bounds.getSize();
        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
      } else {
        this._ctx.save();
        this._ctx.setTransform(1, 0, 0, 1, 0, 0);
        this._ctx.clearRect(
          0,
          0,
          this._container.width,
          this._container.height
        );
        this._ctx.restore();
      }
    },

    _draw: function () {
      var layer,
        bounds = this._redrawBounds;
      this._ctx.save();
      if (bounds) {
        var size = bounds.getSize();
        this._ctx.beginPath();
        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
        this._ctx.clip();
      }

      this._drawing = true;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;
        if (
          !bounds ||
          (layer._pxBounds && layer._pxBounds.intersects(bounds))
        ) {
          layer._updatePath();
        }
      }

      this._drawing = false;

      this._ctx.restore(); // Restore state before clipping.
    },

    _updatePoly: function (layer, closed) {
      if (!this._drawing) {
        return;
      }

      var i,
        j,
        len2,
        p,
        parts = layer._parts,
        len = parts.length,
        ctx = this._ctx;

      if (!len) {
        return;
      }

      ctx.beginPath();

      for (i = 0; i < len; i++) {
        for (j = 0, len2 = parts[i].length; j < len2; j++) {
          p = parts[i][j];
          ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
        }
        if (closed) {
          ctx.closePath();
        }
      }

      this._fillStroke(ctx, layer);

      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
    },

    _updateCircle: function (layer) {
      if (!this._drawing || layer._empty()) {
        return;
      }

      var p = layer._point,
        ctx = this._ctx,
        r = Math.max(Math.round(layer._radius), 1),
        s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

      if (s !== 1) {
        ctx.save();
        ctx.scale(1, s);
      }

      ctx.beginPath();
      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

      if (s !== 1) {
        ctx.restore();
      }

      this._fillStroke(ctx, layer);
    },

    _fillStroke: function (ctx, layer) {
      var options = layer.options;

      if (options.fill) {
        ctx.globalAlpha = options.fillOpacity;
        ctx.fillStyle = options.fillColor || options.color;
        ctx.fill(options.fillRule || "evenodd");
      }

      if (options.stroke && options.weight !== 0) {
        if (ctx.setLineDash) {
          ctx.setLineDash((layer.options && layer.options._dashArray) || []);
        }
        ctx.globalAlpha = options.opacity;
        ctx.lineWidth = options.weight;
        ctx.strokeStyle = options.color;
        ctx.lineCap = options.lineCap;
        ctx.lineJoin = options.lineJoin;
        ctx.stroke();
      }
    },

    // Canvas obviously doesn't have mouse events for individual drawn objects,
    // so we emulate that by calculating what's under the mouse on mousemove/click manually

    _onClick: function (e) {
      var point = this._map.mouseEventToLayerPoint(e),
        layer,
        clickedLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;
        if (layer.options.interactive && layer._containsPoint(point)) {
          if (
            !(e.type === "click" || e.type === "preclick") ||
            !this._map._draggableMoved(layer)
          ) {
            clickedLayer = layer;
          }
        }
      }
      this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
    },

    _onMouseMove: function (e) {
      if (
        !this._map ||
        this._map.dragging.moving() ||
        this._map._animatingZoom
      ) {
        return;
      }

      var point = this._map.mouseEventToLayerPoint(e);
      this._handleMouseHover(e, point);
    },

    _handleMouseOut: function (e) {
      var layer = this._hoveredLayer;
      if (layer) {
        // if we're leaving the layer, fire mouseout
        removeClass(this._container, "leaflet-interactive");
        this._fireEvent([layer], e, "mouseout");
        this._hoveredLayer = null;
        this._mouseHoverThrottled = false;
      }
    },

    _handleMouseHover: function (e, point) {
      if (this._mouseHoverThrottled) {
        return;
      }

      var layer, candidateHoveredLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;
        if (layer.options.interactive && layer._containsPoint(point)) {
          candidateHoveredLayer = layer;
        }
      }

      if (candidateHoveredLayer !== this._hoveredLayer) {
        this._handleMouseOut(e);

        if (candidateHoveredLayer) {
          addClass(this._container, "leaflet-interactive"); // change cursor
          this._fireEvent([candidateHoveredLayer], e, "mouseover");
          this._hoveredLayer = candidateHoveredLayer;
        }
      }

      this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);

      this._mouseHoverThrottled = true;
      setTimeout(
        bind(function () {
          this._mouseHoverThrottled = false;
        }, this),
        32
      );
    },

    _fireEvent: function (layers, e, type) {
      this._map._fireDOMEvent(e, type || e.type, layers);
    },

    _bringToFront: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        // Already last
        return;
      }
      if (prev) {
        prev.next = next;
      } else if (next) {
        // Update first entry unless this is the
        // single entry
        this._drawFirst = next;
      }

      order.prev = this._drawLast;
      this._drawLast.next = order;

      order.next = null;
      this._drawLast = order;

      this._requestRedraw(layer);
    },

    _bringToBack: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (prev) {
        prev.next = next;
      } else {
        // Already first
        return;
      }
      if (next) {
        next.prev = prev;
      } else if (prev) {
        // Update last entry unless this is the
        // single entry
        this._drawLast = prev;
      }

      order.prev = null;

      order.next = this._drawFirst;
      this._drawFirst.prev = order;
      this._drawFirst = order;

      this._requestRedraw(layer);
    },
  });

  // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.
  function canvas(options) {
    return Browser.canvas ? new Canvas(options) : null;
  }

  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */

  var vmlCreate = (function () {
    try {
      document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
      return function (name) {
        return document.createElement("<lvml:" + name + ' class="lvml">');
      };
    } catch (e) {
      // Do not return fn from catch block so `e` can be garbage collected
      // See https://github.com/Leaflet/Leaflet/pull/7279
    }
    return function (name) {
      return document.createElement(
        "<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">'
      );
    };
  })();

  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */

  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
  var vmlMixin = {
    _initContainer: function () {
      this._container = create$1("div", "leaflet-vml-container");
    },

    _update: function () {
      if (this._map._animatingZoom) {
        return;
      }
      Renderer.prototype._update.call(this);
      this.fire("update");
    },

    _initPath: function (layer) {
      var container = (layer._container = vmlCreate("shape"));

      addClass(
        container,
        "leaflet-vml-shape " + (this.options.className || "")
      );

      container.coordsize = "1 1";

      layer._path = vmlCreate("path");
      container.appendChild(layer._path);

      this._updateStyle(layer);
      this._layers[stamp(layer)] = layer;
    },

    _addPath: function (layer) {
      var container = layer._container;
      this._container.appendChild(container);

      if (layer.options.interactive) {
        layer.addInteractiveTarget(container);
      }
    },

    _removePath: function (layer) {
      var container = layer._container;
      remove(container);
      layer.removeInteractiveTarget(container);
      delete this._layers[stamp(layer)];
    },

    _updateStyle: function (layer) {
      var stroke = layer._stroke,
        fill = layer._fill,
        options = layer.options,
        container = layer._container;

      container.stroked = !!options.stroke;
      container.filled = !!options.fill;

      if (options.stroke) {
        if (!stroke) {
          stroke = layer._stroke = vmlCreate("stroke");
        }
        container.appendChild(stroke);
        stroke.weight = options.weight + "px";
        stroke.color = options.color;
        stroke.opacity = options.opacity;

        if (options.dashArray) {
          stroke.dashStyle = isArray(options.dashArray)
            ? options.dashArray.join(" ")
            : options.dashArray.replace(/( *, *)/g, " ");
        } else {
          stroke.dashStyle = "";
        }
        stroke.endcap = options.lineCap.replace("butt", "flat");
        stroke.joinstyle = options.lineJoin;
      } else if (stroke) {
        container.removeChild(stroke);
        layer._stroke = null;
      }

      if (options.fill) {
        if (!fill) {
          fill = layer._fill = vmlCreate("fill");
        }
        container.appendChild(fill);
        fill.color = options.fillColor || options.color;
        fill.opacity = options.fillOpacity;
      } else if (fill) {
        container.removeChild(fill);
        layer._fill = null;
      }
    },

    _updateCircle: function (layer) {
      var p = layer._point.round(),
        r = Math.round(layer._radius),
        r2 = Math.round(layer._radiusY || r);

      this._setPath(
        layer,
        layer._empty()
          ? "M0 0"
          : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360
      );
    },

    _setPath: function (layer, path) {
      layer._path.v = path;
    },

    _bringToFront: function (layer) {
      toFront(layer._container);
    },

    _bringToBack: function (layer) {
      toBack(layer._container);
    },
  };

  var create = Browser.vml ? vmlCreate : svgCreate;

  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({
    _initContainer: function () {
      this._container = create("svg");

      // makes it possible to click through svg root; we'll reset it back in individual paths
      this._container.setAttribute("pointer-events", "none");

      this._rootGroup = create("g");
      this._container.appendChild(this._rootGroup);
    },

    _destroyContainer: function () {
      remove(this._container);
      off(this._container);
      delete this._container;
      delete this._rootGroup;
      delete this._svgSize;
    },

    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
        size = b.getSize(),
        container = this._container;

      // set size of svg-container if changed
      if (!this._svgSize || !this._svgSize.equals(size)) {
        this._svgSize = size;
        container.setAttribute("width", size.x);
        container.setAttribute("height", size.y);
      }

      // movement: update container viewBox so that we don't have to change coordinates of individual layers
      setPosition(container, b.min);
      container.setAttribute(
        "viewBox",
        [b.min.x, b.min.y, size.x, size.y].join(" ")
      );

      this.fire("update");
    },

    // methods below are called by vector layers implementations

    _initPath: function (layer) {
      var path = (layer._path = create("path"));

      // @namespace Path
      // @option className: String = null
      // Custom class name set on an element. Only for SVG renderer.
      if (layer.options.className) {
        addClass(path, layer.options.className);
      }

      if (layer.options.interactive) {
        addClass(path, "leaflet-interactive");
      }

      this._updateStyle(layer);
      this._layers[stamp(layer)] = layer;
    },

    _addPath: function (layer) {
      if (!this._rootGroup) {
        this._initContainer();
      }
      this._rootGroup.appendChild(layer._path);
      layer.addInteractiveTarget(layer._path);
    },

    _removePath: function (layer) {
      remove(layer._path);
      layer.removeInteractiveTarget(layer._path);
      delete this._layers[stamp(layer)];
    },

    _updatePath: function (layer) {
      layer._project();
      layer._update();
    },

    _updateStyle: function (layer) {
      var path = layer._path,
        options = layer.options;

      if (!path) {
        return;
      }

      if (options.stroke) {
        path.setAttribute("stroke", options.color);
        path.setAttribute("stroke-opacity", options.opacity);
        path.setAttribute("stroke-width", options.weight);
        path.setAttribute("stroke-linecap", options.lineCap);
        path.setAttribute("stroke-linejoin", options.lineJoin);

        if (options.dashArray) {
          path.setAttribute("stroke-dasharray", options.dashArray);
        } else {
          path.removeAttribute("stroke-dasharray");
        }

        if (options.dashOffset) {
          path.setAttribute("stroke-dashoffset", options.dashOffset);
        } else {
          path.removeAttribute("stroke-dashoffset");
        }
      } else {
        path.setAttribute("stroke", "none");
      }

      if (options.fill) {
        path.setAttribute("fill", options.fillColor || options.color);
        path.setAttribute("fill-opacity", options.fillOpacity);
        path.setAttribute("fill-rule", options.fillRule || "evenodd");
      } else {
        path.setAttribute("fill", "none");
      }
    },

    _updatePoly: function (layer, closed) {
      this._setPath(layer, pointsToPath(layer._parts, closed));
    },

    _updateCircle: function (layer) {
      var p = layer._point,
        r = Math.max(Math.round(layer._radius), 1),
        r2 = Math.max(Math.round(layer._radiusY), 1) || r,
        arc = "a" + r + "," + r2 + " 0 1,0 ";

      // drawing a circle with two half-arcs
      var d = layer._empty()
        ? "M0 0"
        : "M" +
          (p.x - r) +
          "," +
          p.y +
          arc +
          r * 2 +
          ",0 " +
          arc +
          -r * 2 +
          ",0 ";

      this._setPath(layer, d);
    },

    _setPath: function (layer, path) {
      layer._path.setAttribute("d", path);
    },

    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
    _bringToFront: function (layer) {
      toFront(layer._path);
    },

    _bringToBack: function (layer) {
      toBack(layer._path);
    },
  });

  if (Browser.vml) {
    SVG.include(vmlMixin);
  }

  // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.
  function svg(options) {
    return Browser.svg || Browser.vml ? new SVG(options) : null;
  }

  Map.include({
    // @namespace Map; @method getRenderer(layer: Path): Renderer
    // Returns the instance of `Renderer` that should be used to render the given
    // `Path`. It will ensure that the `renderer` options of the map and paths
    // are respected, and that the renderers do exist on the map.
    getRenderer: function (layer) {
      // @namespace Path; @option renderer: Renderer
      // Use this specific instance of `Renderer` for this path. Takes
      // precedence over the map's [default renderer](#map-renderer).
      var renderer =
        layer.options.renderer ||
        this._getPaneRenderer(layer.options.pane) ||
        this.options.renderer ||
        this._renderer;

      if (!renderer) {
        renderer = this._renderer = this._createRenderer();
      }

      if (!this.hasLayer(renderer)) {
        this.addLayer(renderer);
      }
      return renderer;
    },

    _getPaneRenderer: function (name) {
      if (name === "overlayPane" || name === undefined) {
        return false;
      }

      var renderer = this._paneRenderers[name];
      if (renderer === undefined) {
        renderer = this._createRenderer({ pane: name });
        this._paneRenderers[name] = renderer;
      }
      return renderer;
    },

    _createRenderer: function (options) {
      // @namespace Map; @option preferCanvas: Boolean = false
      // Whether `Path`s should be rendered on a `Canvas` renderer.
      // By default, all `Path`s are rendered in a `SVG` renderer.
      return (this.options.preferCanvas && canvas(options)) || svg(options);
    },
  });

  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */

  var Rectangle = Polygon.extend({
    initialize: function (latLngBounds, options) {
      Polygon.prototype.initialize.call(
        this,
        this._boundsToLatLngs(latLngBounds),
        options
      );
    },

    // @method setBounds(latLngBounds: LatLngBounds): this
    // Redraws the rectangle with the passed bounds.
    setBounds: function (latLngBounds) {
      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    },

    _boundsToLatLngs: function (latLngBounds) {
      latLngBounds = toLatLngBounds(latLngBounds);
      return [
        latLngBounds.getSouthWest(),
        latLngBounds.getNorthWest(),
        latLngBounds.getNorthEast(),
        latLngBounds.getSouthEast(),
      ];
    },
  });

  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
  function rectangle(latLngBounds, options) {
    return new Rectangle(latLngBounds, options);
  }

  SVG.create = create;
  SVG.pointsToPath = pointsToPath;

  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;

  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @option boxZoom: Boolean = true
    // Whether the map can be zoomed to a rectangular area specified by
    // dragging the mouse while pressing the shift key.
    boxZoom: true,
  });

  var BoxZoom = Handler.extend({
    initialize: function (map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._resetStateTimeout = 0;
      map.on("unload", this._destroy, this);
    },

    addHooks: function () {
      on(this._container, "mousedown", this._onMouseDown, this);
    },

    removeHooks: function () {
      off(this._container, "mousedown", this._onMouseDown, this);
    },

    moved: function () {
      return this._moved;
    },

    _destroy: function () {
      remove(this._pane);
      delete this._pane;
    },

    _resetState: function () {
      this._resetStateTimeout = 0;
      this._moved = false;
    },

    _clearDeferredResetState: function () {
      if (this._resetStateTimeout !== 0) {
        clearTimeout(this._resetStateTimeout);
        this._resetStateTimeout = 0;
      }
    },

    _onMouseDown: function (e) {
      if (!e.shiftKey || (e.which !== 1 && e.button !== 1)) {
        return false;
      }

      // Clear the deferred resetState if it hasn't executed yet, otherwise it
      // will interrupt the interaction and orphan a box element in the container.
      this._clearDeferredResetState();
      this._resetState();

      disableTextSelection();
      disableImageDrag();

      this._startPoint = this._map.mouseEventToContainerPoint(e);

      on(
        document,
        {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown,
        },
        this
      );
    },

    _onMouseMove: function (e) {
      if (!this._moved) {
        this._moved = true;

        this._box = create$1("div", "leaflet-zoom-box", this._container);
        addClass(this._container, "leaflet-crosshair");

        this._map.fire("boxzoomstart");
      }

      this._point = this._map.mouseEventToContainerPoint(e);

      var bounds = new Bounds(this._point, this._startPoint),
        size = bounds.getSize();

      setPosition(this._box, bounds.min);

      this._box.style.width = size.x + "px";
      this._box.style.height = size.y + "px";
    },

    _finish: function () {
      if (this._moved) {
        remove(this._box);
        removeClass(this._container, "leaflet-crosshair");
      }

      enableTextSelection();
      enableImageDrag();

      off(
        document,
        {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown,
        },
        this
      );
    },

    _onMouseUp: function (e) {
      if (e.which !== 1 && e.button !== 1) {
        return;
      }

      this._finish();

      if (!this._moved) {
        return;
      }
      // Postpone to next JS tick so internal click event handling
      // still see it as "moved".
      this._clearDeferredResetState();
      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

      var bounds = new LatLngBounds(
        this._map.containerPointToLatLng(this._startPoint),
        this._map.containerPointToLatLng(this._point)
      );

      this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
    },

    _onKeyDown: function (e) {
      if (e.keyCode === 27) {
        this._finish();
        this._clearDeferredResetState();
        this._resetState();
      }
    },
  });

  // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.
  Map.addInitHook("addHandler", "boxZoom", BoxZoom);

  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */

  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option doubleClickZoom: Boolean|String = true
    // Whether the map can be zoomed in by double clicking on it and
    // zoomed out by double clicking while holding shift. If passed
    // `'center'`, double-click zoom will zoom to the center of the
    //  view regardless of where the mouse was.
    doubleClickZoom: true,
  });

  var DoubleClickZoom = Handler.extend({
    addHooks: function () {
      this._map.on("dblclick", this._onDoubleClick, this);
    },

    removeHooks: function () {
      this._map.off("dblclick", this._onDoubleClick, this);
    },

    _onDoubleClick: function (e) {
      var map = this._map,
        oldZoom = map.getZoom(),
        delta = map.options.zoomDelta,
        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

      if (map.options.doubleClickZoom === "center") {
        map.setZoom(zoom);
      } else {
        map.setZoomAround(e.containerPoint, zoom);
      }
    },
  });

  // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.
  Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);

  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @option dragging: Boolean = true
    // Whether the map is draggable with mouse/touch or not.
    dragging: true,

    // @section Panning Inertia Options
    // @option inertia: Boolean = *
    // If enabled, panning of the map will have an inertia effect where
    // the map builds momentum while dragging and continues moving in
    // the same direction for some time. Feels especially nice on touch
    // devices. Enabled by default.
    inertia: true,

    // @option inertiaDeceleration: Number = 3000
    // The rate with which the inertial movement slows down, in pixels/secondÂ².
    inertiaDeceleration: 3400, // px/s^2

    // @option inertiaMaxSpeed: Number = Infinity
    // Max speed of the inertial movement, in pixels/second.
    inertiaMaxSpeed: Infinity, // px/s

    // @option easeLinearity: Number = 0.2
    easeLinearity: 0.2,

    // TODO refactor, move to CRS
    // @option worldCopyJump: Boolean = false
    // With this option enabled, the map tracks when you pan to another "copy"
    // of the world and seamlessly jumps to the original one so that all overlays
    // like markers and vector layers are still visible.
    worldCopyJump: false,

    // @option maxBoundsViscosity: Number = 0.0
    // If `maxBounds` is set, this option will control how solid the bounds
    // are when dragging the map around. The default value of `0.0` allows the
    // user to drag outside the bounds at normal speed, higher values will
    // slow down map dragging outside bounds, and `1.0` makes the bounds fully
    // solid, preventing the user from dragging outside the bounds.
    maxBoundsViscosity: 0.0,
  });

  var Drag = Handler.extend({
    addHooks: function () {
      if (!this._draggable) {
        var map = this._map;

        this._draggable = new Draggable(map._mapPane, map._container);

        this._draggable.on(
          {
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd,
          },
          this
        );

        this._draggable.on("predrag", this._onPreDragLimit, this);
        if (map.options.worldCopyJump) {
          this._draggable.on("predrag", this._onPreDragWrap, this);
          map.on("zoomend", this._onZoomEnd, this);

          map.whenReady(this._onZoomEnd, this);
        }
      }
      addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
      this._draggable.enable();
      this._positions = [];
      this._times = [];
    },

    removeHooks: function () {
      removeClass(this._map._container, "leaflet-grab");
      removeClass(this._map._container, "leaflet-touch-drag");
      this._draggable.disable();
    },

    moved: function () {
      return this._draggable && this._draggable._moved;
    },

    moving: function () {
      return this._draggable && this._draggable._moving;
    },

    _onDragStart: function () {
      var map = this._map;

      map._stop();
      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var bounds = toLatLngBounds(this._map.options.maxBounds);

        this._offsetLimit = toBounds(
          this._map
            .latLngToContainerPoint(bounds.getNorthWest())
            .multiplyBy(-1),
          this._map
            .latLngToContainerPoint(bounds.getSouthEast())
            .multiplyBy(-1)
            .add(this._map.getSize())
        );

        this._viscosity = Math.min(
          1.0,
          Math.max(0.0, this._map.options.maxBoundsViscosity)
        );
      } else {
        this._offsetLimit = null;
      }

      map.fire("movestart").fire("dragstart");

      if (map.options.inertia) {
        this._positions = [];
        this._times = [];
      }
    },

    _onDrag: function (e) {
      if (this._map.options.inertia) {
        var time = (this._lastTime = +new Date()),
          pos = (this._lastPos =
            this._draggable._absPos || this._draggable._newPos);

        this._positions.push(pos);
        this._times.push(time);

        this._prunePositions(time);
      }

      this._map.fire("move", e).fire("drag", e);
    },

    _prunePositions: function (time) {
      while (this._positions.length > 1 && time - this._times[0] > 50) {
        this._positions.shift();
        this._times.shift();
      }
    },

    _onZoomEnd: function () {
      var pxCenter = this._map.getSize().divideBy(2),
        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
    },

    _viscousLimit: function (value, threshold) {
      return value - (value - threshold) * this._viscosity;
    },

    _onPreDragLimit: function () {
      if (!this._viscosity || !this._offsetLimit) {
        return;
      }

      var offset = this._draggable._newPos.subtract(this._draggable._startPos);

      var limit = this._offsetLimit;
      if (offset.x < limit.min.x) {
        offset.x = this._viscousLimit(offset.x, limit.min.x);
      }
      if (offset.y < limit.min.y) {
        offset.y = this._viscousLimit(offset.y, limit.min.y);
      }
      if (offset.x > limit.max.x) {
        offset.x = this._viscousLimit(offset.x, limit.max.x);
      }
      if (offset.y > limit.max.y) {
        offset.y = this._viscousLimit(offset.y, limit.max.y);
      }

      this._draggable._newPos = this._draggable._startPos.add(offset);
    },

    _onPreDragWrap: function () {
      // TODO refactor to be able to adjust map pane position after zoom
      var worldWidth = this._worldWidth,
        halfWidth = Math.round(worldWidth / 2),
        dx = this._initialWorldOffset,
        x = this._draggable._newPos.x,
        newX1 = ((x - halfWidth + dx) % worldWidth) + halfWidth - dx,
        newX2 = ((x + halfWidth + dx) % worldWidth) - halfWidth - dx,
        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

      this._draggable._absPos = this._draggable._newPos.clone();
      this._draggable._newPos.x = newX;
    },

    _onDragEnd: function (e) {
      var map = this._map,
        options = map.options,
        noInertia = !options.inertia || e.noInertia || this._times.length < 2;

      map.fire("dragend", e);

      if (noInertia) {
        map.fire("moveend");
      } else {
        this._prunePositions(+new Date());

        var direction = this._lastPos.subtract(this._positions[0]),
          duration = (this._lastTime - this._times[0]) / 1000,
          ease = options.easeLinearity,
          speedVector = direction.multiplyBy(ease / duration),
          speed = speedVector.distanceTo([0, 0]),
          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
          decelerationDuration =
            limitedSpeed / (options.inertiaDeceleration * ease),
          offset = limitedSpeedVector
            .multiplyBy(-decelerationDuration / 2)
            .round();

        if (!offset.x && !offset.y) {
          map.fire("moveend");
        } else {
          offset = map._limitOffset(offset, map.options.maxBounds);

          requestAnimFrame(function () {
            map.panBy(offset, {
              duration: decelerationDuration,
              easeLinearity: ease,
              noMoveStart: true,
              animate: true,
            });
          });
        }
      }
    },
  });

  // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).
  Map.addInitHook("addHandler", "dragging", Drag);

  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */

  // @namespace Map
  // @section Keyboard Navigation Options
  Map.mergeOptions({
    // @option keyboard: Boolean = true
    // Makes the map focusable and allows users to navigate the map with keyboard
    // arrows and `+`/`-` keys.
    keyboard: true,

    // @option keyboardPanDelta: Number = 80
    // Amount of pixels to pan when pressing an arrow key.
    keyboardPanDelta: 80,
  });

  var Keyboard = Handler.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 54, 173],
    },

    initialize: function (map) {
      this._map = map;

      this._setPanDelta(map.options.keyboardPanDelta);
      this._setZoomDelta(map.options.zoomDelta);
    },

    addHooks: function () {
      var container = this._map._container;

      // make the container focusable by tabbing
      if (container.tabIndex <= 0) {
        container.tabIndex = "0";
      }

      on(
        container,
        {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown,
        },
        this
      );

      this._map.on(
        {
          focus: this._addHooks,
          blur: this._removeHooks,
        },
        this
      );
    },

    removeHooks: function () {
      this._removeHooks();

      off(
        this._map._container,
        {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown,
        },
        this
      );

      this._map.off(
        {
          focus: this._addHooks,
          blur: this._removeHooks,
        },
        this
      );
    },

    _onMouseDown: function () {
      if (this._focused) {
        return;
      }

      var body = document.body,
        docEl = document.documentElement,
        top = body.scrollTop || docEl.scrollTop,
        left = body.scrollLeft || docEl.scrollLeft;

      this._map._container.focus();

      window.scrollTo(left, top);
    },

    _onFocus: function () {
      this._focused = true;
      this._map.fire("focus");
    },

    _onBlur: function () {
      this._focused = false;
      this._map.fire("blur");
    },

    _setPanDelta: function (panDelta) {
      var keys = (this._panKeys = {}),
        codes = this.keyCodes,
        i,
        len;

      for (i = 0, len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * panDelta, 0];
      }
      for (i = 0, len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [panDelta, 0];
      }
      for (i = 0, len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, panDelta];
      }
      for (i = 0, len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * panDelta];
      }
    },

    _setZoomDelta: function (zoomDelta) {
      var keys = (this._zoomKeys = {}),
        codes = this.keyCodes,
        i,
        len;

      for (i = 0, len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoomDelta;
      }
      for (i = 0, len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoomDelta;
      }
    },

    _addHooks: function () {
      on(document, "keydown", this._onKeyDown, this);
    },

    _removeHooks: function () {
      off(document, "keydown", this._onKeyDown, this);
    },

    _onKeyDown: function (e) {
      if (e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      var key = e.keyCode,
        map = this._map,
        offset;

      if (key in this._panKeys) {
        if (!map._panAnim || !map._panAnim._inProgress) {
          offset = this._panKeys[key];
          if (e.shiftKey) {
            offset = toPoint(offset).multiplyBy(3);
          }

          if (map.options.maxBounds) {
            offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
          }

          if (map.options.worldCopyJump) {
            var newLatLng = map.wrapLatLng(
              map.unproject(map.project(map.getCenter()).add(offset))
            );
            map.panTo(newLatLng);
          } else {
            map.panBy(offset);
          }
        }
      } else if (key in this._zoomKeys) {
        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
      } else if (
        key === 27 &&
        map._popup &&
        map._popup.options.closeOnEscapeKey
      ) {
        map.closePopup();
      } else {
        return;
      }

      stop(e);
    },
  });

  // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.
  Map.addInitHook("addHandler", "keyboard", Keyboard);

  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @section Mouse wheel options
    // @option scrollWheelZoom: Boolean|String = true
    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
    // it will zoom to the center of the view regardless of where the mouse was.
    scrollWheelZoom: true,

    // @option wheelDebounceTime: Number = 40
    // Limits the rate at which a wheel can fire (in milliseconds). By default
    // user can't zoom via wheel more often than once per 40 ms.
    wheelDebounceTime: 40,

    // @option wheelPxPerZoomLevel: Number = 60
    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
    // mean a change of one full zoom level. Smaller values will make wheel-zooming
    // faster (and vice versa).
    wheelPxPerZoomLevel: 60,
  });

  var ScrollWheelZoom = Handler.extend({
    addHooks: function () {
      on(this._map._container, "wheel", this._onWheelScroll, this);

      this._delta = 0;
    },

    removeHooks: function () {
      off(this._map._container, "wheel", this._onWheelScroll, this);
    },

    _onWheelScroll: function (e) {
      var delta = getWheelDelta(e);

      var debounce = this._map.options.wheelDebounceTime;

      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);

      if (!this._startTime) {
        this._startTime = +new Date();
      }

      var left = Math.max(debounce - (+new Date() - this._startTime), 0);

      clearTimeout(this._timer);
      this._timer = setTimeout(bind(this._performZoom, this), left);

      stop(e);
    },

    _performZoom: function () {
      var map = this._map,
        zoom = map.getZoom(),
        snap = this._map.options.zoomSnap || 0;

      map._stop(); // stop panning and fly animations if any

      // map the delta with a sigmoid function to -4..4 range leaning on -1..1
      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
        d3 = (4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2))))) / Math.LN2,
        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

      this._delta = 0;
      this._startTime = null;

      if (!delta) {
        return;
      }

      if (map.options.scrollWheelZoom === "center") {
        map.setZoom(zoom + delta);
      } else {
        map.setZoomAround(this._lastMousePos, zoom + delta);
      }
    },
  });

  // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.
  Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);

  /*
   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,
   * which otherwise is not fired by mobile Safari.
   */

  var tapHoldDelay = 600;

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @section Touch interaction options
    // @option tapHold: Boolean
    // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,

    // @option tapTolerance: Number = 15
    // The max number of pixels a user can shift his finger during touch
    // for it to be considered a valid tap.
    tapTolerance: 15,
  });

  var TapHold = Handler.extend({
    addHooks: function () {
      on(this._map._container, "touchstart", this._onDown, this);
    },

    removeHooks: function () {
      off(this._map._container, "touchstart", this._onDown, this);
    },

    _onDown: function (e) {
      clearTimeout(this._holdTimeout);
      if (e.touches.length !== 1) {
        return;
      }

      var first = e.touches[0];
      this._startPos = this._newPos = new Point(first.clientX, first.clientY);

      this._holdTimeout = setTimeout(
        bind(function () {
          this._cancel();
          if (!this._isTapValid()) {
            return;
          }

          // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events
          on(document, "touchend", preventDefault);
          on(document, "touchend touchcancel", this._cancelClickPrevent);
          this._simulateEvent("contextmenu", first);
        }, this),
        tapHoldDelay
      );

      on(document, "touchend touchcancel contextmenu", this._cancel, this);
      on(document, "touchmove", this._onMove, this);
    },

    _cancelClickPrevent: function cancelClickPrevent() {
      off(document, "touchend", preventDefault);
      off(document, "touchend touchcancel", cancelClickPrevent);
    },

    _cancel: function () {
      clearTimeout(this._holdTimeout);
      off(document, "touchend touchcancel contextmenu", this._cancel, this);
      off(document, "touchmove", this._onMove, this);
    },

    _onMove: function (e) {
      var first = e.touches[0];
      this._newPos = new Point(first.clientX, first.clientY);
    },

    _isTapValid: function () {
      return (
        this._newPos.distanceTo(this._startPos) <=
        this._map.options.tapTolerance
      );
    },

    _simulateEvent: function (type, e) {
      var simulatedEvent = new MouseEvent(type, {
        bubbles: true,
        cancelable: true,
        view: window,
        // detail: 1,
        screenX: e.screenX,
        screenY: e.screenY,
        clientX: e.clientX,
        clientY: e.clientY,
        // button: 2,
        // buttons: 2
      });

      simulatedEvent._simulated = true;

      e.target.dispatchEvent(simulatedEvent);
    },
  });

  // @section Handlers
  // @property tapHold: Handler
  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).
  Map.addInitHook("addHandler", "tapHold", TapHold);

  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @section Touch interaction options
    // @option touchZoom: Boolean|String = *
    // Whether the map can be zoomed by touch-dragging with two fingers. If
    // passed `'center'`, it will zoom to the center of the view regardless of
    // where the touch events (fingers) were. Enabled for touch-capable web
    // browsers.
    touchZoom: Browser.touch,

    // @option bounceAtZoomLimits: Boolean = true
    // Set it to false if you don't want the map to zoom beyond min/max zoom
    // and then bounce back when pinch-zooming.
    bounceAtZoomLimits: true,
  });

  var TouchZoom = Handler.extend({
    addHooks: function () {
      addClass(this._map._container, "leaflet-touch-zoom");
      on(this._map._container, "touchstart", this._onTouchStart, this);
    },

    removeHooks: function () {
      removeClass(this._map._container, "leaflet-touch-zoom");
      off(this._map._container, "touchstart", this._onTouchStart, this);
    },

    _onTouchStart: function (e) {
      var map = this._map;
      if (
        !e.touches ||
        e.touches.length !== 2 ||
        map._animatingZoom ||
        this._zooming
      ) {
        return;
      }

      var p1 = map.mouseEventToContainerPoint(e.touches[0]),
        p2 = map.mouseEventToContainerPoint(e.touches[1]);

      this._centerPoint = map.getSize()._divideBy(2);
      this._startLatLng = map.containerPointToLatLng(this._centerPoint);
      if (map.options.touchZoom !== "center") {
        this._pinchStartLatLng = map.containerPointToLatLng(
          p1.add(p2)._divideBy(2)
        );
      }

      this._startDist = p1.distanceTo(p2);
      this._startZoom = map.getZoom();

      this._moved = false;
      this._zooming = true;

      map._stop();

      on(document, "touchmove", this._onTouchMove, this);
      on(document, "touchend touchcancel", this._onTouchEnd, this);

      preventDefault(e);
    },

    _onTouchMove: function (e) {
      if (!e.touches || e.touches.length !== 2 || !this._zooming) {
        return;
      }

      var map = this._map,
        p1 = map.mouseEventToContainerPoint(e.touches[0]),
        p2 = map.mouseEventToContainerPoint(e.touches[1]),
        scale = p1.distanceTo(p2) / this._startDist;

      this._zoom = map.getScaleZoom(scale, this._startZoom);

      if (
        !map.options.bounceAtZoomLimits &&
        ((this._zoom < map.getMinZoom() && scale < 1) ||
          (this._zoom > map.getMaxZoom() && scale > 1))
      ) {
        this._zoom = map._limitZoom(this._zoom);
      }

      if (map.options.touchZoom === "center") {
        this._center = this._startLatLng;
        if (scale === 1) {
          return;
        }
      } else {
        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
        if (scale === 1 && delta.x === 0 && delta.y === 0) {
          return;
        }
        this._center = map.unproject(
          map.project(this._pinchStartLatLng, this._zoom).subtract(delta),
          this._zoom
        );
      }

      if (!this._moved) {
        map._moveStart(true, false);
        this._moved = true;
      }

      cancelAnimFrame(this._animRequest);

      var moveFn = bind(
        map._move,
        map,
        this._center,
        this._zoom,
        { pinch: true, round: false },
        undefined
      );
      this._animRequest = requestAnimFrame(moveFn, this, true);

      preventDefault(e);
    },

    _onTouchEnd: function () {
      if (!this._moved || !this._zooming) {
        this._zooming = false;
        return;
      }

      this._zooming = false;
      cancelAnimFrame(this._animRequest);

      off(document, "touchmove", this._onTouchMove, this);
      off(document, "touchend touchcancel", this._onTouchEnd, this);

      // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
      if (this._map.options.zoomAnimation) {
        this._map._animateZoom(
          this._center,
          this._map._limitZoom(this._zoom),
          true,
          this._map.options.zoomSnap
        );
      } else {
        this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    },
  });

  // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.
  Map.addInitHook("addHandler", "touchZoom", TouchZoom);

  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.TapHold = TapHold;
  Map.TouchZoom = TouchZoom;

  exports.Bounds = Bounds;
  exports.Browser = Browser;
  exports.CRS = CRS;
  exports.Canvas = Canvas;
  exports.Circle = Circle;
  exports.CircleMarker = CircleMarker;
  exports.Class = Class;
  exports.Control = Control;
  exports.DivIcon = DivIcon;
  exports.DivOverlay = DivOverlay;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.Draggable = Draggable;
  exports.Evented = Evented;
  exports.FeatureGroup = FeatureGroup;
  exports.GeoJSON = GeoJSON;
  exports.GridLayer = GridLayer;
  exports.Handler = Handler;
  exports.Icon = Icon;
  exports.ImageOverlay = ImageOverlay;
  exports.LatLng = LatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.LineUtil = LineUtil;
  exports.Map = Map;
  exports.Marker = Marker;
  exports.Mixin = Mixin;
  exports.Path = Path;
  exports.Point = Point;
  exports.PolyUtil = PolyUtil;
  exports.Polygon = Polygon;
  exports.Polyline = Polyline;
  exports.Popup = Popup;
  exports.PosAnimation = PosAnimation;
  exports.Projection = index;
  exports.Rectangle = Rectangle;
  exports.Renderer = Renderer;
  exports.SVG = SVG;
  exports.SVGOverlay = SVGOverlay;
  exports.TileLayer = TileLayer;
  exports.Tooltip = Tooltip;
  exports.Transformation = Transformation;
  exports.Util = Util;
  exports.VideoOverlay = VideoOverlay;
  exports.bind = bind;
  exports.bounds = toBounds;
  exports.canvas = canvas;
  exports.circle = circle;
  exports.circleMarker = circleMarker;
  exports.control = control;
  exports.divIcon = divIcon;
  exports.extend = extend;
  exports.featureGroup = featureGroup;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.gridLayer = gridLayer;
  exports.icon = icon;
  exports.imageOverlay = imageOverlay;
  exports.latLng = toLatLng;
  exports.latLngBounds = toLatLngBounds;
  exports.layerGroup = layerGroup;
  exports.map = createMap;
  exports.marker = marker;
  exports.point = toPoint;
  exports.polygon = polygon;
  exports.polyline = polyline;
  exports.popup = popup;
  exports.rectangle = rectangle;
  exports.setOptions = setOptions;
  exports.stamp = stamp;
  exports.svg = svg;
  exports.svgOverlay = svgOverlay;
  exports.tileLayer = tileLayer;
  exports.tooltip = tooltip;
  exports.transformation = toTransformation;
  exports.version = version;
  exports.videoOverlay = videoOverlay;

  var oldL = window.L;
  exports.noConflict = function () {
    window.L = oldL;
    return this;
  };
  // Always export us to window global (see #2364)
  window.L = exports;
});

L.Icon.Default = L.Icon.Default.extend({
  _getIconUrl: function (name) {
    var paths = {
      "icon-2x.png":
        "/assets/marker-icon-2x-091245b393c16cdcefe54920aa7d3994a0683317ca9a58d35cbc5ec65996398c.png",
      "shadow.png":
        "/assets/marker-shadow-a2d94406ba198f61f68a71ed8f9f9c701122c0c33b775d990edceae4aece567f.png",
      "icon.png":
        "/assets/marker-icon-3d253116ec4ba0e1f22a01cdf1ff7f120fa4d89a6cd0933d68f12951d19809b4.png",
    };
    return paths[name + ".png"];
  },

  _detectIconPath: function () {
    return "";
  },
});
L.Marker = L.Marker.extend({
  options: {
    icon: new L.Icon.Default(),
  },
});

L.marker = function (latlng, options) {
  return new L.Marker(latlng, options);
};
/*
 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 https://github.com/Leaflet/Leaflet.markercluster
 (c) 2012-2017, Dave Leaver
*/
!(function (e, t, i) {
  (L.MarkerClusterGroup = L.FeatureGroup.extend({
    options: {
      maxClusterRadius: 80,
      iconCreateFunction: null,
      clusterPane: L.Marker.prototype.options.pane,
      spiderfyOnMaxZoom: !0,
      showCoverageOnHover: !0,
      zoomToBoundsOnClick: !0,
      singleMarkerMode: !1,
      disableClusteringAtZoom: null,
      removeOutsideVisibleBounds: !0,
      animate: !0,
      animateAddingMarkers: !1,
      spiderfyDistanceMultiplier: 1,
      spiderLegPolylineOptions: { weight: 1.5, color: "#222", opacity: 0.5 },
      chunkedLoading: !1,
      chunkInterval: 200,
      chunkDelay: 50,
      chunkProgress: null,
      polygonOptions: {},
    },
    initialize: function (e) {
      L.Util.setOptions(this, e),
        this.options.iconCreateFunction ||
          (this.options.iconCreateFunction = this._defaultIconCreateFunction),
        (this._featureGroup = L.featureGroup()),
        this._featureGroup.addEventParent(this),
        (this._nonPointGroup = L.featureGroup()),
        this._nonPointGroup.addEventParent(this),
        (this._inZoomAnimation = 0),
        (this._needsClustering = []),
        (this._needsRemoving = []),
        (this._currentShownBounds = null),
        (this._queue = []),
        (this._childMarkerEventHandlers = {
          dragstart: this._childMarkerDragStart,
          move: this._childMarkerMoved,
          dragend: this._childMarkerDragEnd,
        });
      var t = L.DomUtil.TRANSITION && this.options.animate;
      L.extend(this, t ? this._withAnimation : this._noAnimation),
        (this._markerCluster = t
          ? L.MarkerCluster
          : L.MarkerClusterNonAnimated);
    },
    addLayer: function (e) {
      if (e instanceof L.LayerGroup) return this.addLayers([e]);
      if (!e.getLatLng)
        return (
          this._nonPointGroup.addLayer(e),
          this.fire("layeradd", { layer: e }),
          this
        );
      if (!this._map)
        return (
          this._needsClustering.push(e),
          this.fire("layeradd", { layer: e }),
          this
        );
      if (this.hasLayer(e)) return this;
      this._unspiderfy && this._unspiderfy(),
        this._addLayer(e, this._maxZoom),
        this.fire("layeradd", { layer: e }),
        this._topClusterLevel._recalculateBounds(),
        this._refreshClustersIcons();
      var t = e,
        i = this._zoom;
      if (e.__parent) for (; t.__parent._zoom >= i; ) t = t.__parent;
      return (
        this._currentShownBounds.contains(t.getLatLng()) &&
          (this.options.animateAddingMarkers
            ? this._animationAddLayer(e, t)
            : this._animationAddLayerNonAnimated(e, t)),
        this
      );
    },
    removeLayer: function (e) {
      return e instanceof L.LayerGroup
        ? this.removeLayers([e])
        : e.getLatLng
        ? this._map
          ? e.__parent
            ? (this._unspiderfy &&
                (this._unspiderfy(), this._unspiderfyLayer(e)),
              this._removeLayer(e, !0),
              this.fire("layerremove", { layer: e }),
              this._topClusterLevel._recalculateBounds(),
              this._refreshClustersIcons(),
              e.off(this._childMarkerEventHandlers, this),
              this._featureGroup.hasLayer(e) &&
                (this._featureGroup.removeLayer(e),
                e.clusterShow && e.clusterShow()),
              this)
            : this
          : (!this._arraySplice(this._needsClustering, e) &&
              this.hasLayer(e) &&
              this._needsRemoving.push({ layer: e, latlng: e._latlng }),
            this.fire("layerremove", { layer: e }),
            this)
        : (this._nonPointGroup.removeLayer(e),
          this.fire("layerremove", { layer: e }),
          this);
    },
    addLayers: function (e, t) {
      if (!L.Util.isArray(e)) return this.addLayer(e);
      var i,
        n = this._featureGroup,
        r = this._nonPointGroup,
        s = this.options.chunkedLoading,
        o = this.options.chunkInterval,
        a = this.options.chunkProgress,
        h = e.length,
        l = 0,
        u = !0;
      if (this._map) {
        var _ = new Date().getTime(),
          d = L.bind(function () {
            for (var c = new Date().getTime(); h > l; l++) {
              if (s && 0 === l % 200) {
                var p = new Date().getTime() - c;
                if (p > o) break;
              }
              if (((i = e[l]), i instanceof L.LayerGroup))
                u && ((e = e.slice()), (u = !1)),
                  this._extractNonGroupLayers(i, e),
                  (h = e.length);
              else if (i.getLatLng) {
                if (
                  !this.hasLayer(i) &&
                  (this._addLayer(i, this._maxZoom),
                  t || this.fire("layeradd", { layer: i }),
                  i.__parent && 2 === i.__parent.getChildCount())
                ) {
                  var f = i.__parent.getAllChildMarkers(),
                    m = f[0] === i ? f[1] : f[0];
                  n.removeLayer(m);
                }
              } else r.addLayer(i), t || this.fire("layeradd", { layer: i });
            }
            a && a(l, h, new Date().getTime() - _),
              l === h
                ? (this._topClusterLevel._recalculateBounds(),
                  this._refreshClustersIcons(),
                  this._topClusterLevel._recursivelyAddChildrenToMap(
                    null,
                    this._zoom,
                    this._currentShownBounds
                  ))
                : setTimeout(d, this.options.chunkDelay);
          }, this);
        d();
      } else
        for (var c = this._needsClustering; h > l; l++)
          (i = e[l]),
            i instanceof L.LayerGroup
              ? (u && ((e = e.slice()), (u = !1)),
                this._extractNonGroupLayers(i, e),
                (h = e.length))
              : i.getLatLng
              ? this.hasLayer(i) || c.push(i)
              : r.addLayer(i);
      return this;
    },
    removeLayers: function (e) {
      var t,
        i,
        n = e.length,
        r = this._featureGroup,
        s = this._nonPointGroup,
        o = !0;
      if (!this._map) {
        for (t = 0; n > t; t++)
          (i = e[t]),
            i instanceof L.LayerGroup
              ? (o && ((e = e.slice()), (o = !1)),
                this._extractNonGroupLayers(i, e),
                (n = e.length))
              : (this._arraySplice(this._needsClustering, i),
                s.removeLayer(i),
                this.hasLayer(i) &&
                  this._needsRemoving.push({ layer: i, latlng: i._latlng }),
                this.fire("layerremove", { layer: i }));
        return this;
      }
      if (this._unspiderfy) {
        this._unspiderfy();
        var a = e.slice(),
          h = n;
        for (t = 0; h > t; t++)
          (i = a[t]),
            i instanceof L.LayerGroup
              ? (this._extractNonGroupLayers(i, a), (h = a.length))
              : this._unspiderfyLayer(i);
      }
      for (t = 0; n > t; t++)
        (i = e[t]),
          i instanceof L.LayerGroup
            ? (o && ((e = e.slice()), (o = !1)),
              this._extractNonGroupLayers(i, e),
              (n = e.length))
            : i.__parent
            ? (this._removeLayer(i, !0, !0),
              this.fire("layerremove", { layer: i }),
              r.hasLayer(i) &&
                (r.removeLayer(i), i.clusterShow && i.clusterShow()))
            : (s.removeLayer(i), this.fire("layerremove", { layer: i }));
      return (
        this._topClusterLevel._recalculateBounds(),
        this._refreshClustersIcons(),
        this._topClusterLevel._recursivelyAddChildrenToMap(
          null,
          this._zoom,
          this._currentShownBounds
        ),
        this
      );
    },
    clearLayers: function () {
      return (
        this._map ||
          ((this._needsClustering = []),
          delete this._gridClusters,
          delete this._gridUnclustered),
        this._noanimationUnspiderfy && this._noanimationUnspiderfy(),
        this._featureGroup.clearLayers(),
        this._nonPointGroup.clearLayers(),
        this.eachLayer(function (e) {
          e.off(this._childMarkerEventHandlers, this), delete e.__parent;
        }, this),
        this._map && this._generateInitialClusters(),
        this
      );
    },
    getBounds: function () {
      var e = new L.LatLngBounds();
      this._topClusterLevel && e.extend(this._topClusterLevel._bounds);
      for (var t = this._needsClustering.length - 1; t >= 0; t--)
        e.extend(this._needsClustering[t].getLatLng());
      return e.extend(this._nonPointGroup.getBounds()), e;
    },
    eachLayer: function (e, t) {
      var i,
        n,
        r,
        s = this._needsClustering.slice(),
        o = this._needsRemoving;
      for (
        this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(s),
          n = s.length - 1;
        n >= 0;
        n--
      ) {
        for (i = !0, r = o.length - 1; r >= 0; r--)
          if (o[r].layer === s[n]) {
            i = !1;
            break;
          }
        i && e.call(t, s[n]);
      }
      this._nonPointGroup.eachLayer(e, t);
    },
    getLayers: function () {
      var e = [];
      return (
        this.eachLayer(function (t) {
          e.push(t);
        }),
        e
      );
    },
    getLayer: function (e) {
      var t = null;
      return (
        (e = parseInt(e, 10)),
        this.eachLayer(function (i) {
          L.stamp(i) === e && (t = i);
        }),
        t
      );
    },
    hasLayer: function (e) {
      if (!e) return !1;
      var t,
        i = this._needsClustering;
      for (t = i.length - 1; t >= 0; t--) if (i[t] === e) return !0;
      for (i = this._needsRemoving, t = i.length - 1; t >= 0; t--)
        if (i[t].layer === e) return !1;
      return (
        !(!e.__parent || e.__parent._group !== this) ||
        this._nonPointGroup.hasLayer(e)
      );
    },
    zoomToShowLayer: function (e, t) {
      "function" != typeof t && (t = function () {});
      var i = function () {
        (!e._icon && !e.__parent._icon) ||
          this._inZoomAnimation ||
          (this._map.off("moveend", i, this),
          this.off("animationend", i, this),
          e._icon
            ? t()
            : e.__parent._icon &&
              (this.once("spiderfied", t, this), e.__parent.spiderfy()));
      };
      e._icon && this._map.getBounds().contains(e.getLatLng())
        ? t()
        : e.__parent._zoom < Math.round(this._map._zoom)
        ? (this._map.on("moveend", i, this), this._map.panTo(e.getLatLng()))
        : (this._map.on("moveend", i, this),
          this.on("animationend", i, this),
          e.__parent.zoomToBounds());
    },
    onAdd: function (e) {
      this._map = e;
      var t, i, n;
      if (!isFinite(this._map.getMaxZoom()))
        throw "Map has no maxZoom specified";
      for (
        this._featureGroup.addTo(e),
          this._nonPointGroup.addTo(e),
          this._gridClusters || this._generateInitialClusters(),
          this._maxLat = e.options.crs.projection.MAX_LATITUDE,
          t = 0,
          i = this._needsRemoving.length;
        i > t;
        t++
      )
        (n = this._needsRemoving[t]),
          (n.newlatlng = n.layer._latlng),
          (n.layer._latlng = n.latlng);
      for (t = 0, i = this._needsRemoving.length; i > t; t++)
        (n = this._needsRemoving[t]),
          this._removeLayer(n.layer, !0),
          (n.layer._latlng = n.newlatlng);
      (this._needsRemoving = []),
        (this._zoom = Math.round(this._map._zoom)),
        (this._currentShownBounds = this._getExpandedVisibleBounds()),
        this._map.on("zoomend", this._zoomEnd, this),
        this._map.on("moveend", this._moveEnd, this),
        this._spiderfierOnAdd && this._spiderfierOnAdd(),
        this._bindEvents(),
        (i = this._needsClustering),
        (this._needsClustering = []),
        this.addLayers(i, !0);
    },
    onRemove: function (e) {
      e.off("zoomend", this._zoomEnd, this),
        e.off("moveend", this._moveEnd, this),
        this._unbindEvents(),
        (this._map._mapPane.className = this._map._mapPane.className.replace(
          " leaflet-cluster-anim",
          ""
        )),
        this._spiderfierOnRemove && this._spiderfierOnRemove(),
        delete this._maxLat,
        this._hideCoverage(),
        this._featureGroup.remove(),
        this._nonPointGroup.remove(),
        this._featureGroup.clearLayers(),
        (this._map = null);
    },
    getVisibleParent: function (e) {
      for (var t = e; t && !t._icon; ) t = t.__parent;
      return t || null;
    },
    _arraySplice: function (e, t) {
      for (var i = e.length - 1; i >= 0; i--)
        if (e[i] === t) return e.splice(i, 1), !0;
    },
    _removeFromGridUnclustered: function (e, t) {
      for (
        var i = this._map,
          n = this._gridUnclustered,
          r = Math.floor(this._map.getMinZoom());
        t >= r && n[t].removeObject(e, i.project(e.getLatLng(), t));
        t--
      );
    },
    _childMarkerDragStart: function (e) {
      e.target.__dragStart = e.target._latlng;
    },
    _childMarkerMoved: function (e) {
      if (!this._ignoreMove && !e.target.__dragStart) {
        var t = e.target._popup && e.target._popup.isOpen();
        this._moveChild(e.target, e.oldLatLng, e.latlng),
          t && e.target.openPopup();
      }
    },
    _moveChild: function (e, t, i) {
      (e._latlng = t), this.removeLayer(e), (e._latlng = i), this.addLayer(e);
    },
    _childMarkerDragEnd: function (e) {
      e.target.__dragStart &&
        this._moveChild(e.target, e.target.__dragStart, e.target._latlng),
        delete e.target.__dragStart;
    },
    _removeLayer: function (e, t, i) {
      var n = this._gridClusters,
        r = this._gridUnclustered,
        s = this._featureGroup,
        o = this._map,
        a = Math.floor(this._map.getMinZoom());
      t && this._removeFromGridUnclustered(e, this._maxZoom);
      var h,
        l = e.__parent,
        u = l._markers;
      for (
        this._arraySplice(u, e);
        l && (l._childCount--, (l._boundsNeedUpdate = !0), !(l._zoom < a));

      )
        t && l._childCount <= 1
          ? ((h = l._markers[0] === e ? l._markers[1] : l._markers[0]),
            n[l._zoom].removeObject(l, o.project(l._cLatLng, l._zoom)),
            r[l._zoom].addObject(h, o.project(h.getLatLng(), l._zoom)),
            this._arraySplice(l.__parent._childClusters, l),
            l.__parent._markers.push(h),
            (h.__parent = l.__parent),
            l._icon && (s.removeLayer(l), i || s.addLayer(h)))
          : (l._iconNeedsUpdate = !0),
          (l = l.__parent);
      delete e.__parent;
    },
    _isOrIsParent: function (e, t) {
      for (; t; ) {
        if (e === t) return !0;
        t = t.parentNode;
      }
      return !1;
    },
    fire: function (e, t, i) {
      if (t && t.layer instanceof L.MarkerCluster) {
        if (
          t.originalEvent &&
          this._isOrIsParent(t.layer._icon, t.originalEvent.relatedTarget)
        )
          return;
        e = "cluster" + e;
      }
      L.FeatureGroup.prototype.fire.call(this, e, t, i);
    },
    listens: function (e, t) {
      return (
        L.FeatureGroup.prototype.listens.call(this, e, t) ||
        L.FeatureGroup.prototype.listens.call(this, "cluster" + e, t)
      );
    },
    _defaultIconCreateFunction: function (e) {
      var t = e.getChildCount(),
        i = " marker-cluster-";
      return (
        (i += 10 > t ? "small" : 100 > t ? "medium" : "large"),
        new L.DivIcon({
          html: "<div><span>" + t + "</span></div>",
          className: "marker-cluster" + i,
          iconSize: new L.Point(40, 40),
        })
      );
    },
    _bindEvents: function () {
      var e = this._map,
        t = this.options.spiderfyOnMaxZoom,
        i = this.options.showCoverageOnHover,
        n = this.options.zoomToBoundsOnClick;
      (t || n) && this.on("clusterclick", this._zoomOrSpiderfy, this),
        i &&
          (this.on("clustermouseover", this._showCoverage, this),
          this.on("clustermouseout", this._hideCoverage, this),
          e.on("zoomend", this._hideCoverage, this));
    },
    _zoomOrSpiderfy: function (e) {
      for (var t = e.layer, i = t; 1 === i._childClusters.length; )
        i = i._childClusters[0];
      i._zoom === this._maxZoom &&
      i._childCount === t._childCount &&
      this.options.spiderfyOnMaxZoom
        ? t.spiderfy()
        : this.options.zoomToBoundsOnClick && t.zoomToBounds(),
        e.originalEvent &&
          13 === e.originalEvent.keyCode &&
          this._map._container.focus();
    },
    _showCoverage: function (e) {
      var t = this._map;
      this._inZoomAnimation ||
        (this._shownPolygon && t.removeLayer(this._shownPolygon),
        e.layer.getChildCount() > 2 &&
          e.layer !== this._spiderfied &&
          ((this._shownPolygon = new L.Polygon(
            e.layer.getConvexHull(),
            this.options.polygonOptions
          )),
          t.addLayer(this._shownPolygon)));
    },
    _hideCoverage: function () {
      this._shownPolygon &&
        (this._map.removeLayer(this._shownPolygon),
        (this._shownPolygon = null));
    },
    _unbindEvents: function () {
      var e = this.options.spiderfyOnMaxZoom,
        t = this.options.showCoverageOnHover,
        i = this.options.zoomToBoundsOnClick,
        n = this._map;
      (e || i) && this.off("clusterclick", this._zoomOrSpiderfy, this),
        t &&
          (this.off("clustermouseover", this._showCoverage, this),
          this.off("clustermouseout", this._hideCoverage, this),
          n.off("zoomend", this._hideCoverage, this));
    },
    _zoomEnd: function () {
      this._map &&
        (this._mergeSplitClusters(),
        (this._zoom = Math.round(this._map._zoom)),
        (this._currentShownBounds = this._getExpandedVisibleBounds()));
    },
    _moveEnd: function () {
      if (!this._inZoomAnimation) {
        var e = this._getExpandedVisibleBounds();
        this._topClusterLevel._recursivelyRemoveChildrenFromMap(
          this._currentShownBounds,
          Math.floor(this._map.getMinZoom()),
          this._zoom,
          e
        ),
          this._topClusterLevel._recursivelyAddChildrenToMap(
            null,
            Math.round(this._map._zoom),
            e
          ),
          (this._currentShownBounds = e);
      }
    },
    _generateInitialClusters: function () {
      var e = Math.ceil(this._map.getMaxZoom()),
        t = Math.floor(this._map.getMinZoom()),
        i = this.options.maxClusterRadius,
        n = i;
      "function" != typeof i &&
        (n = function () {
          return i;
        }),
        null !== this.options.disableClusteringAtZoom &&
          (e = this.options.disableClusteringAtZoom - 1),
        (this._maxZoom = e),
        (this._gridClusters = {}),
        (this._gridUnclustered = {});
      for (var r = e; r >= t; r--)
        (this._gridClusters[r] = new L.DistanceGrid(n(r))),
          (this._gridUnclustered[r] = new L.DistanceGrid(n(r)));
      this._topClusterLevel = new this._markerCluster(this, t - 1);
    },
    _addLayer: function (e, t) {
      var i,
        n,
        r = this._gridClusters,
        s = this._gridUnclustered,
        o = Math.floor(this._map.getMinZoom());
      for (
        this.options.singleMarkerMode && this._overrideMarkerIcon(e),
          e.on(this._childMarkerEventHandlers, this);
        t >= o;
        t--
      ) {
        i = this._map.project(e.getLatLng(), t);
        var a = r[t].getNearObject(i);
        if (a) return a._addChild(e), (e.__parent = a), void 0;
        if ((a = s[t].getNearObject(i))) {
          var h = a.__parent;
          h && this._removeLayer(a, !1);
          var l = new this._markerCluster(this, t, a, e);
          r[t].addObject(l, this._map.project(l._cLatLng, t)),
            (a.__parent = l),
            (e.__parent = l);
          var u = l;
          for (n = t - 1; n > h._zoom; n--)
            (u = new this._markerCluster(this, n, u)),
              r[n].addObject(u, this._map.project(a.getLatLng(), n));
          return h._addChild(u), this._removeFromGridUnclustered(a, t), void 0;
        }
        s[t].addObject(e, i);
      }
      this._topClusterLevel._addChild(e), (e.__parent = this._topClusterLevel);
    },
    _refreshClustersIcons: function () {
      this._featureGroup.eachLayer(function (e) {
        e instanceof L.MarkerCluster && e._iconNeedsUpdate && e._updateIcon();
      });
    },
    _enqueue: function (e) {
      this._queue.push(e),
        this._queueTimeout ||
          (this._queueTimeout = setTimeout(
            L.bind(this._processQueue, this),
            300
          ));
    },
    _processQueue: function () {
      for (var e = 0; e < this._queue.length; e++) this._queue[e].call(this);
      (this._queue.length = 0),
        clearTimeout(this._queueTimeout),
        (this._queueTimeout = null);
    },
    _mergeSplitClusters: function () {
      var e = Math.round(this._map._zoom);
      this._processQueue(),
        this._zoom < e &&
        this._currentShownBounds.intersects(this._getExpandedVisibleBounds())
          ? (this._animationStart(),
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(
              this._currentShownBounds,
              Math.floor(this._map.getMinZoom()),
              this._zoom,
              this._getExpandedVisibleBounds()
            ),
            this._animationZoomIn(this._zoom, e))
          : this._zoom > e
          ? (this._animationStart(), this._animationZoomOut(this._zoom, e))
          : this._moveEnd();
    },
    _getExpandedVisibleBounds: function () {
      return this.options.removeOutsideVisibleBounds
        ? L.Browser.mobile
          ? this._checkBoundsMaxLat(this._map.getBounds())
          : this._checkBoundsMaxLat(this._map.getBounds().pad(1))
        : this._mapBoundsInfinite;
    },
    _checkBoundsMaxLat: function (e) {
      var t = this._maxLat;
      return (
        t !== i &&
          (e.getNorth() >= t && (e._northEast.lat = 1 / 0),
          e.getSouth() <= -t && (e._southWest.lat = -1 / 0)),
        e
      );
    },
    _animationAddLayerNonAnimated: function (e, t) {
      if (t === e) this._featureGroup.addLayer(e);
      else if (2 === t._childCount) {
        t._addToMap();
        var i = t.getAllChildMarkers();
        this._featureGroup.removeLayer(i[0]),
          this._featureGroup.removeLayer(i[1]);
      } else t._updateIcon();
    },
    _extractNonGroupLayers: function (e, t) {
      var i,
        n = e.getLayers(),
        r = 0;
      for (t = t || []; r < n.length; r++)
        (i = n[r]),
          i instanceof L.LayerGroup
            ? this._extractNonGroupLayers(i, t)
            : t.push(i);
      return t;
    },
    _overrideMarkerIcon: function (e) {
      var t = (e.options.icon = this.options.iconCreateFunction({
        getChildCount: function () {
          return 1;
        },
        getAllChildMarkers: function () {
          return [e];
        },
      }));
      return t;
    },
  })),
    L.MarkerClusterGroup.include({
      _mapBoundsInfinite: new L.LatLngBounds(
        new L.LatLng(-1 / 0, -1 / 0),
        new L.LatLng(1 / 0, 1 / 0)
      ),
    }),
    L.MarkerClusterGroup.include({
      _noAnimation: {
        _animationStart: function () {},
        _animationZoomIn: function (e, t) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(
            this._currentShownBounds,
            Math.floor(this._map.getMinZoom()),
            e
          ),
            this._topClusterLevel._recursivelyAddChildrenToMap(
              null,
              t,
              this._getExpandedVisibleBounds()
            ),
            this.fire("animationend");
        },
        _animationZoomOut: function (e, t) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(
            this._currentShownBounds,
            Math.floor(this._map.getMinZoom()),
            e
          ),
            this._topClusterLevel._recursivelyAddChildrenToMap(
              null,
              t,
              this._getExpandedVisibleBounds()
            ),
            this.fire("animationend");
        },
        _animationAddLayer: function (e, t) {
          this._animationAddLayerNonAnimated(e, t);
        },
      },
      _withAnimation: {
        _animationStart: function () {
          (this._map._mapPane.className += " leaflet-cluster-anim"),
            this._inZoomAnimation++;
        },
        _animationZoomIn: function (e, t) {
          var i,
            n = this._getExpandedVisibleBounds(),
            r = this._featureGroup,
            s = Math.floor(this._map.getMinZoom());
          (this._ignoreMove = !0),
            this._topClusterLevel._recursively(n, e, s, function (s) {
              var o,
                a = s._latlng,
                h = s._markers;
              for (
                n.contains(a) || (a = null),
                  s._isSingleParent() && e + 1 === t
                    ? (r.removeLayer(s),
                      s._recursivelyAddChildrenToMap(null, t, n))
                    : (s.clusterHide(),
                      s._recursivelyAddChildrenToMap(a, t, n)),
                  i = h.length - 1;
                i >= 0;
                i--
              )
                (o = h[i]), n.contains(o._latlng) || r.removeLayer(o);
            }),
            this._forceLayout(),
            this._topClusterLevel._recursivelyBecomeVisible(n, t),
            r.eachLayer(function (e) {
              e instanceof L.MarkerCluster || !e._icon || e.clusterShow();
            }),
            this._topClusterLevel._recursively(n, e, t, function (e) {
              e._recursivelyRestoreChildPositions(t);
            }),
            (this._ignoreMove = !1),
            this._enqueue(function () {
              this._topClusterLevel._recursively(n, e, s, function (e) {
                r.removeLayer(e), e.clusterShow();
              }),
                this._animationEnd();
            });
        },
        _animationZoomOut: function (e, t) {
          this._animationZoomOutSingle(this._topClusterLevel, e - 1, t),
            this._topClusterLevel._recursivelyAddChildrenToMap(
              null,
              t,
              this._getExpandedVisibleBounds()
            ),
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(
              this._currentShownBounds,
              Math.floor(this._map.getMinZoom()),
              e,
              this._getExpandedVisibleBounds()
            );
        },
        _animationAddLayer: function (e, t) {
          var i = this,
            n = this._featureGroup;
          n.addLayer(e),
            t !== e &&
              (t._childCount > 2
                ? (t._updateIcon(),
                  this._forceLayout(),
                  this._animationStart(),
                  e._setPos(this._map.latLngToLayerPoint(t.getLatLng())),
                  e.clusterHide(),
                  this._enqueue(function () {
                    n.removeLayer(e), e.clusterShow(), i._animationEnd();
                  }))
                : (this._forceLayout(),
                  i._animationStart(),
                  i._animationZoomOutSingle(
                    t,
                    this._map.getMaxZoom(),
                    this._zoom
                  )));
        },
      },
      _animationZoomOutSingle: function (e, t, i) {
        var n = this._getExpandedVisibleBounds(),
          r = Math.floor(this._map.getMinZoom());
        e._recursivelyAnimateChildrenInAndAddSelfToMap(n, r, t + 1, i);
        var s = this;
        this._forceLayout(),
          e._recursivelyBecomeVisible(n, i),
          this._enqueue(function () {
            if (1 === e._childCount) {
              var o = e._markers[0];
              (this._ignoreMove = !0),
                o.setLatLng(o.getLatLng()),
                (this._ignoreMove = !1),
                o.clusterShow && o.clusterShow();
            } else
              e._recursively(n, i, r, function (e) {
                e._recursivelyRemoveChildrenFromMap(n, r, t + 1);
              });
            s._animationEnd();
          });
      },
      _animationEnd: function () {
        this._map &&
          (this._map._mapPane.className = this._map._mapPane.className.replace(
            " leaflet-cluster-anim",
            ""
          )),
          this._inZoomAnimation--,
          this.fire("animationend");
      },
      _forceLayout: function () {
        L.Util.falseFn(t.body.offsetWidth);
      },
    }),
    (L.markerClusterGroup = function (e) {
      return new L.MarkerClusterGroup(e);
    }),
    (L.MarkerCluster = L.Marker.extend({
      initialize: function (e, t, i, n) {
        L.Marker.prototype.initialize.call(
          this,
          i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0),
          { icon: this, pane: e.options.clusterPane }
        ),
          (this._group = e),
          (this._zoom = t),
          (this._markers = []),
          (this._childClusters = []),
          (this._childCount = 0),
          (this._iconNeedsUpdate = !0),
          (this._boundsNeedUpdate = !0),
          (this._bounds = new L.LatLngBounds()),
          i && this._addChild(i),
          n && this._addChild(n);
      },
      getAllChildMarkers: function (e) {
        e = e || [];
        for (var t = this._childClusters.length - 1; t >= 0; t--)
          this._childClusters[t].getAllChildMarkers(e);
        for (var i = this._markers.length - 1; i >= 0; i--)
          e.push(this._markers[i]);
        return e;
      },
      getChildCount: function () {
        return this._childCount;
      },
      zoomToBounds: function (e) {
        for (
          var t,
            i = this._childClusters.slice(),
            n = this._group._map,
            r = n.getBoundsZoom(this._bounds),
            s = this._zoom + 1,
            o = n.getZoom();
          i.length > 0 && r > s;

        ) {
          s++;
          var a = [];
          for (t = 0; t < i.length; t++) a = a.concat(i[t]._childClusters);
          i = a;
        }
        r > s
          ? this._group._map.setView(this._latlng, s)
          : o >= r
          ? this._group._map.setView(this._latlng, o + 1)
          : this._group._map.fitBounds(this._bounds, e);
      },
      getBounds: function () {
        var e = new L.LatLngBounds();
        return e.extend(this._bounds), e;
      },
      _updateIcon: function () {
        (this._iconNeedsUpdate = !0), this._icon && this.setIcon(this);
      },
      createIcon: function () {
        return (
          this._iconNeedsUpdate &&
            ((this._iconObj = this._group.options.iconCreateFunction(this)),
            (this._iconNeedsUpdate = !1)),
          this._iconObj.createIcon()
        );
      },
      createShadow: function () {
        return this._iconObj.createShadow();
      },
      _addChild: function (e, t) {
        (this._iconNeedsUpdate = !0),
          (this._boundsNeedUpdate = !0),
          this._setClusterCenter(e),
          e instanceof L.MarkerCluster
            ? (t || (this._childClusters.push(e), (e.__parent = this)),
              (this._childCount += e._childCount))
            : (t || this._markers.push(e), this._childCount++),
          this.__parent && this.__parent._addChild(e, !0);
      },
      _setClusterCenter: function (e) {
        this._cLatLng || (this._cLatLng = e._cLatLng || e._latlng);
      },
      _resetBounds: function () {
        var e = this._bounds;
        e._southWest &&
          ((e._southWest.lat = 1 / 0), (e._southWest.lng = 1 / 0)),
          e._northEast &&
            ((e._northEast.lat = -1 / 0), (e._northEast.lng = -1 / 0));
      },
      _recalculateBounds: function () {
        var e,
          t,
          i,
          n,
          r = this._markers,
          s = this._childClusters,
          o = 0,
          a = 0,
          h = this._childCount;
        if (0 !== h) {
          for (this._resetBounds(), e = 0; e < r.length; e++)
            (i = r[e]._latlng),
              this._bounds.extend(i),
              (o += i.lat),
              (a += i.lng);
          for (e = 0; e < s.length; e++)
            (t = s[e]),
              t._boundsNeedUpdate && t._recalculateBounds(),
              this._bounds.extend(t._bounds),
              (i = t._wLatLng),
              (n = t._childCount),
              (o += i.lat * n),
              (a += i.lng * n);
          (this._latlng = this._wLatLng = new L.LatLng(o / h, a / h)),
            (this._boundsNeedUpdate = !1);
        }
      },
      _addToMap: function (e) {
        e && ((this._backupLatlng = this._latlng), this.setLatLng(e)),
          this._group._featureGroup.addLayer(this);
      },
      _recursivelyAnimateChildrenIn: function (e, t, i) {
        this._recursively(
          e,
          this._group._map.getMinZoom(),
          i - 1,
          function (e) {
            var i,
              n,
              r = e._markers;
            for (i = r.length - 1; i >= 0; i--)
              (n = r[i]), n._icon && (n._setPos(t), n.clusterHide());
          },
          function (e) {
            var i,
              n,
              r = e._childClusters;
            for (i = r.length - 1; i >= 0; i--)
              (n = r[i]), n._icon && (n._setPos(t), n.clusterHide());
          }
        );
      },
      _recursivelyAnimateChildrenInAndAddSelfToMap: function (e, t, i, n) {
        this._recursively(e, n, t, function (r) {
          r._recursivelyAnimateChildrenIn(
            e,
            r._group._map.latLngToLayerPoint(r.getLatLng()).round(),
            i
          ),
            r._isSingleParent() && i - 1 === n
              ? (r.clusterShow(), r._recursivelyRemoveChildrenFromMap(e, t, i))
              : r.clusterHide(),
            r._addToMap();
        });
      },
      _recursivelyBecomeVisible: function (e, t) {
        this._recursively(
          e,
          this._group._map.getMinZoom(),
          t,
          null,
          function (e) {
            e.clusterShow();
          }
        );
      },
      _recursivelyAddChildrenToMap: function (e, t, i) {
        this._recursively(
          i,
          this._group._map.getMinZoom() - 1,
          t,
          function (n) {
            if (t !== n._zoom)
              for (var r = n._markers.length - 1; r >= 0; r--) {
                var s = n._markers[r];
                i.contains(s._latlng) &&
                  (e &&
                    ((s._backupLatlng = s.getLatLng()),
                    s.setLatLng(e),
                    s.clusterHide && s.clusterHide()),
                  n._group._featureGroup.addLayer(s));
              }
          },
          function (t) {
            t._addToMap(e);
          }
        );
      },
      _recursivelyRestoreChildPositions: function (e) {
        for (var t = this._markers.length - 1; t >= 0; t--) {
          var i = this._markers[t];
          i._backupLatlng &&
            (i.setLatLng(i._backupLatlng), delete i._backupLatlng);
        }
        if (e - 1 === this._zoom)
          for (var n = this._childClusters.length - 1; n >= 0; n--)
            this._childClusters[n]._restorePosition();
        else
          for (var r = this._childClusters.length - 1; r >= 0; r--)
            this._childClusters[r]._recursivelyRestoreChildPositions(e);
      },
      _restorePosition: function () {
        this._backupLatlng &&
          (this.setLatLng(this._backupLatlng), delete this._backupLatlng);
      },
      _recursivelyRemoveChildrenFromMap: function (e, t, i, n) {
        var r, s;
        this._recursively(
          e,
          t - 1,
          i - 1,
          function (e) {
            for (s = e._markers.length - 1; s >= 0; s--)
              (r = e._markers[s]),
                (n && n.contains(r._latlng)) ||
                  (e._group._featureGroup.removeLayer(r),
                  r.clusterShow && r.clusterShow());
          },
          function (e) {
            for (s = e._childClusters.length - 1; s >= 0; s--)
              (r = e._childClusters[s]),
                (n && n.contains(r._latlng)) ||
                  (e._group._featureGroup.removeLayer(r),
                  r.clusterShow && r.clusterShow());
          }
        );
      },
      _recursively: function (e, t, i, n, r) {
        var s,
          o,
          a = this._childClusters,
          h = this._zoom;
        if ((h >= t && (n && n(this), r && h === i && r(this)), t > h || i > h))
          for (s = a.length - 1; s >= 0; s--)
            (o = a[s]),
              e.intersects(o._bounds) && o._recursively(e, t, i, n, r);
      },
      _isSingleParent: function () {
        return (
          this._childClusters.length > 0 &&
          this._childClusters[0]._childCount === this._childCount
        );
      },
    })),
    L.Marker.include({
      clusterHide: function () {
        return (
          (this.options.opacityWhenUnclustered = this.options.opacity || 1),
          this.setOpacity(0)
        );
      },
      clusterShow: function () {
        var e = this.setOpacity(
          this.options.opacity || this.options.opacityWhenUnclustered
        );
        return delete this.options.opacityWhenUnclustered, e;
      },
    }),
    (L.DistanceGrid = function (e) {
      (this._cellSize = e),
        (this._sqCellSize = e * e),
        (this._grid = {}),
        (this._objectPoint = {});
    }),
    (L.DistanceGrid.prototype = {
      addObject: function (e, t) {
        var i = this._getCoord(t.x),
          n = this._getCoord(t.y),
          r = this._grid,
          s = (r[n] = r[n] || {}),
          o = (s[i] = s[i] || []),
          a = L.Util.stamp(e);
        (this._objectPoint[a] = t), o.push(e);
      },
      updateObject: function (e, t) {
        this.removeObject(e), this.addObject(e, t);
      },
      removeObject: function (e, t) {
        var i,
          n,
          r = this._getCoord(t.x),
          s = this._getCoord(t.y),
          o = this._grid,
          a = (o[s] = o[s] || {}),
          h = (a[r] = a[r] || []);
        for (
          delete this._objectPoint[L.Util.stamp(e)], i = 0, n = h.length;
          n > i;
          i++
        )
          if (h[i] === e) return h.splice(i, 1), 1 === n && delete a[r], !0;
      },
      eachObject: function (e, t) {
        var i,
          n,
          r,
          s,
          o,
          a,
          h,
          l = this._grid;
        for (i in l) {
          o = l[i];
          for (n in o)
            for (a = o[n], r = 0, s = a.length; s > r; r++)
              (h = e.call(t, a[r])), h && (r--, s--);
        }
      },
      getNearObject: function (e) {
        var t,
          i,
          n,
          r,
          s,
          o,
          a,
          h,
          l = this._getCoord(e.x),
          u = this._getCoord(e.y),
          _ = this._objectPoint,
          d = this._sqCellSize,
          c = null;
        for (t = u - 1; u + 1 >= t; t++)
          if ((r = this._grid[t]))
            for (i = l - 1; l + 1 >= i; i++)
              if ((s = r[i]))
                for (n = 0, o = s.length; o > n; n++)
                  (a = s[n]),
                    (h = this._sqDist(_[L.Util.stamp(a)], e)),
                    (d > h || (d >= h && null === c)) && ((d = h), (c = a));
        return c;
      },
      _getCoord: function (e) {
        var t = Math.floor(e / this._cellSize);
        return isFinite(t) ? t : e;
      },
      _sqDist: function (e, t) {
        var i = t.x - e.x,
          n = t.y - e.y;
        return i * i + n * n;
      },
    }),
    (function () {
      L.QuickHull = {
        getDistant: function (e, t) {
          var i = t[1].lat - t[0].lat,
            n = t[0].lng - t[1].lng;
          return n * (e.lat - t[0].lat) + i * (e.lng - t[0].lng);
        },
        findMostDistantPointFromBaseLine: function (e, t) {
          var i,
            n,
            r,
            s = 0,
            o = null,
            a = [];
          for (i = t.length - 1; i >= 0; i--)
            (n = t[i]),
              (r = this.getDistant(n, e)),
              r > 0 && (a.push(n), r > s && ((s = r), (o = n)));
          return { maxPoint: o, newPoints: a };
        },
        buildConvexHull: function (e, t) {
          var i = [],
            n = this.findMostDistantPointFromBaseLine(e, t);
          return n.maxPoint
            ? ((i = i.concat(
                this.buildConvexHull([e[0], n.maxPoint], n.newPoints)
              )),
              (i = i.concat(
                this.buildConvexHull([n.maxPoint, e[1]], n.newPoints)
              )))
            : [e[0]];
        },
        getConvexHull: function (e) {
          var t,
            i = !1,
            n = !1,
            r = !1,
            s = !1,
            o = null,
            a = null,
            h = null,
            l = null,
            u = null,
            _ = null;
          for (t = e.length - 1; t >= 0; t--) {
            var d = e[t];
            (i === !1 || d.lat > i) && ((o = d), (i = d.lat)),
              (n === !1 || d.lat < n) && ((a = d), (n = d.lat)),
              (r === !1 || d.lng > r) && ((h = d), (r = d.lng)),
              (s === !1 || d.lng < s) && ((l = d), (s = d.lng));
          }
          n !== i ? ((_ = a), (u = o)) : ((_ = l), (u = h));
          var c = [].concat(
            this.buildConvexHull([_, u], e),
            this.buildConvexHull([u, _], e)
          );
          return c;
        },
      };
    })(),
    L.MarkerCluster.include({
      getConvexHull: function () {
        var e,
          t,
          i = this.getAllChildMarkers(),
          n = [];
        for (t = i.length - 1; t >= 0; t--) (e = i[t].getLatLng()), n.push(e);
        return L.QuickHull.getConvexHull(n);
      },
    }),
    L.MarkerCluster.include({
      _2PI: 2 * Math.PI,
      _circleFootSeparation: 25,
      _circleStartAngle: Math.PI / 6,
      _spiralFootSeparation: 28,
      _spiralLengthStart: 11,
      _spiralLengthFactor: 5,
      _circleSpiralSwitchover: 9,
      spiderfy: function () {
        if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {
          var e,
            t = this.getAllChildMarkers(),
            i = this._group,
            n = i._map,
            r = n.latLngToLayerPoint(this._latlng);
          this._group._unspiderfy(),
            (this._group._spiderfied = this),
            t.length >= this._circleSpiralSwitchover
              ? (e = this._generatePointsSpiral(t.length, r))
              : ((r.y += 10), (e = this._generatePointsCircle(t.length, r))),
            this._animationSpiderfy(t, e);
        }
      },
      unspiderfy: function (e) {
        this._group._inZoomAnimation ||
          (this._animationUnspiderfy(e), (this._group._spiderfied = null));
      },
      _generatePointsCircle: function (e, t) {
        var i,
          n,
          r =
            this._group.options.spiderfyDistanceMultiplier *
            this._circleFootSeparation *
            (2 + e),
          s = r / this._2PI,
          o = this._2PI / e,
          a = [];
        for (a.length = e, i = e - 1; i >= 0; i--)
          (n = this._circleStartAngle + i * o),
            (a[i] = new L.Point(
              t.x + s * Math.cos(n),
              t.y + s * Math.sin(n)
            )._round());
        return a;
      },
      _generatePointsSpiral: function (e, t) {
        var i,
          n = this._group.options.spiderfyDistanceMultiplier,
          r = n * this._spiralLengthStart,
          s = n * this._spiralFootSeparation,
          o = n * this._spiralLengthFactor * this._2PI,
          a = 0,
          h = [];
        for (h.length = e, i = e - 1; i >= 0; i--)
          (a += s / r + 5e-4 * i),
            (h[i] = new L.Point(
              t.x + r * Math.cos(a),
              t.y + r * Math.sin(a)
            )._round()),
            (r += o / a);
        return h;
      },
      _noanimationUnspiderfy: function () {
        var e,
          t,
          i = this._group,
          n = i._map,
          r = i._featureGroup,
          s = this.getAllChildMarkers();
        for (
          i._ignoreMove = !0, this.setOpacity(1), t = s.length - 1;
          t >= 0;
          t--
        )
          (e = s[t]),
            r.removeLayer(e),
            e._preSpiderfyLatlng &&
              (e.setLatLng(e._preSpiderfyLatlng), delete e._preSpiderfyLatlng),
            e.setZIndexOffset && e.setZIndexOffset(0),
            e._spiderLeg && (n.removeLayer(e._spiderLeg), delete e._spiderLeg);
        i.fire("unspiderfied", { cluster: this, markers: s }),
          (i._ignoreMove = !1),
          (i._spiderfied = null);
      },
    }),
    (L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
      _animationSpiderfy: function (e, t) {
        var i,
          n,
          r,
          s,
          o = this._group,
          a = o._map,
          h = o._featureGroup,
          l = this._group.options.spiderLegPolylineOptions;
        for (o._ignoreMove = !0, i = 0; i < e.length; i++)
          (s = a.layerPointToLatLng(t[i])),
            (n = e[i]),
            (r = new L.Polyline([this._latlng, s], l)),
            a.addLayer(r),
            (n._spiderLeg = r),
            (n._preSpiderfyLatlng = n._latlng),
            n.setLatLng(s),
            n.setZIndexOffset && n.setZIndexOffset(1e6),
            h.addLayer(n);
        this.setOpacity(0.3),
          (o._ignoreMove = !1),
          o.fire("spiderfied", { cluster: this, markers: e });
      },
      _animationUnspiderfy: function () {
        this._noanimationUnspiderfy();
      },
    })),
    L.MarkerCluster.include({
      _animationSpiderfy: function (e, t) {
        var n,
          r,
          s,
          o,
          a,
          h,
          l = this,
          u = this._group,
          _ = u._map,
          d = u._featureGroup,
          c = this._latlng,
          p = _.latLngToLayerPoint(c),
          f = L.Path.SVG,
          m = L.extend({}, this._group.options.spiderLegPolylineOptions),
          g = m.opacity;
        for (
          g === i &&
            (g =
              L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions
                .opacity),
            f
              ? ((m.opacity = 0),
                (m.className =
                  (m.className || "") + " leaflet-cluster-spider-leg"))
              : (m.opacity = g),
            u._ignoreMove = !0,
            n = 0;
          n < e.length;
          n++
        )
          (r = e[n]),
            (h = _.layerPointToLatLng(t[n])),
            (s = new L.Polyline([c, h], m)),
            _.addLayer(s),
            (r._spiderLeg = s),
            f &&
              ((o = s._path),
              (a = o.getTotalLength() + 0.1),
              (o.style.strokeDasharray = a),
              (o.style.strokeDashoffset = a)),
            r.setZIndexOffset && r.setZIndexOffset(1e6),
            r.clusterHide && r.clusterHide(),
            d.addLayer(r),
            r._setPos && r._setPos(p);
        for (
          u._forceLayout(), u._animationStart(), n = e.length - 1;
          n >= 0;
          n--
        )
          (h = _.layerPointToLatLng(t[n])),
            (r = e[n]),
            (r._preSpiderfyLatlng = r._latlng),
            r.setLatLng(h),
            r.clusterShow && r.clusterShow(),
            f &&
              ((s = r._spiderLeg),
              (o = s._path),
              (o.style.strokeDashoffset = 0),
              s.setStyle({ opacity: g }));
        this.setOpacity(0.3),
          (u._ignoreMove = !1),
          setTimeout(function () {
            u._animationEnd(), u.fire("spiderfied", { cluster: l, markers: e });
          }, 200);
      },
      _animationUnspiderfy: function (e) {
        var t,
          i,
          n,
          r,
          s,
          o,
          a = this,
          h = this._group,
          l = h._map,
          u = h._featureGroup,
          _ = e
            ? l._latLngToNewLayerPoint(this._latlng, e.zoom, e.center)
            : l.latLngToLayerPoint(this._latlng),
          d = this.getAllChildMarkers(),
          c = L.Path.SVG;
        for (
          h._ignoreMove = !0,
            h._animationStart(),
            this.setOpacity(1),
            i = d.length - 1;
          i >= 0;
          i--
        )
          (t = d[i]),
            t._preSpiderfyLatlng &&
              (t.closePopup(),
              t.setLatLng(t._preSpiderfyLatlng),
              delete t._preSpiderfyLatlng,
              (o = !0),
              t._setPos && (t._setPos(_), (o = !1)),
              t.clusterHide && (t.clusterHide(), (o = !1)),
              o && u.removeLayer(t),
              c &&
                ((n = t._spiderLeg),
                (r = n._path),
                (s = r.getTotalLength() + 0.1),
                (r.style.strokeDashoffset = s),
                n.setStyle({ opacity: 0 })));
        (h._ignoreMove = !1),
          setTimeout(function () {
            var e = 0;
            for (i = d.length - 1; i >= 0; i--) (t = d[i]), t._spiderLeg && e++;
            for (i = d.length - 1; i >= 0; i--)
              (t = d[i]),
                t._spiderLeg &&
                  (t.clusterShow && t.clusterShow(),
                  t.setZIndexOffset && t.setZIndexOffset(0),
                  e > 1 && u.removeLayer(t),
                  l.removeLayer(t._spiderLeg),
                  delete t._spiderLeg);
            h._animationEnd(),
              h.fire("unspiderfied", { cluster: a, markers: d });
          }, 200);
      },
    }),
    L.MarkerClusterGroup.include({
      _spiderfied: null,
      unspiderfy: function () {
        this._unspiderfy.apply(this, arguments);
      },
      _spiderfierOnAdd: function () {
        this._map.on("click", this._unspiderfyWrapper, this),
          this._map.options.zoomAnimation &&
            this._map.on("zoomstart", this._unspiderfyZoomStart, this),
          this._map.on("zoomend", this._noanimationUnspiderfy, this),
          L.Browser.touch || this._map.getRenderer(this);
      },
      _spiderfierOnRemove: function () {
        this._map.off("click", this._unspiderfyWrapper, this),
          this._map.off("zoomstart", this._unspiderfyZoomStart, this),
          this._map.off("zoomanim", this._unspiderfyZoomAnim, this),
          this._map.off("zoomend", this._noanimationUnspiderfy, this),
          this._noanimationUnspiderfy();
      },
      _unspiderfyZoomStart: function () {
        this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
      },
      _unspiderfyZoomAnim: function (e) {
        L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") ||
          (this._map.off("zoomanim", this._unspiderfyZoomAnim, this),
          this._unspiderfy(e));
      },
      _unspiderfyWrapper: function () {
        this._unspiderfy();
      },
      _unspiderfy: function (e) {
        this._spiderfied && this._spiderfied.unspiderfy(e);
      },
      _noanimationUnspiderfy: function () {
        this._spiderfied && this._spiderfied._noanimationUnspiderfy();
      },
      _unspiderfyLayer: function (e) {
        e._spiderLeg &&
          (this._featureGroup.removeLayer(e),
          e.clusterShow && e.clusterShow(),
          e.setZIndexOffset && e.setZIndexOffset(0),
          this._map.removeLayer(e._spiderLeg),
          delete e._spiderLeg);
      },
    }),
    L.MarkerClusterGroup.include({
      refreshClusters: function (e) {
        return (
          e
            ? e instanceof L.MarkerClusterGroup
              ? (e = e._topClusterLevel.getAllChildMarkers())
              : e instanceof L.LayerGroup
              ? (e = e._layers)
              : e instanceof L.MarkerCluster
              ? (e = e.getAllChildMarkers())
              : e instanceof L.Marker && (e = [e])
            : (e = this._topClusterLevel.getAllChildMarkers()),
          this._flagParentsIconsNeedUpdate(e),
          this._refreshClustersIcons(),
          this.options.singleMarkerMode &&
            this._refreshSingleMarkerModeMarkers(e),
          this
        );
      },
      _flagParentsIconsNeedUpdate: function (e) {
        var t, i;
        for (t in e)
          for (i = e[t].__parent; i; )
            (i._iconNeedsUpdate = !0), (i = i.__parent);
      },
      _refreshSingleMarkerModeMarkers: function (e) {
        var t, i;
        for (t in e)
          (i = e[t]),
            this.hasLayer(i) && i.setIcon(this._overrideMarkerIcon(i));
      },
    }),
    L.Marker.include({
      refreshIconOptions: function (e, t) {
        var i = this.options.icon;
        return (
          L.setOptions(i, e),
          this.setIcon(i),
          t && this.__parent && this.__parent._group.refreshClusters(this),
          this
        );
      },
    });
})(window, document);
window.TinyMCERails = {
  configuration: {
    default: {},
  },

  initialize: function (config, options) {
    if (typeof tinyMCE != "undefined") {
      // Merge the custom options with the given configuration
      var configuration = TinyMCERails.configuration[config || "default"];
      configuration = TinyMCERails._merge(configuration, options);

      tinymce.init(configuration);
    } else {
      // Wait until TinyMCE is loaded
      setTimeout(function () {
        TinyMCERails.initialize(config, options);
      }, 50);
    }
  },

  setupTurbolinks: function () {
    // Remove all TinyMCE instances before rendering
    document.addEventListener("turbolinks:before-render", function () {
      tinymce.remove();
    });
  },

  _merge: function () {
    var result = {};

    for (var i = 0; i < arguments.length; ++i) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          if (
            Object.prototype.toString.call(source[key]) === "[object Object]"
          ) {
            result[key] = TinyMCERails._merge(result[key], source[key]);
          } else {
            result[key] = source[key];
          }
        }
      }
    }

    return result;
  },
};

if (typeof Turbolinks != "undefined" && Turbolinks.supported) {
  TinyMCERails.setupTurbolinks();
}
window.tinymce = window.tinymce || {
  base: "/assets/tinymce",
  suffix: "",
};
/**
 * TinyMCE version 7.7.1 (2025-03-05)
 */

(function () {
  "use strict";

  var typeOf$1 = function (x) {
    if (x === null) {
      return "null";
    }
    if (x === undefined) {
      return "undefined";
    }
    var t = typeof x;
    if (
      t === "object" &&
      (Array.prototype.isPrototypeOf(x) ||
        (x.constructor && x.constructor.name === "Array"))
    ) {
      return "array";
    }
    if (
      t === "object" &&
      (String.prototype.isPrototypeOf(x) ||
        (x.constructor && x.constructor.name === "String"))
    ) {
      return "string";
    }
    return t;
  };
  var isEquatableType = function (x) {
    return (
      [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null",
      ].indexOf(x) !== -1
    );
  };

  var sort$1 = function (xs, compareFn) {
    var clone = Array.prototype.slice.call(xs);
    return clone.sort(compareFn);
  };

  var contramap = function (eqa, f) {
    return eq$2(function (x, y) {
      return eqa.eq(f(x), f(y));
    });
  };
  var eq$2 = function (f) {
    return { eq: f };
  };
  var tripleEq = eq$2(function (x, y) {
    return x === y;
  });
  var eqString = tripleEq;
  var eqArray = function (eqa) {
    return eq$2(function (x, y) {
      if (x.length !== y.length) {
        return false;
      }
      var len = x.length;
      for (var i = 0; i < len; i++) {
        if (!eqa.eq(x[i], y[i])) {
          return false;
        }
      }
      return true;
    });
  };
  var eqSortedArray = function (eqa, compareFn) {
    return contramap(eqArray(eqa), function (xs) {
      return sort$1(xs, compareFn);
    });
  };
  var eqRecord = function (eqa) {
    return eq$2(function (x, y) {
      var kx = Object.keys(x);
      var ky = Object.keys(y);
      if (!eqSortedArray(eqString).eq(kx, ky)) {
        return false;
      }
      var len = kx.length;
      for (var i = 0; i < len; i++) {
        var q = kx[i];
        if (!eqa.eq(x[q], y[q])) {
          return false;
        }
      }
      return true;
    });
  };
  var eqAny = eq$2(function (x, y) {
    if (x === y) {
      return true;
    }
    var tx = typeOf$1(x);
    var ty = typeOf$1(y);
    if (tx !== ty) {
      return false;
    }
    if (isEquatableType(tx)) {
      return x === y;
    } else if (tx === "array") {
      return eqArray(eqAny).eq(x, y);
    } else if (tx === "object") {
      return eqRecord(eqAny).eq(x, y);
    }
    return false;
  });

  const getPrototypeOf$2 = Object.getPrototypeOf;
  const hasProto = (v, constructor, predicate) => {
    var _a;
    if (predicate(v, constructor.prototype)) {
      return true;
    } else {
      return (
        ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) ===
        constructor.name
      );
    }
  };
  const typeOf = (x) => {
    const t = typeof x;
    if (x === null) {
      return "null";
    } else if (t === "object" && Array.isArray(x)) {
      return "array";
    } else if (
      t === "object" &&
      hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))
    ) {
      return "string";
    } else {
      return t;
    }
  };
  const isType$1 = (type) => (value) => typeOf(value) === type;
  const isSimpleType = (type) => (value) => typeof value === type;
  const eq$1 = (t) => (a) => t === a;
  const is$4 = (value, constructor) =>
    isObject(value) &&
    hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
  const isString = isType$1("string");
  const isObject = isType$1("object");
  const isPlainObject = (value) => is$4(value, Object);
  const isArray$1 = isType$1("array");
  const isNull = eq$1(null);
  const isBoolean = isSimpleType("boolean");
  const isUndefined = eq$1(undefined);
  const isNullable = (a) => a === null || a === undefined;
  const isNonNullable = (a) => !isNullable(a);
  const isFunction = isSimpleType("function");
  const isNumber = isSimpleType("number");
  const isArrayOf = (value, pred) => {
    if (isArray$1(value)) {
      for (let i = 0, len = value.length; i < len; ++i) {
        if (!pred(value[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  };

  const noop = () => {};
  const compose = (fa, fb) => {
    return (...args) => {
      return fa(fb.apply(null, args));
    };
  };
  const compose1 = (fbc, fab) => (a) => fbc(fab(a));
  const constant = (value) => {
    return () => {
      return value;
    };
  };
  const identity = (x) => {
    return x;
  };
  const tripleEquals = (a, b) => {
    return a === b;
  };
  function curry(fn, ...initialArgs) {
    return (...restArgs) => {
      const all = initialArgs.concat(restArgs);
      return fn.apply(null, all);
    };
  }
  const not = (f) => (t) => !f(t);
  const die = (msg) => {
    return () => {
      throw new Error(msg);
    };
  };
  const apply$1 = (f) => {
    return f();
  };
  const call = (f) => {
    f();
  };
  const never = constant(false);
  const always = constant(true);

  class Optional {
    constructor(tag, value) {
      this.tag = tag;
      this.value = value;
    }
    static some(value) {
      return new Optional(true, value);
    }
    static none() {
      return Optional.singletonNone;
    }
    fold(onNone, onSome) {
      if (this.tag) {
        return onSome(this.value);
      } else {
        return onNone();
      }
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(mapper) {
      if (this.tag) {
        return Optional.some(mapper(this.value));
      } else {
        return Optional.none();
      }
    }
    bind(binder) {
      if (this.tag) {
        return binder(this.value);
      } else {
        return Optional.none();
      }
    }
    exists(predicate) {
      return this.tag && predicate(this.value);
    }
    forall(predicate) {
      return !this.tag || predicate(this.value);
    }
    filter(predicate) {
      if (!this.tag || predicate(this.value)) {
        return this;
      } else {
        return Optional.none();
      }
    }
    getOr(replacement) {
      return this.tag ? this.value : replacement;
    }
    or(replacement) {
      return this.tag ? this : replacement;
    }
    getOrThunk(thunk) {
      return this.tag ? this.value : thunk();
    }
    orThunk(thunk) {
      return this.tag ? this : thunk();
    }
    getOrDie(message) {
      if (!this.tag) {
        throw new Error(
          message !== null && message !== void 0
            ? message
            : "Called getOrDie on None"
        );
      } else {
        return this.value;
      }
    }
    static from(value) {
      return isNonNullable(value) ? Optional.some(value) : Optional.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(worker) {
      if (this.tag) {
        worker(this.value);
      }
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Optional.singletonNone = new Optional(false);

  const nativeSlice = Array.prototype.slice;
  const nativeIndexOf = Array.prototype.indexOf;
  const nativePush = Array.prototype.push;
  const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
  const indexOf$1 = (xs, x) => {
    const r = rawIndexOf(xs, x);
    return r === -1 ? Optional.none() : Optional.some(r);
  };
  const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
  const exists = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return true;
      }
    }
    return false;
  };
  const map$3 = (xs, f) => {
    const len = xs.length;
    const r = new Array(len);
    for (let i = 0; i < len; i++) {
      const x = xs[i];
      r[i] = f(x, i);
    }
    return r;
  };
  const each$e = (xs, f) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      f(x, i);
    }
  };
  const eachr = (xs, f) => {
    for (let i = xs.length - 1; i >= 0; i--) {
      const x = xs[i];
      f(x, i);
    }
  };
  const partition$2 = (xs, pred) => {
    const pass = [];
    const fail = [];
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      const arr = pred(x, i) ? pass : fail;
      arr.push(x);
    }
    return {
      pass,
      fail,
    };
  };
  const filter$5 = (xs, pred) => {
    const r = [];
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        r.push(x);
      }
    }
    return r;
  };
  const foldr = (xs, f, acc) => {
    eachr(xs, (x, i) => {
      acc = f(acc, x, i);
    });
    return acc;
  };
  const foldl = (xs, f, acc) => {
    each$e(xs, (x, i) => {
      acc = f(acc, x, i);
    });
    return acc;
  };
  const findUntil$1 = (xs, pred, until) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return Optional.some(x);
      } else if (until(x, i)) {
        break;
      }
    }
    return Optional.none();
  };
  const find$2 = (xs, pred) => {
    return findUntil$1(xs, pred, never);
  };
  const findIndex$2 = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return Optional.some(i);
      }
    }
    return Optional.none();
  };
  const flatten = (xs) => {
    const r = [];
    for (let i = 0, len = xs.length; i < len; ++i) {
      if (!isArray$1(xs[i])) {
        throw new Error(
          "Arr.flatten item " + i + " was not an array, input: " + xs
        );
      }
      nativePush.apply(r, xs[i]);
    }
    return r;
  };
  const bind$3 = (xs, f) => flatten(map$3(xs, f));
  const forall = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; ++i) {
      const x = xs[i];
      if (pred(x, i) !== true) {
        return false;
      }
    }
    return true;
  };
  const reverse = (xs) => {
    const r = nativeSlice.call(xs, 0);
    r.reverse();
    return r;
  };
  const difference = (a1, a2) => filter$5(a1, (x) => !contains$2(a2, x));
  const mapToObject = (xs, f) => {
    const r = {};
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      r[String(x)] = f(x, i);
    }
    return r;
  };
  const sort = (xs, comparator) => {
    const copy = nativeSlice.call(xs, 0);
    copy.sort(comparator);
    return copy;
  };
  const get$b = (xs, i) =>
    i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
  const head = (xs) => get$b(xs, 0);
  const last$2 = (xs) => get$b(xs, xs.length - 1);
  const from = isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
  const findMap = (arr, f) => {
    for (let i = 0; i < arr.length; i++) {
      const r = f(arr[i], i);
      if (r.isSome()) {
        return r;
      }
    }
    return Optional.none();
  };
  const unique$1 = (xs, comparator) => {
    const r = [];
    const isDuplicated = isFunction(comparator)
      ? (x) => exists(r, (i) => comparator(i, x))
      : (x) => contains$2(r, x);
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (!isDuplicated(x)) {
        r.push(x);
      }
    }
    return r;
  };

  const keys = Object.keys;
  const hasOwnProperty$1 = Object.hasOwnProperty;
  const each$d = (obj, f) => {
    const props = keys(obj);
    for (let k = 0, len = props.length; k < len; k++) {
      const i = props[k];
      const x = obj[i];
      f(x, i);
    }
  };
  const map$2 = (obj, f) => {
    return tupleMap(obj, (x, i) => ({
      k: i,
      v: f(x, i),
    }));
  };
  const tupleMap = (obj, f) => {
    const r = {};
    each$d(obj, (x, i) => {
      const tuple = f(x, i);
      r[tuple.k] = tuple.v;
    });
    return r;
  };
  const objAcc = (r) => (x, i) => {
    r[i] = x;
  };
  const internalFilter = (obj, pred, onTrue, onFalse) => {
    each$d(obj, (x, i) => {
      (pred(x, i) ? onTrue : onFalse)(x, i);
    });
  };
  const bifilter = (obj, pred) => {
    const t = {};
    const f = {};
    internalFilter(obj, pred, objAcc(t), objAcc(f));
    return {
      t,
      f,
    };
  };
  const filter$4 = (obj, pred) => {
    const t = {};
    internalFilter(obj, pred, objAcc(t), noop);
    return t;
  };
  const mapToArray = (obj, f) => {
    const r = [];
    each$d(obj, (value, name) => {
      r.push(f(value, name));
    });
    return r;
  };
  const values = (obj) => {
    return mapToArray(obj, identity);
  };
  const get$a = (obj, key) => {
    return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
  };
  const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);
  const hasNonNullableKey = (obj, key) =>
    has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
  const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);

  const stringArray = (a) => {
    const all = {};
    each$e(a, (key) => {
      all[key] = {};
    });
    return keys(all);
  };

  const isArrayLike = (o) => o.length !== undefined;
  const isArray = Array.isArray;
  const toArray$1 = (obj) => {
    if (!isArray(obj)) {
      const array = [];
      for (let i = 0, l = obj.length; i < l; i++) {
        array[i] = obj[i];
      }
      return array;
    } else {
      return obj;
    }
  };
  const each$c = (o, cb, s) => {
    if (!o) {
      return false;
    }
    s = s || o;
    if (isArrayLike(o)) {
      for (let n = 0, l = o.length; n < l; n++) {
        if (cb.call(s, o[n], n, o) === false) {
          return false;
        }
      }
    } else {
      for (const n in o) {
        if (has$2(o, n)) {
          if (cb.call(s, o[n], n, o) === false) {
            return false;
          }
        }
      }
    }
    return true;
  };
  const map$1 = (array, callback) => {
    const out = [];
    each$c(array, (item, index) => {
      out.push(callback(item, index, array));
    });
    return out;
  };
  const filter$3 = (a, f) => {
    const o = [];
    each$c(a, (v, index) => {
      if (!f || f(v, index, a)) {
        o.push(v);
      }
    });
    return o;
  };
  const indexOf = (a, v) => {
    if (a) {
      for (let i = 0, l = a.length; i < l; i++) {
        if (a[i] === v) {
          return i;
        }
      }
    }
    return -1;
  };
  const reduce = (collection, iteratee, accumulator, thisArg) => {
    let acc = isUndefined(accumulator) ? collection[0] : accumulator;
    for (let i = 0; i < collection.length; i++) {
      acc = iteratee.call(thisArg, acc, collection[i], i);
    }
    return acc;
  };
  const findIndex$1 = (array, predicate, thisArg) => {
    for (let i = 0, l = array.length; i < l; i++) {
      if (predicate.call(thisArg, array[i], i, array)) {
        return i;
      }
    }
    return -1;
  };
  const last$1 = (collection) => collection[collection.length - 1];

  const cached = (f) => {
    let called = false;
    let r;
    return (...args) => {
      if (!called) {
        called = true;
        r = f.apply(null, args);
      }
      return r;
    };
  };

  const DeviceType = (os, browser, userAgent, mediaMatch) => {
    const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
    const isiPhone = os.isiOS() && !isiPad;
    const isMobile = os.isiOS() || os.isAndroid();
    const isTouch = isMobile || mediaMatch("(pointer:coarse)");
    const isTablet =
      isiPad ||
      (!isiPhone && isMobile && mediaMatch("(min-device-width:768px)"));
    const isPhone = isiPhone || (isMobile && !isTablet);
    const iOSwebview =
      browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
    const isDesktop = !isPhone && !isTablet && !iOSwebview;
    return {
      isiPad: constant(isiPad),
      isiPhone: constant(isiPhone),
      isTablet: constant(isTablet),
      isPhone: constant(isPhone),
      isTouch: constant(isTouch),
      isAndroid: os.isAndroid,
      isiOS: os.isiOS,
      isWebView: constant(iOSwebview),
      isDesktop: constant(isDesktop),
    };
  };

  const firstMatch = (regexes, s) => {
    for (let i = 0; i < regexes.length; i++) {
      const x = regexes[i];
      if (x.test(s)) {
        return x;
      }
    }
    return undefined;
  };
  const find$1 = (regexes, agent) => {
    const r = firstMatch(regexes, agent);
    if (!r) {
      return {
        major: 0,
        minor: 0,
      };
    }
    const group = (i) => {
      return Number(agent.replace(r, "$" + i));
    };
    return nu$3(group(1), group(2));
  };
  const detect$4 = (versionRegexes, agent) => {
    const cleanedAgent = String(agent).toLowerCase();
    if (versionRegexes.length === 0) {
      return unknown$2();
    }
    return find$1(versionRegexes, cleanedAgent);
  };
  const unknown$2 = () => {
    return nu$3(0, 0);
  };
  const nu$3 = (major, minor) => {
    return {
      major,
      minor,
    };
  };
  const Version = {
    nu: nu$3,
    detect: detect$4,
    unknown: unknown$2,
  };

  const detectBrowser$1 = (browsers, userAgentData) => {
    return findMap(userAgentData.brands, (uaBrand) => {
      const lcBrand = uaBrand.brand.toLowerCase();
      return find$2(browsers, (browser) => {
        var _a;
        return (
          lcBrand ===
          ((_a = browser.brand) === null || _a === void 0
            ? void 0
            : _a.toLowerCase())
        );
      }).map((info) => ({
        current: info.name,
        version: Version.nu(parseInt(uaBrand.version, 10), 0),
      }));
    });
  };

  const detect$3 = (candidates, userAgent) => {
    const agent = String(userAgent).toLowerCase();
    return find$2(candidates, (candidate) => {
      return candidate.search(agent);
    });
  };
  const detectBrowser = (browsers, userAgent) => {
    return detect$3(browsers, userAgent).map((browser) => {
      const version = Version.detect(browser.versionRegexes, userAgent);
      return {
        current: browser.name,
        version,
      };
    });
  };
  const detectOs = (oses, userAgent) => {
    return detect$3(oses, userAgent).map((os) => {
      const version = Version.detect(os.versionRegexes, userAgent);
      return {
        current: os.name,
        version,
      };
    });
  };

  const removeFromStart = (str, numChars) => {
    return str.substring(numChars);
  };

  const checkRange = (str, substr, start) =>
    substr === "" ||
    (str.length >= substr.length &&
      str.substr(start, start + substr.length) === substr);
  const removeLeading = (str, prefix) => {
    return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
  };
  const contains$1 = (str, substr, start = 0, end) => {
    const idx = str.indexOf(substr, start);
    if (idx !== -1) {
      return isUndefined(end) ? true : idx + substr.length <= end;
    } else {
      return false;
    }
  };
  const startsWith = (str, prefix) => {
    return checkRange(str, prefix, 0);
  };
  const endsWith = (str, suffix) => {
    return checkRange(str, suffix, str.length - suffix.length);
  };
  const blank = (r) => (s) => s.replace(r, "");
  const trim$4 = blank(/^\s+|\s+$/g);
  const lTrim = blank(/^\s+/g);
  const rTrim = blank(/\s+$/g);
  const isNotEmpty = (s) => s.length > 0;
  const isEmpty$3 = (s) => !isNotEmpty(s);
  const repeat = (s, count) => (count <= 0 ? "" : new Array(count + 1).join(s));
  const toInt = (value, radix = 10) => {
    const num = parseInt(value, radix);
    return isNaN(num) ? Optional.none() : Optional.some(num);
  };

  const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
  const checkContains = (target) => {
    return (uastring) => {
      return contains$1(uastring, target);
    };
  };
  const browsers = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (uastring) => {
        return (
          contains$1(uastring, "edge/") &&
          contains$1(uastring, "chrome") &&
          contains$1(uastring, "safari") &&
          contains$1(uastring, "applewebkit")
        );
      },
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
      search: (uastring) => {
        return (
          contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe")
        );
      },
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/,
      ],
      search: (uastring) => {
        return contains$1(uastring, "msie") || contains$1(uastring, "trident");
      },
    },
    {
      name: "Opera",
      versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
      search: checkContains("opera"),
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: checkContains("firefox"),
    },
    {
      name: "Safari",
      versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
      search: (uastring) => {
        return (
          (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) &&
          contains$1(uastring, "applewebkit")
        );
      },
    },
  ];
  const oses = [
    {
      name: "Windows",
      search: checkContains("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/],
    },
    {
      name: "iOS",
      search: (uastring) => {
        return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
      },
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/,
      ],
    },
    {
      name: "Android",
      search: checkContains("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/],
    },
    {
      name: "macOS",
      search: checkContains("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/],
    },
    {
      name: "Linux",
      search: checkContains("linux"),
      versionRegexes: [],
    },
    {
      name: "Solaris",
      search: checkContains("sunos"),
      versionRegexes: [],
    },
    {
      name: "FreeBSD",
      search: checkContains("freebsd"),
      versionRegexes: [],
    },
    {
      name: "ChromeOS",
      search: checkContains("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/],
    },
  ];
  const PlatformInfo = {
    browsers: constant(browsers),
    oses: constant(oses),
  };

  const edge = "Edge";
  const chromium = "Chromium";
  const ie = "IE";
  const opera = "Opera";
  const firefox = "Firefox";
  const safari = "Safari";
  const unknown$1 = () => {
    return nu$2({
      current: undefined,
      version: Version.unknown(),
    });
  };
  const nu$2 = (info) => {
    const current = info.current;
    const version = info.version;
    const isBrowser = (name) => () => current === name;
    return {
      current,
      version,
      isEdge: isBrowser(edge),
      isChromium: isBrowser(chromium),
      isIE: isBrowser(ie),
      isOpera: isBrowser(opera),
      isFirefox: isBrowser(firefox),
      isSafari: isBrowser(safari),
    };
  };
  const Browser = {
    unknown: unknown$1,
    nu: nu$2,
    edge: constant(edge),
    chromium: constant(chromium),
    ie: constant(ie),
    opera: constant(opera),
    firefox: constant(firefox),
    safari: constant(safari),
  };

  const windows = "Windows";
  const ios = "iOS";
  const android = "Android";
  const linux = "Linux";
  const macos = "macOS";
  const solaris = "Solaris";
  const freebsd = "FreeBSD";
  const chromeos = "ChromeOS";
  const unknown = () => {
    return nu$1({
      current: undefined,
      version: Version.unknown(),
    });
  };
  const nu$1 = (info) => {
    const current = info.current;
    const version = info.version;
    const isOS = (name) => () => current === name;
    return {
      current,
      version,
      isWindows: isOS(windows),
      isiOS: isOS(ios),
      isAndroid: isOS(android),
      isMacOS: isOS(macos),
      isLinux: isOS(linux),
      isSolaris: isOS(solaris),
      isFreeBSD: isOS(freebsd),
      isChromeOS: isOS(chromeos),
    };
  };
  const OperatingSystem = {
    unknown,
    nu: nu$1,
    windows: constant(windows),
    ios: constant(ios),
    android: constant(android),
    linux: constant(linux),
    macos: constant(macos),
    solaris: constant(solaris),
    freebsd: constant(freebsd),
    chromeos: constant(chromeos),
  };

  const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {
    const browsers = PlatformInfo.browsers();
    const oses = PlatformInfo.oses();
    const browser = userAgentDataOpt
      .bind((userAgentData) => detectBrowser$1(browsers, userAgentData))
      .orThunk(() => detectBrowser(browsers, userAgent))
      .fold(Browser.unknown, Browser.nu);
    const os = detectOs(oses, userAgent).fold(
      OperatingSystem.unknown,
      OperatingSystem.nu
    );
    const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
    return {
      browser,
      os,
      deviceType,
    };
  };
  const PlatformDetection = { detect: detect$2 };

  const mediaMatch = (query) => window.matchMedia(query).matches;
  let platform$4 = cached(() =>
    PlatformDetection.detect(
      window.navigator.userAgent,
      Optional.from(window.navigator.userAgentData),
      mediaMatch
    )
  );
  const detect$1 = () => platform$4();

  const userAgent = window.navigator.userAgent;
  const platform$3 = detect$1();
  const browser$3 = platform$3.browser;
  const os$1 = platform$3.os;
  const deviceType = platform$3.deviceType;
  const windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
  const Env = {
    transparentSrc:
      "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
    documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,
    cacheSuffix: null,
    container: null,
    canHaveCSP: !browser$3.isIE(),
    windowsPhone,
    browser: {
      current: browser$3.current,
      version: browser$3.version,
      isChromium: browser$3.isChromium,
      isEdge: browser$3.isEdge,
      isFirefox: browser$3.isFirefox,
      isIE: browser$3.isIE,
      isOpera: browser$3.isOpera,
      isSafari: browser$3.isSafari,
    },
    os: {
      current: os$1.current,
      version: os$1.version,
      isAndroid: os$1.isAndroid,
      isChromeOS: os$1.isChromeOS,
      isFreeBSD: os$1.isFreeBSD,
      isiOS: os$1.isiOS,
      isLinux: os$1.isLinux,
      isMacOS: os$1.isMacOS,
      isSolaris: os$1.isSolaris,
      isWindows: os$1.isWindows,
    },
    deviceType: {
      isDesktop: deviceType.isDesktop,
      isiPad: deviceType.isiPad,
      isiPhone: deviceType.isiPhone,
      isPhone: deviceType.isPhone,
      isTablet: deviceType.isTablet,
      isTouch: deviceType.isTouch,
      isWebView: deviceType.isWebView,
    },
  };

  const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
  const trim$3 = (str) => {
    return isNullable(str) ? "" : ("" + str).replace(whiteSpaceRegExp$1, "");
  };
  const is$3 = (obj, type) => {
    if (!type) {
      return obj !== undefined;
    }
    if (type === "array" && isArray(obj)) {
      return true;
    }
    return typeof obj === type;
  };
  const makeMap$4 = (items, delim, map = {}) => {
    const resolvedItems = isString(items)
      ? items.split(delim || ",")
      : items || [];
    let i = resolvedItems.length;
    while (i--) {
      map[resolvedItems[i]] = {};
    }
    return map;
  };
  const hasOwnProperty = has$2;
  const extend$3 = (obj, ...exts) => {
    for (let i = 0; i < exts.length; i++) {
      const ext = exts[i];
      for (const name in ext) {
        if (has$2(ext, name)) {
          const value = ext[name];
          if (value !== undefined) {
            obj[name] = value;
          }
        }
      }
    }
    return obj;
  };
  const walk$4 = function (o, f, n, s) {
    s = s || this;
    if (o) {
      if (n) {
        o = o[n];
      }
      each$c(o, (o, i) => {
        if (f.call(s, o, i, n) === false) {
          return false;
        } else {
          walk$4(o, f, n, s);
          return true;
        }
      });
    }
  };
  const resolve$3 = (n, o = window) => {
    const path = n.split(".");
    for (let i = 0, l = path.length; i < l; i++) {
      o = o[path[i]];
      if (!o) {
        break;
      }
    }
    return o;
  };
  const explode$3 = (s, d) => {
    if (isArray$1(s)) {
      return s;
    } else if (s === "") {
      return [];
    } else {
      return map$1(s.split(d || ","), trim$3);
    }
  };
  const _addCacheSuffix = (url) => {
    const cacheSuffix = Env.cacheSuffix;
    if (cacheSuffix) {
      url += (url.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
    }
    return url;
  };
  const Tools = {
    trim: trim$3,
    isArray: isArray,
    is: is$3,
    toArray: toArray$1,
    makeMap: makeMap$4,
    each: each$c,
    map: map$1,
    grep: filter$3,
    inArray: indexOf,
    hasOwn: hasOwnProperty,
    extend: extend$3,
    walk: walk$4,
    resolve: resolve$3,
    explode: explode$3,
    _addCacheSuffix,
  };

  const is$2 = (lhs, rhs, comparator = tripleEquals) =>
    lhs.exists((left) => comparator(left, rhs));
  const equals = (lhs, rhs, comparator = tripleEquals) =>
    lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
  const cat = (arr) => {
    const r = [];
    const push = (x) => {
      r.push(x);
    };
    for (let i = 0; i < arr.length; i++) {
      arr[i].each(push);
    }
    return r;
  };
  const lift2 = (oa, ob, f) =>
    oa.isSome() && ob.isSome()
      ? Optional.some(f(oa.getOrDie(), ob.getOrDie()))
      : Optional.none();
  const lift3 = (oa, ob, oc, f) =>
    oa.isSome() && ob.isSome() && oc.isSome()
      ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie()))
      : Optional.none();
  const someIf = (b, a) => (b ? Optional.some(a) : Optional.none());

  const Global =
    typeof window !== "undefined" ? window : Function("return this;")();

  const path = (parts, scope) => {
    let o = scope !== undefined && scope !== null ? scope : Global;
    for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {
      o = o[parts[i]];
    }
    return o;
  };
  const resolve$2 = (p, scope) => {
    const parts = p.split(".");
    return path(parts, scope);
  };

  const unsafe = (name, scope) => {
    return resolve$2(name, scope);
  };
  const getOrDie = (name, scope) => {
    const actual = unsafe(name, scope);
    if (actual === undefined || actual === null) {
      throw new Error(name + " not available on this browser");
    }
    return actual;
  };

  const getPrototypeOf$1 = Object.getPrototypeOf;
  const sandHTMLElement = (scope) => {
    return getOrDie("HTMLElement", scope);
  };
  const isPrototypeOf = (x) => {
    const scope = resolve$2("ownerDocument.defaultView", x);
    return (
      isObject(x) &&
      (sandHTMLElement(scope).prototype.isPrototypeOf(x) ||
        /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name))
    );
  };

  const COMMENT = 8;
  const DOCUMENT = 9;
  const DOCUMENT_FRAGMENT = 11;
  const ELEMENT = 1;
  const TEXT = 3;

  const name = (element) => {
    const r = element.dom.nodeName;
    return r.toLowerCase();
  };
  const type$1 = (element) => element.dom.nodeType;
  const isType = (t) => (element) => type$1(element) === t;
  const isComment$1 = (element) =>
    type$1(element) === COMMENT || name(element) === "#comment";
  const isHTMLElement$1 = (element) =>
    isElement$7(element) && isPrototypeOf(element.dom);
  const isElement$7 = isType(ELEMENT);
  const isText$c = isType(TEXT);
  const isDocument$2 = isType(DOCUMENT);
  const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
  const isTag = (tag) => (e) => isElement$7(e) && name(e) === tag;

  const rawSet = (dom, key, value) => {
    if (isString(value) || isBoolean(value) || isNumber(value)) {
      dom.setAttribute(key, value + "");
    } else {
      console.error(
        "Invalid call to Attribute.set. Key ",
        key,
        ":: Value ",
        value,
        ":: Element ",
        dom
      );
      throw new Error("Attribute value was not simple");
    }
  };
  const set$4 = (element, key, value) => {
    rawSet(element.dom, key, value);
  };
  const setAll$1 = (element, attrs) => {
    const dom = element.dom;
    each$d(attrs, (v, k) => {
      rawSet(dom, k, v);
    });
  };
  const get$9 = (element, key) => {
    const v = element.dom.getAttribute(key);
    return v === null ? undefined : v;
  };
  const getOpt = (element, key) => Optional.from(get$9(element, key));
  const has$1 = (element, key) => {
    const dom = element.dom;
    return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
  };
  const remove$9 = (element, key) => {
    element.dom.removeAttribute(key);
  };
  const hasNone = (element) => {
    const attrs = element.dom.attributes;
    return attrs === undefined || attrs === null || attrs.length === 0;
  };
  const clone$4 = (element) =>
    foldl(
      element.dom.attributes,
      (acc, attr) => {
        acc[attr.name] = attr.value;
        return acc;
      },
      {}
    );

  const read$4 = (element, attr) => {
    const value = get$9(element, attr);
    return value === undefined || value === "" ? [] : value.split(" ");
  };
  const add$4 = (element, attr, id) => {
    const old = read$4(element, attr);
    const nu = old.concat([id]);
    set$4(element, attr, nu.join(" "));
    return true;
  };
  const remove$8 = (element, attr, id) => {
    const nu = filter$5(read$4(element, attr), (v) => v !== id);
    if (nu.length > 0) {
      set$4(element, attr, nu.join(" "));
    } else {
      remove$9(element, attr);
    }
    return false;
  };

  const supports = (element) => element.dom.classList !== undefined;
  const get$8 = (element) => read$4(element, "class");
  const add$3 = (element, clazz) => add$4(element, "class", clazz);
  const remove$7 = (element, clazz) => remove$8(element, "class", clazz);
  const toggle$2 = (element, clazz) => {
    if (contains$2(get$8(element), clazz)) {
      return remove$7(element, clazz);
    } else {
      return add$3(element, clazz);
    }
  };

  const add$2 = (element, clazz) => {
    if (supports(element)) {
      element.dom.classList.add(clazz);
    } else {
      add$3(element, clazz);
    }
  };
  const cleanClass = (element) => {
    const classList = supports(element)
      ? element.dom.classList
      : get$8(element);
    if (classList.length === 0) {
      remove$9(element, "class");
    }
  };
  const remove$6 = (element, clazz) => {
    if (supports(element)) {
      const classList = element.dom.classList;
      classList.remove(clazz);
    } else {
      remove$7(element, clazz);
    }
    cleanClass(element);
  };
  const toggle$1 = (element, clazz) => {
    const result = supports(element)
      ? element.dom.classList.toggle(clazz)
      : toggle$2(element, clazz);
    cleanClass(element);
    return result;
  };
  const has = (element, clazz) =>
    supports(element) && element.dom.classList.contains(clazz);

  const fromHtml$1 = (html, scope) => {
    const doc = scope || document;
    const div = doc.createElement("div");
    div.innerHTML = html;
    if (!div.hasChildNodes() || div.childNodes.length > 1) {
      const message = "HTML does not have a single root node";
      console.error(message, html);
      throw new Error(message);
    }
    return fromDom$2(div.childNodes[0]);
  };
  const fromTag = (tag, scope) => {
    const doc = scope || document;
    const node = doc.createElement(tag);
    return fromDom$2(node);
  };
  const fromText = (text, scope) => {
    const doc = scope || document;
    const node = doc.createTextNode(text);
    return fromDom$2(node);
  };
  const fromDom$2 = (node) => {
    if (node === null || node === undefined) {
      throw new Error("Node cannot be null or undefined");
    }
    return { dom: node };
  };
  const fromPoint$2 = (docElm, x, y) =>
    Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
  const SugarElement = {
    fromHtml: fromHtml$1,
    fromTag,
    fromText,
    fromDom: fromDom$2,
    fromPoint: fromPoint$2,
  };

  const toArray = (target, f) => {
    const r = [];
    const recurse = (e) => {
      r.push(e);
      return f(e);
    };
    let cur = f(target);
    do {
      cur = cur.bind(recurse);
    } while (cur.isSome());
    return r;
  };

  const is$1 = (element, selector) => {
    const dom = element.dom;
    if (dom.nodeType !== ELEMENT) {
      return false;
    } else {
      const elem = dom;
      if (elem.matches !== undefined) {
        return elem.matches(selector);
      } else if (elem.msMatchesSelector !== undefined) {
        return elem.msMatchesSelector(selector);
      } else if (elem.webkitMatchesSelector !== undefined) {
        return elem.webkitMatchesSelector(selector);
      } else if (elem.mozMatchesSelector !== undefined) {
        return elem.mozMatchesSelector(selector);
      } else {
        throw new Error("Browser lacks native selectors");
      }
    }
  };
  const bypassSelector = (dom) =>
    (dom.nodeType !== ELEMENT &&
      dom.nodeType !== DOCUMENT &&
      dom.nodeType !== DOCUMENT_FRAGMENT) ||
    dom.childElementCount === 0;
  const all = (selector, scope) => {
    const base = scope === undefined ? document : scope.dom;
    return bypassSelector(base)
      ? []
      : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
  };
  const one = (selector, scope) => {
    const base = scope === undefined ? document : scope.dom;
    return bypassSelector(base)
      ? Optional.none()
      : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
  };

  const eq = (e1, e2) => e1.dom === e2.dom;
  const contains = (e1, e2) => {
    const d1 = e1.dom;
    const d2 = e2.dom;
    return d1 === d2 ? false : d1.contains(d2);
  };

  const owner$1 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
  const documentOrOwner = (dos) => (isDocument$2(dos) ? dos : owner$1(dos));
  const documentElement = (element) =>
    SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
  const defaultView = (element) =>
    SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
  const parent = (element) =>
    Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
  const parentElement = (element) =>
    Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
  const parents$1 = (element, isRoot) => {
    const stop = isFunction(isRoot) ? isRoot : never;
    let dom = element.dom;
    const ret = [];
    while (dom.parentNode !== null && dom.parentNode !== undefined) {
      const rawParent = dom.parentNode;
      const p = SugarElement.fromDom(rawParent);
      ret.push(p);
      if (stop(p) === true) {
        break;
      } else {
        dom = rawParent;
      }
    }
    return ret;
  };
  const siblings = (element) => {
    const filterSelf = (elements) => filter$5(elements, (x) => !eq(element, x));
    return parent(element).map(children$1).map(filterSelf).getOr([]);
  };
  const prevSibling = (element) =>
    Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
  const nextSibling = (element) =>
    Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
  const prevSiblings = (element) => reverse(toArray(element, prevSibling));
  const nextSiblings = (element) => toArray(element, nextSibling);
  const children$1 = (element) =>
    map$3(element.dom.childNodes, SugarElement.fromDom);
  const child$1 = (element, index) => {
    const cs = element.dom.childNodes;
    return Optional.from(cs[index]).map(SugarElement.fromDom);
  };
  const firstChild = (element) => child$1(element, 0);
  const lastChild = (element) =>
    child$1(element, element.dom.childNodes.length - 1);
  const childNodesCount = (element) => element.dom.childNodes.length;

  const getHead = (doc) => {
    const b = doc.dom.head;
    if (b === null || b === undefined) {
      throw new Error("Head is not available yet");
    }
    return SugarElement.fromDom(b);
  };

  const isShadowRoot = (dos) =>
    isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
  const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());
  const getStyleContainer = (dos) =>
    isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
  const getContentContainer = (dos) =>
    isShadowRoot(dos)
      ? dos
      : SugarElement.fromDom(documentOrOwner(dos).dom.body);
  const getShadowRoot = (e) => {
    const r = getRootNode(e);
    return isShadowRoot(r) ? Optional.some(r) : Optional.none();
  };
  const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
  const getOriginalEventTarget = (event) => {
    if (isNonNullable(event.target)) {
      const el = SugarElement.fromDom(event.target);
      if (isElement$7(el) && isOpenShadowHost(el)) {
        if (event.composed && event.composedPath) {
          const composedPath = event.composedPath();
          if (composedPath) {
            return head(composedPath);
          }
        }
      }
    }
    return Optional.from(event.target);
  };
  const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);

  const inBody = (element) => {
    const dom = isText$c(element) ? element.dom.parentNode : element.dom;
    if (dom === undefined || dom === null || dom.ownerDocument === null) {
      return false;
    }
    const doc = dom.ownerDocument;
    return getShadowRoot(SugarElement.fromDom(dom)).fold(
      () => doc.body.contains(dom),
      compose1(inBody, getShadowHost)
    );
  };

  var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {
    if (is(scope, a)) {
      return Optional.some(scope);
    } else if (isFunction(isRoot) && isRoot(scope)) {
      return Optional.none();
    } else {
      return ancestor(scope, a, isRoot);
    }
  };

  const ancestor$4 = (scope, predicate, isRoot) => {
    let element = scope.dom;
    const stop = isFunction(isRoot) ? isRoot : never;
    while (element.parentNode) {
      element = element.parentNode;
      const el = SugarElement.fromDom(element);
      if (predicate(el)) {
        return Optional.some(el);
      } else if (stop(el)) {
        break;
      }
    }
    return Optional.none();
  };
  const closest$4 = (scope, predicate, isRoot) => {
    const is = (s, test) => test(s);
    return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);
  };
  const sibling$1 = (scope, predicate) => {
    const element = scope.dom;
    if (!element.parentNode) {
      return Optional.none();
    }
    return child(
      SugarElement.fromDom(element.parentNode),
      (x) => !eq(scope, x) && predicate(x)
    );
  };
  const child = (scope, predicate) => {
    const pred = (node) => predicate(SugarElement.fromDom(node));
    const result = find$2(scope.dom.childNodes, pred);
    return result.map(SugarElement.fromDom);
  };
  const descendant$2 = (scope, predicate) => {
    const descend = (node) => {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = SugarElement.fromDom(node.childNodes[i]);
        if (predicate(child)) {
          return Optional.some(child);
        }
        const res = descend(node.childNodes[i]);
        if (res.isSome()) {
          return res;
        }
      }
      return Optional.none();
    };
    return descend(scope.dom);
  };

  const ancestor$3 = (scope, selector, isRoot) =>
    ancestor$4(scope, (e) => is$1(e, selector), isRoot);
  const descendant$1 = (scope, selector) => one(selector, scope);
  const closest$3 = (scope, selector, isRoot) => {
    const is = (element, selector) => is$1(element, selector);
    return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);
  };

  const closest$2 = (target) => closest$3(target, "[contenteditable]");
  const isEditable$2 = (element, assumeEditable = false) => {
    if (inBody(element)) {
      return element.dom.isContentEditable;
    } else {
      return closest$2(element).fold(
        constant(assumeEditable),
        (editable) => getRaw$1(editable) === "true"
      );
    }
  };
  const getRaw$1 = (element) => element.dom.contentEditable;
  const set$3 = (element, editable) => {
    element.dom.contentEditable = editable ? "true" : "false";
  };

  const isSupported = (dom) =>
    dom.style !== undefined && isFunction(dom.style.getPropertyValue);

  const internalSet = (dom, property, value) => {
    if (!isString(value)) {
      console.error(
        "Invalid call to CSS.set. Property ",
        property,
        ":: Value ",
        value,
        ":: Element ",
        dom
      );
      throw new Error("CSS value must be a string: " + value);
    }
    if (isSupported(dom)) {
      dom.style.setProperty(property, value);
    }
  };
  const internalRemove = (dom, property) => {
    if (isSupported(dom)) {
      dom.style.removeProperty(property);
    }
  };
  const set$2 = (element, property, value) => {
    const dom = element.dom;
    internalSet(dom, property, value);
  };
  const setAll = (element, css) => {
    const dom = element.dom;
    each$d(css, (v, k) => {
      internalSet(dom, k, v);
    });
  };
  const get$7 = (element, property) => {
    const dom = element.dom;
    const styles = window.getComputedStyle(dom);
    const r = styles.getPropertyValue(property);
    return r === "" && !inBody(element) ? getUnsafeProperty(dom, property) : r;
  };
  const getUnsafeProperty = (dom, property) =>
    isSupported(dom) ? dom.style.getPropertyValue(property) : "";
  const getRaw = (element, property) => {
    const dom = element.dom;
    const raw = getUnsafeProperty(dom, property);
    return Optional.from(raw).filter((r) => r.length > 0);
  };
  const getAllRaw = (element) => {
    const css = {};
    const dom = element.dom;
    if (isSupported(dom)) {
      for (let i = 0; i < dom.style.length; i++) {
        const ruleName = dom.style.item(i);
        css[ruleName] = dom.style[ruleName];
      }
    }
    return css;
  };
  const remove$5 = (element, property) => {
    const dom = element.dom;
    internalRemove(dom, property);
    if (is$2(getOpt(element, "style").map(trim$4), "")) {
      remove$9(element, "style");
    }
  };
  const reflow = (e) => e.dom.offsetWidth;

  const before$3 = (marker, element) => {
    const parent$1 = parent(marker);
    parent$1.each((v) => {
      v.dom.insertBefore(element.dom, marker.dom);
    });
  };
  const after$4 = (marker, element) => {
    const sibling = nextSibling(marker);
    sibling.fold(
      () => {
        const parent$1 = parent(marker);
        parent$1.each((v) => {
          append$1(v, element);
        });
      },
      (v) => {
        before$3(v, element);
      }
    );
  };
  const prepend = (parent, element) => {
    const firstChild$1 = firstChild(parent);
    firstChild$1.fold(
      () => {
        append$1(parent, element);
      },
      (v) => {
        parent.dom.insertBefore(element.dom, v.dom);
      }
    );
  };
  const append$1 = (parent, element) => {
    parent.dom.appendChild(element.dom);
  };
  const wrap$2 = (element, wrapper) => {
    before$3(element, wrapper);
    append$1(wrapper, element);
  };

  const after$3 = (marker, elements) => {
    each$e(elements, (x, i) => {
      const e = i === 0 ? marker : elements[i - 1];
      after$4(e, x);
    });
  };
  const append = (parent, elements) => {
    each$e(elements, (x) => {
      append$1(parent, x);
    });
  };

  const empty = (element) => {
    element.dom.textContent = "";
    each$e(children$1(element), (rogue) => {
      remove$4(rogue);
    });
  };
  const remove$4 = (element) => {
    const dom = element.dom;
    if (dom.parentNode !== null) {
      dom.parentNode.removeChild(dom);
    }
  };
  const unwrap = (wrapper) => {
    const children = children$1(wrapper);
    if (children.length > 0) {
      after$3(wrapper, children);
    }
    remove$4(wrapper);
  };

  const fromHtml = (html, scope) => {
    const doc = scope || document;
    const div = doc.createElement("div");
    div.innerHTML = html;
    return children$1(SugarElement.fromDom(div));
  };
  const fromDom$1 = (nodes) => map$3(nodes, SugarElement.fromDom);

  const get$6 = (element) => element.dom.innerHTML;
  const set$1 = (element, content) => {
    const owner = owner$1(element);
    const docDom = owner.dom;
    const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
    const contentElements = fromHtml(content, docDom);
    append(fragment, contentElements);
    empty(element);
    append$1(element, fragment);
  };
  const getOuter = (element) => {
    const container = SugarElement.fromTag("div");
    const clone = SugarElement.fromDom(element.dom.cloneNode(true));
    append$1(container, clone);
    return get$6(container);
  };

  const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
    target,
    x,
    y,
    stop,
    prevent,
    kill,
    raw,
  });
  const fromRawEvent = (rawEvent) => {
    const target = SugarElement.fromDom(
      getOriginalEventTarget(rawEvent).getOr(rawEvent.target)
    );
    const stop = () => rawEvent.stopPropagation();
    const prevent = () => rawEvent.preventDefault();
    const kill = compose(prevent, stop);
    return mkEvent(
      target,
      rawEvent.clientX,
      rawEvent.clientY,
      stop,
      prevent,
      kill,
      rawEvent
    );
  };
  const handle$1 = (filter, handler) => (rawEvent) => {
    if (filter(rawEvent)) {
      handler(fromRawEvent(rawEvent));
    }
  };
  const binder = (element, event, filter, handler, useCapture) => {
    const wrapped = handle$1(filter, handler);
    element.dom.addEventListener(event, wrapped, useCapture);
    return { unbind: curry(unbind, element, event, wrapped, useCapture) };
  };
  const bind$2 = (element, event, filter, handler) =>
    binder(element, event, filter, handler, false);
  const unbind = (element, event, handler, useCapture) => {
    element.dom.removeEventListener(event, handler, useCapture);
  };

  const r = (left, top) => {
    const translate = (x, y) => r(left + x, top + y);
    return {
      left,
      top,
      translate,
    };
  };
  const SugarPosition = r;

  const boxPosition = (dom) => {
    const box = dom.getBoundingClientRect();
    return SugarPosition(box.left, box.top);
  };
  const firstDefinedOrZero = (a, b) => {
    if (a !== undefined) {
      return a;
    } else {
      return b !== undefined ? b : 0;
    }
  };
  const absolute = (element) => {
    const doc = element.dom.ownerDocument;
    const body = doc.body;
    const win = doc.defaultView;
    const html = doc.documentElement;
    if (body === element.dom) {
      return SugarPosition(body.offsetLeft, body.offsetTop);
    }
    const scrollTop = firstDefinedOrZero(
      win === null || win === void 0 ? void 0 : win.pageYOffset,
      html.scrollTop
    );
    const scrollLeft = firstDefinedOrZero(
      win === null || win === void 0 ? void 0 : win.pageXOffset,
      html.scrollLeft
    );
    const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
    const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
    return viewport(element).translate(
      scrollLeft - clientLeft,
      scrollTop - clientTop
    );
  };
  const viewport = (element) => {
    const dom = element.dom;
    const doc = dom.ownerDocument;
    const body = doc.body;
    if (body === dom) {
      return SugarPosition(body.offsetLeft, body.offsetTop);
    }
    if (!inBody(element)) {
      return SugarPosition(0, 0);
    }
    return boxPosition(dom);
  };

  const get$5 = (_DOC) => {
    const doc = _DOC !== undefined ? _DOC.dom : document;
    const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
    const y = doc.body.scrollTop || doc.documentElement.scrollTop;
    return SugarPosition(x, y);
  };
  const to = (x, y, _DOC) => {
    const doc = _DOC !== undefined ? _DOC.dom : document;
    const win = doc.defaultView;
    if (win) {
      win.scrollTo(x, y);
    }
  };
  const intoView = (element, alignToTop) => {
    const isSafari = detect$1().browser.isSafari();
    if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
      element.dom.scrollIntoViewIfNeeded(false);
    } else {
      element.dom.scrollIntoView(alignToTop);
    }
  };

  const get$4 = (_win) => {
    const win = _win === undefined ? window : _win;
    if (detect$1().browser.isFirefox()) {
      return Optional.none();
    } else {
      return Optional.from(win.visualViewport);
    }
  };
  const bounds = (x, y, width, height) => ({
    x,
    y,
    width,
    height,
    right: x + width,
    bottom: y + height,
  });
  const getBounds = (_win) => {
    const win = _win === undefined ? window : _win;
    const doc = win.document;
    const scroll = get$5(SugarElement.fromDom(doc));
    return get$4(win).fold(
      () => {
        const html = win.document.documentElement;
        const width = html.clientWidth;
        const height = html.clientHeight;
        return bounds(scroll.left, scroll.top, width, height);
      },
      (visualViewport) =>
        bounds(
          Math.max(visualViewport.pageLeft, scroll.left),
          Math.max(visualViewport.pageTop, scroll.top),
          visualViewport.width,
          visualViewport.height
        )
    );
  };

  const children = (scope, predicate) => filter$5(children$1(scope), predicate);
  const descendants$1 = (scope, predicate) => {
    let result = [];
    each$e(children$1(scope), (x) => {
      if (predicate(x)) {
        result = result.concat([x]);
      }
      result = result.concat(descendants$1(x, predicate));
    });
    return result;
  };

  const descendants = (scope, selector) => all(selector, scope);

  const ancestor$2 = (scope, predicate, isRoot) =>
    ancestor$4(scope, predicate, isRoot).isSome();
  const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();
  const descendant = (scope, predicate) =>
    descendant$2(scope, predicate).isSome();

  class DomTreeWalker {
    constructor(startNode, rootNode) {
      this.node = startNode;
      this.rootNode = rootNode;
      this.current = this.current.bind(this);
      this.next = this.next.bind(this);
      this.prev = this.prev.bind(this);
      this.prev2 = this.prev2.bind(this);
    }
    current() {
      return this.node;
    }
    next(shallow) {
      this.node = this.findSibling(
        this.node,
        "firstChild",
        "nextSibling",
        shallow
      );
      return this.node;
    }
    prev(shallow) {
      this.node = this.findSibling(
        this.node,
        "lastChild",
        "previousSibling",
        shallow
      );
      return this.node;
    }
    prev2(shallow) {
      this.node = this.findPreviousNode(this.node, shallow);
      return this.node;
    }
    findSibling(node, startName, siblingName, shallow) {
      if (node) {
        if (!shallow && node[startName]) {
          return node[startName];
        }
        if (node !== this.rootNode) {
          let sibling = node[siblingName];
          if (sibling) {
            return sibling;
          }
          for (
            let parent = node.parentNode;
            parent && parent !== this.rootNode;
            parent = parent.parentNode
          ) {
            sibling = parent[siblingName];
            if (sibling) {
              return sibling;
            }
          }
        }
      }
      return undefined;
    }
    findPreviousNode(node, shallow) {
      if (node) {
        const sibling = node.previousSibling;
        if (this.rootNode && sibling === this.rootNode) {
          return;
        }
        if (sibling) {
          if (!shallow) {
            for (
              let child = sibling.lastChild;
              child;
              child = child.lastChild
            ) {
              if (!child.lastChild) {
                return child;
              }
            }
          }
          return sibling;
        }
        const parent = node.parentNode;
        if (parent && parent !== this.rootNode) {
          return parent;
        }
      }
      return undefined;
    }
  }

  const zeroWidth = "\uFEFF";
  const nbsp = "\xA0";
  const isZwsp$2 = (char) => char === zeroWidth;
  const removeZwsp = (s) => s.replace(/\uFEFF/g, "");

  const whiteSpaceRegExp = /^[ \t\r\n]*$/;
  const isWhitespaceText = (text) => whiteSpaceRegExp.test(text);
  const isZwsp$1 = (text) => {
    for (const c of text) {
      if (!isZwsp$2(c)) {
        return false;
      }
    }
    return true;
  };
  const isCollapsibleWhitespace$1 = (c) => " \f\t\x0B".indexOf(c) !== -1;
  const isNewLineChar = (c) => c === "\n" || c === "\r";
  const isNewline = (text, idx) =>
    idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;
  const normalize$4 = (
    text,
    tabSpaces = 4,
    isStartOfContent = true,
    isEndOfContent = true
  ) => {
    const tabSpace = repeat(" ", tabSpaces);
    const normalizedText = text.replace(/\t/g, tabSpace);
    const result = foldl(
      normalizedText,
      (acc, c) => {
        if (isCollapsibleWhitespace$1(c) || c === nbsp) {
          if (
            acc.pcIsSpace ||
            (acc.str === "" && isStartOfContent) ||
            (acc.str.length === normalizedText.length - 1 && isEndOfContent) ||
            isNewline(normalizedText, acc.str.length + 1)
          ) {
            return {
              pcIsSpace: false,
              str: acc.str + nbsp,
            };
          } else {
            return {
              pcIsSpace: true,
              str: acc.str + " ",
            };
          }
        } else {
          return {
            pcIsSpace: isNewLineChar(c),
            str: acc.str + c,
          };
        }
      },
      {
        pcIsSpace: false,
        str: "",
      }
    );
    return result.str;
  };

  const isNodeType = (type) => {
    return (node) => {
      return !!node && node.nodeType === type;
    };
  };
  const isRestrictedNode = (node) => !!node && !Object.getPrototypeOf(node);
  const isElement$6 = isNodeType(1);
  const isHTMLElement = (node) =>
    isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));
  const isSVGElement = (node) =>
    isElement$6(node) && node.namespaceURI === "http://www.w3.org/2000/svg";
  const matchNodeName = (name) => {
    const lowerCasedName = name.toLowerCase();
    return (node) =>
      isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
  };
  const matchNodeNames = (names) => {
    const lowerCasedNames = names.map((s) => s.toLowerCase());
    return (node) => {
      if (node && node.nodeName) {
        const nodeName = node.nodeName.toLowerCase();
        return contains$2(lowerCasedNames, nodeName);
      }
      return false;
    };
  };
  const matchStyleValues = (name, values) => {
    const items = values.toLowerCase().split(" ");
    return (node) => {
      if (isElement$6(node)) {
        const win = node.ownerDocument.defaultView;
        if (win) {
          for (let i = 0; i < items.length; i++) {
            const computed = win.getComputedStyle(node, null);
            const cssValue = computed ? computed.getPropertyValue(name) : null;
            if (cssValue === items[i]) {
              return true;
            }
          }
        }
      }
      return false;
    };
  };
  const hasAttribute = (attrName) => {
    return (node) => {
      return isElement$6(node) && node.hasAttribute(attrName);
    };
  };
  const isBogus$1 = (node) =>
    isElement$6(node) && node.hasAttribute("data-mce-bogus");
  const isBogusAll = (node) =>
    isElement$6(node) && node.getAttribute("data-mce-bogus") === "all";
  const isTable$2 = (node) => isElement$6(node) && node.tagName === "TABLE";
  const hasContentEditableState = (value) => {
    return (node) => {
      if (isHTMLElement(node)) {
        if (node.contentEditable === value) {
          return true;
        }
        if (node.getAttribute("data-mce-contenteditable") === value) {
          return true;
        }
      }
      return false;
    };
  };
  const isTextareaOrInput = matchNodeNames(["textarea", "input"]);
  const isText$b = isNodeType(3);
  const isCData = isNodeType(4);
  const isPi = isNodeType(7);
  const isComment = isNodeType(8);
  const isDocument$1 = isNodeType(9);
  const isDocumentFragment = isNodeType(11);
  const isBr$6 = matchNodeName("br");
  const isImg = matchNodeName("img");
  const isContentEditableTrue$3 = hasContentEditableState("true");
  const isContentEditableFalse$b = hasContentEditableState("false");
  const isEditingHost = (node) =>
    isHTMLElement(node) &&
    node.isContentEditable &&
    isNonNullable(node.parentElement) &&
    !node.parentElement.isContentEditable;
  const isTableCell$3 = matchNodeNames(["td", "th"]);
  const isTableCellOrCaption = matchNodeNames(["td", "th", "caption"]);
  const isMedia$2 = matchNodeNames(["video", "audio", "object", "embed"]);
  const isListItem$2 = matchNodeName("li");
  const isDetails = matchNodeName("details");
  const isSummary$1 = matchNodeName("summary");

  const defaultOptionValues = {
    skipBogus: true,
    includeZwsp: false,
    checkRootAsContent: false,
  };
  const hasWhitespacePreserveParent = (node, rootNode, schema) => {
    const rootElement = SugarElement.fromDom(rootNode);
    const startNode = SugarElement.fromDom(node);
    const whitespaceElements = schema.getWhitespaceElements();
    const predicate = (node) => has$2(whitespaceElements, name(node));
    return ancestor$2(startNode, predicate, curry(eq, rootElement));
  };
  const isNamedAnchor = (node) => {
    return (
      isElement$6(node) &&
      node.nodeName === "A" &&
      !node.hasAttribute("href") &&
      (node.hasAttribute("name") || node.hasAttribute("id"))
    );
  };
  const isNonEmptyElement$1 = (node, schema) => {
    return (
      isElement$6(node) && has$2(schema.getNonEmptyElements(), node.nodeName)
    );
  };
  const isBookmark = hasAttribute("data-mce-bookmark");
  const hasNonEditableParent = (node) =>
    parentElement(SugarElement.fromDom(node)).exists(
      (parent) => !isEditable$2(parent)
    );
  const isWhitespace$1 = (node, rootNode, schema) =>
    isWhitespaceText(node.data) &&
    !hasWhitespacePreserveParent(node, rootNode, schema);
  const isText$a = (node, rootNode, schema, options) =>
    isText$b(node) &&
    !isWhitespace$1(node, rootNode, schema) &&
    (!options.includeZwsp || !isZwsp$1(node.data));
  const isContentNode = (schema, node, rootNode, options) => {
    return (
      (isFunction(options.isContent) && options.isContent(node)) ||
      isNonEmptyElement$1(node, schema) ||
      isBookmark(node) ||
      isNamedAnchor(node) ||
      isText$a(node, rootNode, schema, options) ||
      isContentEditableFalse$b(node) ||
      (isContentEditableTrue$3(node) && hasNonEditableParent(node))
    );
  };
  const isEmptyNode = (schema, targetNode, opts) => {
    const options = {
      ...defaultOptionValues,
      ...opts,
    };
    if (options.checkRootAsContent) {
      if (isContentNode(schema, targetNode, targetNode, options)) {
        return false;
      }
    }
    let node = targetNode.firstChild;
    let brCount = 0;
    if (!node) {
      return true;
    }
    const walker = new DomTreeWalker(node, targetNode);
    do {
      if (options.skipBogus && isElement$6(node)) {
        const bogusValue = node.getAttribute("data-mce-bogus");
        if (bogusValue) {
          node = walker.next(bogusValue === "all");
          continue;
        }
      }
      if (isComment(node)) {
        node = walker.next(true);
        continue;
      }
      if (isBr$6(node)) {
        brCount++;
        node = walker.next();
        continue;
      }
      if (isContentNode(schema, node, targetNode, options)) {
        return false;
      }
      node = walker.next();
    } while (node);
    return brCount <= 1;
  };
  const isEmpty$2 = (schema, elm, options) => {
    return isEmptyNode(schema, elm.dom, {
      checkRootAsContent: true,
      ...options,
    });
  };
  const isContent$1 = (schema, node, options) => {
    return isContentNode(schema, node, node, {
      includeZwsp: defaultOptionValues.includeZwsp,
      ...options,
    });
  };

  const Cell = (initial) => {
    let value = initial;
    const get = () => {
      return value;
    };
    const set = (v) => {
      value = v;
    };
    return {
      get,
      set,
    };
  };

  const singleton = (doRevoke) => {
    const subject = Cell(Optional.none());
    const revoke = () => subject.get().each(doRevoke);
    const clear = () => {
      revoke();
      subject.set(Optional.none());
    };
    const isSet = () => subject.get().isSome();
    const get = () => subject.get();
    const set = (s) => {
      revoke();
      subject.set(Optional.some(s));
    };
    return {
      clear,
      isSet,
      get,
      set,
    };
  };
  const repeatable = (delay) => {
    const intervalId = Cell(Optional.none());
    const revoke = () => intervalId.get().each((id) => clearInterval(id));
    const clear = () => {
      revoke();
      intervalId.set(Optional.none());
    };
    const isSet = () => intervalId.get().isSome();
    const get = () => intervalId.get();
    const set = (functionToRepeat) => {
      revoke();
      intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
    };
    return {
      clear,
      isSet,
      get,
      set,
    };
  };
  const value$2 = () => {
    const subject = singleton(noop);
    const on = (f) => subject.get().each(f);
    return {
      ...subject,
      on,
    };
  };

  const nodeNameToNamespaceType = (name) => {
    const lowerCaseName = name.toLowerCase();
    if (lowerCaseName === "svg") {
      return "svg";
    } else if (lowerCaseName === "math") {
      return "math";
    } else {
      return "html";
    }
  };
  const isNonHtmlElementRootName = (name) =>
    nodeNameToNamespaceType(name) !== "html";
  const isNonHtmlElementRoot = (node) =>
    isNonHtmlElementRootName(node.nodeName);
  const toScopeType = (node) => nodeNameToNamespaceType(node.nodeName);
  const namespaceElements = ["svg", "math"];
  const createNamespaceTracker = () => {
    const currentScope = value$2();
    const current = () => currentScope.get().map(toScopeType).getOr("html");
    const track = (node) => {
      if (isNonHtmlElementRoot(node)) {
        currentScope.set(node);
      } else if (
        currentScope.get().exists((scopeNode) => !scopeNode.contains(node))
      ) {
        currentScope.clear();
      }
      return current();
    };
    const reset = () => {
      currentScope.clear();
    };
    return {
      track,
      current,
      reset,
    };
  };

  const transparentBlockAttr = "data-mce-block";
  const elementNames = (map) =>
    filter$5(keys(map), (key) => !/[A-Z]/.test(key));
  const makeSelectorFromSchemaMap = (map) =>
    map$3(elementNames(map), (name) => {
      const escapedName = CSS.escape(name);
      return (
        `${escapedName}:` +
        map$3(namespaceElements, (ns) => `not(${ns} ${escapedName})`).join(":")
      );
    }).join(",");
  const updateTransparent = (blocksSelector, transparent) => {
    if (isNonNullable(transparent.querySelector(blocksSelector))) {
      transparent.setAttribute(transparentBlockAttr, "true");
      if (transparent.getAttribute("data-mce-selected") === "inline-boundary") {
        transparent.removeAttribute("data-mce-selected");
      }
      return true;
    } else {
      transparent.removeAttribute(transparentBlockAttr);
      return false;
    }
  };
  const updateBlockStateOnChildren = (schema, scope) => {
    const transparentSelector = makeSelectorFromSchemaMap(
      schema.getTransparentElements()
    );
    const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
    return filter$5(
      scope.querySelectorAll(transparentSelector),
      (transparent) => updateTransparent(blocksSelector, transparent)
    );
  };
  const trimEdge = (schema, el, leftSide) => {
    var _a;
    const childPropertyName = leftSide ? "lastChild" : "firstChild";
    for (
      let child = el[childPropertyName];
      child;
      child = child[childPropertyName]
    ) {
      if (isEmptyNode(schema, child, { checkRootAsContent: true })) {
        (_a = child.parentNode) === null || _a === void 0
          ? void 0
          : _a.removeChild(child);
        return;
      }
    }
  };
  const split$2 = (schema, parentElm, splitElm) => {
    const range = document.createRange();
    const parentNode = parentElm.parentNode;
    if (parentNode) {
      range.setStartBefore(parentElm);
      range.setEndBefore(splitElm);
      const beforeFragment = range.extractContents();
      trimEdge(schema, beforeFragment, true);
      range.setStartAfter(splitElm);
      range.setEndAfter(parentElm);
      const afterFragment = range.extractContents();
      trimEdge(schema, afterFragment, false);
      if (!isEmptyNode(schema, beforeFragment, { checkRootAsContent: true })) {
        parentNode.insertBefore(beforeFragment, parentElm);
      }
      if (!isEmptyNode(schema, splitElm, { checkRootAsContent: true })) {
        parentNode.insertBefore(splitElm, parentElm);
      }
      if (!isEmptyNode(schema, afterFragment, { checkRootAsContent: true })) {
        parentNode.insertBefore(afterFragment, parentElm);
      }
      parentNode.removeChild(parentElm);
    }
  };
  const splitInvalidChildren = (schema, scope, transparentBlocks) => {
    const blocksElements = schema.getBlockElements();
    const rootNode = SugarElement.fromDom(scope);
    const isBlock = (el) => name(el) in blocksElements;
    const isRoot = (el) => eq(el, rootNode);
    each$e(fromDom$1(transparentBlocks), (transparentBlock) => {
      ancestor$4(transparentBlock, isBlock, isRoot).each((parentBlock) => {
        const invalidChildren = children(
          transparentBlock,
          (el) =>
            isBlock(el) && !schema.isValidChild(name(parentBlock), name(el))
        );
        if (invalidChildren.length > 0) {
          const stateScope = parentElement(parentBlock);
          each$e(invalidChildren, (child) => {
            ancestor$4(child, isBlock, isRoot).each((parentBlock) => {
              split$2(schema, parentBlock.dom, child.dom);
            });
          });
          stateScope.each((scope) =>
            updateBlockStateOnChildren(schema, scope.dom)
          );
        }
      });
    });
  };
  const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
    each$e(
      [
        ...transparentBlocks,
        ...(isTransparentBlock(schema, scope) ? [scope] : []),
      ],
      (block) =>
        each$e(
          descendants(
            SugarElement.fromDom(block),
            block.nodeName.toLowerCase()
          ),
          (elm) => {
            if (isTransparentInline(schema, elm.dom)) {
              unwrap(elm);
            }
          }
        )
    );
  };
  const updateChildren = (schema, scope) => {
    const transparentBlocks = updateBlockStateOnChildren(schema, scope);
    splitInvalidChildren(schema, scope, transparentBlocks);
    unwrapInvalidChildren(schema, scope, transparentBlocks);
  };
  const updateElement = (schema, target) => {
    if (isTransparentElement(schema, target)) {
      const blocksSelector = makeSelectorFromSchemaMap(
        schema.getBlockElements()
      );
      updateTransparent(blocksSelector, target);
    }
  };
  const updateCaret = (schema, root, caretParent) => {
    const isRoot = (el) => eq(el, SugarElement.fromDom(root));
    const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);
    get$b(parents, parents.length - 2)
      .filter(isElement$7)
      .fold(
        () => updateChildren(schema, root),
        (scope) => updateChildren(schema, scope.dom)
      );
  };
  const hasBlockAttr = (el) => el.hasAttribute(transparentBlockAttr);
  const isTransparentElementName = (schema, name) =>
    has$2(schema.getTransparentElements(), name);
  const isTransparentElement = (schema, node) =>
    isElement$6(node) && isTransparentElementName(schema, node.nodeName);
  const isTransparentBlock = (schema, node) =>
    isTransparentElement(schema, node) && hasBlockAttr(node);
  const isTransparentInline = (schema, node) =>
    isTransparentElement(schema, node) && !hasBlockAttr(node);
  const isTransparentAstBlock = (schema, node) =>
    node.type === 1 &&
    isTransparentElementName(schema, node.name) &&
    isString(node.attr(transparentBlockAttr));

  const browser$2 = detect$1().browser;
  const firstElement = (nodes) => find$2(nodes, isElement$7);
  const getTableCaptionDeltaY = (elm) => {
    if (browser$2.isFirefox() && name(elm) === "table") {
      return firstElement(children$1(elm))
        .filter((elm) => {
          return name(elm) === "caption";
        })
        .bind((caption) => {
          return firstElement(nextSiblings(caption)).map((body) => {
            const bodyTop = body.dom.offsetTop;
            const captionTop = caption.dom.offsetTop;
            const captionHeight = caption.dom.offsetHeight;
            return bodyTop <= captionTop ? -captionHeight : 0;
          });
        })
        .getOr(0);
    } else {
      return 0;
    }
  };
  const hasChild = (elm, child) =>
    elm.children && contains$2(elm.children, child);
  const getPos = (body, elm, rootElm) => {
    let x = 0,
      y = 0;
    const doc = body.ownerDocument;
    rootElm = rootElm ? rootElm : body;
    if (elm) {
      if (
        rootElm === body &&
        elm.getBoundingClientRect &&
        get$7(SugarElement.fromDom(body), "position") === "static"
      ) {
        const pos = elm.getBoundingClientRect();
        x =
          pos.left +
          (doc.documentElement.scrollLeft || body.scrollLeft) -
          doc.documentElement.clientLeft;
        y =
          pos.top +
          (doc.documentElement.scrollTop || body.scrollTop) -
          doc.documentElement.clientTop;
        return {
          x,
          y,
        };
      }
      let offsetParent = elm;
      while (
        offsetParent &&
        offsetParent !== rootElm &&
        offsetParent.nodeType &&
        !hasChild(offsetParent, rootElm)
      ) {
        const castOffsetParent = offsetParent;
        x += castOffsetParent.offsetLeft || 0;
        y += castOffsetParent.offsetTop || 0;
        offsetParent = castOffsetParent.offsetParent;
      }
      offsetParent = elm.parentNode;
      while (
        offsetParent &&
        offsetParent !== rootElm &&
        offsetParent.nodeType &&
        !hasChild(offsetParent, rootElm)
      ) {
        x -= offsetParent.scrollLeft || 0;
        y -= offsetParent.scrollTop || 0;
        offsetParent = offsetParent.parentNode;
      }
      y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
    }
    return {
      x,
      y,
    };
  };

  const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
    let idCount = 0;
    const loadedStates = {};
    const edos = SugarElement.fromDom(documentOrShadowRoot);
    const doc = documentOrOwner(edos);
    const _setReferrerPolicy = (referrerPolicy) => {
      settings.referrerPolicy = referrerPolicy;
    };
    const _setContentCssCors = (contentCssCors) => {
      settings.contentCssCors = contentCssCors;
    };
    const addStyle = (element) => {
      append$1(getStyleContainer(edos), element);
    };
    const removeStyle = (id) => {
      const styleContainer = getStyleContainer(edos);
      descendant$1(styleContainer, "#" + id).each(remove$4);
    };
    const getOrCreateState = (url) =>
      get$a(loadedStates, url).getOrThunk(() => ({
        id: "mce-u" + idCount++,
        passed: [],
        failed: [],
        count: 0,
      }));
    const load = (url) =>
      new Promise((success, failure) => {
        let link;
        const urlWithSuffix = Tools._addCacheSuffix(url);
        const state = getOrCreateState(urlWithSuffix);
        loadedStates[urlWithSuffix] = state;
        state.count++;
        const resolve = (callbacks, status) => {
          each$e(callbacks, call);
          state.status = status;
          state.passed = [];
          state.failed = [];
          if (link) {
            link.onload = null;
            link.onerror = null;
            link = null;
          }
        };
        const passed = () => resolve(state.passed, 2);
        const failed = () => resolve(state.failed, 3);
        if (success) {
          state.passed.push(success);
        }
        if (failure) {
          state.failed.push(failure);
        }
        if (state.status === 1) {
          return;
        }
        if (state.status === 2) {
          passed();
          return;
        }
        if (state.status === 3) {
          failed();
          return;
        }
        state.status = 1;
        const linkElem = SugarElement.fromTag("link", doc.dom);
        setAll$1(linkElem, {
          rel: "stylesheet",
          type: "text/css",
          id: state.id,
        });
        if (settings.contentCssCors) {
          set$4(linkElem, "crossOrigin", "anonymous");
        }
        if (settings.referrerPolicy) {
          set$4(linkElem, "referrerpolicy", settings.referrerPolicy);
        }
        link = linkElem.dom;
        link.onload = passed;
        link.onerror = failed;
        addStyle(linkElem);
        set$4(linkElem, "href", urlWithSuffix);
      });
    const loadRawCss = (key, css) => {
      const state = getOrCreateState(key);
      loadedStates[key] = state;
      state.count++;
      const styleElem = SugarElement.fromTag("style", doc.dom);
      setAll$1(styleElem, {
        rel: "stylesheet",
        type: "text/css",
        id: state.id,
        "data-mce-key": key,
      });
      styleElem.dom.innerHTML = css;
      addStyle(styleElem);
    };
    const loadAll = (urls) => {
      const loadedUrls = Promise.allSettled(
        map$3(urls, (url) => load(url).then(constant(url)))
      );
      return loadedUrls.then((results) => {
        const parts = partition$2(results, (r) => r.status === "fulfilled");
        if (parts.fail.length > 0) {
          return Promise.reject(map$3(parts.fail, (result) => result.reason));
        } else {
          return map$3(parts.pass, (result) => result.value);
        }
      });
    };
    const unload = (url) => {
      const urlWithSuffix = Tools._addCacheSuffix(url);
      get$a(loadedStates, urlWithSuffix).each((state) => {
        const count = --state.count;
        if (count === 0) {
          delete loadedStates[urlWithSuffix];
          removeStyle(state.id);
        }
      });
    };
    const unloadRawCss = (key) => {
      get$a(loadedStates, key).each((state) => {
        const count = --state.count;
        if (count === 0) {
          delete loadedStates[key];
          removeStyle(state.id);
        }
      });
    };
    const unloadAll = (urls) => {
      each$e(urls, (url) => {
        unload(url);
      });
    };
    return {
      load,
      loadRawCss,
      loadAll,
      unload,
      unloadRawCss,
      unloadAll,
      _setReferrerPolicy,
      _setContentCssCors,
    };
  };

  const create$c = () => {
    const map = new WeakMap();
    const forElement = (referenceElement, settings) => {
      const root = getRootNode(referenceElement);
      const rootDom = root.dom;
      return Optional.from(map.get(rootDom)).getOrThunk(() => {
        const sl = StyleSheetLoader(rootDom, settings);
        map.set(rootDom, sl);
        return sl;
      });
    };
    return { forElement };
  };
  const instance = create$c();

  const isSpan = (node) => node.nodeName.toLowerCase() === "span";
  const isInlineContent = (node, schema) =>
    isNonNullable(node) &&
    (isContent$1(schema, node) || schema.isInline(node.nodeName.toLowerCase()));
  const surroundedByInlineContent = (node, root, schema) => {
    const prev = new DomTreeWalker(node, root).prev(false);
    const next = new DomTreeWalker(node, root).next(false);
    const prevIsInline = isUndefined(prev) || isInlineContent(prev, schema);
    const nextIsInline = isUndefined(next) || isInlineContent(next, schema);
    return prevIsInline && nextIsInline;
  };
  const isBookmarkNode$2 = (node) =>
    isSpan(node) && node.getAttribute("data-mce-type") === "bookmark";
  const isKeepTextNode = (node, root, schema) =>
    isText$b(node) &&
    node.data.length > 0 &&
    surroundedByInlineContent(node, root, schema);
  const isKeepElement = (node) =>
    isElement$6(node) ? node.childNodes.length > 0 : false;
  const isDocument = (node) => isDocumentFragment(node) || isDocument$1(node);
  const trimNode = (dom, node, schema, root) => {
    var _a;
    const rootNode = root || node;
    if (isElement$6(node) && isBookmarkNode$2(node)) {
      return node;
    }
    const children = node.childNodes;
    for (let i = children.length - 1; i >= 0; i--) {
      trimNode(dom, children[i], schema, rootNode);
    }
    if (isElement$6(node)) {
      const currentChildren = node.childNodes;
      if (
        currentChildren.length === 1 &&
        isBookmarkNode$2(currentChildren[0])
      ) {
        (_a = node.parentNode) === null || _a === void 0
          ? void 0
          : _a.insertBefore(currentChildren[0], node);
      }
    }
    if (
      !isDocument(node) &&
      !isContent$1(schema, node) &&
      !isKeepElement(node) &&
      !isKeepTextNode(node, rootNode, schema)
    ) {
      dom.remove(node);
    }
    return node;
  };

  const makeMap$3 = Tools.makeMap;
  const attrsCharsRegExp =
    /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  const textCharsRegExp =
    /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  const rawCharsRegExp = /[<>&\"\']/g;
  const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
  const asciiMap = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02c6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017d",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017e",
    159: "\u0178",
  };
  const baseEntities = {
    '"': "&quot;",
    "'": "&#39;",
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    "`": "&#96;",
  };
  const reverseEntities = {
    "&lt;": "<",
    "&gt;": ">",
    "&amp;": "&",
    "&quot;": '"',
    "&apos;": `'`,
  };
  const nativeDecode = (text) => {
    const elm = SugarElement.fromTag("div").dom;
    elm.innerHTML = text;
    return elm.textContent || elm.innerText || text;
  };
  const buildEntitiesLookup = (items, radix) => {
    const lookup = {};
    if (items) {
      const itemList = items.split(",");
      radix = radix || 10;
      for (let i = 0; i < itemList.length; i += 2) {
        const chr = String.fromCharCode(parseInt(itemList[i], radix));
        if (!baseEntities[chr]) {
          const entity = "&" + itemList[i + 1] + ";";
          lookup[chr] = entity;
          lookup[entity] = chr;
        }
      }
      return lookup;
    } else {
      return undefined;
    }
  };
  const namedEntities = buildEntitiesLookup(
    "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy," +
      "5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute," +
      "5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34," +
      "5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil," +
      "68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde," +
      "6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute," +
      "6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml," +
      "75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc," +
      "7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash," +
      "7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta," +
      "sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu," +
      "st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi," +
      "t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota," +
      "tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau," +
      "u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip," +
      "81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym," +
      "8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr," +
      "8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod," +
      "8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup," +
      "8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4," +
      "nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob," +
      "rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0," +
      "Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm," +
      "80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger," +
      "811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
    32
  );
  const encodeRaw = (text, attr) =>
    text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
      return baseEntities[chr] || chr;
    });
  const encodeAllRaw = (text) =>
    ("" + text).replace(rawCharsRegExp, (chr) => {
      return baseEntities[chr] || chr;
    });
  const encodeNumeric = (text, attr) =>
    text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
      if (chr.length > 1) {
        return (
          "&#" +
          ((chr.charCodeAt(0) - 55296) * 1024 +
            (chr.charCodeAt(1) - 56320) +
            65536) +
          ";"
        );
      }
      return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
    });
  const encodeNamed = (text, attr, entities) => {
    const resolveEntities = entities || namedEntities;
    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
      return baseEntities[chr] || resolveEntities[chr] || chr;
    });
  };
  const getEncodeFunc = (name, entities) => {
    const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
    const encodeNamedAndNumeric = (text, attr) =>
      text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        if (baseEntities[chr] !== undefined) {
          return baseEntities[chr];
        }
        if (entitiesMap[chr] !== undefined) {
          return entitiesMap[chr];
        }
        if (chr.length > 1) {
          return (
            "&#" +
            ((chr.charCodeAt(0) - 55296) * 1024 +
              (chr.charCodeAt(1) - 56320) +
              65536) +
            ";"
          );
        }
        return "&#" + chr.charCodeAt(0) + ";";
      });
    const encodeCustomNamed = (text, attr) => {
      return encodeNamed(text, attr, entitiesMap);
    };
    const nameMap = makeMap$3(name.replace(/\+/g, ","));
    if (nameMap.named && nameMap.numeric) {
      return encodeNamedAndNumeric;
    }
    if (nameMap.named) {
      if (entities) {
        return encodeCustomNamed;
      }
      return encodeNamed;
    }
    if (nameMap.numeric) {
      return encodeNumeric;
    }
    return encodeRaw;
  };
  const decode = (text) =>
    text.replace(entityRegExp, (all, numeric) => {
      if (numeric) {
        if (numeric.charAt(0).toLowerCase() === "x") {
          numeric = parseInt(numeric.substr(1), 16);
        } else {
          numeric = parseInt(numeric, 10);
        }
        if (numeric > 65535) {
          numeric -= 65536;
          return String.fromCharCode(
            55296 + (numeric >> 10),
            56320 + (numeric & 1023)
          );
        }
        return asciiMap[numeric] || String.fromCharCode(numeric);
      }
      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
    });
  const Entities = {
    encodeRaw,
    encodeAllRaw,
    encodeNumeric,
    encodeNamed,
    getEncodeFunc,
    decode,
  };

  const split$1 = (items, delim) => {
    items = Tools.trim(items);
    return items ? items.split(delim || " ") : [];
  };
  const patternToRegExp = (str) =>
    new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
  const isRegExp$1 = (obj) =>
    isObject(obj) &&
    obj.source &&
    Object.prototype.toString.call(obj) === "[object RegExp]";
  const deepCloneElementRule = (obj) => {
    const helper = (value) => {
      if (isArray$1(value)) {
        return map$3(value, helper);
      } else if (isRegExp$1(value)) {
        return new RegExp(value.source, value.flags);
      } else if (isObject(value)) {
        return map$2(value, helper);
      } else {
        return value;
      }
    };
    return helper(obj);
  };

  const parseCustomElementsRules = (value) => {
    const customElementRegExp = /^(~)?(.+)$/;
    return bind$3(split$1(value, ","), (rule) => {
      const matches = customElementRegExp.exec(rule);
      if (matches) {
        const inline = matches[1] === "~";
        const cloneName = inline ? "span" : "div";
        const name = matches[2];
        return [
          {
            cloneName,
            name,
          },
        ];
      } else {
        return [];
      }
    });
  };

  const getGlobalAttributeSet = (type) => {
    return Object.freeze([
      "id",
      "accesskey",
      "class",
      "dir",
      "lang",
      "style",
      "tabindex",
      "title",
      "role",
      ...(type !== "html4"
        ? [
            "contenteditable",
            "contextmenu",
            "draggable",
            "dropzone",
            "hidden",
            "spellcheck",
            "translate",
            "itemprop",
            "itemscope",
            "itemtype",
          ]
        : []),
      ...(type !== "html5-strict" ? ["xml:lang"] : []),
    ]);
  };

  const getElementSetsAsStrings = (type) => {
    let blockContent;
    let phrasingContent;
    blockContent =
      "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
    phrasingContent =
      "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd " +
      "label map noscript object q s samp script select small span strong sub sup " +
      "textarea u var #text #comment";
    if (type !== "html4") {
      const transparentContent = "a ins del canvas map";
      blockContent +=
        " article aside details dialog figure main header footer hgroup section nav " +
        transparentContent;
      phrasingContent +=
        " audio canvas command data datalist mark meter output picture " +
        "progress time wbr video ruby bdi keygen svg";
    }
    if (type !== "html5-strict") {
      const html4PhrasingContent = "acronym applet basefont big font strike tt";
      phrasingContent = [phrasingContent, html4PhrasingContent].join(" ");
      const html4BlockContent = "center dir isindex noframes";
      blockContent = [blockContent, html4BlockContent].join(" ");
    }
    const flowContent = [blockContent, phrasingContent].join(" ");
    return {
      blockContent,
      phrasingContent,
      flowContent,
    };
  };
  const getElementSets = (type) => {
    const { blockContent, phrasingContent, flowContent } =
      getElementSetsAsStrings(type);
    const toArr = (value) => {
      return Object.freeze(value.split(" "));
    };
    return Object.freeze({
      blockContent: toArr(blockContent),
      phrasingContent: toArr(phrasingContent),
      flowContent: toArr(flowContent),
    });
  };

  const cachedSets = {
    html4: cached(() => getElementSets("html4")),
    html5: cached(() => getElementSets("html5")),
    "html5-strict": cached(() => getElementSets("html5-strict")),
  };
  const getElementsPreset = (type, name) => {
    const { blockContent, phrasingContent, flowContent } = cachedSets[type]();
    if (name === "blocks") {
      return Optional.some(blockContent);
    } else if (name === "phrasing") {
      return Optional.some(phrasingContent);
    } else if (name === "flow") {
      return Optional.some(flowContent);
    } else {
      return Optional.none();
    }
  };

  const makeSchema = (type) => {
    const globalAttributes = getGlobalAttributeSet(type);
    const { phrasingContent, flowContent } = getElementSetsAsStrings(type);
    const schema = {};
    const addElement = (name, attributes, children) => {
      schema[name] = {
        attributes: mapToObject(attributes, constant({})),
        attributesOrder: attributes,
        children: mapToObject(children, constant({})),
      };
    };
    const add = (name, attributes = "", children = "") => {
      const childNames = split$1(children);
      const names = split$1(name);
      let ni = names.length;
      const allAttributes = [...globalAttributes, ...split$1(attributes)];
      while (ni--) {
        addElement(names[ni], allAttributes.slice(), childNames);
      }
    };
    const addAttrs = (name, attributes) => {
      const names = split$1(name);
      const attrs = split$1(attributes);
      let ni = names.length;
      while (ni--) {
        const schemaItem = schema[names[ni]];
        for (let i = 0, l = attrs.length; i < l; i++) {
          schemaItem.attributes[attrs[i]] = {};
          schemaItem.attributesOrder.push(attrs[i]);
        }
      }
    };
    if (type !== "html5-strict") {
      const html4PhrasingContent = "acronym applet basefont big font strike tt";
      each$e(split$1(html4PhrasingContent), (name) => {
        add(name, "", phrasingContent);
      });
      const html4BlockContent = "center dir isindex noframes";
      each$e(split$1(html4BlockContent), (name) => {
        add(name, "", flowContent);
      });
    }
    add("html", "manifest", "head body");
    add("head", "", "base command link meta noscript script style title");
    add("title hr noscript br");
    add("base", "href target");
    add("link", "href rel media hreflang type sizes hreflang");
    add("meta", "name http-equiv content charset");
    add("style", "media type scoped");
    add("script", "src async defer type charset");
    add(
      "body",
      "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus " +
        "onhashchange onload onmessage onoffline ononline onpagehide onpageshow " +
        "onpopstate onresize onscroll onstorage onunload",
      flowContent
    );
    add("dd div", "", flowContent);
    add(
      "address dt caption",
      "",
      type === "html4" ? phrasingContent : flowContent
    );
    add(
      "h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn",
      "",
      phrasingContent
    );
    add("blockquote", "cite", flowContent);
    add("ol", "reversed start type", "li");
    add("ul", "", "li");
    add("li", "value", flowContent);
    add("dl", "", "dt dd");
    add(
      "a",
      "href target rel media hreflang type",
      type === "html4" ? phrasingContent : flowContent
    );
    add("q", "cite", phrasingContent);
    add("ins del", "cite datetime", flowContent);
    add("img", "src sizes srcset alt usemap ismap width height");
    add("iframe", "src name width height", flowContent);
    add("embed", "src type width height");
    add(
      "object",
      "data type typemustmatch name usemap form width height",
      [flowContent, "param"].join(" ")
    );
    add("param", "name value");
    add("map", "name", [flowContent, "area"].join(" "));
    add("area", "alt coords shape href target rel media hreflang type");
    add(
      "table",
      "border",
      "caption colgroup thead tfoot tbody tr" + (type === "html4" ? " col" : "")
    );
    add("colgroup", "span", "col");
    add("col", "span");
    add("tbody thead tfoot", "", "tr");
    add("tr", "", "td th");
    add("td", "colspan rowspan headers", flowContent);
    add("th", "colspan rowspan headers scope abbr", flowContent);
    add(
      "form",
      "accept-charset action autocomplete enctype method name novalidate target",
      flowContent
    );
    add("fieldset", "disabled form name", [flowContent, "legend"].join(" "));
    add("label", "form for", phrasingContent);
    add(
      "input",
      "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate " +
        "formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"
    );
    add(
      "button",
      "disabled form formaction formenctype formmethod formnovalidate formtarget name type value",
      type === "html4" ? flowContent : phrasingContent
    );
    add(
      "select",
      "disabled form multiple name required size",
      "option optgroup"
    );
    add("optgroup", "disabled label", "option");
    add("option", "disabled label selected value");
    add(
      "textarea",
      "cols dirname disabled form maxlength name readonly required rows wrap"
    );
    add("menu", "type label", [flowContent, "li"].join(" "));
    add("noscript", "", flowContent);
    if (type !== "html4") {
      add("wbr");
      add("ruby", "", [phrasingContent, "rt rp"].join(" "));
      add("figcaption", "", flowContent);
      add("mark rt rp bdi", "", phrasingContent);
      add("summary", "", [phrasingContent, "h1 h2 h3 h4 h5 h6"].join(" "));
      add("canvas", "width height", flowContent);
      add("data", "value", phrasingContent);
      add(
        "video",
        "src crossorigin poster preload autoplay mediagroup loop " +
          "muted controls width height buffered",
        [flowContent, "track source"].join(" ")
      );
      add(
        "audio",
        "src crossorigin preload autoplay mediagroup loop muted controls " +
          "buffered volume",
        [flowContent, "track source"].join(" ")
      );
      add("picture", "", "img source");
      add("source", "src srcset type media sizes");
      add("track", "kind src srclang label default");
      add("datalist", "", [phrasingContent, "option"].join(" "));
      add("article section nav aside main header footer", "", flowContent);
      add("hgroup", "", "h1 h2 h3 h4 h5 h6");
      add("figure", "", [flowContent, "figcaption"].join(" "));
      add("time", "datetime", phrasingContent);
      add("dialog", "open", flowContent);
      add("command", "type label icon disabled checked radiogroup command");
      add("output", "for form name", phrasingContent);
      add("progress", "value max", phrasingContent);
      add("meter", "value min max low high optimum", phrasingContent);
      add("details", "open", [flowContent, "summary"].join(" "));
      add("keygen", "autofocus challenge disabled form keytype name");
      addElement(
        "svg",
        "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(
          " "
        ),
        []
      );
    }
    if (type !== "html5-strict") {
      addAttrs("script", "language xml:space");
      addAttrs("style", "xml:space");
      addAttrs(
        "object",
        "declare classid code codebase codetype archive standby align border hspace vspace"
      );
      addAttrs("embed", "align name hspace vspace");
      addAttrs("param", "valuetype type");
      addAttrs("a", "charset name rev shape coords");
      addAttrs("br", "clear");
      addAttrs(
        "applet",
        "codebase archive code object alt name width height align hspace vspace"
      );
      addAttrs("img", "name longdesc align border hspace vspace");
      addAttrs(
        "iframe",
        "longdesc frameborder marginwidth marginheight scrolling align"
      );
      addAttrs("font basefont", "size color face");
      addAttrs("input", "usemap align");
      addAttrs("select");
      addAttrs("textarea");
      addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
      addAttrs("ul", "type compact");
      addAttrs("li", "type");
      addAttrs("ol dl menu dir", "compact");
      addAttrs("pre", "width xml:space");
      addAttrs("hr", "align noshade size width");
      addAttrs("isindex", "prompt");
      addAttrs(
        "table",
        "summary width frame rules cellspacing cellpadding align bgcolor"
      );
      addAttrs("col", "width align char charoff valign");
      addAttrs("colgroup", "width align char charoff valign");
      addAttrs("thead", "align char charoff valign");
      addAttrs("tr", "align char charoff valign bgcolor");
      addAttrs(
        "th",
        "axis align char charoff valign nowrap bgcolor width height"
      );
      addAttrs("form", "accept");
      addAttrs(
        "td",
        "abbr axis scope align char charoff valign nowrap bgcolor width height"
      );
      addAttrs("tfoot", "align char charoff valign");
      addAttrs("tbody", "align char charoff valign");
      addAttrs("area", "nohref");
      addAttrs("body", "background bgcolor text link vlink alink");
    }
    if (type !== "html4") {
      addAttrs("input button select textarea", "autofocus");
      addAttrs("input textarea", "placeholder");
      addAttrs("a", "download");
      addAttrs("link script img", "crossorigin");
      addAttrs("img", "loading");
      addAttrs(
        "iframe",
        "sandbox seamless allow allowfullscreen loading referrerpolicy"
      );
    }
    if (type !== "html4") {
      each$e([schema.video, schema.audio], (item) => {
        delete item.children.audio;
        delete item.children.video;
      });
    }
    each$e(split$1("a form meter progress dfn"), (name) => {
      if (schema[name]) {
        delete schema[name].children[name];
      }
    });
    delete schema.caption.children.table;
    delete schema.script;
    return schema;
  };

  const prefixToOperation = (prefix) => (prefix === "-" ? "remove" : "add");
  const parseValidChild = (name) => {
    const validChildRegExp =
      /^(@?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)$/;
    return Optional.from(validChildRegExp.exec(name)).map((matches) => ({
      preset: matches[1] === "@",
      name: matches[2],
    }));
  };
  const parseValidChildrenRules = (value) => {
    const childRuleRegExp =
      /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
    return bind$3(split$1(value, ","), (rule) => {
      const matches = childRuleRegExp.exec(rule);
      if (matches) {
        const prefix = matches[1];
        const operation = prefix ? prefixToOperation(prefix) : "replace";
        const name = matches[2];
        const validChildren = bind$3(split$1(matches[3], "|"), (validChild) =>
          parseValidChild(validChild).toArray()
        );
        return [
          {
            operation,
            name,
            validChildren,
          },
        ];
      } else {
        return [];
      }
    });
  };

  const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {
    const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
    const hasPatternsRegExp = /[*?+]/;
    const { attributes, attributesOrder } = targetElement;
    return each$e(split$1(attrData, "|"), (rule) => {
      const matches = attrRuleRegExp.exec(rule);
      if (matches) {
        const attr = {};
        const attrType = matches[1];
        const attrName = matches[2].replace(/[\\:]:/g, ":");
        const attrPrefix = matches[3];
        const value = matches[4];
        if (attrType === "!") {
          targetElement.attributesRequired =
            targetElement.attributesRequired || [];
          targetElement.attributesRequired.push(attrName);
          attr.required = true;
        }
        if (attrType === "-") {
          delete attributes[attrName];
          attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);
          return;
        }
        if (attrPrefix) {
          if (attrPrefix === "=") {
            targetElement.attributesDefault =
              targetElement.attributesDefault || [];
            targetElement.attributesDefault.push({
              name: attrName,
              value,
            });
            attr.defaultValue = value;
          } else if (attrPrefix === "~") {
            targetElement.attributesForced =
              targetElement.attributesForced || [];
            targetElement.attributesForced.push({
              name: attrName,
              value,
            });
            attr.forcedValue = value;
          } else if (attrPrefix === "<") {
            attr.validValues = Tools.makeMap(value, "?");
          }
        }
        if (hasPatternsRegExp.test(attrName)) {
          const attrPattern = attr;
          targetElement.attributePatterns =
            targetElement.attributePatterns || [];
          attrPattern.pattern = patternToRegExp(attrName);
          targetElement.attributePatterns.push(attrPattern);
        } else {
          if (!attributes[attrName]) {
            attributesOrder.push(attrName);
          }
          attributes[attrName] = attr;
        }
      }
    });
  };
  const cloneAttributesInto = (from, to) => {
    each$d(from.attributes, (value, key) => {
      to.attributes[key] = value;
    });
    to.attributesOrder.push(...from.attributesOrder);
  };
  const parseValidElementsRules = (globalElement, validElements) => {
    const elementRuleRegExp =
      /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
    return bind$3(split$1(validElements, ","), (rule) => {
      const matches = elementRuleRegExp.exec(rule);
      if (matches) {
        const prefix = matches[1];
        const elementName = matches[2];
        const outputName = matches[3];
        const attrsPrefix = matches[4];
        const attrData = matches[5];
        const element = {
          attributes: {},
          attributesOrder: [],
        };
        globalElement.each((el) => cloneAttributesInto(el, element));
        if (prefix === "#") {
          element.paddEmpty = true;
        } else if (prefix === "-") {
          element.removeEmpty = true;
        }
        if (attrsPrefix === "!") {
          element.removeEmptyAttrs = true;
        }
        if (attrData) {
          parseValidElementsAttrDataIntoElement(attrData, element);
        }
        if (outputName) {
          element.outputName = elementName;
        }
        if (elementName === "@") {
          if (globalElement.isNone()) {
            globalElement = Optional.some(element);
          } else {
            return [];
          }
        }
        return [
          outputName
            ? {
                name: elementName,
                element,
                aliasName: outputName,
              }
            : {
                name: elementName,
                element,
              },
        ];
      } else {
        return [];
      }
    });
  };

  const mapCache = {};
  const makeMap$2 = Tools.makeMap,
    each$b = Tools.each,
    extend$2 = Tools.extend,
    explode$2 = Tools.explode;
  const createMap = (defaultValue, extendWith = {}) => {
    const value = makeMap$2(
      defaultValue,
      " ",
      makeMap$2(defaultValue.toUpperCase(), " ")
    );
    return extend$2(value, extendWith);
  };
  const getTextRootBlockElements = (schema) =>
    createMap(
      "td th li dt dd figcaption caption details summary",
      schema.getTextBlockElements()
    );
  const compileElementMap = (value, mode) => {
    if (value) {
      const styles = {};
      if (isString(value)) {
        value = { "*": value };
      }
      each$b(value, (value, key) => {
        styles[key] = styles[key.toUpperCase()] =
          mode === "map" ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);
      });
      return styles;
    } else {
      return undefined;
    }
  };
  const Schema = (settings = {}) => {
    var _a;
    const elements = {};
    const children = {};
    let patternElements = [];
    const customElementsMap = {};
    const specialElements = {};
    const createLookupTable = (option, defaultValue, extendWith) => {
      const value = settings[option];
      if (!value) {
        let newValue = mapCache[option];
        if (!newValue) {
          newValue = createMap(defaultValue, extendWith);
          mapCache[option] = newValue;
        }
        return newValue;
      } else {
        return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
      }
    };
    const schemaType =
      (_a = settings.schema) !== null && _a !== void 0 ? _a : "html5";
    const schemaItems = makeSchema(schemaType);
    if (settings.verify_html === false) {
      settings.valid_elements = "*[*]";
    }
    const validStyles = compileElementMap(settings.valid_styles);
    const invalidStyles = compileElementMap(settings.invalid_styles, "map");
    const validClasses = compileElementMap(settings.valid_classes, "map");
    const whitespaceElementsMap = createLookupTable(
      "whitespace_elements",
      "pre script noscript style textarea video audio iframe object code"
    );
    const selfClosingElementsMap = createLookupTable(
      "self_closing_elements",
      "colgroup dd dt li option p td tfoot th thead tr"
    );
    const voidElementsMap = createLookupTable(
      "void_elements",
      "area base basefont br col frame hr img input isindex link " +
        "meta param embed source wbr track"
    );
    const boolAttrMap = createLookupTable(
      "boolean_attributes",
      "checked compact declare defer disabled ismap multiple nohref noresize " +
        "noshade nowrap readonly selected autoplay loop controls allowfullscreen"
    );
    const nonEmptyOrMoveCaretBeforeOnEnter =
      "td th iframe video audio object script code";
    const nonEmptyElementsMap = createLookupTable(
      "non_empty_elements",
      nonEmptyOrMoveCaretBeforeOnEnter + " pre svg textarea summary",
      voidElementsMap
    );
    const moveCaretBeforeOnEnterElementsMap = createLookupTable(
      "move_caret_before_on_enter_elements",
      nonEmptyOrMoveCaretBeforeOnEnter + " table",
      voidElementsMap
    );
    const headings = "h1 h2 h3 h4 h5 h6";
    const textBlockElementsMap = createLookupTable(
      "text_block_elements",
      headings +
        " p div address pre form " +
        "blockquote center dir fieldset header footer article section hgroup aside main nav figure"
    );
    const blockElementsMap = createLookupTable(
      "block_elements",
      "hr table tbody thead tfoot " +
        "th tr td li ol ul caption dl dt dd noscript menu isindex option " +
        "datalist select optgroup figcaption details summary html body multicol listing",
      textBlockElementsMap
    );
    const textInlineElementsMap = createLookupTable(
      "text_inline_elements",
      "span strong b em i font s strike u var cite " +
        "dfn code mark q sup sub samp"
    );
    const transparentElementsMap = createLookupTable(
      "transparent_elements",
      "a ins del canvas map"
    );
    const wrapBlockElementsMap = createLookupTable(
      "wrap_block_elements",
      "pre " + headings
    );
    each$b(
      "script noscript iframe noframes noembed title style textarea xmp plaintext".split(
        " "
      ),
      (name) => {
        specialElements[name] = new RegExp("</" + name + "[^>]*>", "gi");
      }
    );
    const addValidElements = (validElements) => {
      const globalElement = Optional.from(elements["@"]);
      const hasPatternsRegExp = /[*?+]/;
      each$e(
        parseValidElementsRules(
          globalElement,
          validElements !== null && validElements !== void 0
            ? validElements
            : ""
        ),
        ({ name, element, aliasName }) => {
          if (aliasName) {
            elements[aliasName] = element;
          }
          if (hasPatternsRegExp.test(name)) {
            const patternElement = element;
            patternElement.pattern = patternToRegExp(name);
            patternElements.push(patternElement);
          } else {
            elements[name] = element;
          }
        }
      );
    };
    const setValidElements = (validElements) => {
      patternElements = [];
      each$e(keys(elements), (name) => {
        delete elements[name];
      });
      addValidElements(validElements);
    };
    const addCustomElement = (name, spec) => {
      var _a, _b;
      delete mapCache.text_block_elements;
      delete mapCache.block_elements;
      const inline = spec.extends ? !isBlock(spec.extends) : false;
      const cloneName = spec.extends;
      children[name] = cloneName ? children[cloneName] : {};
      customElementsMap[name] =
        cloneName !== null && cloneName !== void 0 ? cloneName : name;
      nonEmptyElementsMap[name.toUpperCase()] = {};
      nonEmptyElementsMap[name] = {};
      if (!inline) {
        blockElementsMap[name.toUpperCase()] = {};
        blockElementsMap[name] = {};
      }
      if (cloneName && !elements[name] && elements[cloneName]) {
        const customRule = deepCloneElementRule(elements[cloneName]);
        delete customRule.removeEmptyAttrs;
        delete customRule.removeEmpty;
        elements[name] = customRule;
      } else {
        elements[name] = {
          attributesOrder: [],
          attributes: {},
        };
      }
      if (isArray$1(spec.attributes)) {
        const processAttrName = (name) => {
          customRule.attributesOrder.push(name);
          customRule.attributes[name] = {};
        };
        const customRule =
          (_a = elements[name]) !== null && _a !== void 0 ? _a : {};
        delete customRule.attributesDefault;
        delete customRule.attributesForced;
        delete customRule.attributePatterns;
        delete customRule.attributesRequired;
        customRule.attributesOrder = [];
        customRule.attributes = {};
        each$e(spec.attributes, (attrName) => {
          const globalAttrs = getGlobalAttributeSet(schemaType);
          parseValidChild(attrName).each(({ preset, name }) => {
            if (preset) {
              if (name === "global") {
                each$e(globalAttrs, processAttrName);
              }
            } else {
              processAttrName(name);
            }
          });
        });
        elements[name] = customRule;
      }
      if (isBoolean(spec.padEmpty)) {
        const customRule =
          (_b = elements[name]) !== null && _b !== void 0 ? _b : {};
        customRule.paddEmpty = spec.padEmpty;
        elements[name] = customRule;
      }
      if (isArray$1(spec.children)) {
        const customElementChildren = {};
        const processNodeName = (name) => {
          customElementChildren[name] = {};
        };
        const processPreset = (name) => {
          getElementsPreset(schemaType, name).each((names) => {
            each$e(names, processNodeName);
          });
        };
        each$e(spec.children, (child) => {
          parseValidChild(child).each(({ preset, name }) => {
            if (preset) {
              processPreset(name);
            } else {
              processNodeName(name);
            }
          });
        });
        children[name] = customElementChildren;
      }
      if (cloneName) {
        each$d(children, (element, elmName) => {
          if (element[cloneName]) {
            children[elmName] = element = extend$2({}, children[elmName]);
            element[name] = element[cloneName];
          }
        });
      }
    };
    const addCustomElementsFromString = (customElements) => {
      each$e(
        parseCustomElementsRules(
          customElements !== null && customElements !== void 0
            ? customElements
            : ""
        ),
        ({ name, cloneName }) => {
          addCustomElement(name, { extends: cloneName });
        }
      );
    };
    const addCustomElements = (customElements) => {
      if (isObject(customElements)) {
        each$d(customElements, (spec, name) => addCustomElement(name, spec));
      } else if (isString(customElements)) {
        addCustomElementsFromString(customElements);
      }
    };
    const addValidChildren = (validChildren) => {
      each$e(
        parseValidChildrenRules(
          validChildren !== null && validChildren !== void 0
            ? validChildren
            : ""
        ),
        ({ operation, name, validChildren }) => {
          const parent =
            operation === "replace" ? { "#comment": {} } : children[name];
          const processNodeName = (name) => {
            if (operation === "remove") {
              delete parent[name];
            } else {
              parent[name] = {};
            }
          };
          const processPreset = (name) => {
            getElementsPreset(schemaType, name).each((names) => {
              each$e(names, processNodeName);
            });
          };
          each$e(validChildren, ({ preset, name }) => {
            if (preset) {
              processPreset(name);
            } else {
              processNodeName(name);
            }
          });
          children[name] = parent;
        }
      );
    };
    const getElementRule = (name) => {
      const element = elements[name];
      if (element) {
        return element;
      }
      let i = patternElements.length;
      while (i--) {
        const patternElement = patternElements[i];
        if (patternElement.pattern.test(name)) {
          return patternElement;
        }
      }
      return undefined;
    };
    const setup = () => {
      if (!settings.valid_elements) {
        each$b(schemaItems, (element, name) => {
          elements[name] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder,
          };
          children[name] = element.children;
        });
        each$b(split$1("strong/b em/i"), (item) => {
          const items = split$1(item, "/");
          elements[items[1]].outputName = items[0];
        });
        each$b(textInlineElementsMap, (_val, name) => {
          if (elements[name]) {
            if (settings.padd_empty_block_inline_children) {
              elements[name].paddInEmptyBlock = true;
            }
            elements[name].removeEmpty = true;
          }
        });
        each$b(split$1("ol ul blockquote a table tbody"), (name) => {
          if (elements[name]) {
            elements[name].removeEmpty = true;
          }
        });
        each$b(
          split$1(
            "p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"
          ),
          (name) => {
            if (elements[name]) {
              elements[name].paddEmpty = true;
            }
          }
        );
        each$b(split$1("span"), (name) => {
          elements[name].removeEmptyAttrs = true;
        });
      } else {
        setValidElements(settings.valid_elements);
        each$b(schemaItems, (element, name) => {
          children[name] = element.children;
        });
      }
      delete elements.svg;
      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);
      addValidChildren("+ol[ul|ol],+ul[ul|ol]");
      each$b(
        {
          dd: "dl",
          dt: "dl",
          li: "ul ol",
          td: "tr",
          th: "tr",
          tr: "tbody thead tfoot",
          tbody: "table",
          thead: "table",
          tfoot: "table",
          legend: "fieldset",
          area: "map",
          param: "video audio object",
        },
        (parents, item) => {
          if (elements[item]) {
            elements[item].parentsRequired = split$1(parents);
          }
        }
      );
      if (settings.invalid_elements) {
        each$b(explode$2(settings.invalid_elements), (item) => {
          if (elements[item]) {
            delete elements[item];
          }
        });
      }
      if (!getElementRule("span")) {
        addValidElements("span[!data-mce-type|*]");
      }
    };
    const getValidStyles = constant(validStyles);
    const getInvalidStyles = constant(invalidStyles);
    const getValidClasses = constant(validClasses);
    const getBoolAttrs = constant(boolAttrMap);
    const getBlockElements = constant(blockElementsMap);
    const getTextBlockElements = constant(textBlockElementsMap);
    const getTextInlineElements = constant(textInlineElementsMap);
    const getVoidElements = constant(Object.seal(voidElementsMap));
    const getSelfClosingElements = constant(selfClosingElementsMap);
    const getNonEmptyElements = constant(nonEmptyElementsMap);
    const getMoveCaretBeforeOnEnterElements = constant(
      moveCaretBeforeOnEnterElementsMap
    );
    const getWhitespaceElements = constant(whitespaceElementsMap);
    const getTransparentElements = constant(transparentElementsMap);
    const getWrapBlockElements = constant(wrapBlockElementsMap);
    const getSpecialElements = constant(Object.seal(specialElements));
    const isValidChild = (name, child) => {
      const parent = children[name.toLowerCase()];
      return !!(parent && parent[child.toLowerCase()]);
    };
    const isValid = (name, attr) => {
      const rule = getElementRule(name);
      if (rule) {
        if (attr) {
          if (rule.attributes[attr]) {
            return true;
          }
          const attrPatterns = rule.attributePatterns;
          if (attrPatterns) {
            let i = attrPatterns.length;
            while (i--) {
              if (attrPatterns[i].pattern.test(attr)) {
                return true;
              }
            }
          }
        } else {
          return true;
        }
      }
      return false;
    };
    const isBlock = (name) => has$2(getBlockElements(), name);
    const isInline = (name) =>
      !startsWith(name, "#") && isValid(name) && !isBlock(name);
    const isWrapper = (name) =>
      has$2(getWrapBlockElements(), name) || isInline(name);
    const getCustomElements = constant(customElementsMap);
    setup();
    return {
      type: schemaType,
      children,
      elements,
      getValidStyles,
      getValidClasses,
      getBlockElements,
      getInvalidStyles,
      getVoidElements,
      getTextBlockElements,
      getTextInlineElements,
      getBoolAttrs,
      getElementRule,
      getSelfClosingElements,
      getNonEmptyElements,
      getMoveCaretBeforeOnEnterElements,
      getWhitespaceElements,
      getTransparentElements,
      getSpecialElements,
      isValidChild,
      isValid,
      isBlock,
      isInline,
      isWrapper,
      getCustomElements,
      addValidElements,
      setValidElements,
      addCustomElements,
      addValidChildren,
    };
  };

  const hexColour = (value) => ({ value: normalizeHex(value) });
  const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
  const toHex = (component) => {
    const hex = component.toString(16);
    return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
  };
  const fromRgba = (rgbaColour) => {
    const value =
      toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
    return hexColour(value);
  };

  const rgbRegex =
    /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i;
  const rgbaRegex =
    /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i;
  const rgbaColour = (red, green, blue, alpha) => ({
    red,
    green,
    blue,
    alpha,
  });
  const fromStringValues = (red, green, blue, alpha) => {
    const r = parseInt(red, 10);
    const g = parseInt(green, 10);
    const b = parseInt(blue, 10);
    const a = parseFloat(alpha);
    return rgbaColour(r, g, b, a);
  };
  const getColorFormat = (colorString) => {
    if (rgbRegex.test(colorString)) {
      return "rgb";
    } else if (rgbaRegex.test(colorString)) {
      return "rgba";
    }
    return "other";
  };
  const fromString = (rgbaString) => {
    const rgbMatch = rgbRegex.exec(rgbaString);
    if (rgbMatch !== null) {
      return Optional.some(
        fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1")
      );
    }
    const rgbaMatch = rgbaRegex.exec(rgbaString);
    if (rgbaMatch !== null) {
      return Optional.some(
        fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4])
      );
    }
    return Optional.none();
  };
  const toString = (rgba) =>
    `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;

  const rgbaToHexString = (color) =>
    fromString(color)
      .map(fromRgba)
      .map((h) => "#" + h.value)
      .getOr(color);

  const Styles = (settings = {}, schema) => {
    const urlOrStrRegExp =
      /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
    const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
    const trimRightRegExp = /\s+$/;
    const encodingLookup = {};
    let validStyles;
    let invalidStyles;
    const invisibleChar = zeroWidth;
    if (schema) {
      validStyles = schema.getValidStyles();
      invalidStyles = schema.getInvalidStyles();
    }
    const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
    for (let i = 0; i < encodingItems.length; i++) {
      encodingLookup[encodingItems[i]] = invisibleChar + i;
      encodingLookup[invisibleChar + i] = encodingItems[i];
    }
    const self = {
      parse: (css) => {
        const styles = {};
        let isEncoded = false;
        const urlConverter = settings.url_converter;
        const urlConverterScope = settings.url_converter_scope || self;
        const compress = (prefix, suffix, noJoin) => {
          const top = styles[prefix + "-top" + suffix];
          if (!top) {
            return;
          }
          const right = styles[prefix + "-right" + suffix];
          if (!right) {
            return;
          }
          const bottom = styles[prefix + "-bottom" + suffix];
          if (!bottom) {
            return;
          }
          const left = styles[prefix + "-left" + suffix];
          if (!left) {
            return;
          }
          const box = [top, right, bottom, left];
          let i = box.length - 1;
          while (i--) {
            if (box[i] !== box[i + 1]) {
              break;
            }
          }
          if (i > -1 && noJoin) {
            return;
          }
          styles[prefix + suffix] = i === -1 ? box[0] : box.join(" ");
          delete styles[prefix + "-top" + suffix];
          delete styles[prefix + "-right" + suffix];
          delete styles[prefix + "-bottom" + suffix];
          delete styles[prefix + "-left" + suffix];
        };
        const canCompress = (key) => {
          const value = styles[key];
          if (!value) {
            return;
          }
          const values = value.indexOf(",") > -1 ? [value] : value.split(" ");
          let i = values.length;
          while (i--) {
            if (values[i] !== values[0]) {
              return false;
            }
          }
          styles[key] = values[0];
          return true;
        };
        const compress2 = (target, a, b, c) => {
          if (!canCompress(a)) {
            return;
          }
          if (!canCompress(b)) {
            return;
          }
          if (!canCompress(c)) {
            return;
          }
          styles[target] = styles[a] + " " + styles[b] + " " + styles[c];
          delete styles[a];
          delete styles[b];
          delete styles[c];
        };
        const encode = (str) => {
          isEncoded = true;
          return encodingLookup[str];
        };
        const decode = (str, keepSlashes) => {
          if (isEncoded) {
            str = str.replace(/\uFEFF[0-9]/g, (str) => {
              return encodingLookup[str];
            });
          }
          if (!keepSlashes) {
            str = str.replace(/\\([\'\";:])/g, "$1");
          }
          return str;
        };
        const decodeSingleHexSequence = (escSeq) => {
          return String.fromCharCode(parseInt(escSeq.slice(1), 16));
        };
        const decodeHexSequences = (value) => {
          return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
        };
        const processUrl = (match, url, url2, url3, str, str2) => {
          str = str || str2;
          if (str) {
            str = decode(str);
            return `'` + str.replace(/\'/g, `\\'`) + `'`;
          }
          url = decode(url || url2 || url3 || "");
          if (!settings.allow_script_urls) {
            const scriptUrl = url.replace(/[\s\r\n]+/g, "");
            if (/(java|vb)script:/i.test(scriptUrl)) {
              return "";
            }
            if (
              !settings.allow_svg_data_urls &&
              /^data:image\/svg/i.test(scriptUrl)
            ) {
              return "";
            }
          }
          if (urlConverter) {
            url = urlConverter.call(urlConverterScope, url, "style");
          }
          return `url('` + url.replace(/\'/g, `\\'`) + `')`;
        };
        if (css) {
          css = css.replace(/[\u0000-\u001F]/g, "");
          css = css
            .replace(/\\[\"\';:\uFEFF]/g, encode)
            .replace(/\"[^\"]+\"|\'[^\']+\'/g, (str) => {
              return str.replace(/[;:]/g, encode);
            });
          let matches;
          while ((matches = styleRegExp.exec(css))) {
            styleRegExp.lastIndex = matches.index + matches[0].length;
            let name = matches[1].replace(trimRightRegExp, "").toLowerCase();
            let value = matches[2].replace(trimRightRegExp, "");
            if (name && value) {
              name = decodeHexSequences(name);
              value = decodeHexSequences(value);
              if (
                name.indexOf(invisibleChar) !== -1 ||
                name.indexOf('"') !== -1
              ) {
                continue;
              }
              if (
                !settings.allow_script_urls &&
                (name === "behavior" || /expression\s*\(|\/\*|\*\//.test(value))
              ) {
                continue;
              }
              if (name === "font-weight" && value === "700") {
                value = "bold";
              } else if (name === "color" || name === "background-color") {
                value = value.toLowerCase();
              }
              if (getColorFormat(value) === "rgb") {
                fromString(value).each((rgba) => {
                  value = rgbaToHexString(toString(rgba)).toLowerCase();
                });
              }
              value = value.replace(urlOrStrRegExp, processUrl);
              styles[name] = isEncoded ? decode(value, true) : value;
            }
          }
          compress("border", "", true);
          compress("border", "-width");
          compress("border", "-color");
          compress("border", "-style");
          compress("padding", "");
          compress("margin", "");
          compress2("border", "border-width", "border-style", "border-color");
          if (styles.border === "medium none") {
            delete styles.border;
          }
          if (styles["border-image"] === "none") {
            delete styles["border-image"];
          }
        }
        return styles;
      },
      serialize: (styles, elementName) => {
        let css = "";
        const serializeStyles = (elemName, validStyleList) => {
          const styleList = validStyleList[elemName];
          if (styleList) {
            for (let i = 0, l = styleList.length; i < l; i++) {
              const name = styleList[i];
              const value = styles[name];
              if (value) {
                css += (css.length > 0 ? " " : "") + name + ": " + value + ";";
              }
            }
          }
        };
        const isValid = (name, elemName) => {
          if (!invalidStyles || !elemName) {
            return true;
          }
          let styleMap = invalidStyles["*"];
          if (styleMap && styleMap[name]) {
            return false;
          }
          styleMap = invalidStyles[elemName];
          return !(styleMap && styleMap[name]);
        };
        if (elementName && validStyles) {
          serializeStyles("*", validStyles);
          serializeStyles(elementName, validStyles);
        } else {
          each$d(styles, (value, name) => {
            if (value && isValid(name, elementName)) {
              css += (css.length > 0 ? " " : "") + name + ": " + value + ";";
            }
          });
        }
        return css;
      },
    };
    return self;
  };

  const deprecated = {
    keyLocation: true,
    layerX: true,
    layerY: true,
    returnValue: true,
    webkitMovementX: true,
    webkitMovementY: true,
    keyIdentifier: true,
    mozPressure: true,
  };
  const isNativeEvent = (event) =>
    event instanceof Event || isFunction(event.initEvent);
  const hasIsDefaultPrevented = (event) =>
    event.isDefaultPrevented === always || event.isDefaultPrevented === never;
  const needsNormalizing = (event) =>
    isNullable(event.preventDefault) || isNativeEvent(event);
  const clone$3 = (originalEvent, data) => {
    const event = data !== null && data !== void 0 ? data : {};
    for (const name in originalEvent) {
      if (!has$2(deprecated, name)) {
        event[name] = originalEvent[name];
      }
    }
    if (isNonNullable(originalEvent.composedPath)) {
      event.composedPath = () => originalEvent.composedPath();
    }
    if (isNonNullable(originalEvent.getModifierState)) {
      event.getModifierState = (keyArg) =>
        originalEvent.getModifierState(keyArg);
    }
    if (isNonNullable(originalEvent.getTargetRanges)) {
      event.getTargetRanges = () => originalEvent.getTargetRanges();
    }
    return event;
  };
  const normalize$3 = (type, originalEvent, fallbackTarget, data) => {
    var _a;
    const event = clone$3(originalEvent, data);
    event.type = type;
    if (isNullable(event.target)) {
      event.target =
        (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
    }
    if (needsNormalizing(originalEvent)) {
      event.preventDefault = () => {
        event.defaultPrevented = true;
        event.isDefaultPrevented = always;
        if (isFunction(originalEvent.preventDefault)) {
          originalEvent.preventDefault();
        }
      };
      event.stopPropagation = () => {
        event.cancelBubble = true;
        event.isPropagationStopped = always;
        if (isFunction(originalEvent.stopPropagation)) {
          originalEvent.stopPropagation();
        }
      };
      event.stopImmediatePropagation = () => {
        event.isImmediatePropagationStopped = always;
        event.stopPropagation();
      };
      if (!hasIsDefaultPrevented(event)) {
        event.isDefaultPrevented =
          event.defaultPrevented === true ? always : never;
        event.isPropagationStopped =
          event.cancelBubble === true ? always : never;
        event.isImmediatePropagationStopped = never;
      }
    }
    return event;
  };

  const eventExpandoPrefix = "mce-data-";
  const mouseEventRe = /^(?:mouse|contextmenu)|click/;
  const addEvent = (target, name, callback, capture) => {
    target.addEventListener(name, callback, capture || false);
  };
  const removeEvent = (target, name, callback, capture) => {
    target.removeEventListener(name, callback, capture || false);
  };
  const isMouseEvent = (event) =>
    isNonNullable(event) && mouseEventRe.test(event.type);
  const fix = (originalEvent, data) => {
    const event = normalize$3(
      originalEvent.type,
      originalEvent,
      document,
      data
    );
    if (
      isMouseEvent(originalEvent) &&
      isUndefined(originalEvent.pageX) &&
      !isUndefined(originalEvent.clientX)
    ) {
      const eventDoc = event.target.ownerDocument || document;
      const doc = eventDoc.documentElement;
      const body = eventDoc.body;
      const mouseEvent = event;
      mouseEvent.pageX =
        originalEvent.clientX +
        ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
        ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
      mouseEvent.pageY =
        originalEvent.clientY +
        ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) -
        ((doc && doc.clientTop) || (body && body.clientTop) || 0);
    }
    return event;
  };
  const bindOnReady = (win, callback, eventUtils) => {
    const doc = win.document,
      event = { type: "ready" };
    if (eventUtils.domLoaded) {
      callback(event);
      return;
    }
    const isDocReady = () => {
      return (
        doc.readyState === "complete" ||
        (doc.readyState === "interactive" && doc.body)
      );
    };
    const readyHandler = () => {
      removeEvent(win, "DOMContentLoaded", readyHandler);
      removeEvent(win, "load", readyHandler);
      if (!eventUtils.domLoaded) {
        eventUtils.domLoaded = true;
        callback(event);
      }
      win = null;
    };
    if (isDocReady()) {
      readyHandler();
    } else {
      addEvent(win, "DOMContentLoaded", readyHandler);
    }
    if (!eventUtils.domLoaded) {
      addEvent(win, "load", readyHandler);
    }
  };
  class EventUtils {
    constructor() {
      this.domLoaded = false;
      this.events = {};
      this.count = 1;
      this.expando = eventExpandoPrefix + (+new Date()).toString(32);
      this.hasFocusIn = "onfocusin" in document.documentElement;
      this.count = 1;
    }
    bind(target, names, callback, scope) {
      const self = this;
      let callbackList;
      const win = window;
      const defaultNativeHandler = (evt) => {
        self.executeHandlers(fix(evt || win.event), id);
      };
      if (!target || isText$b(target) || isComment(target)) {
        return callback;
      }
      let id;
      if (!target[self.expando]) {
        id = self.count++;
        target[self.expando] = id;
        self.events[id] = {};
      } else {
        id = target[self.expando];
      }
      scope = scope || target;
      const namesList = names.split(" ");
      let i = namesList.length;
      while (i--) {
        let name = namesList[i];
        let nativeHandler = defaultNativeHandler;
        let capture = false;
        let fakeName = false;
        if (name === "DOMContentLoaded") {
          name = "ready";
        }
        if (
          self.domLoaded &&
          name === "ready" &&
          target.readyState === "complete"
        ) {
          callback.call(scope, fix({ type: name }));
          continue;
        }
        if (!self.hasFocusIn && (name === "focusin" || name === "focusout")) {
          capture = true;
          fakeName = name === "focusin" ? "focus" : "blur";
          nativeHandler = (evt) => {
            const event = fix(evt || win.event);
            event.type = event.type === "focus" ? "focusin" : "focusout";
            self.executeHandlers(event, id);
          };
        }
        callbackList = self.events[id][name];
        if (!callbackList) {
          self.events[id][name] = callbackList = [
            {
              func: callback,
              scope,
            },
          ];
          callbackList.fakeName = fakeName;
          callbackList.capture = capture;
          callbackList.nativeHandler = nativeHandler;
          if (name === "ready") {
            bindOnReady(target, nativeHandler, self);
          } else {
            addEvent(target, fakeName || name, nativeHandler, capture);
          }
        } else {
          if (name === "ready" && self.domLoaded) {
            callback(fix({ type: name }));
          } else {
            callbackList.push({
              func: callback,
              scope,
            });
          }
        }
      }
      target = callbackList = null;
      return callback;
    }
    unbind(target, names, callback) {
      if (!target || isText$b(target) || isComment(target)) {
        return this;
      }
      const id = target[this.expando];
      if (id) {
        let eventMap = this.events[id];
        if (names) {
          const namesList = names.split(" ");
          let i = namesList.length;
          while (i--) {
            const name = namesList[i];
            const callbackList = eventMap[name];
            if (callbackList) {
              if (callback) {
                let ci = callbackList.length;
                while (ci--) {
                  if (callbackList[ci].func === callback) {
                    const nativeHandler = callbackList.nativeHandler;
                    const fakeName = callbackList.fakeName,
                      capture = callbackList.capture;
                    const newCallbackList = callbackList
                      .slice(0, ci)
                      .concat(callbackList.slice(ci + 1));
                    newCallbackList.nativeHandler = nativeHandler;
                    newCallbackList.fakeName = fakeName;
                    newCallbackList.capture = capture;
                    eventMap[name] = newCallbackList;
                  }
                }
              }
              if (!callback || callbackList.length === 0) {
                delete eventMap[name];
                removeEvent(
                  target,
                  callbackList.fakeName || name,
                  callbackList.nativeHandler,
                  callbackList.capture
                );
              }
            }
          }
        } else {
          each$d(eventMap, (callbackList, name) => {
            removeEvent(
              target,
              callbackList.fakeName || name,
              callbackList.nativeHandler,
              callbackList.capture
            );
          });
          eventMap = {};
        }
        for (const name in eventMap) {
          if (has$2(eventMap, name)) {
            return this;
          }
        }
        delete this.events[id];
        try {
          delete target[this.expando];
        } catch (_a) {
          target[this.expando] = null;
        }
      }
      return this;
    }
    fire(target, name, args) {
      return this.dispatch(target, name, args);
    }
    dispatch(target, name, args) {
      if (!target || isText$b(target) || isComment(target)) {
        return this;
      }
      const event = fix(
        {
          type: name,
          target,
        },
        args
      );
      do {
        const id = target[this.expando];
        if (id) {
          this.executeHandlers(event, id);
        }
        target =
          target.parentNode ||
          target.ownerDocument ||
          target.defaultView ||
          target.parentWindow;
      } while (target && !event.isPropagationStopped());
      return this;
    }
    clean(target) {
      if (!target || isText$b(target) || isComment(target)) {
        return this;
      }
      if (target[this.expando]) {
        this.unbind(target);
      }
      if (!target.getElementsByTagName) {
        target = target.document;
      }
      if (target && target.getElementsByTagName) {
        this.unbind(target);
        const children = target.getElementsByTagName("*");
        let i = children.length;
        while (i--) {
          target = children[i];
          if (target[this.expando]) {
            this.unbind(target);
          }
        }
      }
      return this;
    }
    destroy() {
      this.events = {};
    }
    cancel(e) {
      if (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      return false;
    }
    executeHandlers(evt, id) {
      const container = this.events[id];
      const callbackList = container && container[evt.type];
      if (callbackList) {
        for (let i = 0, l = callbackList.length; i < l; i++) {
          const callback = callbackList[i];
          if (callback && callback.func.call(callback.scope, evt) === false) {
            evt.preventDefault();
          }
          if (evt.isImmediatePropagationStopped()) {
            return;
          }
        }
      }
    }
  }
  EventUtils.Event = new EventUtils();

  const each$a = Tools.each;
  const grep = Tools.grep;
  const internalStyleName = "data-mce-style";
  const numericalCssMap = Tools.makeMap(
    "fill-opacity font-weight line-height opacity orphans widows z-index zoom",
    " "
  );
  const legacySetAttribute = (elm, name, value) => {
    if (isNullable(value) || value === "") {
      remove$9(elm, name);
    } else {
      set$4(elm, name, value);
    }
  };
  const camelCaseToHyphens = (name) =>
    name.replace(/[A-Z]/g, (v) => "-" + v.toLowerCase());
  const findNodeIndex = (node, normalized) => {
    let idx = 0;
    if (node) {
      for (
        let lastNodeType = node.nodeType, tempNode = node.previousSibling;
        tempNode;
        tempNode = tempNode.previousSibling
      ) {
        const nodeType = tempNode.nodeType;
        if (normalized && isText$b(tempNode)) {
          if (nodeType === lastNodeType || !tempNode.data.length) {
            continue;
          }
        }
        idx++;
        lastNodeType = nodeType;
      }
    }
    return idx;
  };
  const updateInternalStyleAttr = (styles, elm) => {
    const rawValue = get$9(elm, "style");
    const value = styles.serialize(styles.parse(rawValue), name(elm));
    legacySetAttribute(elm, internalStyleName, value);
  };
  const convertStyleToString = (cssValue, cssName) => {
    if (isNumber(cssValue)) {
      return has$2(numericalCssMap, cssName) ? cssValue + "" : cssValue + "px";
    } else {
      return cssValue;
    }
  };
  const applyStyle$1 = ($elm, cssName, cssValue) => {
    const normalizedName = camelCaseToHyphens(cssName);
    if (isNullable(cssValue) || cssValue === "") {
      remove$5($elm, normalizedName);
    } else {
      set$2(
        $elm,
        normalizedName,
        convertStyleToString(cssValue, normalizedName)
      );
    }
  };
  const setupAttrHooks = (styles, settings, getContext) => {
    const keepValues = settings.keep_values;
    const keepUrlHook = {
      set: (elm, value, name) => {
        const sugarElm = SugarElement.fromDom(elm);
        if (isFunction(settings.url_converter) && isNonNullable(value)) {
          value = settings.url_converter.call(
            settings.url_converter_scope || getContext(),
            String(value),
            name,
            elm
          );
        }
        const internalName = "data-mce-" + name;
        legacySetAttribute(sugarElm, internalName, value);
        legacySetAttribute(sugarElm, name, value);
      },
      get: (elm, name) => {
        const sugarElm = SugarElement.fromDom(elm);
        return get$9(sugarElm, "data-mce-" + name) || get$9(sugarElm, name);
      },
    };
    const attrHooks = {
      style: {
        set: (elm, value) => {
          const sugarElm = SugarElement.fromDom(elm);
          if (keepValues) {
            legacySetAttribute(sugarElm, internalStyleName, value);
          }
          remove$9(sugarElm, "style");
          if (isString(value)) {
            setAll(sugarElm, styles.parse(value));
          }
        },
        get: (elm) => {
          const sugarElm = SugarElement.fromDom(elm);
          const value =
            get$9(sugarElm, internalStyleName) || get$9(sugarElm, "style");
          return styles.serialize(styles.parse(value), name(sugarElm));
        },
      },
    };
    if (keepValues) {
      attrHooks.href = attrHooks.src = keepUrlHook;
    }
    return attrHooks;
  };
  const DOMUtils = (doc, settings = {}) => {
    const addedStyles = {};
    const win = window;
    const files = {};
    let counter = 0;
    const stdMode = true;
    const boxModel = true;
    const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
      contentCssCors: settings.contentCssCors,
      referrerPolicy: settings.referrerPolicy,
    });
    const boundEvents = [];
    const schema = settings.schema ? settings.schema : Schema({});
    const styles = Styles(
      {
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope,
      },
      settings.schema
    );
    const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
    const blockElementsMap = schema.getBlockElements();
    const isBlock = (node) => {
      if (isString(node)) {
        return has$2(blockElementsMap, node);
      } else {
        return (
          isElement$6(node) &&
          (has$2(blockElementsMap, node.nodeName) ||
            isTransparentBlock(schema, node))
        );
      }
    };
    const get = (elm) =>
      elm && doc && isString(elm) ? doc.getElementById(elm) : elm;
    const _get = (elm) => {
      const value = get(elm);
      return isNonNullable(value) ? SugarElement.fromDom(value) : null;
    };
    const getAttrib = (elm, name, defaultVal = "") => {
      let value;
      const $elm = _get(elm);
      if (isNonNullable($elm) && isElement$7($elm)) {
        const hook = attrHooks[name];
        if (hook && hook.get) {
          value = hook.get($elm.dom, name);
        } else {
          value = get$9($elm, name);
        }
      }
      return isNonNullable(value) ? value : defaultVal;
    };
    const getAttribs = (elm) => {
      const node = get(elm);
      return isNullable(node) ? [] : node.attributes;
    };
    const setAttrib = (elm, name, value) => {
      run(elm, (e) => {
        if (isElement$6(e)) {
          const $elm = SugarElement.fromDom(e);
          const val = value === "" ? null : value;
          const originalValue = get$9($elm, name);
          const hook = attrHooks[name];
          if (hook && hook.set) {
            hook.set($elm.dom, val, name);
          } else {
            legacySetAttribute($elm, name, val);
          }
          if (originalValue !== val && settings.onSetAttrib) {
            settings.onSetAttrib({
              attrElm: $elm.dom,
              attrName: name,
              attrValue: val,
            });
          }
        }
      });
    };
    const clone = (node, deep) => {
      return node.cloneNode(deep);
    };
    const getRoot = () => settings.root_element || doc.body;
    const getViewPort = (argWin) => {
      const vp = getBounds(argWin);
      return {
        x: vp.x,
        y: vp.y,
        w: vp.width,
        h: vp.height,
      };
    };
    const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);
    const setStyle = (elm, name, value) => {
      run(elm, (e) => {
        const $elm = SugarElement.fromDom(e);
        applyStyle$1($elm, name, value);
        if (settings.update_styles) {
          updateInternalStyleAttr(styles, $elm);
        }
      });
    };
    const setStyles = (elm, stylesArg) => {
      run(elm, (e) => {
        const $elm = SugarElement.fromDom(e);
        each$d(stylesArg, (v, n) => {
          applyStyle$1($elm, n, v);
        });
        if (settings.update_styles) {
          updateInternalStyleAttr(styles, $elm);
        }
      });
    };
    const getStyle = (elm, name, computed) => {
      const $elm = get(elm);
      if (isNullable($elm) || (!isHTMLElement($elm) && !isSVGElement($elm))) {
        return undefined;
      }
      if (computed) {
        return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));
      } else {
        name = name.replace(/-(\D)/g, (a, b) => b.toUpperCase());
        if (name === "float") {
          name = "cssFloat";
        }
        return $elm.style ? $elm.style[name] : undefined;
      }
    };
    const getSize = (elm) => {
      const $elm = get(elm);
      if (!$elm) {
        return {
          w: 0,
          h: 0,
        };
      }
      let w = getStyle($elm, "width");
      let h = getStyle($elm, "height");
      if (!w || w.indexOf("px") === -1) {
        w = "0";
      }
      if (!h || h.indexOf("px") === -1) {
        h = "0";
      }
      return {
        w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
        h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight,
      };
    };
    const getRect = (elm) => {
      const $elm = get(elm);
      const pos = getPos$1($elm);
      const size = getSize($elm);
      return {
        x: pos.x,
        y: pos.y,
        w: size.w,
        h: size.h,
      };
    };
    const is = (elm, selector) => {
      if (!elm) {
        return false;
      }
      const elms = isArray$1(elm) ? elm : [elm];
      return exists(elms, (e) => {
        return is$1(SugarElement.fromDom(e), selector);
      });
    };
    const getParents = (elm, selector, root, collect) => {
      const result = [];
      let node = get(elm);
      collect = collect === undefined;
      const resolvedRoot =
        root || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
      if (isString(selector)) {
        if (selector === "*") {
          selector = isElement$6;
        } else {
          const selectorVal = selector;
          selector = (node) => is(node, selectorVal);
        }
      }
      while (node) {
        if (
          node === resolvedRoot ||
          isNullable(node.nodeType) ||
          isDocument$1(node) ||
          isDocumentFragment(node)
        ) {
          break;
        }
        if (!selector || selector(node)) {
          if (collect) {
            result.push(node);
          } else {
            return [node];
          }
        }
        node = node.parentNode;
      }
      return collect ? result : null;
    };
    const getParent = (node, selector, root) => {
      const parents = getParents(node, selector, root, false);
      return parents && parents.length > 0 ? parents[0] : null;
    };
    const _findSib = (node, selector, name) => {
      let func = selector;
      if (node) {
        if (isString(selector)) {
          func = (node) => {
            return is(node, selector);
          };
        }
        for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {
          if (isFunction(func) && func(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const getNext = (node, selector) => _findSib(node, selector, "nextSibling");
    const getPrev = (node, selector) =>
      _findSib(node, selector, "previousSibling");
    const isParentNode = (node) => isFunction(node.querySelectorAll);
    const select = (selector, scope) => {
      var _a, _b;
      const elm =
        (_b =
          (_a = get(scope)) !== null && _a !== void 0
            ? _a
            : settings.root_element) !== null && _b !== void 0
          ? _b
          : doc;
      return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
    };
    const run = function (elm, func, scope) {
      const context = scope !== null && scope !== void 0 ? scope : this;
      if (isArray$1(elm)) {
        const result = [];
        each$a(elm, (e, i) => {
          const node = get(e);
          if (node) {
            result.push(func.call(context, node, i));
          }
        });
        return result;
      } else {
        const node = get(elm);
        return !node ? false : func.call(context, node);
      }
    };
    const setAttribs = (elm, attrs) => {
      run(elm, ($elm) => {
        each$d(attrs, (value, name) => {
          setAttrib($elm, name, value);
        });
      });
    };
    const setHTML = (elm, html) => {
      run(elm, (e) => {
        const $elm = SugarElement.fromDom(e);
        set$1($elm, html);
      });
    };
    const add = (parentElm, name, attrs, html, create) =>
      run(parentElm, (parentElm) => {
        const newElm = isString(name) ? doc.createElement(name) : name;
        if (isNonNullable(attrs)) {
          setAttribs(newElm, attrs);
        }
        if (html) {
          if (!isString(html) && html.nodeType) {
            newElm.appendChild(html);
          } else if (isString(html)) {
            setHTML(newElm, html);
          }
        }
        return !create ? parentElm.appendChild(newElm) : newElm;
      });
    const create = (name, attrs, html) =>
      add(doc.createElement(name), name, attrs, html, true);
    const decode = Entities.decode;
    const encode = Entities.encodeAllRaw;
    const createHTML = (name, attrs, html = "") => {
      let outHtml = "<" + name;
      for (const key in attrs) {
        if (hasNonNullableKey(attrs, key)) {
          outHtml += " " + key + '="' + encode(attrs[key]) + '"';
        }
      }
      if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {
        return outHtml + " />";
      } else {
        return outHtml + ">" + html + "</" + name + ">";
      }
    };
    const createFragment = (html) => {
      const container = doc.createElement("div");
      const frag = doc.createDocumentFragment();
      frag.appendChild(container);
      if (html) {
        container.innerHTML = html;
      }
      let node;
      while ((node = container.firstChild)) {
        frag.appendChild(node);
      }
      frag.removeChild(container);
      return frag;
    };
    const remove = (node, keepChildren) => {
      return run(node, (n) => {
        const $node = SugarElement.fromDom(n);
        if (keepChildren) {
          each$e(children$1($node), (child) => {
            if (isText$c(child) && child.dom.length === 0) {
              remove$4(child);
            } else {
              before$3($node, child);
            }
          });
        }
        remove$4($node);
        return $node.dom;
      });
    };
    const removeAllAttribs = (e) =>
      run(e, (e) => {
        const attrs = e.attributes;
        for (let i = attrs.length - 1; i >= 0; i--) {
          e.removeAttributeNode(attrs.item(i));
        }
      });
    const parseStyle = (cssText) => styles.parse(cssText);
    const serializeStyle = (stylesArg, name) =>
      styles.serialize(stylesArg, name);
    const addStyle = (cssText) => {
      if (self !== DOMUtils.DOM && doc === document) {
        if (addedStyles[cssText]) {
          return;
        }
        addedStyles[cssText] = true;
      }
      let styleElm = doc.getElementById("mceDefaultStyles");
      if (!styleElm) {
        styleElm = doc.createElement("style");
        styleElm.id = "mceDefaultStyles";
        styleElm.type = "text/css";
        const head = doc.head;
        if (head.firstChild) {
          head.insertBefore(styleElm, head.firstChild);
        } else {
          head.appendChild(styleElm);
        }
      }
      if (styleElm.styleSheet) {
        styleElm.styleSheet.cssText += cssText;
      } else {
        styleElm.appendChild(doc.createTextNode(cssText));
      }
    };
    const loadCSS = (urls) => {
      if (!urls) {
        urls = "";
      }
      each$e(urls.split(","), (url) => {
        files[url] = true;
        styleSheetLoader.load(url).catch(noop);
      });
    };
    const toggleClass = (elm, cls, state) => {
      run(elm, (e) => {
        if (isElement$6(e)) {
          const $elm = SugarElement.fromDom(e);
          const classes = cls.split(" ");
          each$e(classes, (c) => {
            if (isNonNullable(state)) {
              const fn = state ? add$2 : remove$6;
              fn($elm, c);
            } else {
              toggle$1($elm, c);
            }
          });
        }
      });
    };
    const addClass = (elm, cls) => {
      toggleClass(elm, cls, true);
    };
    const removeClass = (elm, cls) => {
      toggleClass(elm, cls, false);
    };
    const hasClass = (elm, cls) => {
      const $elm = _get(elm);
      const classes = cls.split(" ");
      return isNonNullable($elm) && forall(classes, (c) => has($elm, c));
    };
    const show = (elm) => {
      run(elm, (e) => remove$5(SugarElement.fromDom(e), "display"));
    };
    const hide = (elm) => {
      run(elm, (e) => set$2(SugarElement.fromDom(e), "display", "none"));
    };
    const isHidden = (elm) => {
      const $elm = _get(elm);
      return isNonNullable($elm) && is$2(getRaw($elm, "display"), "none");
    };
    const uniqueId = (prefix) => (!prefix ? "mce_" : prefix) + counter++;
    const getOuterHTML = (elm) => {
      const $elm = _get(elm);
      if (isNonNullable($elm)) {
        return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
      } else {
        return "";
      }
    };
    const setOuterHTML = (elm, html) => {
      run(elm, ($elm) => {
        if (isElement$6($elm)) {
          $elm.outerHTML = html;
        }
      });
    };
    const insertAfter = (node, reference) => {
      const referenceNode = get(reference);
      return run(node, (node) => {
        const parent =
          referenceNode === null || referenceNode === void 0
            ? void 0
            : referenceNode.parentNode;
        const nextSibling =
          referenceNode === null || referenceNode === void 0
            ? void 0
            : referenceNode.nextSibling;
        if (parent) {
          if (nextSibling) {
            parent.insertBefore(node, nextSibling);
          } else {
            parent.appendChild(node);
          }
        }
        return node;
      });
    };
    const replace = (newElm, oldElm, keepChildren) =>
      run(oldElm, (elm) => {
        var _a;
        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
        if (keepChildren) {
          each$a(grep(elm.childNodes), (node) => {
            replacee.appendChild(node);
          });
        }
        (_a = elm.parentNode) === null || _a === void 0
          ? void 0
          : _a.replaceChild(replacee, elm);
        return elm;
      });
    const rename = (elm, name) => {
      if (elm.nodeName !== name.toUpperCase()) {
        const newElm = create(name);
        each$a(getAttribs(elm), (attrNode) => {
          setAttrib(
            newElm,
            attrNode.nodeName,
            getAttrib(elm, attrNode.nodeName)
          );
        });
        replace(newElm, elm, true);
        return newElm;
      } else {
        return elm;
      }
    };
    const findCommonAncestor = (a, b) => {
      let ps = a;
      while (ps) {
        let pe = b;
        while (pe && ps !== pe) {
          pe = pe.parentNode;
        }
        if (ps === pe) {
          break;
        }
        ps = ps.parentNode;
      }
      if (!ps && a.ownerDocument) {
        return a.ownerDocument.documentElement;
      } else {
        return ps;
      }
    };
    const isEmpty = (node, elements, options) => {
      if (isPlainObject(elements)) {
        const isContent = (node) => {
          const name = node.nodeName.toLowerCase();
          return Boolean(elements[name]);
        };
        return isEmptyNode(schema, node, {
          ...options,
          isContent,
        });
      } else {
        return isEmptyNode(schema, node, options);
      }
    };
    const createRng = () => doc.createRange();
    const split = (parentElm, splitElm, replacementElm) => {
      let range = createRng();
      let beforeFragment;
      let afterFragment;
      if (
        parentElm &&
        splitElm &&
        parentElm.parentNode &&
        splitElm.parentNode
      ) {
        const parentNode = parentElm.parentNode;
        range.setStart(parentNode, findNodeIndex(parentElm));
        range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
        beforeFragment = range.extractContents();
        range = createRng();
        range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
        range.setEnd(parentNode, findNodeIndex(parentElm) + 1);
        afterFragment = range.extractContents();
        parentNode.insertBefore(
          trimNode(self, beforeFragment, schema),
          parentElm
        );
        if (replacementElm) {
          parentNode.insertBefore(replacementElm, parentElm);
        } else {
          parentNode.insertBefore(splitElm, parentElm);
        }
        parentNode.insertBefore(
          trimNode(self, afterFragment, schema),
          parentElm
        );
        remove(parentElm);
        return replacementElm || splitElm;
      } else {
        return undefined;
      }
    };
    const bind = (target, name, func, scope) => {
      if (isArray$1(target)) {
        let i = target.length;
        const rv = [];
        while (i--) {
          rv[i] = bind(target[i], name, func, scope);
        }
        return rv;
      } else {
        if (settings.collect && (target === doc || target === win)) {
          boundEvents.push([target, name, func, scope]);
        }
        return events.bind(target, name, func, scope || self);
      }
    };
    const unbind = (target, name, func) => {
      if (isArray$1(target)) {
        let i = target.length;
        const rv = [];
        while (i--) {
          rv[i] = unbind(target[i], name, func);
        }
        return rv;
      } else {
        if (boundEvents.length > 0 && (target === doc || target === win)) {
          let i = boundEvents.length;
          while (i--) {
            const [boundTarget, boundName, boundFunc] = boundEvents[i];
            if (
              target === boundTarget &&
              (!name || name === boundName) &&
              (!func || func === boundFunc)
            ) {
              events.unbind(boundTarget, boundName, boundFunc);
            }
          }
        }
        return events.unbind(target, name, func);
      }
    };
    const dispatch = (target, name, evt) => events.dispatch(target, name, evt);
    const fire = (target, name, evt) => events.dispatch(target, name, evt);
    const getContentEditable = (node) => {
      if (node && isHTMLElement(node)) {
        const contentEditable = node.getAttribute("data-mce-contenteditable");
        if (contentEditable && contentEditable !== "inherit") {
          return contentEditable;
        }
        return node.contentEditable !== "inherit" ? node.contentEditable : null;
      } else {
        return null;
      }
    };
    const getContentEditableParent = (node) => {
      const root = getRoot();
      let state = null;
      for (
        let tempNode = node;
        tempNode && tempNode !== root;
        tempNode = tempNode.parentNode
      ) {
        state = getContentEditable(tempNode);
        if (state !== null) {
          break;
        }
      }
      return state;
    };
    const isEditable = (node) => {
      if (isNonNullable(node)) {
        const scope = isElement$6(node) ? node : node.parentElement;
        return (
          isNonNullable(scope) &&
          isHTMLElement(scope) &&
          isEditable$2(SugarElement.fromDom(scope))
        );
      } else {
        return false;
      }
    };
    const destroy = () => {
      if (boundEvents.length > 0) {
        let i = boundEvents.length;
        while (i--) {
          const [boundTarget, boundName, boundFunc] = boundEvents[i];
          events.unbind(boundTarget, boundName, boundFunc);
        }
      }
      each$d(files, (_, url) => {
        styleSheetLoader.unload(url);
        delete files[url];
      });
    };
    const isChildOf = (node, parent) => {
      return node === parent || parent.contains(node);
    };
    const dumpRng = (r) =>
      "startContainer: " +
      r.startContainer.nodeName +
      ", startOffset: " +
      r.startOffset +
      ", endContainer: " +
      r.endContainer.nodeName +
      ", endOffset: " +
      r.endOffset;
    const self = {
      doc,
      settings,
      win,
      files,
      stdMode,
      boxModel,
      styleSheetLoader,
      boundEvents,
      styles,
      schema,
      events,
      isBlock: isBlock,
      root: null,
      clone,
      getRoot,
      getViewPort,
      getRect,
      getSize,
      getParent,
      getParents: getParents,
      get,
      getNext,
      getPrev,
      select,
      is,
      add,
      create,
      createHTML,
      createFragment,
      remove,
      setStyle,
      getStyle: getStyle,
      setStyles,
      removeAllAttribs,
      setAttrib,
      setAttribs,
      getAttrib,
      getPos: getPos$1,
      parseStyle,
      serializeStyle,
      addStyle,
      loadCSS,
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      show,
      hide,
      isHidden,
      uniqueId,
      setHTML,
      getOuterHTML,
      setOuterHTML,
      decode,
      encode,
      insertAfter,
      replace,
      rename,
      findCommonAncestor,
      run,
      getAttribs,
      isEmpty,
      createRng,
      nodeIndex: findNodeIndex,
      split,
      bind: bind,
      unbind: unbind,
      fire,
      dispatch,
      getContentEditable,
      getContentEditableParent,
      isEditable,
      destroy,
      isChildOf,
      dumpRng,
    };
    const attrHooks = setupAttrHooks(styles, settings, constant(self));
    return self;
  };
  DOMUtils.DOM = DOMUtils(document);
  DOMUtils.nodeIndex = findNodeIndex;

  const DOM$b = DOMUtils.DOM;
  const QUEUED = 0;
  const LOADING = 1;
  const LOADED = 2;
  const FAILED = 3;
  class ScriptLoader {
    constructor(settings = {}) {
      this.states = {};
      this.queue = [];
      this.scriptLoadedCallbacks = {};
      this.queueLoadedCallbacks = [];
      this.loading = false;
      this.settings = settings;
    }
    _setReferrerPolicy(referrerPolicy) {
      this.settings.referrerPolicy = referrerPolicy;
    }
    loadScript(url) {
      return new Promise((resolve, reject) => {
        const dom = DOM$b;
        let elm;
        const cleanup = () => {
          dom.remove(id);
          if (elm) {
            elm.onerror = elm.onload = elm = null;
          }
        };
        const done = () => {
          cleanup();
          resolve();
        };
        const error = () => {
          cleanup();
          reject("Failed to load script: " + url);
        };
        const id = dom.uniqueId();
        elm = document.createElement("script");
        elm.id = id;
        elm.type = "text/javascript";
        elm.src = Tools._addCacheSuffix(url);
        if (this.settings.referrerPolicy) {
          dom.setAttrib(elm, "referrerpolicy", this.settings.referrerPolicy);
        }
        elm.onload = done;
        elm.onerror = error;
        (document.getElementsByTagName("head")[0] || document.body).appendChild(
          elm
        );
      });
    }
    isDone(url) {
      return this.states[url] === LOADED;
    }
    markDone(url) {
      this.states[url] = LOADED;
    }
    add(url) {
      const self = this;
      self.queue.push(url);
      const state = self.states[url];
      if (state === undefined) {
        self.states[url] = QUEUED;
      }
      return new Promise((resolve, reject) => {
        if (!self.scriptLoadedCallbacks[url]) {
          self.scriptLoadedCallbacks[url] = [];
        }
        self.scriptLoadedCallbacks[url].push({
          resolve,
          reject,
        });
      });
    }
    load(url) {
      return this.add(url);
    }
    remove(url) {
      delete this.states[url];
      delete this.scriptLoadedCallbacks[url];
    }
    loadQueue() {
      const queue = this.queue;
      this.queue = [];
      return this.loadScripts(queue);
    }
    loadScripts(scripts) {
      const self = this;
      const execCallbacks = (name, url) => {
        get$a(self.scriptLoadedCallbacks, url).each((callbacks) => {
          each$e(callbacks, (callback) => callback[name](url));
        });
        delete self.scriptLoadedCallbacks[url];
      };
      const processResults = (results) => {
        const failures = filter$5(
          results,
          (result) => result.status === "rejected"
        );
        if (failures.length > 0) {
          return Promise.reject(
            bind$3(failures, ({ reason }) =>
              isArray$1(reason) ? reason : [reason]
            )
          );
        } else {
          return Promise.resolve();
        }
      };
      const load = (urls) =>
        Promise.allSettled(
          map$3(urls, (url) => {
            if (self.states[url] === LOADED) {
              execCallbacks("resolve", url);
              return Promise.resolve();
            } else if (self.states[url] === FAILED) {
              execCallbacks("reject", url);
              return Promise.reject(url);
            } else {
              self.states[url] = LOADING;
              return self.loadScript(url).then(
                () => {
                  self.states[url] = LOADED;
                  execCallbacks("resolve", url);
                  const queue = self.queue;
                  if (queue.length > 0) {
                    self.queue = [];
                    return load(queue).then(processResults);
                  } else {
                    return Promise.resolve();
                  }
                },
                () => {
                  self.states[url] = FAILED;
                  execCallbacks("reject", url);
                  return Promise.reject(url);
                }
              );
            }
          })
        );
      const processQueue = (urls) => {
        self.loading = true;
        return load(urls).then((results) => {
          self.loading = false;
          const nextQueuedItem = self.queueLoadedCallbacks.shift();
          Optional.from(nextQueuedItem).each(call);
          return processResults(results);
        });
      };
      const uniqueScripts = stringArray(scripts);
      if (self.loading) {
        return new Promise((resolve, reject) => {
          self.queueLoadedCallbacks.push(() => {
            processQueue(uniqueScripts).then(resolve, reject);
          });
        });
      } else {
        return processQueue(uniqueScripts);
      }
    }
  }
  ScriptLoader.ScriptLoader = new ScriptLoader();

  const isDuplicated = (items, item) => {
    const firstIndex = items.indexOf(item);
    return (
      firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex
    );
  };
  const isRaw = (str) => isObject(str) && has$2(str, "raw");
  const isTokenised = (str) => isArray$1(str) && str.length > 1;
  const data = {};
  const currentCode = Cell("en");
  const getLanguageData = () => get$a(data, currentCode.get());
  const getData$1 = () => map$2(data, (value) => ({ ...value }));
  const setCode = (newCode) => {
    if (newCode) {
      currentCode.set(newCode);
    }
  };
  const getCode = () => currentCode.get();
  const add$1 = (code, items) => {
    let langData = data[code];
    if (!langData) {
      data[code] = langData = {};
    }
    const lcNames = map$3(keys(items), (name) => name.toLowerCase());
    each$d(items, (translation, name) => {
      const lcName = name.toLowerCase();
      if (lcName !== name && isDuplicated(lcNames, lcName)) {
        if (!has$2(items, lcName)) {
          langData[lcName] = translation;
        }
        langData[name] = translation;
      } else {
        langData[lcName] = translation;
      }
    });
  };
  const translate = (text) => {
    const langData = getLanguageData().getOr({});
    const toString = (obj) => {
      if (isFunction(obj)) {
        return Object.prototype.toString.call(obj);
      }
      return !isEmpty(obj) ? "" + obj : "";
    };
    const isEmpty = (text) =>
      text === "" || text === null || text === undefined;
    const getLangData = (text) => {
      const textStr = toString(text);
      return has$2(langData, textStr)
        ? toString(langData[textStr])
        : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);
    };
    const removeContext = (str) => str.replace(/{context:\w+}$/, "");
    if (isEmpty(text)) {
      return "";
    }
    if (isRaw(text)) {
      return toString(text.raw);
    }
    if (isTokenised(text)) {
      const values = text.slice(1);
      const substitued = getLangData(text[0]).replace(
        /\{([0-9]+)\}/g,
        ($1, $2) => (has$2(values, $2) ? toString(values[$2]) : $1)
      );
      return removeContext(substitued);
    }
    return removeContext(getLangData(text));
  };
  const isRtl$1 = () =>
    getLanguageData()
      .bind((items) => get$a(items, "_dir"))
      .exists((dir) => dir === "rtl");
  const hasCode = (code) => has$2(data, code);
  const I18n = {
    getData: getData$1,
    setCode,
    getCode,
    add: add$1,
    translate,
    isRtl: isRtl$1,
    hasCode,
  };

  const AddOnManager = () => {
    const items = [];
    const urls = {};
    const lookup = {};
    const _listeners = [];
    const runListeners = (name, state) => {
      const matchedListeners = filter$5(
        _listeners,
        (listener) => listener.name === name && listener.state === state
      );
      each$e(matchedListeners, (listener) => listener.resolve());
    };
    const isLoaded = (name) => has$2(urls, name);
    const isAdded = (name) => has$2(lookup, name);
    const get = (name) => {
      if (lookup[name]) {
        return lookup[name].instance;
      }
      return undefined;
    };
    const loadLanguagePack = (name, languages) => {
      const language = I18n.getCode();
      const wrappedLanguages = "," + (languages || "") + ",";
      if (
        !language ||
        (languages && wrappedLanguages.indexOf("," + language + ",") === -1)
      ) {
        return;
      }
      ScriptLoader.ScriptLoader.add(urls[name] + "/langs/" + language + ".js");
    };
    const requireLangPack = (name, languages) => {
      if (AddOnManager.languageLoad !== false) {
        if (isLoaded(name)) {
          loadLanguagePack(name, languages);
        } else {
          waitFor(name, "loaded").then(() => loadLanguagePack(name, languages));
        }
      }
    };
    const add = (id, addOn) => {
      items.push(addOn);
      lookup[id] = { instance: addOn };
      runListeners(id, "added");
      return addOn;
    };
    const remove = (name) => {
      delete urls[name];
      delete lookup[name];
    };
    const createUrl = (baseUrl, dep) => {
      if (isString(dep)) {
        return isString(baseUrl)
          ? {
              prefix: "",
              resource: dep,
              suffix: "",
            }
          : {
              prefix: baseUrl.prefix,
              resource: dep,
              suffix: baseUrl.suffix,
            };
      } else {
        return dep;
      }
    };
    const load = (name, addOnUrl) => {
      if (urls[name]) {
        return Promise.resolve();
      }
      let urlString = isString(addOnUrl)
        ? addOnUrl
        : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
      if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
        urlString = AddOnManager.baseURL + "/" + urlString;
      }
      urls[name] = urlString.substring(0, urlString.lastIndexOf("/"));
      const done = () => {
        runListeners(name, "loaded");
        return Promise.resolve();
      };
      if (lookup[name]) {
        return done();
      } else {
        return ScriptLoader.ScriptLoader.add(urlString).then(done);
      }
    };
    const waitFor = (name, state = "added") => {
      if (state === "added" && isAdded(name)) {
        return Promise.resolve();
      } else if (state === "loaded" && isLoaded(name)) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          _listeners.push({
            name,
            state,
            resolve,
          });
        });
      }
    };
    return {
      items,
      urls,
      lookup,
      get,
      requireLangPack,
      add,
      remove,
      createUrl,
      load,
      waitFor,
    };
  };
  AddOnManager.languageLoad = true;
  AddOnManager.baseURL = "";
  AddOnManager.PluginManager = AddOnManager();
  AddOnManager.ThemeManager = AddOnManager();
  AddOnManager.ModelManager = AddOnManager();

  const first$1 = (fn, rate) => {
    let timer = null;
    const cancel = () => {
      if (!isNull(timer)) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const throttle = (...args) => {
      if (isNull(timer)) {
        timer = setTimeout(() => {
          timer = null;
          fn.apply(null, args);
        }, rate);
      }
    };
    return {
      cancel,
      throttle,
    };
  };
  const last = (fn, rate) => {
    let timer = null;
    const cancel = () => {
      if (!isNull(timer)) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const throttle = (...args) => {
      cancel();
      timer = setTimeout(() => {
        timer = null;
        fn.apply(null, args);
      }, rate);
    };
    return {
      cancel,
      throttle,
    };
  };

  const ancestor$1 = (scope, selector, isRoot) =>
    ancestor$3(scope, selector, isRoot).isSome();

  const annotation = constant("mce-annotation");
  const dataAnnotation = constant("data-mce-annotation");
  const dataAnnotationId = constant("data-mce-annotation-uid");
  const dataAnnotationActive = constant("data-mce-annotation-active");
  const dataAnnotationClasses = constant("data-mce-annotation-classes");
  const dataAnnotationAttributes = constant("data-mce-annotation-attrs");

  const isRoot$1 = (root) => (node) => eq(node, root);
  const identify = (editor, annotationName) => {
    const rng = editor.selection.getRng();
    const start = SugarElement.fromDom(rng.startContainer);
    const root = SugarElement.fromDom(editor.getBody());
    const selector = annotationName.fold(
      () => "." + annotation(),
      (an) => `[${dataAnnotation()}="${an}"]`
    );
    const newStart = child$1(start, rng.startOffset).getOr(start);
    const closest = closest$3(newStart, selector, isRoot$1(root));
    return closest.bind((c) =>
      getOpt(c, `${dataAnnotationId()}`).bind((uid) =>
        getOpt(c, `${dataAnnotation()}`).map((name) => {
          const elements = findMarkers(editor, uid);
          return {
            uid,
            name,
            elements,
          };
        })
      )
    );
  };
  const isAnnotation = (elem) => isElement$7(elem) && has(elem, annotation());
  const isBogusElement = (elem, root) =>
    has$1(elem, "data-mce-bogus") ||
    ancestor$1(elem, '[data-mce-bogus="all"]', isRoot$1(root));
  const findMarkers = (editor, uid) => {
    const body = SugarElement.fromDom(editor.getBody());
    const descendants$1 = descendants(body, `[${dataAnnotationId()}="${uid}"]`);
    return filter$5(
      descendants$1,
      (descendant) => !isBogusElement(descendant, body)
    );
  };
  const findAll = (editor, name) => {
    const body = SugarElement.fromDom(editor.getBody());
    const markers = descendants(body, `[${dataAnnotation()}="${name}"]`);
    const directory = {};
    each$e(markers, (m) => {
      if (!isBogusElement(m, body)) {
        const uid = get$9(m, dataAnnotationId());
        const nodesAlready = get$a(directory, uid).getOr([]);
        directory[uid] = nodesAlready.concat([m]);
      }
    });
    return directory;
  };

  const setup$y = (editor, registry) => {
    const changeCallbacks = Cell({});
    const initData = () => ({
      listeners: [],
      previous: value$2(),
    });
    const withCallbacks = (name, f) => {
      updateCallbacks(name, (data) => {
        f(data);
        return data;
      });
    };
    const updateCallbacks = (name, f) => {
      const callbackMap = changeCallbacks.get();
      const data = get$a(callbackMap, name).getOrThunk(initData);
      const outputData = f(data);
      callbackMap[name] = outputData;
      changeCallbacks.set(callbackMap);
    };
    const fireCallbacks = (name, uid, elements) => {
      withCallbacks(name, (data) => {
        each$e(data.listeners, (f) =>
          f(true, name, {
            uid,
            nodes: map$3(elements, (elem) => elem.dom),
          })
        );
      });
    };
    const fireNoAnnotation = (name) => {
      withCallbacks(name, (data) => {
        each$e(data.listeners, (f) => f(false, name));
      });
    };
    const toggleActiveAttr = (uid, state) => {
      each$e(findMarkers(editor, uid), (elem) => {
        if (state) {
          set$4(elem, dataAnnotationActive(), "true");
        } else {
          remove$9(elem, dataAnnotationActive());
        }
      });
    };
    const onNodeChange = last(() => {
      const annotations = sort(registry.getNames());
      each$e(annotations, (name) => {
        updateCallbacks(name, (data) => {
          const prev = data.previous.get();
          identify(editor, Optional.some(name)).fold(
            () => {
              prev.each((uid) => {
                fireNoAnnotation(name);
                data.previous.clear();
                toggleActiveAttr(uid, false);
              });
            },
            ({ uid, name, elements }) => {
              if (!is$2(prev, uid)) {
                prev.each((uid) => toggleActiveAttr(uid, false));
                fireCallbacks(name, uid, elements);
                data.previous.set(uid);
                toggleActiveAttr(uid, true);
              }
            }
          );
          return {
            previous: data.previous,
            listeners: data.listeners,
          };
        });
      });
    }, 30);
    editor.on("remove", () => {
      onNodeChange.cancel();
    });
    editor.on("NodeChange", () => {
      onNodeChange.throttle();
    });
    const addListener = (name, f) => {
      updateCallbacks(name, (data) => ({
        previous: data.previous,
        listeners: data.listeners.concat([f]),
      }));
    };
    return { addListener };
  };

  const setup$x = (editor, registry) => {
    const dataAnnotation$1 = dataAnnotation();
    const identifyParserNode = (node) =>
      Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);
    const removeDirectAnnotation = (node) => {
      var _a, _b;
      node.attr(dataAnnotationId(), null);
      node.attr(dataAnnotation(), null);
      node.attr(dataAnnotationActive(), null);
      const customAttrNames = Optional.from(
        node.attr(dataAnnotationAttributes())
      )
        .map((names) => names.split(","))
        .getOr([]);
      const customClasses = Optional.from(node.attr(dataAnnotationClasses()))
        .map((names) => names.split(","))
        .getOr([]);
      each$e(customAttrNames, (name) => node.attr(name, null));
      const classList =
        (_b =
          (_a = node.attr("class")) === null || _a === void 0
            ? void 0
            : _a.split(" ")) !== null && _b !== void 0
          ? _b
          : [];
      const newClassList = difference(
        classList,
        [annotation()].concat(customClasses)
      );
      node.attr(
        "class",
        newClassList.length > 0 ? newClassList.join(" ") : null
      );
      node.attr(dataAnnotationClasses(), null);
      node.attr(dataAnnotationAttributes(), null);
    };
    editor.serializer.addTempAttr(dataAnnotationActive());
    editor.serializer.addAttributeFilter(dataAnnotation$1, (nodes) => {
      for (const node of nodes) {
        identifyParserNode(node).each((settings) => {
          if (settings.persistent === false) {
            if (node.name === "span") {
              node.unwrap();
            } else {
              removeDirectAnnotation(node);
            }
          }
        });
      }
    });
  };

  const create$b = () => {
    const annotations = {};
    const register = (name, settings) => {
      annotations[name] = {
        name,
        settings,
      };
    };
    const lookup = (name) => get$a(annotations, name).map((a) => a.settings);
    const getNames = () => keys(annotations);
    return {
      register,
      lookup,
      getNames,
    };
  };

  const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);
  const random = () =>
    window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;

  let unique = 0;
  const generate$1 = (prefix) => {
    const date = new Date();
    const time = date.getTime();
    const random$1 = Math.floor(random() * 1000000000);
    unique++;
    return prefix + "_" + random$1 + unique + String(time);
  };

  const add = (element, classes) => {
    each$e(classes, (x) => {
      add$2(element, x);
    });
  };
  const remove$3 = (element, classes) => {
    each$e(classes, (x) => {
      remove$6(element, x);
    });
  };

  const clone$2 = (original, isDeep) =>
    SugarElement.fromDom(original.dom.cloneNode(isDeep));
  const shallow$1 = (original) => clone$2(original, false);
  const deep$1 = (original) => clone$2(original, true);
  const shallowAs = (original, tag) => {
    const nu = SugarElement.fromTag(tag);
    const attributes = clone$4(original);
    setAll$1(nu, attributes);
    return nu;
  };
  const mutate = (original, tag) => {
    const nu = shallowAs(original, tag);
    after$4(original, nu);
    const children = children$1(original);
    append(nu, children);
    remove$4(original);
    return nu;
  };

  const TextWalker = (startNode, rootNode, isBoundary = never) => {
    const walker = new DomTreeWalker(startNode, rootNode);
    const walk = (direction) => {
      let next;
      do {
        next = walker[direction]();
      } while (next && !isText$b(next) && !isBoundary(next));
      return Optional.from(next).filter(isText$b);
    };
    return {
      current: () => Optional.from(walker.current()).filter(isText$b),
      next: () => walk("next"),
      prev: () => walk("prev"),
      prev2: () => walk("prev2"),
    };
  };

  const TextSeeker = (dom, isBoundary) => {
    const isBlockBoundary = isBoundary
      ? isBoundary
      : (node) =>
          dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);
    const walk = (node, offset, walker, process) => {
      if (isText$b(node)) {
        const newOffset = process(node, offset, node.data);
        if (newOffset !== -1) {
          return Optional.some({
            container: node,
            offset: newOffset,
          });
        }
      }
      return walker().bind((next) =>
        walk(next.container, next.offset, walker, process)
      );
    };
    const backwards = (node, offset, process, root) => {
      const walker = TextWalker(
        node,
        root !== null && root !== void 0 ? root : dom.getRoot(),
        isBlockBoundary
      );
      return walk(
        node,
        offset,
        () =>
          walker.prev().map((prev) => ({
            container: prev,
            offset: prev.length,
          })),
        process
      ).getOrNull();
    };
    const forwards = (node, offset, process, root) => {
      const walker = TextWalker(
        node,
        root !== null && root !== void 0 ? root : dom.getRoot(),
        isBlockBoundary
      );
      return walk(
        node,
        offset,
        () =>
          walker.next().map((next) => ({
            container: next,
            offset: 0,
          })),
        process
      ).getOrNull();
    };
    return {
      backwards,
      forwards,
    };
  };

  const NodeValue = (is, name) => {
    const get = (element) => {
      if (!is(element)) {
        throw new Error(
          "Can only get " + name + " value of a " + name + " node"
        );
      }
      return getOption(element).getOr("");
    };
    const getOption = (element) =>
      is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
    const set = (element, value) => {
      if (!is(element)) {
        throw new Error(
          "Can only set raw " + name + " value of a " + name + " node"
        );
      }
      element.dom.nodeValue = value;
    };
    return {
      get,
      getOption,
      set,
    };
  };

  const api$1 = NodeValue(isText$c, "text");
  const get$3 = (element) => api$1.get(element);
  const getOption = (element) => api$1.getOption(element);
  const set = (element, value) => api$1.set(element, value);

  const tableCells = ["td", "th"];
  const tableSections = ["thead", "tbody", "tfoot"];
  const textBlocks = [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "p",
    "div",
    "address",
    "pre",
    "form",
    "blockquote",
    "center",
    "dir",
    "fieldset",
    "header",
    "footer",
    "article",
    "section",
    "hgroup",
    "aside",
    "nav",
    "figure",
  ];
  const listItems$1 = ["li", "dd", "dt"];
  const lists = ["ul", "ol", "dl"];
  const wsElements = ["pre", "script", "textarea", "style"];
  const lazyLookup = (items) => {
    let lookup;
    return (node) => {
      lookup = lookup ? lookup : mapToObject(items, always);
      return has$2(lookup, name(node));
    };
  };
  const isTable$1 = (node) => name(node) === "table";
  const isBr$5 = (node) => isElement$7(node) && name(node) === "br";
  const isTextBlock$2 = lazyLookup(textBlocks);
  const isList = lazyLookup(lists);
  const isListItem$1 = lazyLookup(listItems$1);
  const isTableSection = lazyLookup(tableSections);
  const isTableCell$2 = lazyLookup(tableCells);
  const isWsPreserveElement = lazyLookup(wsElements);

  const getLastChildren$1 = (elm) => {
    const children = [];
    let rawNode = elm.dom;
    while (rawNode) {
      children.push(SugarElement.fromDom(rawNode));
      rawNode = rawNode.lastChild;
    }
    return children;
  };
  const removeTrailingBr = (elm) => {
    const allBrs = descendants(elm, "br");
    const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
    if (allBrs.length === brs.length) {
      each$e(brs, remove$4);
    }
  };
  const createPaddingBr = () => {
    const br = SugarElement.fromTag("br");
    set$4(br, "data-mce-bogus", "1");
    return br;
  };
  const fillWithPaddingBr = (elm) => {
    empty(elm);
    append$1(elm, createPaddingBr());
  };
  const trimBlockTrailingBr = (elm, schema) => {
    lastChild(elm).each((lastChild) => {
      prevSibling(lastChild).each((lastChildPrevSibling) => {
        if (
          schema.isBlock(name(elm)) &&
          isBr$5(lastChild) &&
          schema.isBlock(name(lastChildPrevSibling))
        ) {
          remove$4(lastChild);
        }
      });
    });
  };

  const ZWSP$1 = zeroWidth;
  const isZwsp = isZwsp$2;
  const trim$2 = removeZwsp;
  const insert$5 = (editor) =>
    editor.insertContent(ZWSP$1, { preserve_zwsp: true });

  const isElement$5 = isElement$6;
  const isText$9 = isText$b;
  const isCaretContainerBlock$1 = (node) => {
    if (isText$9(node)) {
      node = node.parentNode;
    }
    return isElement$5(node) && node.hasAttribute("data-mce-caret");
  };
  const isCaretContainerInline = (node) => isText$9(node) && isZwsp(node.data);
  const isCaretContainer$2 = (node) =>
    isCaretContainerBlock$1(node) || isCaretContainerInline(node);
  const hasContent = (node) =>
    node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
  const insertInline$1 = (node, before) => {
    var _a;
    const doc =
      (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
    const textNode = doc.createTextNode(ZWSP$1);
    const parentNode = node.parentNode;
    if (!before) {
      const sibling = node.nextSibling;
      if (isText$9(sibling)) {
        if (isCaretContainer$2(sibling)) {
          return sibling;
        }
        if (startsWithCaretContainer$1(sibling)) {
          sibling.splitText(1);
          return sibling;
        }
      }
      if (node.nextSibling) {
        parentNode === null || parentNode === void 0
          ? void 0
          : parentNode.insertBefore(textNode, node.nextSibling);
      } else {
        parentNode === null || parentNode === void 0
          ? void 0
          : parentNode.appendChild(textNode);
      }
    } else {
      const sibling = node.previousSibling;
      if (isText$9(sibling)) {
        if (isCaretContainer$2(sibling)) {
          return sibling;
        }
        if (endsWithCaretContainer$1(sibling)) {
          return sibling.splitText(sibling.data.length - 1);
        }
      }
      parentNode === null || parentNode === void 0
        ? void 0
        : parentNode.insertBefore(textNode, node);
    }
    return textNode;
  };
  const isBeforeInline = (pos) => {
    const container = pos.container();
    if (!isText$b(container)) {
      return false;
    }
    return (
      container.data.charAt(pos.offset()) === ZWSP$1 ||
      (pos.isAtStart() && isCaretContainerInline(container.previousSibling))
    );
  };
  const isAfterInline = (pos) => {
    const container = pos.container();
    if (!isText$b(container)) {
      return false;
    }
    return (
      container.data.charAt(pos.offset() - 1) === ZWSP$1 ||
      (pos.isAtEnd() && isCaretContainerInline(container.nextSibling))
    );
  };
  const insertBlock = (blockName, node, before) => {
    var _a;
    const doc =
      (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
    const blockNode = doc.createElement(blockName);
    blockNode.setAttribute("data-mce-caret", before ? "before" : "after");
    blockNode.setAttribute("data-mce-bogus", "all");
    blockNode.appendChild(createPaddingBr().dom);
    const parentNode = node.parentNode;
    if (!before) {
      if (node.nextSibling) {
        parentNode === null || parentNode === void 0
          ? void 0
          : parentNode.insertBefore(blockNode, node.nextSibling);
      } else {
        parentNode === null || parentNode === void 0
          ? void 0
          : parentNode.appendChild(blockNode);
      }
    } else {
      parentNode === null || parentNode === void 0
        ? void 0
        : parentNode.insertBefore(blockNode, node);
    }
    return blockNode;
  };
  const startsWithCaretContainer$1 = (node) =>
    isText$9(node) && node.data[0] === ZWSP$1;
  const endsWithCaretContainer$1 = (node) =>
    isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
  const trimBogusBr = (elm) => {
    var _a;
    const brs = elm.getElementsByTagName("br");
    const lastBr = brs[brs.length - 1];
    if (isBogus$1(lastBr)) {
      (_a = lastBr.parentNode) === null || _a === void 0
        ? void 0
        : _a.removeChild(lastBr);
    }
  };
  const showCaretContainerBlock = (caretContainer) => {
    if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
      trimBogusBr(caretContainer);
      caretContainer.removeAttribute("data-mce-caret");
      caretContainer.removeAttribute("data-mce-bogus");
      caretContainer.removeAttribute("style");
      caretContainer.removeAttribute("data-mce-style");
      caretContainer.removeAttribute("_moz_abspos");
      return caretContainer;
    }
    return null;
  };
  const isRangeInCaretContainerBlock = (range) =>
    isCaretContainerBlock$1(range.startContainer);

  const round$2 = Math.round;
  const clone$1 = (rect) => {
    if (!rect) {
      return {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0,
      };
    }
    return {
      left: round$2(rect.left),
      top: round$2(rect.top),
      bottom: round$2(rect.bottom),
      right: round$2(rect.right),
      width: round$2(rect.width),
      height: round$2(rect.height),
    };
  };
  const collapse = (rect, toStart) => {
    rect = clone$1(rect);
    if (toStart) {
      rect.right = rect.left;
    } else {
      rect.left = rect.left + rect.width;
      rect.right = rect.left;
    }
    rect.width = 0;
    return rect;
  };
  const isEqual = (rect1, rect2) =>
    rect1.left === rect2.left &&
    rect1.top === rect2.top &&
    rect1.bottom === rect2.bottom &&
    rect1.right === rect2.right;
  const isValidOverflow = (overflowY, rect1, rect2) =>
    overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
  const isAbove$1 = (rect1, rect2) => {
    const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
    if (rect1.bottom - halfHeight < rect2.top) {
      return true;
    }
    if (rect1.top > rect2.bottom) {
      return false;
    }
    return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
  };
  const isBelow$1 = (rect1, rect2) => {
    if (rect1.top > rect2.bottom) {
      return true;
    }
    if (rect1.bottom < rect2.top) {
      return false;
    }
    return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
  };
  const containsXY = (rect, clientX, clientY) =>
    clientX >= rect.left &&
    clientX <= rect.right &&
    clientY >= rect.top &&
    clientY <= rect.bottom;
  const boundingClientRectFromRects = (rects) => {
    return foldl(
      rects,
      (acc, rect) => {
        return acc.fold(
          () => Optional.some(rect),
          (prevRect) => {
            const left = Math.min(rect.left, prevRect.left);
            const top = Math.min(rect.top, prevRect.top);
            const right = Math.max(rect.right, prevRect.right);
            const bottom = Math.max(rect.bottom, prevRect.bottom);
            return Optional.some({
              top,
              right,
              bottom,
              left,
              width: right - left,
              height: bottom - top,
            });
          }
        );
      },
      Optional.none()
    );
  };
  const distanceToRectEdgeFromXY = (rect, x, y) => {
    const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
    const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
    return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
  };
  const overlapY = (r1, r2) =>
    Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));

  const getSelectedNode = (range) => {
    const startContainer = range.startContainer,
      startOffset = range.startOffset;
    if (
      startContainer === range.endContainer &&
      startContainer.hasChildNodes() &&
      range.endOffset === startOffset + 1
    ) {
      return startContainer.childNodes[startOffset];
    }
    return null;
  };
  const getNode$1 = (container, offset) => {
    if (isElement$6(container) && container.hasChildNodes()) {
      const childNodes = container.childNodes;
      const safeOffset = clamp$2(offset, 0, childNodes.length - 1);
      return childNodes[safeOffset];
    } else {
      return container;
    }
  };
  const getNodeUnsafe = (container, offset) => {
    if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {
      return undefined;
    } else {
      return getNode$1(container, offset);
    }
  };

  const extendingChars = new RegExp(
    "[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a" +
      "\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0" +
      "\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c" +
      "\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3" +
      "\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc" +
      "\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57" +
      "\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56" +
      "\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44" +
      "\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9" +
      "\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97" +
      "\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074" +
      "\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5" +
      "\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18" +
      "\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1ABE\u1b00-\u1b03\u1b34" +
      "\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9" +
      "\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9" +
      "\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20DD-\u20E0\u20e1\u20E2-\u20E4\u20e5-\u20f0\u2cef-\u2cf1" +
      "\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\uA670-\uA672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1" +
      "\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc" +
      "\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1" +
      "\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]"
  );
  const isExtendingChar = (ch) =>
    isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);

  const or = (...args) => {
    return (x) => {
      for (let i = 0; i < args.length; i++) {
        if (args[i](x)) {
          return true;
        }
      }
      return false;
    };
  };
  const and = (...args) => {
    return (x) => {
      for (let i = 0; i < args.length; i++) {
        if (!args[i](x)) {
          return false;
        }
      }
      return true;
    };
  };

  const isContentEditableTrue$2 = isContentEditableTrue$3;
  const isContentEditableFalse$a = isContentEditableFalse$b;
  const isBr$4 = isBr$6;
  const isText$8 = isText$b;
  const isInvalidTextElement = matchNodeNames(["script", "style", "textarea"]);
  const isAtomicInline = matchNodeNames([
    "img",
    "input",
    "textarea",
    "hr",
    "iframe",
    "video",
    "audio",
    "object",
    "embed",
  ]);
  const isTable = matchNodeNames(["table"]);
  const isCaretContainer$1 = isCaretContainer$2;
  const isCaretCandidate$3 = (node) => {
    if (isCaretContainer$1(node)) {
      return false;
    }
    if (isText$8(node)) {
      return !isInvalidTextElement(node.parentNode);
    }
    return (
      isAtomicInline(node) ||
      isBr$4(node) ||
      isTable(node) ||
      isNonUiContentEditableFalse(node)
    );
  };
  const isUnselectable = (node) =>
    isElement$6(node) && node.getAttribute("unselectable") === "true";
  const isNonUiContentEditableFalse = (node) =>
    !isUnselectable(node) && isContentEditableFalse$a(node);
  const isInEditable = (node, root) => {
    for (
      let tempNode = node.parentNode;
      tempNode && tempNode !== root;
      tempNode = tempNode.parentNode
    ) {
      if (isNonUiContentEditableFalse(tempNode)) {
        return false;
      }
      if (isContentEditableTrue$2(tempNode)) {
        return true;
      }
    }
    return true;
  };
  const isAtomicContentEditableFalse = (node) => {
    if (!isNonUiContentEditableFalse(node)) {
      return false;
    }
    return !foldl(
      from(node.getElementsByTagName("*")),
      (result, elm) => {
        return result || isContentEditableTrue$2(elm);
      },
      false
    );
  };
  const isAtomic$1 = (node) =>
    isAtomicInline(node) || isAtomicContentEditableFalse(node);
  const isEditableCaretCandidate$1 = (node, root) =>
    isCaretCandidate$3(node) && isInEditable(node, root);

  const isElement$4 = isElement$6;
  const isCaretCandidate$2 = isCaretCandidate$3;
  const isBlock$2 = matchStyleValues("display", "block table");
  const isFloated = matchStyleValues("float", "left right");
  const isValidElementCaretCandidate = and(
    isElement$4,
    isCaretCandidate$2,
    not(isFloated)
  );
  const isNotPre = not(
    matchStyleValues("white-space", "pre pre-line pre-wrap")
  );
  const isText$7 = isText$b;
  const isBr$3 = isBr$6;
  const nodeIndex$1 = DOMUtils.nodeIndex;
  const resolveIndex$1 = getNodeUnsafe;
  const createRange$1 = (doc) =>
    doc ? doc.createRange() : DOMUtils.DOM.createRng();
  const isWhiteSpace$1 = (chr) => isString(chr) && /[\r\n\t ]/.test(chr);
  const isRange = (rng) => !!rng.setStart && !!rng.setEnd;
  const isHiddenWhiteSpaceRange = (range) => {
    const container = range.startContainer;
    const offset = range.startOffset;
    if (
      isWhiteSpace$1(range.toString()) &&
      isNotPre(container.parentNode) &&
      isText$b(container)
    ) {
      const text = container.data;
      if (
        isWhiteSpace$1(text[offset - 1]) ||
        isWhiteSpace$1(text[offset + 1])
      ) {
        return true;
      }
    }
    return false;
  };
  const getBrClientRect = (brNode) => {
    const doc = brNode.ownerDocument;
    const rng = createRange$1(doc);
    const nbsp$1 = doc.createTextNode(nbsp);
    const parentNode = brNode.parentNode;
    parentNode.insertBefore(nbsp$1, brNode);
    rng.setStart(nbsp$1, 0);
    rng.setEnd(nbsp$1, 1);
    const clientRect = clone$1(rng.getBoundingClientRect());
    parentNode.removeChild(nbsp$1);
    return clientRect;
  };
  const getBoundingClientRectWebKitText = (rng) => {
    const sc = rng.startContainer;
    const ec = rng.endContainer;
    const so = rng.startOffset;
    const eo = rng.endOffset;
    if (sc === ec && isText$b(ec) && so === 0 && eo === 1) {
      const newRng = rng.cloneRange();
      newRng.setEndAfter(ec);
      return getBoundingClientRect$1(newRng);
    } else {
      return null;
    }
  };
  const isZeroRect = (r) =>
    r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
  const getBoundingClientRect$1 = (item) => {
    var _a;
    let clientRect;
    const clientRects = item.getClientRects();
    if (clientRects.length > 0) {
      clientRect = clone$1(clientRects[0]);
    } else {
      clientRect = clone$1(item.getBoundingClientRect());
    }
    if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
      return getBrClientRect(item);
    }
    if (isZeroRect(clientRect) && isRange(item)) {
      return (_a = getBoundingClientRectWebKitText(item)) !== null &&
        _a !== void 0
        ? _a
        : clientRect;
    }
    return clientRect;
  };
  const collapseAndInflateWidth = (clientRect, toStart) => {
    const newClientRect = collapse(clientRect, toStart);
    newClientRect.width = 1;
    newClientRect.right = newClientRect.left + 1;
    return newClientRect;
  };
  const getCaretPositionClientRects = (caretPosition) => {
    const clientRects = [];
    const addUniqueAndValidRect = (clientRect) => {
      if (clientRect.height === 0) {
        return;
      }
      if (clientRects.length > 0) {
        if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
          return;
        }
      }
      clientRects.push(clientRect);
    };
    const addCharacterOffset = (container, offset) => {
      const range = createRange$1(container.ownerDocument);
      if (offset < container.data.length) {
        if (isExtendingChar(container.data[offset])) {
          return;
        }
        if (isExtendingChar(container.data[offset - 1])) {
          range.setStart(container, offset);
          range.setEnd(container, offset + 1);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(
              collapseAndInflateWidth(getBoundingClientRect$1(range), false)
            );
            return;
          }
        }
      }
      if (offset > 0) {
        range.setStart(container, offset - 1);
        range.setEnd(container, offset);
        if (!isHiddenWhiteSpaceRange(range)) {
          addUniqueAndValidRect(
            collapseAndInflateWidth(getBoundingClientRect$1(range), false)
          );
        }
      }
      if (offset < container.data.length) {
        range.setStart(container, offset);
        range.setEnd(container, offset + 1);
        if (!isHiddenWhiteSpaceRange(range)) {
          addUniqueAndValidRect(
            collapseAndInflateWidth(getBoundingClientRect$1(range), true)
          );
        }
      }
    };
    const container = caretPosition.container();
    const offset = caretPosition.offset();
    if (isText$7(container)) {
      addCharacterOffset(container, offset);
      return clientRects;
    }
    if (isElement$4(container)) {
      if (caretPosition.isAtEnd()) {
        const node = resolveIndex$1(container, offset);
        if (isText$7(node)) {
          addCharacterOffset(node, node.data.length);
        }
        if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
          addUniqueAndValidRect(
            collapseAndInflateWidth(getBoundingClientRect$1(node), false)
          );
        }
      } else {
        const node = resolveIndex$1(container, offset);
        if (isText$7(node)) {
          addCharacterOffset(node, 0);
        }
        if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
          addUniqueAndValidRect(
            collapseAndInflateWidth(getBoundingClientRect$1(node), false)
          );
          return clientRects;
        }
        const beforeNode = resolveIndex$1(
          caretPosition.container(),
          caretPosition.offset() - 1
        );
        if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
          if (
            isBlock$2(beforeNode) ||
            isBlock$2(node) ||
            !isValidElementCaretCandidate(node)
          ) {
            addUniqueAndValidRect(
              collapseAndInflateWidth(
                getBoundingClientRect$1(beforeNode),
                false
              )
            );
          }
        }
        if (isValidElementCaretCandidate(node)) {
          addUniqueAndValidRect(
            collapseAndInflateWidth(getBoundingClientRect$1(node), true)
          );
        }
      }
    }
    return clientRects;
  };
  const CaretPosition = (container, offset, clientRects) => {
    const isAtStart = () => {
      if (isText$7(container)) {
        return offset === 0;
      }
      return offset === 0;
    };
    const isAtEnd = () => {
      if (isText$7(container)) {
        return offset >= container.data.length;
      }
      return offset >= container.childNodes.length;
    };
    const toRange = () => {
      const range = createRange$1(container.ownerDocument);
      range.setStart(container, offset);
      range.setEnd(container, offset);
      return range;
    };
    const getClientRects = () => {
      if (!clientRects) {
        clientRects = getCaretPositionClientRects(
          CaretPosition(container, offset)
        );
      }
      return clientRects;
    };
    const isVisible = () => getClientRects().length > 0;
    const isEqual = (caretPosition) =>
      caretPosition &&
      container === caretPosition.container() &&
      offset === caretPosition.offset();
    const getNode = (before) =>
      resolveIndex$1(container, before ? offset - 1 : offset);
    return {
      container: constant(container),
      offset: constant(offset),
      toRange,
      getClientRects,
      isVisible,
      isAtStart,
      isAtEnd,
      isEqual,
      getNode,
    };
  };
  CaretPosition.fromRangeStart = (range) =>
    CaretPosition(range.startContainer, range.startOffset);
  CaretPosition.fromRangeEnd = (range) =>
    CaretPosition(range.endContainer, range.endOffset);
  CaretPosition.after = (node) =>
    CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
  CaretPosition.before = (node) =>
    CaretPosition(node.parentNode, nodeIndex$1(node));
  CaretPosition.isAbove = (pos1, pos2) =>
    lift2(
      head(pos2.getClientRects()),
      last$2(pos1.getClientRects()),
      isAbove$1
    ).getOr(false);
  CaretPosition.isBelow = (pos1, pos2) =>
    lift2(
      last$2(pos2.getClientRects()),
      head(pos1.getClientRects()),
      isBelow$1
    ).getOr(false);
  CaretPosition.isAtStart = (pos) => (pos ? pos.isAtStart() : false);
  CaretPosition.isAtEnd = (pos) => (pos ? pos.isAtEnd() : false);
  CaretPosition.isTextPosition = (pos) =>
    pos ? isText$b(pos.container()) : false;
  CaretPosition.isElementPosition = (pos) => !CaretPosition.isTextPosition(pos);

  const trimEmptyTextNode$1 = (dom, node) => {
    if (isText$b(node) && node.data.length === 0) {
      dom.remove(node);
    }
  };
  const insertNode = (dom, rng, node) => {
    rng.insertNode(node);
    trimEmptyTextNode$1(dom, node.previousSibling);
    trimEmptyTextNode$1(dom, node.nextSibling);
  };
  const insertFragment = (dom, rng, frag) => {
    const firstChild = Optional.from(frag.firstChild);
    const lastChild = Optional.from(frag.lastChild);
    rng.insertNode(frag);
    firstChild.each((child) => trimEmptyTextNode$1(dom, child.previousSibling));
    lastChild.each((child) => trimEmptyTextNode$1(dom, child.nextSibling));
  };
  const rangeInsertNode = (dom, rng, node) => {
    if (isDocumentFragment(node)) {
      insertFragment(dom, rng, node);
    } else {
      insertNode(dom, rng, node);
    }
  };

  const isText$6 = isText$b;
  const isBogus = isBogus$1;
  const nodeIndex = DOMUtils.nodeIndex;
  const normalizedParent = (node) => {
    const parentNode = node.parentNode;
    if (isBogus(parentNode)) {
      return normalizedParent(parentNode);
    }
    return parentNode;
  };
  const getChildNodes = (node) => {
    if (!node) {
      return [];
    }
    return reduce(
      node.childNodes,
      (result, node) => {
        if (isBogus(node) && node.nodeName !== "BR") {
          result = result.concat(getChildNodes(node));
        } else {
          result.push(node);
        }
        return result;
      },
      []
    );
  };
  const normalizedTextOffset = (node, offset) => {
    let tempNode = node;
    while ((tempNode = tempNode.previousSibling)) {
      if (!isText$6(tempNode)) {
        break;
      }
      offset += tempNode.data.length;
    }
    return offset;
  };
  const equal = (a) => (b) => a === b;
  const normalizedNodeIndex = (node) => {
    let nodes, index;
    nodes = getChildNodes(normalizedParent(node));
    index = findIndex$1(nodes, equal(node), node);
    nodes = nodes.slice(0, index + 1);
    const numTextFragments = reduce(
      nodes,
      (result, node, i) => {
        if (isText$6(node) && isText$6(nodes[i - 1])) {
          result++;
        }
        return result;
      },
      0
    );
    nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
    index = findIndex$1(nodes, equal(node), node);
    return index - numTextFragments;
  };
  const createPathItem = (node) => {
    const name = isText$6(node) ? "text()" : node.nodeName.toLowerCase();
    return name + "[" + normalizedNodeIndex(node) + "]";
  };
  const parentsUntil$1 = (root, node, predicate) => {
    const parents = [];
    for (
      let tempNode = node.parentNode;
      tempNode && tempNode !== root;
      tempNode = tempNode.parentNode
    ) {
      if (predicate && predicate(tempNode)) {
        break;
      }
      parents.push(tempNode);
    }
    return parents;
  };
  const create$a = (root, caretPosition) => {
    let path = [];
    let container = caretPosition.container();
    let offset = caretPosition.offset();
    let outputOffset;
    if (isText$6(container)) {
      outputOffset = normalizedTextOffset(container, offset);
    } else {
      const childNodes = container.childNodes;
      if (offset >= childNodes.length) {
        outputOffset = "after";
        offset = childNodes.length - 1;
      } else {
        outputOffset = "before";
      }
      container = childNodes[offset];
    }
    path.push(createPathItem(container));
    let parents = parentsUntil$1(root, container);
    parents = filter$3(parents, not(isBogus$1));
    path = path.concat(
      map$1(parents, (node) => {
        return createPathItem(node);
      })
    );
    return path.reverse().join("/") + "," + outputOffset;
  };
  const resolvePathItem = (node, name, index) => {
    let nodes = getChildNodes(node);
    nodes = filter$3(nodes, (node, index) => {
      return !isText$6(node) || !isText$6(nodes[index - 1]);
    });
    nodes = filter$3(nodes, matchNodeNames([name]));
    return nodes[index];
  };
  const findTextPosition = (container, offset) => {
    let node = container;
    let targetOffset = 0;
    while (isText$6(node)) {
      const dataLen = node.data.length;
      if (offset >= targetOffset && offset <= targetOffset + dataLen) {
        container = node;
        offset = offset - targetOffset;
        break;
      }
      if (!isText$6(node.nextSibling)) {
        container = node;
        offset = dataLen;
        break;
      }
      targetOffset += dataLen;
      node = node.nextSibling;
    }
    if (isText$6(container) && offset > container.data.length) {
      offset = container.data.length;
    }
    return CaretPosition(container, offset);
  };
  const resolve$1 = (root, path) => {
    if (!path) {
      return null;
    }
    const parts = path.split(",");
    const paths = parts[0].split("/");
    const offset = parts.length > 1 ? parts[1] : "before";
    const container = reduce(
      paths,
      (result, value) => {
        const match = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
        if (!match) {
          return null;
        }
        if (match[1] === "text()") {
          match[1] = "#text";
        }
        return resolvePathItem(result, match[1], parseInt(match[2], 10));
      },
      root
    );
    if (!container) {
      return null;
    }
    if (!isText$6(container) && container.parentNode) {
      let nodeOffset;
      if (offset === "after") {
        nodeOffset = nodeIndex(container) + 1;
      } else {
        nodeOffset = nodeIndex(container);
      }
      return CaretPosition(container.parentNode, nodeOffset);
    }
    return findTextPosition(container, parseInt(offset, 10));
  };

  const isContentEditableFalse$9 = isContentEditableFalse$b;
  const getNormalizedTextOffset$1 = (trim, container, offset) => {
    let trimmedOffset = trim(container.data.slice(0, offset)).length;
    for (
      let node = container.previousSibling;
      node && isText$b(node);
      node = node.previousSibling
    ) {
      trimmedOffset += trim(node.data).length;
    }
    return trimmedOffset;
  };
  const getPoint = (dom, trim, normalized, rng, start) => {
    const container = start ? rng.startContainer : rng.endContainer;
    let offset = start ? rng.startOffset : rng.endOffset;
    const point = [];
    const root = dom.getRoot();
    if (isText$b(container)) {
      point.push(
        normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset
      );
    } else {
      let after = 0;
      const childNodes = container.childNodes;
      if (offset >= childNodes.length && childNodes.length) {
        after = 1;
        offset = Math.max(0, childNodes.length - 1);
      }
      point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
    }
    for (let node = container; node && node !== root; node = node.parentNode) {
      point.push(dom.nodeIndex(node, normalized));
    }
    return point;
  };
  const getLocation = (trim, selection, normalized, rng) => {
    const dom = selection.dom;
    const start = getPoint(dom, trim, normalized, rng, true);
    const forward = selection.isForward();
    const fakeCaret = isRangeInCaretContainerBlock(rng)
      ? { isFakeCaret: true }
      : {};
    if (!selection.isCollapsed()) {
      const end = getPoint(dom, trim, normalized, rng, false);
      return {
        start,
        end,
        forward,
        ...fakeCaret,
      };
    } else {
      return {
        start,
        forward,
        ...fakeCaret,
      };
    }
  };
  const findIndex = (dom, name, element) => {
    let count = 0;
    Tools.each(dom.select(name), (node) => {
      if (node.getAttribute("data-mce-bogus") === "all") {
        return;
      } else if (node === element) {
        return false;
      } else {
        count++;
        return;
      }
    });
    return count;
  };
  const moveEndPoint$1 = (rng, start) => {
    let container = start ? rng.startContainer : rng.endContainer;
    let offset = start ? rng.startOffset : rng.endOffset;
    if (isElement$6(container) && container.nodeName === "TR") {
      const childNodes = container.childNodes;
      container =
        childNodes[
          Math.min(start ? offset : offset - 1, childNodes.length - 1)
        ];
      if (container) {
        offset = start ? 0 : container.childNodes.length;
        if (start) {
          rng.setStart(container, offset);
        } else {
          rng.setEnd(container, offset);
        }
      }
    }
  };
  const normalizeTableCellSelection = (rng) => {
    moveEndPoint$1(rng, true);
    moveEndPoint$1(rng, false);
    return rng;
  };
  const findSibling = (node, offset) => {
    if (isElement$6(node)) {
      node = getNode$1(node, offset);
      if (isContentEditableFalse$9(node)) {
        return node;
      }
    }
    if (isCaretContainer$2(node)) {
      if (isText$b(node) && isCaretContainerBlock$1(node)) {
        node = node.parentNode;
      }
      let sibling = node.previousSibling;
      if (isContentEditableFalse$9(sibling)) {
        return sibling;
      }
      sibling = node.nextSibling;
      if (isContentEditableFalse$9(sibling)) {
        return sibling;
      }
    }
    return undefined;
  };
  const findAdjacentContentEditableFalseElm = (rng) => {
    return (
      findSibling(rng.startContainer, rng.startOffset) ||
      findSibling(rng.endContainer, rng.endOffset)
    );
  };
  const getOffsetBookmark = (trim, normalized, selection) => {
    const element = selection.getNode();
    const rng = selection.getRng();
    if (element.nodeName === "IMG" || isContentEditableFalse$9(element)) {
      const name = element.nodeName;
      return {
        name,
        index: findIndex(selection.dom, name, element),
      };
    }
    const sibling = findAdjacentContentEditableFalseElm(rng);
    if (sibling) {
      const name = sibling.tagName;
      return {
        name,
        index: findIndex(selection.dom, name, sibling),
      };
    }
    return getLocation(trim, selection, normalized, rng);
  };
  const getCaretBookmark = (selection) => {
    const rng = selection.getRng();
    return {
      start: create$a(
        selection.dom.getRoot(),
        CaretPosition.fromRangeStart(rng)
      ),
      end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
      forward: selection.isForward(),
    };
  };
  const getRangeBookmark = (selection) => {
    return {
      rng: selection.getRng(),
      forward: selection.isForward(),
    };
  };
  const createBookmarkSpan = (dom, id, filled) => {
    const args = {
      "data-mce-type": "bookmark",
      id,
      style: "overflow:hidden;line-height:0px",
    };
    return filled
      ? dom.create("span", args, "&#xFEFF;")
      : dom.create("span", args);
  };
  const getPersistentBookmark = (selection, filled) => {
    const dom = selection.dom;
    let rng = selection.getRng();
    const id = dom.uniqueId();
    const collapsed = selection.isCollapsed();
    const element = selection.getNode();
    const name = element.nodeName;
    const forward = selection.isForward();
    if (name === "IMG") {
      return {
        name,
        index: findIndex(dom, name, element),
      };
    }
    const rng2 = normalizeTableCellSelection(rng.cloneRange());
    if (!collapsed) {
      rng2.collapse(false);
      const endBookmarkNode = createBookmarkSpan(dom, id + "_end", filled);
      rangeInsertNode(dom, rng2, endBookmarkNode);
    }
    rng = normalizeTableCellSelection(rng);
    rng.collapse(true);
    const startBookmarkNode = createBookmarkSpan(dom, id + "_start", filled);
    rangeInsertNode(dom, rng, startBookmarkNode);
    selection.moveToBookmark({
      id,
      keep: true,
      forward,
    });
    return {
      id,
      forward,
    };
  };
  const getBookmark$3 = (selection, type, normalized = false) => {
    if (type === 2) {
      return getOffsetBookmark(trim$2, normalized, selection);
    } else if (type === 3) {
      return getCaretBookmark(selection);
    } else if (type) {
      return getRangeBookmark(selection);
    } else {
      return getPersistentBookmark(selection, false);
    }
  };
  const getUndoBookmark = curry(getOffsetBookmark, identity, true);

  const value$1 = (value) => {
    const applyHelper = (fn) => fn(value);
    const constHelper = constant(value);
    const outputHelper = () => output;
    const output = {
      tag: true,
      inner: value,
      fold: (_onError, onValue) => onValue(value),
      isValue: always,
      isError: never,
      map: (mapper) => Result.value(mapper(value)),
      mapError: outputHelper,
      bind: applyHelper,
      exists: applyHelper,
      forall: applyHelper,
      getOr: constHelper,
      or: outputHelper,
      getOrThunk: constHelper,
      orThunk: outputHelper,
      getOrDie: constHelper,
      each: (fn) => {
        fn(value);
      },
      toOptional: () => Optional.some(value),
    };
    return output;
  };
  const error = (error) => {
    const outputHelper = () => output;
    const output = {
      tag: false,
      inner: error,
      fold: (onError, _onValue) => onError(error),
      isValue: never,
      isError: always,
      map: outputHelper,
      mapError: (mapper) => Result.error(mapper(error)),
      bind: outputHelper,
      exists: never,
      forall: always,
      getOr: identity,
      or: identity,
      getOrThunk: apply$1,
      orThunk: apply$1,
      getOrDie: die(String(error)),
      each: noop,
      toOptional: Optional.none,
    };
    return output;
  };
  const fromOption = (optional, err) =>
    optional.fold(() => error(err), value$1);
  const Result = {
    value: value$1,
    error,
    fromOption,
  };

  const generate = (cases) => {
    if (!isArray$1(cases)) {
      throw new Error("cases must be an array");
    }
    if (cases.length === 0) {
      throw new Error("there must be at least one case");
    }
    const constructors = [];
    const adt = {};
    each$e(cases, (acase, count) => {
      const keys$1 = keys(acase);
      if (keys$1.length !== 1) {
        throw new Error("one and only one name per case");
      }
      const key = keys$1[0];
      const value = acase[key];
      if (adt[key] !== undefined) {
        throw new Error("duplicate key detected:" + key);
      } else if (key === "cata") {
        throw new Error("cannot have a case named cata (sorry)");
      } else if (!isArray$1(value)) {
        throw new Error("case arguments must be an array");
      }
      constructors.push(key);
      adt[key] = (...args) => {
        const argLength = args.length;
        if (argLength !== value.length) {
          throw new Error(
            "Wrong number of arguments to case " +
              key +
              ". Expected " +
              value.length +
              " (" +
              value +
              "), got " +
              argLength
          );
        }
        const match = (branches) => {
          const branchKeys = keys(branches);
          if (constructors.length !== branchKeys.length) {
            throw new Error(
              "Wrong number of arguments to match. Expected: " +
                constructors.join(",") +
                "\nActual: " +
                branchKeys.join(",")
            );
          }
          const allReqd = forall(constructors, (reqKey) => {
            return contains$2(branchKeys, reqKey);
          });
          if (!allReqd) {
            throw new Error(
              "Not all branches were specified when using match. Specified: " +
                branchKeys.join(", ") +
                "\nRequired: " +
                constructors.join(", ")
            );
          }
          return branches[key].apply(null, args);
        };
        return {
          fold: (...foldArgs) => {
            if (foldArgs.length !== cases.length) {
              throw new Error(
                "Wrong number of arguments to fold. Expected " +
                  cases.length +
                  ", got " +
                  foldArgs.length
              );
            }
            const target = foldArgs[count];
            return target.apply(null, args);
          },
          match,
          log: (label) => {
            console.log(label, {
              constructors,
              constructor: key,
              params: args,
            });
          },
        };
      };
    });
    return adt;
  };
  const Adt = { generate };

  Adt.generate([
    {
      bothErrors: ["error1", "error2"],
    },
    {
      firstError: ["error1", "value2"],
    },
    {
      secondError: ["value1", "error2"],
    },
    {
      bothValues: ["value1", "value2"],
    },
  ]);
  const partition$1 = (results) => {
    const errors = [];
    const values = [];
    each$e(results, (result) => {
      result.fold(
        (err) => {
          errors.push(err);
        },
        (value) => {
          values.push(value);
        }
      );
    });
    return {
      errors,
      values,
    };
  };

  const isInlinePattern = (pattern) =>
    pattern.type === "inline-command" || pattern.type === "inline-format";
  const isBlockPattern = (pattern) =>
    pattern.type === "block-command" || pattern.type === "block-format";
  const hasBlockTrigger = (pattern, trigger) =>
    (pattern.type === "block-command" || pattern.type === "block-format") &&
    pattern.trigger === trigger;
  const normalizePattern = (pattern) => {
    var _a;
    const err = (message) =>
      Result.error({
        message,
        pattern,
      });
    const formatOrCmd = (name, onFormat, onCommand) => {
      if (pattern.format !== undefined) {
        let formats;
        if (isArray$1(pattern.format)) {
          if (!forall(pattern.format, isString)) {
            return err(
              name + " pattern has non-string items in the `format` array"
            );
          }
          formats = pattern.format;
        } else if (isString(pattern.format)) {
          formats = [pattern.format];
        } else {
          return err(name + " pattern has non-string `format` parameter");
        }
        return Result.value(onFormat(formats));
      } else if (pattern.cmd !== undefined) {
        if (!isString(pattern.cmd)) {
          return err(name + " pattern has non-string `cmd` parameter");
        }
        return Result.value(onCommand(pattern.cmd, pattern.value));
      } else {
        return err(
          name + " pattern is missing both `format` and `cmd` parameters"
        );
      }
    };
    if (!isObject(pattern)) {
      return err("Raw pattern is not an object");
    }
    if (!isString(pattern.start)) {
      return err("Raw pattern is missing `start` parameter");
    }
    if (pattern.end !== undefined) {
      if (!isString(pattern.end)) {
        return err("Inline pattern has non-string `end` parameter");
      }
      if (pattern.start.length === 0 && pattern.end.length === 0) {
        return err("Inline pattern has empty `start` and `end` parameters");
      }
      let start = pattern.start;
      let end = pattern.end;
      if (end.length === 0) {
        end = start;
        start = "";
      }
      return formatOrCmd(
        "Inline",
        (format) => ({
          type: "inline-format",
          start,
          end,
          format,
        }),
        (cmd, value) => ({
          type: "inline-command",
          start,
          end,
          cmd,
          value,
        })
      );
    } else if (pattern.replacement !== undefined) {
      if (!isString(pattern.replacement)) {
        return err(
          "Replacement pattern has non-string `replacement` parameter"
        );
      }
      if (pattern.start.length === 0) {
        return err("Replacement pattern has empty `start` parameter");
      }
      return Result.value({
        type: "inline-command",
        start: "",
        end: pattern.start,
        cmd: "mceInsertContent",
        value: pattern.replacement,
      });
    } else {
      const trigger =
        (_a = pattern.trigger) !== null && _a !== void 0 ? _a : "space";
      if (pattern.start.length === 0) {
        return err("Block pattern has empty `start` parameter");
      }
      return formatOrCmd(
        "Block",
        (formats) => ({
          type: "block-format",
          start: pattern.start,
          format: formats[0],
          trigger,
        }),
        (command, commandValue) => ({
          type: "block-command",
          start: pattern.start,
          cmd: command,
          value: commandValue,
          trigger,
        })
      );
    }
  };
  const getBlockPatterns = (patterns) => filter$5(patterns, isBlockPattern);
  const getInlinePatterns = (patterns) => filter$5(patterns, isInlinePattern);
  const createPatternSet = (patterns, dynamicPatternsLookup) => ({
    inlinePatterns: getInlinePatterns(patterns),
    blockPatterns: getBlockPatterns(patterns),
    dynamicPatternsLookup,
  });
  const filterByTrigger = (patterns, trigger) => {
    return {
      ...patterns,
      blockPatterns: filter$5(patterns.blockPatterns, (pattern) =>
        hasBlockTrigger(pattern, trigger)
      ),
    };
  };
  const fromRawPatterns = (patterns) => {
    const normalized = partition$1(map$3(patterns, normalizePattern));
    each$e(normalized.errors, (err) => console.error(err.message, err.pattern));
    return normalized.values;
  };
  const fromRawPatternsLookup = (lookupFn) => {
    return (ctx) => {
      const rawPatterns = lookupFn(ctx);
      return fromRawPatterns(rawPatterns);
    };
  };

  const firePreProcess = (editor, args) => editor.dispatch("PreProcess", args);
  const firePostProcess = (editor, args) =>
    editor.dispatch("PostProcess", args);
  const fireRemove = (editor) => {
    editor.dispatch("remove");
  };
  const fireDetach = (editor) => {
    editor.dispatch("detach");
  };
  const fireSwitchMode = (editor, mode) => {
    editor.dispatch("SwitchMode", { mode });
  };
  const fireObjectResizeStart = (editor, target, width, height, origin) => {
    editor.dispatch("ObjectResizeStart", {
      target,
      width,
      height,
      origin,
    });
  };
  const fireObjectResized = (editor, target, width, height, origin) => {
    editor.dispatch("ObjectResized", {
      target,
      width,
      height,
      origin,
    });
  };
  const firePreInit = (editor) => {
    editor.dispatch("PreInit");
  };
  const firePostRender = (editor) => {
    editor.dispatch("PostRender");
  };
  const fireInit = (editor) => {
    editor.dispatch("Init");
  };
  const firePlaceholderToggle = (editor, state) => {
    editor.dispatch("PlaceholderToggle", { state });
  };
  const fireError = (editor, errorType, error) => {
    editor.dispatch(errorType, error);
  };
  const fireFormatApply = (editor, format, node, vars) => {
    editor.dispatch("FormatApply", {
      format,
      node,
      vars,
    });
  };
  const fireFormatRemove = (editor, format, node, vars) => {
    editor.dispatch("FormatRemove", {
      format,
      node,
      vars,
    });
  };
  const fireBeforeSetContent = (editor, args) =>
    editor.dispatch("BeforeSetContent", args);
  const fireSetContent = (editor, args) => editor.dispatch("SetContent", args);
  const fireBeforeGetContent = (editor, args) =>
    editor.dispatch("BeforeGetContent", args);
  const fireGetContent = (editor, args) => editor.dispatch("GetContent", args);
  const fireAutocompleterStart = (editor, args) => {
    editor.dispatch("AutocompleterStart", args);
  };
  const fireAutocompleterUpdate = (editor, args) => {
    editor.dispatch("AutocompleterUpdate", args);
  };
  const fireAutocompleterUpdateActiveRange = (editor, args) => {
    editor.dispatch("AutocompleterUpdateActiveRange", args);
  };
  const fireAutocompleterEnd = (editor) => {
    editor.dispatch("AutocompleterEnd");
  };
  const firePastePreProcess = (editor, html, internal) =>
    editor.dispatch("PastePreProcess", {
      content: html,
      internal,
    });
  const firePastePostProcess = (editor, node, internal) =>
    editor.dispatch("PastePostProcess", {
      node,
      internal,
    });
  const firePastePlainTextToggle = (editor, state) =>
    editor.dispatch("PastePlainTextToggle", { state });
  const fireEditableRootStateChange = (editor, state) =>
    editor.dispatch("EditableRootStateChange", { state });
  const fireDisabledStateChange = (editor, state) =>
    editor.dispatch("DisabledStateChange", { state });

  const deviceDetection$1 = detect$1().deviceType;
  const isTouch = deviceDetection$1.isTouch();
  const DOM$a = DOMUtils.DOM;
  const getHash = (value) => {
    const items =
      value.indexOf("=") > 0
        ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/)
        : value.split(",");
    return foldl(
      items,
      (output, item) => {
        const arr = item.split("=");
        const key = arr[0];
        const val = arr.length > 1 ? arr[1] : key;
        output[trim$4(key)] = trim$4(val);
        return output;
      },
      {}
    );
  };
  const isRegExp = (x) => is$4(x, RegExp);
  const option = (name) => (editor) => editor.options.get(name);
  const stringOrObjectProcessor = (value) => isString(value) || isObject(value);
  const bodyOptionProcessor =
    (editor, defaultValue = "") =>
    (value) => {
      const valid = isString(value);
      if (valid) {
        if (value.indexOf("=") !== -1) {
          const bodyObj = getHash(value);
          return {
            value: get$a(bodyObj, editor.id).getOr(defaultValue),
            valid,
          };
        } else {
          return {
            value,
            valid,
          };
        }
      } else {
        return {
          valid: false,
          message: "Must be a string.",
        };
      }
    };
  const register$7 = (editor) => {
    const registerOption = editor.options.register;
    registerOption("id", {
      processor: "string",
      default: editor.id,
    });
    registerOption("selector", { processor: "string" });
    registerOption("target", { processor: "object" });
    registerOption("suffix", { processor: "string" });
    registerOption("cache_suffix", { processor: "string" });
    registerOption("base_url", { processor: "string" });
    registerOption("referrer_policy", {
      processor: "string",
      default: "",
    });
    registerOption("language_load", {
      processor: "boolean",
      default: true,
    });
    registerOption("inline", {
      processor: "boolean",
      default: false,
    });
    registerOption("iframe_attrs", {
      processor: "object",
      default: {},
    });
    registerOption("doctype", {
      processor: "string",
      default: "<!DOCTYPE html>",
    });
    registerOption("document_base_url", {
      processor: "string",
      default: editor.documentBaseUrl,
    });
    registerOption("body_id", {
      processor: bodyOptionProcessor(editor, "tinymce"),
      default: "tinymce",
    });
    registerOption("body_class", {
      processor: bodyOptionProcessor(editor),
      default: "",
    });
    registerOption("content_security_policy", {
      processor: "string",
      default: "",
    });
    registerOption("br_in_pre", {
      processor: "boolean",
      default: true,
    });
    registerOption("forced_root_block", {
      processor: (value) => {
        const valid = isString(value) && isNotEmpty(value);
        if (valid) {
          return {
            value,
            valid,
          };
        } else {
          return {
            valid: false,
            message: "Must be a non-empty string.",
          };
        }
      },
      default: "p",
    });
    registerOption("forced_root_block_attrs", {
      processor: "object",
      default: {},
    });
    registerOption("newline_behavior", {
      processor: (value) => {
        const valid = contains$2(
          ["block", "linebreak", "invert", "default"],
          value
        );
        return valid
          ? {
              value,
              valid,
            }
          : {
              valid: false,
              message: "Must be one of: block, linebreak, invert or default.",
            };
      },
      default: "default",
    });
    registerOption("br_newline_selector", {
      processor: "string",
      default: ".mce-toc h2,figcaption,caption",
    });
    registerOption("no_newline_selector", {
      processor: "string",
      default: "",
    });
    registerOption("keep_styles", {
      processor: "boolean",
      default: true,
    });
    registerOption("end_container_on_empty_block", {
      processor: (value) => {
        if (isBoolean(value)) {
          return {
            valid: true,
            value,
          };
        } else if (isString(value)) {
          return {
            valid: true,
            value,
          };
        } else {
          return {
            valid: false,
            message: "Must be boolean or a string",
          };
        }
      },
      default: "blockquote",
    });
    registerOption("font_size_style_values", {
      processor: "string",
      default: "xx-small,x-small,small,medium,large,x-large,xx-large",
    });
    registerOption("font_size_legacy_values", {
      processor: "string",
      default: "xx-small,small,medium,large,x-large,xx-large,300%",
    });
    registerOption("font_size_classes", {
      processor: "string",
      default: "",
    });
    registerOption("automatic_uploads", {
      processor: "boolean",
      default: true,
    });
    registerOption("images_reuse_filename", {
      processor: "boolean",
      default: false,
    });
    registerOption("images_replace_blob_uris", {
      processor: "boolean",
      default: true,
    });
    registerOption("icons", {
      processor: "string",
      default: "",
    });
    registerOption("icons_url", {
      processor: "string",
      default: "",
    });
    registerOption("images_upload_url", {
      processor: "string",
      default: "",
    });
    registerOption("images_upload_base_path", {
      processor: "string",
      default: "",
    });
    registerOption("images_upload_credentials", {
      processor: "boolean",
      default: false,
    });
    registerOption("images_upload_handler", { processor: "function" });
    registerOption("language", {
      processor: "string",
      default: "en",
    });
    registerOption("language_url", {
      processor: "string",
      default: "",
    });
    registerOption("entity_encoding", {
      processor: "string",
      default: "named",
    });
    registerOption("indent", {
      processor: "boolean",
      default: true,
    });
    registerOption("indent_before", {
      processor: "string",
      default:
        "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead," +
        "tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
    });
    registerOption("indent_after", {
      processor: "string",
      default:
        "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead," +
        "tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
    });
    registerOption("indent_use_margin", {
      processor: "boolean",
      default: false,
    });
    registerOption("indentation", {
      processor: "string",
      default: "40px",
    });
    registerOption("content_css", {
      processor: (value) => {
        const valid =
          value === false || isString(value) || isArrayOf(value, isString);
        if (valid) {
          if (isString(value)) {
            return {
              value: map$3(value.split(","), trim$4),
              valid,
            };
          } else if (isArray$1(value)) {
            return {
              value,
              valid,
            };
          } else if (value === false) {
            return {
              value: [],
              valid,
            };
          } else {
            return {
              value,
              valid,
            };
          }
        } else {
          return {
            valid: false,
            message: "Must be false, a string or an array of strings.",
          };
        }
      },
      default: isInline$1(editor) ? [] : ["default"],
    });
    registerOption("content_style", { processor: "string" });
    registerOption("content_css_cors", {
      processor: "boolean",
      default: false,
    });
    registerOption("font_css", {
      processor: (value) => {
        const valid = isString(value) || isArrayOf(value, isString);
        if (valid) {
          const newValue = isArray$1(value)
            ? value
            : map$3(value.split(","), trim$4);
          return {
            value: newValue,
            valid,
          };
        } else {
          return {
            valid: false,
            message: "Must be a string or an array of strings.",
          };
        }
      },
      default: [],
    });
    registerOption("inline_boundaries", {
      processor: "boolean",
      default: true,
    });
    registerOption("inline_boundaries_selector", {
      processor: "string",
      default: "a[href],code,span.mce-annotation",
    });
    registerOption("object_resizing", {
      processor: (value) => {
        const valid = isBoolean(value) || isString(value);
        if (valid) {
          if (
            value === false ||
            deviceDetection$1.isiPhone() ||
            deviceDetection$1.isiPad()
          ) {
            return {
              value: "",
              valid,
            };
          } else {
            return {
              value:
                value === true
                  ? "table,img,figure.image,div,video,iframe"
                  : value,
              valid,
            };
          }
        } else {
          return {
            valid: false,
            message: "Must be boolean or a string",
          };
        }
      },
      default: !isTouch,
    });
    registerOption("resize_img_proportional", {
      processor: "boolean",
      default: true,
    });
    registerOption("event_root", { processor: "string" });
    registerOption("service_message", { processor: "string" });
    registerOption("theme", {
      processor: (value) =>
        value === false || isString(value) || isFunction(value),
      default: "silver",
    });
    registerOption("theme_url", { processor: "string" });
    registerOption("formats", { processor: "object" });
    registerOption("format_empty_lines", {
      processor: "boolean",
      default: false,
    });
    registerOption("format_noneditable_selector", {
      processor: "string",
      default: "",
    });
    registerOption("preview_styles", {
      processor: (value) => {
        const valid = value === false || isString(value);
        if (valid) {
          return {
            value: value === false ? "" : value,
            valid,
          };
        } else {
          return {
            valid: false,
            message: "Must be false or a string",
          };
        }
      },
      default:
        "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow",
    });
    registerOption("custom_ui_selector", {
      processor: "string",
      default: "",
    });
    registerOption("hidden_input", {
      processor: "boolean",
      default: true,
    });
    registerOption("submit_patch", {
      processor: "boolean",
      default: true,
    });
    registerOption("encoding", { processor: "string" });
    registerOption("add_form_submit_trigger", {
      processor: "boolean",
      default: true,
    });
    registerOption("add_unload_trigger", {
      processor: "boolean",
      default: true,
    });
    registerOption("custom_undo_redo_levels", {
      processor: "number",
      default: 0,
    });
    registerOption("disable_nodechange", {
      processor: "boolean",
      default: false,
    });
    registerOption("disabled", {
      processor: (value) => {
        if (isBoolean(value)) {
          if (editor.initialized && isDisabled$1(editor) !== value) {
            Promise.resolve().then(() => {
              fireDisabledStateChange(editor, value);
            });
          }
          return {
            valid: true,
            value,
          };
        }
        return {
          valid: false,
          message: "The value must be a boolean.",
        };
      },
      default: false,
    });
    registerOption("readonly", {
      processor: "boolean",
      default: false,
    });
    registerOption("editable_root", {
      processor: "boolean",
      default: true,
    });
    registerOption("plugins", {
      processor: "string[]",
      default: [],
    });
    registerOption("external_plugins", { processor: "object" });
    registerOption("forced_plugins", { processor: "string[]" });
    registerOption("model", {
      processor: "string",
      default: editor.hasPlugin("rtc") ? "plugin" : "dom",
    });
    registerOption("model_url", { processor: "string" });
    registerOption("block_unsupported_drop", {
      processor: "boolean",
      default: true,
    });
    registerOption("visual", {
      processor: "boolean",
      default: true,
    });
    registerOption("visual_table_class", {
      processor: "string",
      default: "mce-item-table",
    });
    registerOption("visual_anchor_class", {
      processor: "string",
      default: "mce-item-anchor",
    });
    registerOption("iframe_aria_text", {
      processor: "string",
      default: "Rich Text Area".concat(
        editor.hasPlugin("help") ? ". Press ALT-0 for help." : ""
      ),
    });
    registerOption("setup", { processor: "function" });
    registerOption("init_instance_callback", { processor: "function" });
    registerOption("url_converter", {
      processor: "function",
      default: editor.convertURL,
    });
    registerOption("url_converter_scope", {
      processor: "object",
      default: editor,
    });
    registerOption("urlconverter_callback", { processor: "function" });
    registerOption("allow_conditional_comments", {
      processor: "boolean",
      default: false,
    });
    registerOption("allow_html_data_urls", {
      processor: "boolean",
      default: false,
    });
    registerOption("allow_svg_data_urls", { processor: "boolean" });
    registerOption("allow_html_in_named_anchor", {
      processor: "boolean",
      default: false,
    });
    registerOption("allow_script_urls", {
      processor: "boolean",
      default: false,
    });
    registerOption("allow_unsafe_link_target", {
      processor: "boolean",
      default: false,
    });
    registerOption("allow_mathml_annotation_encodings", {
      processor: (value) => {
        const valid = isArrayOf(value, isString);
        return valid
          ? {
              value,
              valid,
            }
          : {
              valid: false,
              message: "Must be an array of strings.",
            };
      },
      default: [],
    });
    registerOption("convert_fonts_to_spans", {
      processor: "boolean",
      default: true,
      deprecated: true,
    });
    registerOption("fix_list_elements", {
      processor: "boolean",
      default: false,
    });
    registerOption("preserve_cdata", {
      processor: "boolean",
      default: false,
    });
    registerOption("remove_trailing_brs", {
      processor: "boolean",
      default: true,
    });
    registerOption("pad_empty_with_br", {
      processor: "boolean",
      default: false,
    });
    registerOption("inline_styles", {
      processor: "boolean",
      default: true,
      deprecated: true,
    });
    registerOption("element_format", {
      processor: "string",
      default: "html",
    });
    registerOption("entities", { processor: "string" });
    registerOption("schema", {
      processor: "string",
      default: "html5",
    });
    registerOption("convert_urls", {
      processor: "boolean",
      default: true,
    });
    registerOption("relative_urls", {
      processor: "boolean",
      default: true,
    });
    registerOption("remove_script_host", {
      processor: "boolean",
      default: true,
    });
    registerOption("custom_elements", { processor: stringOrObjectProcessor });
    registerOption("extended_valid_elements", { processor: "string" });
    registerOption("invalid_elements", { processor: "string" });
    registerOption("invalid_styles", { processor: stringOrObjectProcessor });
    registerOption("valid_children", { processor: "string" });
    registerOption("valid_classes", { processor: stringOrObjectProcessor });
    registerOption("valid_elements", { processor: "string" });
    registerOption("valid_styles", { processor: stringOrObjectProcessor });
    registerOption("verify_html", {
      processor: "boolean",
      default: true,
    });
    registerOption("auto_focus", {
      processor: (value) => isString(value) || value === true,
    });
    registerOption("browser_spellcheck", {
      processor: "boolean",
      default: false,
    });
    registerOption("protect", { processor: "array" });
    registerOption("images_file_types", {
      processor: "string",
      default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp",
    });
    registerOption("deprecation_warnings", {
      processor: "boolean",
      default: true,
    });
    registerOption("a11y_advanced_options", {
      processor: "boolean",
      default: false,
    });
    registerOption("api_key", { processor: "string" });
    registerOption("license_key", { processor: "string" });
    registerOption("paste_block_drop", {
      processor: "boolean",
      default: false,
    });
    registerOption("paste_data_images", {
      processor: "boolean",
      default: true,
    });
    registerOption("paste_preprocess", { processor: "function" });
    registerOption("paste_postprocess", { processor: "function" });
    registerOption("paste_webkit_styles", {
      processor: "string",
      default: "none",
    });
    registerOption("paste_remove_styles_if_webkit", {
      processor: "boolean",
      default: true,
    });
    registerOption("paste_merge_formats", {
      processor: "boolean",
      default: true,
    });
    registerOption("smart_paste", {
      processor: "boolean",
      default: true,
    });
    registerOption("paste_as_text", {
      processor: "boolean",
      default: false,
    });
    registerOption("paste_tab_spaces", {
      processor: "number",
      default: 4,
    });
    registerOption("text_patterns", {
      processor: (value) => {
        if (isArrayOf(value, isObject) || value === false) {
          const patterns = value === false ? [] : value;
          return {
            value: fromRawPatterns(patterns),
            valid: true,
          };
        } else {
          return {
            valid: false,
            message: "Must be an array of objects or false.",
          };
        }
      },
      default: [
        {
          start: "*",
          end: "*",
          format: "italic",
        },
        {
          start: "**",
          end: "**",
          format: "bold",
        },
        {
          start: "#",
          format: "h1",
          trigger: "space",
        },
        {
          start: "##",
          format: "h2",
          trigger: "space",
        },
        {
          start: "###",
          format: "h3",
          trigger: "space",
        },
        {
          start: "####",
          format: "h4",
          trigger: "space",
        },
        {
          start: "#####",
          format: "h5",
          trigger: "space",
        },
        {
          start: "######",
          format: "h6",
          trigger: "space",
        },
        {
          start: "1.",
          cmd: "InsertOrderedList",
          trigger: "space",
        },
        {
          start: "*",
          cmd: "InsertUnorderedList",
          trigger: "space",
        },
        {
          start: "-",
          cmd: "InsertUnorderedList",
          trigger: "space",
        },
        {
          start: ">",
          cmd: "mceBlockQuote",
          trigger: "space",
        },
        {
          start: "---",
          cmd: "InsertHorizontalRule",
          trigger: "space",
        },
      ],
    });
    registerOption("text_patterns_lookup", {
      processor: (value) => {
        if (isFunction(value)) {
          return {
            value: fromRawPatternsLookup(value),
            valid: true,
          };
        } else {
          return {
            valid: false,
            message: "Must be a single function",
          };
        }
      },
      default: (_ctx) => [],
    });
    registerOption("noneditable_class", {
      processor: "string",
      default: "mceNonEditable",
    });
    registerOption("editable_class", {
      processor: "string",
      default: "mceEditable",
    });
    registerOption("noneditable_regexp", {
      processor: (value) => {
        if (isArrayOf(value, isRegExp)) {
          return {
            value,
            valid: true,
          };
        } else if (isRegExp(value)) {
          return {
            value: [value],
            valid: true,
          };
        } else {
          return {
            valid: false,
            message: "Must be a RegExp or an array of RegExp.",
          };
        }
      },
      default: [],
    });
    registerOption("table_tab_navigation", {
      processor: "boolean",
      default: true,
    });
    registerOption("highlight_on_focus", {
      processor: "boolean",
      default: true,
    });
    registerOption("xss_sanitization", {
      processor: "boolean",
      default: true,
    });
    registerOption("details_initial_state", {
      processor: (value) => {
        const valid = contains$2(["inherited", "collapsed", "expanded"], value);
        return valid
          ? {
              value,
              valid,
            }
          : {
              valid: false,
              message: "Must be one of: inherited, collapsed, or expanded.",
            };
      },
      default: "inherited",
    });
    registerOption("details_serialized_state", {
      processor: (value) => {
        const valid = contains$2(["inherited", "collapsed", "expanded"], value);
        return valid
          ? {
              value,
              valid,
            }
          : {
              valid: false,
              message: "Must be one of: inherited, collapsed, or expanded.",
            };
      },
      default: "inherited",
    });
    registerOption("init_content_sync", {
      processor: "boolean",
      default: false,
    });
    registerOption("newdocument_content", {
      processor: "string",
      default: "",
    });
    registerOption("sandbox_iframes", {
      processor: "boolean",
      default: true,
    });
    registerOption("sandbox_iframes_exclusions", {
      processor: "string[]",
      default: [
        "youtube.com",
        "youtu.be",
        "vimeo.com",
        "player.vimeo.com",
        "dailymotion.com",
        "embed.music.apple.com",
        "open.spotify.com",
        "giphy.com",
        "dai.ly",
        "codepen.io",
      ],
    });
    registerOption("convert_unsafe_embeds", {
      processor: "boolean",
      default: true,
    });
    editor.on("ScriptsLoaded", () => {
      registerOption("directionality", {
        processor: "string",
        default: I18n.isRtl() ? "rtl" : undefined,
      });
      registerOption("placeholder", {
        processor: "string",
        default: DOM$a.getAttrib(editor.getElement(), "placeholder"),
      });
    });
  };
  const getIframeAttrs = option("iframe_attrs");
  const getDocType = option("doctype");
  const getDocumentBaseUrl = option("document_base_url");
  const getBodyId = option("body_id");
  const getBodyClass = option("body_class");
  const getContentSecurityPolicy = option("content_security_policy");
  const shouldPutBrInPre$1 = option("br_in_pre");
  const getForcedRootBlock = option("forced_root_block");
  const getForcedRootBlockAttrs = option("forced_root_block_attrs");
  const getNewlineBehavior = option("newline_behavior");
  const getBrNewLineSelector = option("br_newline_selector");
  const getNoNewLineSelector = option("no_newline_selector");
  const shouldKeepStyles = option("keep_styles");
  const shouldEndContainerOnEmptyBlock = option("end_container_on_empty_block");
  const isAutomaticUploadsEnabled = option("automatic_uploads");
  const shouldReuseFileName = option("images_reuse_filename");
  const shouldReplaceBlobUris = option("images_replace_blob_uris");
  const getIconPackName = option("icons");
  const getIconsUrl = option("icons_url");
  const getImageUploadUrl = option("images_upload_url");
  const getImageUploadBasePath = option("images_upload_base_path");
  const getImagesUploadCredentials = option("images_upload_credentials");
  const getImagesUploadHandler = option("images_upload_handler");
  const shouldUseContentCssCors = option("content_css_cors");
  const getReferrerPolicy = option("referrer_policy");
  const getLanguageCode = option("language");
  const getLanguageUrl = option("language_url");
  const shouldIndentUseMargin = option("indent_use_margin");
  const getIndentation = option("indentation");
  const getContentCss = option("content_css");
  const getContentStyle = option("content_style");
  const getFontCss = option("font_css");
  const getDirectionality = option("directionality");
  const getInlineBoundarySelector = option("inline_boundaries_selector");
  const getObjectResizing = option("object_resizing");
  const getResizeImgProportional = option("resize_img_proportional");
  const getPlaceholder = option("placeholder");
  const getEventRoot = option("event_root");
  const getServiceMessage = option("service_message");
  const getTheme = option("theme");
  const getThemeUrl = option("theme_url");
  const getModel = option("model");
  const getModelUrl = option("model_url");
  const isInlineBoundariesEnabled = option("inline_boundaries");
  const getFormats = option("formats");
  const getPreviewStyles = option("preview_styles");
  const canFormatEmptyLines = option("format_empty_lines");
  const getFormatNoneditableSelector = option("format_noneditable_selector");
  const getCustomUiSelector = option("custom_ui_selector");
  const isInline$1 = option("inline");
  const hasHiddenInput = option("hidden_input");
  const shouldPatchSubmit = option("submit_patch");
  const shouldAddFormSubmitTrigger = option("add_form_submit_trigger");
  const shouldAddUnloadTrigger = option("add_unload_trigger");
  const getCustomUndoRedoLevels = option("custom_undo_redo_levels");
  const shouldDisableNodeChange = option("disable_nodechange");
  const isReadOnly$1 = option("readonly");
  const hasEditableRoot$1 = option("editable_root");
  const hasContentCssCors = option("content_css_cors");
  const getPlugins = option("plugins");
  const getExternalPlugins$1 = option("external_plugins");
  const shouldBlockUnsupportedDrop = option("block_unsupported_drop");
  const isVisualAidsEnabled = option("visual");
  const getVisualAidsTableClass = option("visual_table_class");
  const getVisualAidsAnchorClass = option("visual_anchor_class");
  const getIframeAriaText = option("iframe_aria_text");
  const getSetupCallback = option("setup");
  const getInitInstanceCallback = option("init_instance_callback");
  const getUrlConverterCallback = option("urlconverter_callback");
  const getAutoFocus = option("auto_focus");
  const shouldBrowserSpellcheck = option("browser_spellcheck");
  const getProtect = option("protect");
  const shouldPasteBlockDrop = option("paste_block_drop");
  const shouldPasteDataImages = option("paste_data_images");
  const getPastePreProcess = option("paste_preprocess");
  const getPastePostProcess = option("paste_postprocess");
  const getNewDocumentContent = option("newdocument_content");
  const getPasteWebkitStyles = option("paste_webkit_styles");
  const shouldPasteRemoveWebKitStyles = option("paste_remove_styles_if_webkit");
  const shouldPasteMergeFormats = option("paste_merge_formats");
  const isSmartPasteEnabled = option("smart_paste");
  const isPasteAsTextEnabled = option("paste_as_text");
  const getPasteTabSpaces = option("paste_tab_spaces");
  const shouldAllowHtmlDataUrls = option("allow_html_data_urls");
  const getTextPatterns = option("text_patterns");
  const getTextPatternsLookup = option("text_patterns_lookup");
  const getNonEditableClass = option("noneditable_class");
  const getEditableClass = option("editable_class");
  const getNonEditableRegExps = option("noneditable_regexp");
  const shouldPreserveCData = option("preserve_cdata");
  const shouldHighlightOnFocus = option("highlight_on_focus");
  const shouldSanitizeXss = option("xss_sanitization");
  const shouldUseDocumentWrite = option("init_content_sync");
  const hasTextPatternsLookup = (editor) =>
    editor.options.isSet("text_patterns_lookup");
  const getFontStyleValues = (editor) =>
    Tools.explode(editor.options.get("font_size_style_values"));
  const getFontSizeClasses = (editor) =>
    Tools.explode(editor.options.get("font_size_classes"));
  const isEncodingXml = (editor) => editor.options.get("encoding") === "xml";
  const getAllowedImageFileTypes = (editor) =>
    Tools.explode(editor.options.get("images_file_types"));
  const hasTableTabNavigation = option("table_tab_navigation");
  const getDetailsInitialState = option("details_initial_state");
  const getDetailsSerializedState = option("details_serialized_state");
  const shouldSandboxIframes = option("sandbox_iframes");
  const getSandboxIframesExclusions = (editor) =>
    editor.options.get("sandbox_iframes_exclusions");
  const shouldConvertUnsafeEmbeds = option("convert_unsafe_embeds");
  const getLicenseKey = option("license_key");
  const getApiKey = option("api_key");
  const isDisabled$1 = option("disabled");

  const isElement$3 = isElement$6;
  const isText$5 = isText$b;
  const removeNode$1 = (node) => {
    const parentNode = node.parentNode;
    if (parentNode) {
      parentNode.removeChild(node);
    }
  };
  const trimCount = (text) => {
    const trimmedText = trim$2(text);
    return {
      count: text.length - trimmedText.length,
      text: trimmedText,
    };
  };
  const deleteZwspChars = (caretContainer) => {
    let idx;
    while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
      caretContainer.deleteData(idx, 1);
    }
  };
  const removeUnchanged = (caretContainer, pos) => {
    remove$2(caretContainer);
    return pos;
  };
  const removeTextAndReposition = (caretContainer, pos) => {
    const before = trimCount(caretContainer.data.substr(0, pos.offset()));
    const after = trimCount(caretContainer.data.substr(pos.offset()));
    const text = before.text + after.text;
    if (text.length > 0) {
      deleteZwspChars(caretContainer);
      return CaretPosition(caretContainer, pos.offset() - before.count);
    } else {
      return pos;
    }
  };
  const removeElementAndReposition = (caretContainer, pos) => {
    const parentNode = pos.container();
    const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer)
      .map((index) => {
        return index < pos.offset()
          ? CaretPosition(parentNode, pos.offset() - 1)
          : pos;
      })
      .getOr(pos);
    remove$2(caretContainer);
    return newPosition;
  };
  const removeTextCaretContainer = (caretContainer, pos) =>
    isText$5(caretContainer) && pos.container() === caretContainer
      ? removeTextAndReposition(caretContainer, pos)
      : removeUnchanged(caretContainer, pos);
  const removeElementCaretContainer = (caretContainer, pos) =>
    pos.container() === caretContainer.parentNode
      ? removeElementAndReposition(caretContainer, pos)
      : removeUnchanged(caretContainer, pos);
  const removeAndReposition = (container, pos) =>
    CaretPosition.isTextPosition(pos)
      ? removeTextCaretContainer(container, pos)
      : removeElementCaretContainer(container, pos);
  const remove$2 = (caretContainerNode) => {
    if (
      isElement$3(caretContainerNode) &&
      isCaretContainer$2(caretContainerNode)
    ) {
      if (hasContent(caretContainerNode)) {
        caretContainerNode.removeAttribute("data-mce-caret");
      } else {
        removeNode$1(caretContainerNode);
      }
    }
    if (isText$5(caretContainerNode)) {
      deleteZwspChars(caretContainerNode);
      if (caretContainerNode.data.length === 0) {
        removeNode$1(caretContainerNode);
      }
    }
  };

  const isContentEditableFalse$8 = isContentEditableFalse$b;
  const isMedia$1 = isMedia$2;
  const isTableCell$1 = isTableCell$3;
  const inlineFakeCaretSelector =
    "*[contentEditable=false],video,audio,embed,object";
  const getAbsoluteClientRect = (root, element, before) => {
    const clientRect = collapse(element.getBoundingClientRect(), before);
    let scrollX;
    let scrollY;
    if (root.tagName === "BODY") {
      const docElm = root.ownerDocument.documentElement;
      scrollX = root.scrollLeft || docElm.scrollLeft;
      scrollY = root.scrollTop || docElm.scrollTop;
    } else {
      const rootRect = root.getBoundingClientRect();
      scrollX = root.scrollLeft - rootRect.left;
      scrollY = root.scrollTop - rootRect.top;
    }
    clientRect.left += scrollX;
    clientRect.right += scrollX;
    clientRect.top += scrollY;
    clientRect.bottom += scrollY;
    clientRect.width = 1;
    let margin = element.offsetWidth - element.clientWidth;
    if (margin > 0) {
      if (before) {
        margin *= -1;
      }
      clientRect.left += margin;
      clientRect.right += margin;
    }
    return clientRect;
  };
  const trimInlineCaretContainers = (root) => {
    var _a, _b;
    const fakeCaretTargetNodes = descendants(
      SugarElement.fromDom(root),
      inlineFakeCaretSelector
    );
    for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
      const node = fakeCaretTargetNodes[i].dom;
      let sibling = node.previousSibling;
      if (endsWithCaretContainer$1(sibling)) {
        const data = sibling.data;
        if (data.length === 1) {
          (_a = sibling.parentNode) === null || _a === void 0
            ? void 0
            : _a.removeChild(sibling);
        } else {
          sibling.deleteData(data.length - 1, 1);
        }
      }
      sibling = node.nextSibling;
      if (startsWithCaretContainer$1(sibling)) {
        const data = sibling.data;
        if (data.length === 1) {
          (_b = sibling.parentNode) === null || _b === void 0
            ? void 0
            : _b.removeChild(sibling);
        } else {
          sibling.deleteData(0, 1);
        }
      }
    }
  };
  const FakeCaret = (editor, root, isBlock, hasFocus) => {
    const lastVisualCaret = value$2();
    let cursorInterval;
    let caretContainerNode;
    const caretBlock = getForcedRootBlock(editor);
    const dom = editor.dom;
    const show = (before, element) => {
      let rng;
      hide();
      if (isTableCell$1(element)) {
        return null;
      }
      if (isBlock(element)) {
        const caretContainer = insertBlock(caretBlock, element, before);
        const clientRect = getAbsoluteClientRect(root, element, before);
        dom.setStyle(caretContainer, "top", clientRect.top);
        dom.setStyle(caretContainer, "caret-color", "transparent");
        caretContainerNode = caretContainer;
        const caret = dom.create("div", {
          class: "mce-visual-caret",
          "data-mce-bogus": "all",
        });
        dom.setStyles(caret, { ...clientRect });
        dom.add(root, caret);
        lastVisualCaret.set({
          caret,
          element,
          before,
        });
        if (before) {
          dom.addClass(caret, "mce-visual-caret-before");
        }
        startBlink();
        rng = element.ownerDocument.createRange();
        rng.setStart(caretContainer, 0);
        rng.setEnd(caretContainer, 0);
      } else {
        caretContainerNode = insertInline$1(element, before);
        rng = element.ownerDocument.createRange();
        if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
          rng.setStart(caretContainerNode, 0);
          rng.setEnd(caretContainerNode, 0);
        } else {
          rng.setStart(caretContainerNode, 1);
          rng.setEnd(caretContainerNode, 1);
        }
        return rng;
      }
      return rng;
    };
    const hide = () => {
      trimInlineCaretContainers(root);
      if (caretContainerNode) {
        remove$2(caretContainerNode);
        caretContainerNode = null;
      }
      lastVisualCaret.on((caretState) => {
        dom.remove(caretState.caret);
        lastVisualCaret.clear();
      });
      if (cursorInterval) {
        clearInterval(cursorInterval);
        cursorInterval = undefined;
      }
    };
    const startBlink = () => {
      cursorInterval = setInterval(() => {
        lastVisualCaret.on((caretState) => {
          if (hasFocus()) {
            dom.toggleClass(caretState.caret, "mce-visual-caret-hidden");
          } else {
            dom.addClass(caretState.caret, "mce-visual-caret-hidden");
          }
        });
      }, 500);
    };
    const reposition = () => {
      lastVisualCaret.on((caretState) => {
        const clientRect = getAbsoluteClientRect(
          root,
          caretState.element,
          caretState.before
        );
        dom.setStyles(caretState.caret, { ...clientRect });
      });
    };
    const destroy = () => clearInterval(cursorInterval);
    const getCss = () =>
      ".mce-visual-caret {" +
      "position: absolute;" +
      "background-color: black;" +
      "background-color: currentcolor;" +
      "}" +
      ".mce-visual-caret-hidden {" +
      "display: none;" +
      "}" +
      "*[data-mce-caret] {" +
      "position: absolute;" +
      "left: -1000px;" +
      "right: auto;" +
      "top: 0;" +
      "margin: 0;" +
      "padding: 0;" +
      "}";
    return {
      show,
      hide,
      getCss,
      reposition,
      destroy,
    };
  };
  const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
  const isInlineFakeCaretTarget = (node) =>
    isContentEditableFalse$8(node) || isMedia$1(node);
  const isFakeCaretTarget = (node) => {
    const isTarget =
      isInlineFakeCaretTarget(node) ||
      (isTable$2(node) && isFakeCaretTableBrowser());
    return (
      isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2)
    );
  };

  const isContentEditableTrue$1 = isContentEditableTrue$3;
  const isContentEditableFalse$7 = isContentEditableFalse$b;
  const isMedia = isMedia$2;
  const isBlockLike = matchStyleValues(
    "display",
    "block table table-cell table-row table-caption list-item"
  );
  const isCaretContainer = isCaretContainer$2;
  const isCaretContainerBlock = isCaretContainerBlock$1;
  const isElement$2 = isElement$6;
  const isText$4 = isText$b;
  const isCaretCandidate$1 = isCaretCandidate$3;
  const isForwards = (direction) => direction === 1;
  const isBackwards = (direction) => direction === -1;
  const skipCaretContainers = (walk, shallow) => {
    let node;
    while ((node = walk(shallow))) {
      if (!isCaretContainerBlock(node)) {
        return node;
      }
    }
    return null;
  };
  const findNode = (node, direction, predicateFn, rootNode, shallow) => {
    const walker = new DomTreeWalker(node, rootNode);
    const isCefOrCaretContainer =
      isContentEditableFalse$7(node) || isCaretContainerBlock(node);
    let tempNode;
    if (isBackwards(direction)) {
      if (isCefOrCaretContainer) {
        tempNode = skipCaretContainers(walker.prev.bind(walker), true);
        if (predicateFn(tempNode)) {
          return tempNode;
        }
      }
      while (
        (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow))
      ) {
        if (predicateFn(tempNode)) {
          return tempNode;
        }
      }
    }
    if (isForwards(direction)) {
      if (isCefOrCaretContainer) {
        tempNode = skipCaretContainers(walker.next.bind(walker), true);
        if (predicateFn(tempNode)) {
          return tempNode;
        }
      }
      while (
        (tempNode = skipCaretContainers(walker.next.bind(walker), shallow))
      ) {
        if (predicateFn(tempNode)) {
          return tempNode;
        }
      }
    }
    return null;
  };
  const getEditingHost = (node, rootNode) => {
    const isCETrue = (node) => isContentEditableTrue$1(node.dom);
    const isRoot = (node) => node.dom === rootNode;
    return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot)
      .map((elm) => elm.dom)
      .getOr(rootNode);
  };
  const getParentBlock$3 = (node, rootNode) => {
    while (node && node !== rootNode) {
      if (isBlockLike(node)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
  const isInSameBlock = (caretPosition1, caretPosition2, rootNode) =>
    getParentBlock$3(caretPosition1.container(), rootNode) ===
    getParentBlock$3(caretPosition2.container(), rootNode);
  const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
    if (!caretPosition) {
      return Optional.none();
    }
    const container = caretPosition.container();
    const offset = caretPosition.offset();
    if (!isElement$2(container)) {
      return Optional.none();
    }
    return Optional.from(container.childNodes[offset + relativeOffset]);
  };
  const beforeAfter = (before, node) => {
    var _a;
    const doc =
      (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
    const range = doc.createRange();
    if (before) {
      range.setStartBefore(node);
      range.setEndBefore(node);
    } else {
      range.setStartAfter(node);
      range.setEndAfter(node);
    }
    return range;
  };
  const isNodesInSameBlock = (root, node1, node2) =>
    getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
  const lean = (left, root, node) => {
    const siblingName = left ? "previousSibling" : "nextSibling";
    let tempNode = node;
    while (tempNode && tempNode !== root) {
      let sibling = tempNode[siblingName];
      if (sibling && isCaretContainer(sibling)) {
        sibling = sibling[siblingName];
      }
      if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {
        if (isNodesInSameBlock(root, sibling, tempNode)) {
          return sibling;
        }
        break;
      }
      if (isCaretCandidate$1(sibling)) {
        break;
      }
      tempNode = tempNode.parentNode;
    }
    return null;
  };
  const before$2 = curry(beforeAfter, true);
  const after$2 = curry(beforeAfter, false);
  const normalizeRange = (direction, root, range) => {
    let node;
    const leanLeft = curry(lean, true, root);
    const leanRight = curry(lean, false, root);
    const container = range.startContainer;
    const offset = range.startOffset;
    if (isCaretContainerBlock$1(container)) {
      const block = isText$4(container) ? container.parentNode : container;
      const location = block.getAttribute("data-mce-caret");
      if (location === "before") {
        node = block.nextSibling;
        if (isFakeCaretTarget(node)) {
          return before$2(node);
        }
      }
      if (location === "after") {
        node = block.previousSibling;
        if (isFakeCaretTarget(node)) {
          return after$2(node);
        }
      }
    }
    if (!range.collapsed) {
      return range;
    }
    if (isText$b(container)) {
      if (isCaretContainer(container)) {
        if (direction === 1) {
          node = leanRight(container);
          if (node) {
            return before$2(node);
          }
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
        }
        if (direction === -1) {
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
          node = leanRight(container);
          if (node) {
            return before$2(node);
          }
        }
        return range;
      }
      if (
        endsWithCaretContainer$1(container) &&
        offset >= container.data.length - 1
      ) {
        if (direction === 1) {
          node = leanRight(container);
          if (node) {
            return before$2(node);
          }
        }
        return range;
      }
      if (startsWithCaretContainer$1(container) && offset <= 1) {
        if (direction === -1) {
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
        }
        return range;
      }
      if (offset === container.data.length) {
        node = leanRight(container);
        if (node) {
          return before$2(node);
        }
        return range;
      }
      if (offset === 0) {
        node = leanLeft(container);
        if (node) {
          return after$2(node);
        }
        return range;
      }
    }
    return range;
  };
  const getRelativeCefElm = (forward, caretPosition) =>
    getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(
      isContentEditableFalse$7
    );
  const getNormalizedRangeEndPoint = (direction, root, range) => {
    const normalizedRange = normalizeRange(direction, root, range);
    return direction === -1
      ? CaretPosition.fromRangeStart(normalizedRange)
      : CaretPosition.fromRangeEnd(normalizedRange);
  };
  const getElementFromPosition = (pos) =>
    Optional.from(pos.getNode()).map(SugarElement.fromDom);
  const getElementFromPrevPosition = (pos) =>
    Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
  const getVisualCaretPosition = (walkFn, caretPosition) => {
    let pos = caretPosition;
    while ((pos = walkFn(pos))) {
      if (pos.isVisible()) {
        return pos;
      }
    }
    return pos;
  };
  const isMoveInsideSameBlock = (from, to) => {
    const inSameBlock = isInSameBlock(from, to);
    if (!inSameBlock && isBr$6(from.getNode())) {
      return true;
    }
    return inSameBlock;
  };

  const isContentEditableFalse$6 = isContentEditableFalse$b;
  const isText$3 = isText$b;
  const isElement$1 = isElement$6;
  const isBr$2 = isBr$6;
  const isCaretCandidate = isCaretCandidate$3;
  const isAtomic = isAtomic$1;
  const isEditableCaretCandidate = isEditableCaretCandidate$1;
  const getParents$3 = (node, root) => {
    const parents = [];
    let tempNode = node;
    while (tempNode && tempNode !== root) {
      parents.push(tempNode);
      tempNode = tempNode.parentNode;
    }
    return parents;
  };
  const nodeAtIndex = (container, offset) => {
    if (container.hasChildNodes() && offset < container.childNodes.length) {
      return container.childNodes[offset];
    }
    return null;
  };
  const getCaretCandidatePosition = (direction, node) => {
    if (isForwards(direction)) {
      if (
        isCaretCandidate(node.previousSibling) &&
        !isText$3(node.previousSibling)
      ) {
        return CaretPosition.before(node);
      }
      if (isText$3(node)) {
        return CaretPosition(node, 0);
      }
    }
    if (isBackwards(direction)) {
      if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
        return CaretPosition.after(node);
      }
      if (isText$3(node)) {
        return CaretPosition(node, node.data.length);
      }
    }
    if (isBackwards(direction)) {
      if (isBr$2(node)) {
        return CaretPosition.before(node);
      }
      return CaretPosition.after(node);
    }
    return CaretPosition.before(node);
  };
  const moveForwardFromBr = (root, nextNode) => {
    const nextSibling = nextNode.nextSibling;
    if (nextSibling && isCaretCandidate(nextSibling)) {
      if (isText$3(nextSibling)) {
        return CaretPosition(nextSibling, 0);
      } else {
        return CaretPosition.before(nextSibling);
      }
    } else {
      return findCaretPosition$1(1, CaretPosition.after(nextNode), root);
    }
  };
  const findCaretPosition$1 = (direction, startPos, root) => {
    let node;
    let nextNode;
    let innerNode;
    let caretPosition;
    if (!isElement$1(root) || !startPos) {
      return null;
    }
    if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
      caretPosition = CaretPosition.after(root.lastChild);
      if (
        isBackwards(direction) &&
        isCaretCandidate(root.lastChild) &&
        isElement$1(root.lastChild)
      ) {
        return isBr$2(root.lastChild)
          ? CaretPosition.before(root.lastChild)
          : caretPosition;
      }
    } else {
      caretPosition = startPos;
    }
    const container = caretPosition.container();
    let offset = caretPosition.offset();
    if (isText$3(container)) {
      if (isBackwards(direction) && offset > 0) {
        return CaretPosition(container, --offset);
      }
      if (isForwards(direction) && offset < container.length) {
        return CaretPosition(container, ++offset);
      }
      node = container;
    } else {
      if (isBackwards(direction) && offset > 0) {
        nextNode = nodeAtIndex(container, offset - 1);
        if (isCaretCandidate(nextNode)) {
          if (!isAtomic(nextNode)) {
            innerNode = findNode(
              nextNode,
              direction,
              isEditableCaretCandidate,
              nextNode
            );
            if (innerNode) {
              if (isText$3(innerNode)) {
                return CaretPosition(innerNode, innerNode.data.length);
              }
              return CaretPosition.after(innerNode);
            }
          }
          if (isText$3(nextNode)) {
            return CaretPosition(nextNode, nextNode.data.length);
          }
          return CaretPosition.before(nextNode);
        }
      }
      if (isForwards(direction) && offset < container.childNodes.length) {
        nextNode = nodeAtIndex(container, offset);
        if (isCaretCandidate(nextNode)) {
          if (isBr$2(nextNode)) {
            return moveForwardFromBr(root, nextNode);
          }
          if (!isAtomic(nextNode)) {
            innerNode = findNode(
              nextNode,
              direction,
              isEditableCaretCandidate,
              nextNode
            );
            if (innerNode) {
              if (isText$3(innerNode)) {
                return CaretPosition(innerNode, 0);
              }
              return CaretPosition.before(innerNode);
            }
          }
          if (isText$3(nextNode)) {
            return CaretPosition(nextNode, 0);
          }
          return CaretPosition.after(nextNode);
        }
      }
      node = nextNode ? nextNode : caretPosition.getNode();
    }
    if (
      node &&
      ((isForwards(direction) && caretPosition.isAtEnd()) ||
        (isBackwards(direction) && caretPosition.isAtStart()))
    ) {
      node = findNode(node, direction, always, root, true);
      if (isEditableCaretCandidate(node, root)) {
        return getCaretCandidatePosition(direction, node);
      }
    }
    nextNode = node
      ? findNode(node, direction, isEditableCaretCandidate, root)
      : node;
    const rootContentEditableFalseElm = last$1(
      filter$5(getParents$3(container, root), isContentEditableFalse$6)
    );
    if (
      rootContentEditableFalseElm &&
      (!nextNode || !rootContentEditableFalseElm.contains(nextNode))
    ) {
      if (isForwards(direction)) {
        caretPosition = CaretPosition.after(rootContentEditableFalseElm);
      } else {
        caretPosition = CaretPosition.before(rootContentEditableFalseElm);
      }
      return caretPosition;
    }
    if (nextNode) {
      return getCaretCandidatePosition(direction, nextNode);
    }
    return null;
  };
  const CaretWalker = (root) => ({
    next: (caretPosition) => {
      return findCaretPosition$1(1, caretPosition, root);
    },
    prev: (caretPosition) => {
      return findCaretPosition$1(-1, caretPosition, root);
    },
  });

  const walkToPositionIn = (forward, root, start) => {
    const position = forward
      ? CaretPosition.before(start)
      : CaretPosition.after(start);
    return fromPosition(forward, root, position);
  };
  const afterElement = (node) =>
    isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
  const isBeforeOrStart = (position) => {
    if (CaretPosition.isTextPosition(position)) {
      return position.offset() === 0;
    } else {
      return isCaretCandidate$3(position.getNode());
    }
  };
  const isAfterOrEnd = (position) => {
    if (CaretPosition.isTextPosition(position)) {
      const container = position.container();
      return position.offset() === container.data.length;
    } else {
      return isCaretCandidate$3(position.getNode(true));
    }
  };
  const isBeforeAfterSameElement = (from, to) =>
    !CaretPosition.isTextPosition(from) &&
    !CaretPosition.isTextPosition(to) &&
    from.getNode() === to.getNode(true);
  const isAtBr = (position) =>
    !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
  const shouldSkipPosition = (forward, from, to) => {
    if (forward) {
      return (
        !isBeforeAfterSameElement(from, to) &&
        !isAtBr(from) &&
        isAfterOrEnd(from) &&
        isBeforeOrStart(to)
      );
    } else {
      return (
        !isBeforeAfterSameElement(to, from) &&
        isBeforeOrStart(from) &&
        isAfterOrEnd(to)
      );
    }
  };
  const fromPosition = (forward, root, pos) => {
    const walker = CaretWalker(root);
    return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
  };
  const navigate = (forward, root, from) =>
    fromPosition(forward, root, from).bind((to) => {
      if (
        isInSameBlock(from, to, root) &&
        shouldSkipPosition(forward, from, to)
      ) {
        return fromPosition(forward, root, to);
      } else {
        return Optional.some(to);
      }
    });
  const navigateIgnore = (forward, root, from, ignoreFilter) =>
    navigate(forward, root, from).bind((pos) =>
      ignoreFilter(pos)
        ? navigateIgnore(forward, root, pos, ignoreFilter)
        : Optional.some(pos)
    );
  const positionIn = (forward, element) => {
    const startNode = forward ? element.firstChild : element.lastChild;
    if (isText$b(startNode)) {
      return Optional.some(
        CaretPosition(startNode, forward ? 0 : startNode.data.length)
      );
    } else if (startNode) {
      if (isCaretCandidate$3(startNode)) {
        return Optional.some(
          forward ? CaretPosition.before(startNode) : afterElement(startNode)
        );
      } else {
        return walkToPositionIn(forward, element, startNode);
      }
    } else {
      return Optional.none();
    }
  };
  const nextPosition = curry(fromPosition, true);
  const prevPosition = curry(fromPosition, false);
  const firstPositionIn = curry(positionIn, true);
  const lastPositionIn = curry(positionIn, false);

  const CARET_ID = "_mce_caret";
  const isCaretNode = (node) => isElement$6(node) && node.id === CARET_ID;
  const getParentCaretContainer = (body, node) => {
    let currentNode = node;
    while (currentNode && currentNode !== body) {
      if (isCaretNode(currentNode)) {
        return currentNode;
      }
      currentNode = currentNode.parentNode;
    }
    return null;
  };

  const isStringPathBookmark = (bookmark) => isString(bookmark.start);
  const isRangeBookmark = (bookmark) => has$2(bookmark, "rng");
  const isIdBookmark = (bookmark) => has$2(bookmark, "id");
  const isIndexBookmark = (bookmark) => has$2(bookmark, "name");
  const isPathBookmark = (bookmark) => Tools.isArray(bookmark.start);

  const isForwardBookmark = (bookmark) =>
    !isIndexBookmark(bookmark) && isBoolean(bookmark.forward)
      ? bookmark.forward
      : true;
  const addBogus = (dom, node) => {
    if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {
      node.innerHTML = '<br data-mce-bogus="1" />';
    }
    return node;
  };
  const resolveCaretPositionBookmark = (dom, bookmark) => {
    const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));
    const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));
    return lift2(startPos, endPos, (start, end) => {
      const range = dom.createRng();
      range.setStart(start.container(), start.offset());
      range.setEnd(end.container(), end.offset());
      return {
        range,
        forward: isForwardBookmark(bookmark),
      };
    });
  };
  const insertZwsp = (node, rng) => {
    var _a;
    const doc =
      (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
    const textNode = doc.createTextNode(ZWSP$1);
    node.appendChild(textNode);
    rng.setStart(textNode, 0);
    rng.setEnd(textNode, 0);
  };
  const isEmpty$1 = (node) => !node.hasChildNodes();
  const tryFindRangePosition = (node, rng) =>
    lastPositionIn(node).fold(never, (pos) => {
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      return true;
    });
  const padEmptyCaretContainer = (root, node, rng) => {
    if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
      insertZwsp(node, rng);
      return true;
    } else {
      return false;
    }
  };
  const setEndPoint = (dom, start, bookmark, rng) => {
    const point = bookmark[start ? "start" : "end"];
    const root = dom.getRoot();
    if (point) {
      let node = root;
      let offset = point[0];
      for (let i = point.length - 1; node && i >= 1; i--) {
        const children = node.childNodes;
        if (padEmptyCaretContainer(root, node, rng)) {
          return true;
        }
        if (point[i] > children.length - 1) {
          if (padEmptyCaretContainer(root, node, rng)) {
            return true;
          }
          return tryFindRangePosition(node, rng);
        }
        node = children[point[i]];
      }
      if (isText$b(node)) {
        offset = Math.min(point[0], node.data.length);
      }
      if (isElement$6(node)) {
        offset = Math.min(point[0], node.childNodes.length);
      }
      if (start) {
        rng.setStart(node, offset);
      } else {
        rng.setEnd(node, offset);
      }
    }
    return true;
  };
  const isValidTextNode = (node) => isText$b(node) && node.data.length > 0;
  const restoreEndPoint = (dom, suffix, bookmark) => {
    const marker = dom.get(bookmark.id + "_" + suffix);
    const markerParent =
      marker === null || marker === void 0 ? void 0 : marker.parentNode;
    const keep = bookmark.keep;
    if (marker && markerParent) {
      let container;
      let offset;
      if (suffix === "start") {
        if (!keep) {
          container = markerParent;
          offset = dom.nodeIndex(marker);
        } else {
          if (marker.hasChildNodes()) {
            container = marker.firstChild;
            offset = 1;
          } else if (isValidTextNode(marker.nextSibling)) {
            container = marker.nextSibling;
            offset = 0;
          } else if (isValidTextNode(marker.previousSibling)) {
            container = marker.previousSibling;
            offset = marker.previousSibling.data.length;
          } else {
            container = markerParent;
            offset = dom.nodeIndex(marker) + 1;
          }
        }
      } else {
        if (!keep) {
          container = markerParent;
          offset = dom.nodeIndex(marker);
        } else {
          if (marker.hasChildNodes()) {
            container = marker.firstChild;
            offset = 1;
          } else if (isValidTextNode(marker.previousSibling)) {
            container = marker.previousSibling;
            offset = marker.previousSibling.data.length;
          } else {
            container = markerParent;
            offset = dom.nodeIndex(marker);
          }
        }
      }
      if (!keep) {
        const prev = marker.previousSibling;
        const next = marker.nextSibling;
        Tools.each(Tools.grep(marker.childNodes), (node) => {
          if (isText$b(node)) {
            node.data = node.data.replace(/\uFEFF/g, "");
          }
        });
        let otherMarker;
        while ((otherMarker = dom.get(bookmark.id + "_" + suffix))) {
          dom.remove(otherMarker, true);
        }
        if (isText$b(next) && isText$b(prev) && !Env.browser.isOpera()) {
          const idx = prev.data.length;
          prev.appendData(next.data);
          dom.remove(next);
          container = prev;
          offset = idx;
        }
      }
      return Optional.some(CaretPosition(container, offset));
    } else {
      return Optional.none();
    }
  };
  const resolvePaths = (dom, bookmark) => {
    const range = dom.createRng();
    if (
      setEndPoint(dom, true, bookmark, range) &&
      setEndPoint(dom, false, bookmark, range)
    ) {
      return Optional.some({
        range,
        forward: isForwardBookmark(bookmark),
      });
    } else {
      return Optional.none();
    }
  };
  const resolveId = (dom, bookmark) => {
    const startPos = restoreEndPoint(dom, "start", bookmark);
    const endPos = restoreEndPoint(dom, "end", bookmark);
    return lift2(startPos, endPos.or(startPos), (spos, epos) => {
      const range = dom.createRng();
      range.setStart(addBogus(dom, spos.container()), spos.offset());
      range.setEnd(addBogus(dom, epos.container()), epos.offset());
      return {
        range,
        forward: isForwardBookmark(bookmark),
      };
    });
  };
  const resolveIndex = (dom, bookmark) =>
    Optional.from(dom.select(bookmark.name)[bookmark.index]).map((elm) => {
      const range = dom.createRng();
      range.selectNode(elm);
      return {
        range,
        forward: true,
      };
    });
  const resolve = (selection, bookmark) => {
    const dom = selection.dom;
    if (bookmark) {
      if (isPathBookmark(bookmark)) {
        return resolvePaths(dom, bookmark);
      } else if (isStringPathBookmark(bookmark)) {
        return resolveCaretPositionBookmark(dom, bookmark);
      } else if (isIdBookmark(bookmark)) {
        return resolveId(dom, bookmark);
      } else if (isIndexBookmark(bookmark)) {
        return resolveIndex(dom, bookmark);
      } else if (isRangeBookmark(bookmark)) {
        return Optional.some({
          range: bookmark.rng,
          forward: isForwardBookmark(bookmark),
        });
      }
    }
    return Optional.none();
  };

  const getBookmark$2 = (selection, type, normalized) => {
    return getBookmark$3(selection, type, normalized);
  };
  const moveToBookmark = (selection, bookmark) => {
    resolve(selection, bookmark).each(({ range, forward }) => {
      selection.setRng(range, forward);
    });
  };
  const isBookmarkNode$1 = (node) => {
    return (
      isElement$6(node) &&
      node.tagName === "SPAN" &&
      node.getAttribute("data-mce-type") === "bookmark"
    );
  };

  const is = (expected) => (actual) => expected === actual;
  const isNbsp = is(nbsp);
  const isWhiteSpace = (chr) =>
    chr !== "" && " \f\n\r\t\x0B".indexOf(chr) !== -1;
  const isContent = (chr) =>
    !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);

  const getRanges$1 = (selection) => {
    const ranges = [];
    if (selection) {
      for (let i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
    }
    return ranges;
  };
  const getSelectedNodes = (ranges) => {
    return bind$3(ranges, (range) => {
      const node = getSelectedNode(range);
      return node ? [SugarElement.fromDom(node)] : [];
    });
  };
  const hasMultipleRanges = (selection) => {
    return getRanges$1(selection).length > 1;
  };

  const getCellsFromRanges = (ranges) =>
    filter$5(getSelectedNodes(ranges), isTableCell$2);
  const getCellsFromElement = (elm) =>
    descendants(elm, "td[data-mce-selected],th[data-mce-selected]");
  const getCellsFromElementOrRanges = (ranges, element) => {
    const selectedCells = getCellsFromElement(element);
    return selectedCells.length > 0
      ? selectedCells
      : getCellsFromRanges(ranges);
  };
  const getCellsFromEditor = (editor) =>
    getCellsFromElementOrRanges(
      getRanges$1(editor.selection.getSel()),
      SugarElement.fromDom(editor.getBody())
    );
  const getClosestTable = (cell, isRoot) => ancestor$3(cell, "table", isRoot);

  const getStartNode = (rng) => {
    const sc = rng.startContainer,
      so = rng.startOffset;
    if (isText$b(sc)) {
      return so === 0
        ? Optional.some(SugarElement.fromDom(sc))
        : Optional.none();
    } else {
      return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
    }
  };
  const getEndNode = (rng) => {
    const ec = rng.endContainer,
      eo = rng.endOffset;
    if (isText$b(ec)) {
      return eo === ec.data.length
        ? Optional.some(SugarElement.fromDom(ec))
        : Optional.none();
    } else {
      return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
    }
  };
  const getFirstChildren = (node) => {
    return firstChild(node).fold(constant([node]), (child) => {
      return [node].concat(getFirstChildren(child));
    });
  };
  const getLastChildren = (node) => {
    return lastChild(node).fold(constant([node]), (child) => {
      if (name(child) === "br") {
        return prevSibling(child)
          .map((sibling) => {
            return [node].concat(getLastChildren(sibling));
          })
          .getOr([]);
      } else {
        return [node].concat(getLastChildren(child));
      }
    });
  };
  const hasAllContentsSelected = (elm, rng) => {
    return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
      const start = find$2(getFirstChildren(elm), curry(eq, startNode));
      const end = find$2(getLastChildren(elm), curry(eq, endNode));
      return start.isSome() && end.isSome();
    }).getOr(false);
  };
  const moveEndPoint = (dom, rng, node, start) => {
    const root = node;
    const walker = new DomTreeWalker(node, root);
    const moveCaretBeforeOnEnterElementsMap = filter$4(
      dom.schema.getMoveCaretBeforeOnEnterElements(),
      (_, name) => !contains$2(["td", "th", "table"], name.toLowerCase())
    );
    let currentNode = node;
    do {
      if (isText$b(currentNode) && Tools.trim(currentNode.data).length !== 0) {
        if (start) {
          rng.setStart(currentNode, 0);
        } else {
          rng.setEnd(currentNode, currentNode.data.length);
        }
        return;
      }
      if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
        if (start) {
          rng.setStartBefore(currentNode);
        } else {
          if (currentNode.nodeName === "BR") {
            rng.setEndBefore(currentNode);
          } else {
            rng.setEndAfter(currentNode);
          }
        }
        return;
      }
    } while ((currentNode = start ? walker.next() : walker.prev()));
    if (root.nodeName === "BODY") {
      if (start) {
        rng.setStart(root, 0);
      } else {
        rng.setEnd(root, root.childNodes.length);
      }
    }
  };
  const hasAnyRanges = (editor) => {
    const sel = editor.selection.getSel();
    return isNonNullable(sel) && sel.rangeCount > 0;
  };
  const runOnRanges = (editor, executor) => {
    const fakeSelectionNodes = getCellsFromEditor(editor);
    if (fakeSelectionNodes.length > 0) {
      each$e(fakeSelectionNodes, (elem) => {
        const node = elem.dom;
        const fakeNodeRng = editor.dom.createRng();
        fakeNodeRng.setStartBefore(node);
        fakeNodeRng.setEndAfter(node);
        executor(fakeNodeRng, true);
      });
    } else {
      executor(editor.selection.getRng(), false);
    }
  };
  const preserve = (selection, fillBookmark, executor) => {
    const bookmark = getPersistentBookmark(selection, fillBookmark);
    executor(bookmark);
    selection.moveToBookmark(bookmark);
  };

  const isNode = (node) =>
    isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
  const isElementNode$1 = (node) =>
    isElement$6(node) &&
    !isBookmarkNode$1(node) &&
    !isCaretNode(node) &&
    !isBogus$1(node);
  const isElementDirectlySelected = (dom, node) => {
    if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
      const selectedAttr = dom.getAttrib(node, "data-mce-selected");
      const value = parseInt(selectedAttr, 10);
      return !isNaN(value) && value > 0;
    } else {
      return false;
    }
  };
  const preserveSelection = (editor, action, shouldMoveStart) => {
    const { selection, dom } = editor;
    const selectedNodeBeforeAction = selection.getNode();
    const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(
      selectedNodeBeforeAction
    );
    preserve(selection, true, () => {
      action();
    });
    const isBeforeNodeStillNoneditable =
      isSelectedBeforeNodeNoneditable &&
      isContentEditableFalse$b(selectedNodeBeforeAction);
    if (
      isBeforeNodeStillNoneditable &&
      dom.isChildOf(selectedNodeBeforeAction, editor.getBody())
    ) {
      editor.selection.select(selectedNodeBeforeAction);
    } else if (shouldMoveStart(selection.getStart())) {
      moveStartToNearestText(dom, selection);
    }
  };
  const moveStartToNearestText = (dom, selection) => {
    var _a, _b;
    const rng = selection.getRng();
    const { startContainer, startOffset } = rng;
    const selectedNode = selection.getNode();
    if (isElementDirectlySelected(dom, selectedNode)) {
      return;
    }
    if (isElement$6(startContainer)) {
      const nodes = startContainer.childNodes;
      const root = dom.getRoot();
      let walker;
      if (startOffset < nodes.length) {
        const startNode = nodes[startOffset];
        walker = new DomTreeWalker(
          startNode,
          (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0
            ? _a
            : root
        );
      } else {
        const startNode = nodes[nodes.length - 1];
        walker = new DomTreeWalker(
          startNode,
          (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0
            ? _b
            : root
        );
        walker.next(true);
      }
      for (let node = walker.current(); node; node = walker.next()) {
        if (dom.getContentEditable(node) === "false") {
          return;
        } else if (isText$b(node) && !isWhiteSpaceNode$1(node)) {
          rng.setStart(node, 0);
          selection.setRng(rng);
          return;
        }
      }
    }
  };
  const getNonWhiteSpaceSibling = (node, next, inc) => {
    if (node) {
      const nextName = next ? "nextSibling" : "previousSibling";
      for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
        if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {
          return node;
        }
      }
    }
    return undefined;
  };
  const isTextBlock$1 = (schema, node) =>
    !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] ||
    isTransparentBlock(schema, node);
  const isValid = (ed, parent, child) => {
    return ed.schema.isValidChild(parent, child);
  };
  const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
    if (isNonNullable(node) && isText$b(node)) {
      const data = allowSpaces ? node.data.replace(/ /g, "\xA0") : node.data;
      return isWhitespaceText(data);
    } else {
      return false;
    }
  };
  const isEmptyTextNode$1 = (node) => {
    return isNonNullable(node) && isText$b(node) && node.length === 0;
  };
  const isWrapNoneditableTarget = (editor, node) => {
    const baseDataSelector = "[data-mce-cef-wrappable]";
    const formatNoneditableSelector = getFormatNoneditableSelector(editor);
    const selector = isEmpty$3(formatNoneditableSelector)
      ? baseDataSelector
      : `${baseDataSelector},${formatNoneditableSelector}`;
    return is$1(SugarElement.fromDom(node), selector);
  };
  const isWrappableNoneditable = (editor, node) => {
    const dom = editor.dom;
    return (
      isElementNode$1(node) &&
      dom.getContentEditable(node) === "false" &&
      isWrapNoneditableTarget(editor, node) &&
      dom.select('[contenteditable="true"]', node).length === 0
    );
  };
  const replaceVars = (value, vars) => {
    if (isFunction(value)) {
      return value(vars);
    } else if (isNonNullable(vars)) {
      value = value.replace(/%(\w+)/g, (str, name) => {
        return vars[name] || str;
      });
    }
    return value;
  };
  const isEq$5 = (str1, str2) => {
    str1 = str1 || "";
    str2 = str2 || "";
    str1 = "" + (str1.nodeName || str1);
    str2 = "" + (str2.nodeName || str2);
    return str1.toLowerCase() === str2.toLowerCase();
  };
  const normalizeStyleValue = (value, name) => {
    if (isNullable(value)) {
      return null;
    } else {
      let strValue = String(value);
      if (name === "color" || name === "backgroundColor") {
        strValue = rgbaToHexString(strValue);
      }
      if (name === "fontWeight" && value === 700) {
        strValue = "bold";
      }
      if (name === "fontFamily") {
        strValue = strValue.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
      }
      return strValue;
    }
  };
  const getStyle = (dom, node, name) => {
    const style = dom.getStyle(node, name);
    return normalizeStyleValue(style, name);
  };
  const getTextDecoration = (dom, node) => {
    let decoration;
    dom.getParent(node, (n) => {
      if (isElement$6(n)) {
        decoration = dom.getStyle(n, "text-decoration");
        return !!decoration && decoration !== "none";
      } else {
        return false;
      }
    });
    return decoration;
  };
  const getParents$2 = (dom, node, selector) => {
    return dom.getParents(node, selector, dom.getRoot());
  };
  const isFormatPredicate = (editor, formatName, predicate) => {
    const formats = editor.formatter.get(formatName);
    return isNonNullable(formats) && exists(formats, predicate);
  };
  const isVariableFormatName = (editor, formatName) => {
    const hasVariableValues = (format) => {
      const isVariableValue = (val) =>
        isFunction(val) || (val.length > 1 && val.charAt(0) === "%");
      return exists(["styles", "attributes"], (key) =>
        get$a(format, key).exists((field) => {
          const fieldValues = isArray$1(field) ? field : values(field);
          return exists(fieldValues, isVariableValue);
        })
      );
    };
    return isFormatPredicate(editor, formatName, hasVariableValues);
  };
  const areSimilarFormats = (editor, formatName, otherFormatName) => {
    const validKeys = [
      "inline",
      "block",
      "selector",
      "attributes",
      "styles",
      "classes",
    ];
    const filterObj = (format) =>
      filter$4(format, (_, key) =>
        exists(validKeys, (validKey) => validKey === key)
      );
    return isFormatPredicate(editor, formatName, (fmt1) => {
      const filteredFmt1 = filterObj(fmt1);
      return isFormatPredicate(editor, otherFormatName, (fmt2) => {
        const filteredFmt2 = filterObj(fmt2);
        return equal$1(filteredFmt1, filteredFmt2);
      });
    });
  };
  const isBlockFormat = (format) => hasNonNullableKey(format, "block");
  const isWrappingBlockFormat = (format) =>
    isBlockFormat(format) && format.wrapper === true;
  const isNonWrappingBlockFormat = (format) =>
    isBlockFormat(format) && format.wrapper !== true;
  const isSelectorFormat = (format) => hasNonNullableKey(format, "selector");
  const isInlineFormat = (format) => hasNonNullableKey(format, "inline");
  const isMixedFormat = (format) =>
    isSelectorFormat(format) &&
    isInlineFormat(format) &&
    is$2(get$a(format, "mixed"), true);
  const shouldExpandToSelector = (format) =>
    isSelectorFormat(format) &&
    format.expand !== false &&
    !isInlineFormat(format);
  const getEmptyCaretContainers = (node) => {
    const nodes = [];
    let tempNode = node;
    while (tempNode) {
      if (
        (isText$b(tempNode) && tempNode.data !== ZWSP$1) ||
        tempNode.childNodes.length > 1
      ) {
        return [];
      }
      if (isElement$6(tempNode)) {
        nodes.push(tempNode);
      }
      tempNode = tempNode.firstChild;
    }
    return nodes;
  };
  const isCaretContainerEmpty = (node) => {
    return getEmptyCaretContainers(node).length > 0;
  };
  const isEmptyCaretFormatElement = (element) => {
    return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
  };

  const isBookmarkNode = isBookmarkNode$1;
  const getParents$1 = getParents$2;
  const isWhiteSpaceNode = isWhiteSpaceNode$1;
  const isTextBlock = isTextBlock$1;
  const isBogusBr = (node) => {
    return (
      isBr$6(node) && node.getAttribute("data-mce-bogus") && !node.nextSibling
    );
  };
  const findParentContentEditable = (dom, node) => {
    let parent = node;
    while (parent) {
      if (isElement$6(parent) && dom.getContentEditable(parent)) {
        return dom.getContentEditable(parent) === "false" ? parent : node;
      }
      parent = parent.parentNode;
    }
    return node;
  };
  const walkText = (start, node, offset, predicate) => {
    const str = node.data;
    if (start) {
      for (let i = offset; i > 0; i--) {
        if (predicate(str.charAt(i - 1))) {
          return i;
        }
      }
    } else {
      for (let i = offset; i < str.length; i++) {
        if (predicate(str.charAt(i))) {
          return i;
        }
      }
    }
    return -1;
  };
  const findSpace = (start, node, offset) =>
    walkText(start, node, offset, (c) => isNbsp(c) || isWhiteSpace(c));
  const findContent = (start, node, offset) =>
    walkText(start, node, offset, isContent);
  const findWordEndPoint = (
    dom,
    body,
    container,
    offset,
    start,
    includeTrailingSpaces
  ) => {
    let lastTextNode;
    const closestRoot = dom.getParent(
      container,
      (node) => isEditingHost(node) || dom.isBlock(node)
    );
    const rootNode = isNonNullable(closestRoot) ? closestRoot : body;
    const walk = (container, offset, pred) => {
      const textSeeker = TextSeeker(dom);
      const walker = start ? textSeeker.backwards : textSeeker.forwards;
      return Optional.from(
        walker(
          container,
          offset,
          (text, textOffset) => {
            if (isBookmarkNode(text.parentNode)) {
              return -1;
            } else {
              lastTextNode = text;
              return pred(start, text, textOffset);
            }
          },
          rootNode
        )
      );
    };
    const spaceResult = walk(container, offset, findSpace);
    return spaceResult
      .bind((result) =>
        includeTrailingSpaces
          ? walk(
              result.container,
              result.offset + (start ? -1 : 0),
              findContent
            )
          : Optional.some(result)
      )
      .orThunk(() =>
        lastTextNode
          ? Optional.some({
              container: lastTextNode,
              offset: start ? 0 : lastTextNode.length,
            })
          : Optional.none()
      );
  };
  const findSelectorEndPoint = (
    dom,
    formatList,
    rng,
    container,
    siblingName
  ) => {
    const sibling = container[siblingName];
    if (isText$b(container) && isEmpty$3(container.data) && sibling) {
      container = sibling;
    }
    const parents = getParents$1(dom, container);
    for (let i = 0; i < parents.length; i++) {
      for (let y = 0; y < formatList.length; y++) {
        const curFormat = formatList[y];
        if (
          isNonNullable(curFormat.collapsed) &&
          curFormat.collapsed !== rng.collapsed
        ) {
          continue;
        }
        if (
          isSelectorFormat(curFormat) &&
          dom.is(parents[i], curFormat.selector)
        ) {
          return parents[i];
        }
      }
    }
    return container;
  };
  const findBlockEndPoint = (dom, formatList, container, siblingName) => {
    var _a;
    let node = container;
    const root = dom.getRoot();
    const format = formatList[0];
    if (isBlockFormat(format)) {
      node = format.wrapper
        ? null
        : dom.getParent(container, format.block, root);
    }
    if (!node) {
      const scopeRoot =
        (_a = dom.getParent(container, "LI,TD,TH,SUMMARY")) !== null &&
        _a !== void 0
          ? _a
          : root;
      node = dom.getParent(
        isText$b(container) ? container.parentNode : container,
        (node) => node !== root && isTextBlock(dom.schema, node),
        scopeRoot
      );
    }
    if (node && isBlockFormat(format) && format.wrapper) {
      node = getParents$1(dom, node, "ul,ol").reverse()[0] || node;
    }
    if (!node) {
      node = container;
      while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {
        node = node[siblingName];
        if (isEq$5(node, "br")) {
          break;
        }
      }
    }
    return node || container;
  };
  const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {
    const parent = container.parentNode;
    if (isNonNullable(container[siblingName])) {
      return false;
    } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {
      return true;
    } else {
      return isAtBlockBoundary$1(dom, root, parent, siblingName);
    }
  };
  const findParentContainer = (
    dom,
    formatList,
    container,
    offset,
    start,
    expandToBlock
  ) => {
    let parent = container;
    const siblingName = start ? "previousSibling" : "nextSibling";
    const root = dom.getRoot();
    if (isText$b(container) && !isWhiteSpaceNode(container)) {
      if (start ? offset > 0 : offset < container.data.length) {
        return container;
      }
    }
    while (parent) {
      if (isEditingHost(parent)) {
        return container;
      }
      if (!formatList[0].block_expand && dom.isBlock(parent)) {
        return expandToBlock ? parent : container;
      }
      for (
        let sibling = parent[siblingName];
        sibling;
        sibling = sibling[siblingName]
      ) {
        const allowSpaces =
          isText$b(sibling) &&
          !isAtBlockBoundary$1(dom, root, sibling, siblingName);
        if (
          !isBookmarkNode(sibling) &&
          !isBogusBr(sibling) &&
          !isWhiteSpaceNode(sibling, allowSpaces)
        ) {
          return parent;
        }
      }
      if (parent === root || parent.parentNode === root) {
        container = parent;
        break;
      }
      parent = parent.parentNode;
    }
    return container;
  };
  const isSelfOrParentBookmark = (container) =>
    isBookmarkNode(container.parentNode) || isBookmarkNode(container);
  const expandRng = (dom, rng, formatList, expandOptions = {}) => {
    const { includeTrailingSpace = false, expandToBlock = true } =
      expandOptions;
    const editableHost = dom.getParent(rng.commonAncestorContainer, (node) =>
      isEditingHost(node)
    );
    const root = isNonNullable(editableHost) ? editableHost : dom.getRoot();
    let { startContainer, startOffset, endContainer, endOffset } = rng;
    const format = formatList[0];
    if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
      startContainer = getNode$1(startContainer, startOffset);
      if (isText$b(startContainer)) {
        startOffset = 0;
      }
    }
    if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
      endContainer = getNode$1(
        endContainer,
        rng.collapsed ? endOffset : endOffset - 1
      );
      if (isText$b(endContainer)) {
        endOffset = endContainer.data.length;
      }
    }
    startContainer = findParentContentEditable(dom, startContainer);
    endContainer = findParentContentEditable(dom, endContainer);
    if (isSelfOrParentBookmark(startContainer)) {
      startContainer = isBookmarkNode(startContainer)
        ? startContainer
        : startContainer.parentNode;
      if (rng.collapsed) {
        startContainer = startContainer.previousSibling || startContainer;
      } else {
        startContainer = startContainer.nextSibling || startContainer;
      }
      if (isText$b(startContainer)) {
        startOffset = rng.collapsed ? startContainer.length : 0;
      }
    }
    if (isSelfOrParentBookmark(endContainer)) {
      endContainer = isBookmarkNode(endContainer)
        ? endContainer
        : endContainer.parentNode;
      if (rng.collapsed) {
        endContainer = endContainer.nextSibling || endContainer;
      } else {
        endContainer = endContainer.previousSibling || endContainer;
      }
      if (isText$b(endContainer)) {
        endOffset = rng.collapsed ? 0 : endContainer.length;
      }
    }
    if (rng.collapsed) {
      const startPoint = findWordEndPoint(
        dom,
        root,
        startContainer,
        startOffset,
        true,
        includeTrailingSpace
      );
      startPoint.each(({ container, offset }) => {
        startContainer = container;
        startOffset = offset;
      });
      const endPoint = findWordEndPoint(
        dom,
        root,
        endContainer,
        endOffset,
        false,
        includeTrailingSpace
      );
      endPoint.each(({ container, offset }) => {
        endContainer = container;
        endOffset = offset;
      });
    }
    if (isInlineFormat(format) || format.block_expand) {
      if (
        !isInlineFormat(format) ||
        !isText$b(startContainer) ||
        startOffset === 0
      ) {
        startContainer = findParentContainer(
          dom,
          formatList,
          startContainer,
          startOffset,
          true,
          expandToBlock
        );
      }
      if (
        !isInlineFormat(format) ||
        !isText$b(endContainer) ||
        endOffset === endContainer.data.length
      ) {
        endContainer = findParentContainer(
          dom,
          formatList,
          endContainer,
          endOffset,
          false,
          expandToBlock
        );
      }
    }
    if (shouldExpandToSelector(format)) {
      startContainer = findSelectorEndPoint(
        dom,
        formatList,
        rng,
        startContainer,
        "previousSibling"
      );
      endContainer = findSelectorEndPoint(
        dom,
        formatList,
        rng,
        endContainer,
        "nextSibling"
      );
    }
    if (isBlockFormat(format) || isSelectorFormat(format)) {
      startContainer = findBlockEndPoint(
        dom,
        formatList,
        startContainer,
        "previousSibling"
      );
      endContainer = findBlockEndPoint(
        dom,
        formatList,
        endContainer,
        "nextSibling"
      );
      if (isBlockFormat(format)) {
        if (!dom.isBlock(startContainer)) {
          startContainer = findParentContainer(
            dom,
            formatList,
            startContainer,
            startOffset,
            true,
            expandToBlock
          );
          if (isText$b(startContainer)) {
            startOffset = 0;
          }
        }
        if (!dom.isBlock(endContainer)) {
          endContainer = findParentContainer(
            dom,
            formatList,
            endContainer,
            endOffset,
            false,
            expandToBlock
          );
          if (isText$b(endContainer)) {
            endOffset = endContainer.data.length;
          }
        }
      }
    }
    if (isElement$6(startContainer) && startContainer.parentNode) {
      startOffset = dom.nodeIndex(startContainer);
      startContainer = startContainer.parentNode;
    }
    if (isElement$6(endContainer) && endContainer.parentNode) {
      endOffset = dom.nodeIndex(endContainer) + 1;
      endContainer = endContainer.parentNode;
    }
    return {
      startContainer,
      startOffset,
      endContainer,
      endOffset,
    };
  };

  const walk$3 = (dom, rng, callback) => {
    var _a;
    const startOffset = rng.startOffset;
    const startContainer = getNode$1(rng.startContainer, startOffset);
    const endOffset = rng.endOffset;
    const endContainer = getNode$1(rng.endContainer, endOffset - 1);
    const exclude = (nodes) => {
      const firstNode = nodes[0];
      if (
        isText$b(firstNode) &&
        firstNode === startContainer &&
        startOffset >= firstNode.data.length
      ) {
        nodes.splice(0, 1);
      }
      const lastNode = nodes[nodes.length - 1];
      if (
        endOffset === 0 &&
        nodes.length > 0 &&
        lastNode === endContainer &&
        isText$b(lastNode)
      ) {
        nodes.splice(nodes.length - 1, 1);
      }
      return nodes;
    };
    const collectSiblings = (node, name, endNode) => {
      const siblings = [];
      for (; node && node !== endNode; node = node[name]) {
        siblings.push(node);
      }
      return siblings;
    };
    const findEndPoint = (node, root) =>
      dom.getParent(node, (node) => node.parentNode === root, root);
    const walkBoundary = (startNode, endNode, next) => {
      const siblingName = next ? "nextSibling" : "previousSibling";
      for (
        let node = startNode, parent = node.parentNode;
        node && node !== endNode;
        node = parent
      ) {
        parent = node.parentNode;
        const siblings = collectSiblings(
          node === startNode ? node : node[siblingName],
          siblingName
        );
        if (siblings.length) {
          if (!next) {
            siblings.reverse();
          }
          callback(exclude(siblings));
        }
      }
    };
    if (startContainer === endContainer) {
      return callback(exclude([startContainer]));
    }
    const ancestor =
      (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null &&
      _a !== void 0
        ? _a
        : dom.getRoot();
    if (dom.isChildOf(startContainer, endContainer)) {
      return walkBoundary(startContainer, ancestor, true);
    }
    if (dom.isChildOf(endContainer, startContainer)) {
      return walkBoundary(endContainer, ancestor);
    }
    const startPoint = findEndPoint(startContainer, ancestor) || startContainer;
    const endPoint = findEndPoint(endContainer, ancestor) || endContainer;
    walkBoundary(startContainer, startPoint, true);
    const siblings = collectSiblings(
      startPoint === startContainer ? startPoint : startPoint.nextSibling,
      "nextSibling",
      endPoint === endContainer ? endPoint.nextSibling : endPoint
    );
    if (siblings.length) {
      callback(exclude(siblings));
    }
    walkBoundary(endContainer, endPoint);
  };

  const validBlocks = [
    'pre[class*=language-][contenteditable="false"]',
    "figure.image",
    "div[data-ephox-embed-iri]",
    "div.tiny-pageembed",
    "div.mce-toc",
    "div[data-mce-toc]",
  ];
  const isZeroWidth = (elem) => isText$c(elem) && get$3(elem) === ZWSP$1;
  const context = (editor, elem, wrapName, nodeName) =>
    parent(elem).fold(
      () => "skipping",
      (parent) => {
        if (nodeName === "br" || isZeroWidth(elem)) {
          return "valid";
        } else if (isAnnotation(elem)) {
          return "existing";
        } else if (isCaretNode(elem.dom)) {
          return "caret";
        } else if (exists(validBlocks, (selector) => is$1(elem, selector))) {
          return "valid-block";
        } else if (
          !isValid(editor, wrapName, nodeName) ||
          !isValid(editor, name(parent), wrapName)
        ) {
          return "invalid-child";
        } else {
          return "valid";
        }
      }
    );

  const applyWordGrab = (editor, rng) => {
    const r = expandRng(editor.dom, rng, [{ inline: "span" }]);
    rng.setStart(r.startContainer, r.startOffset);
    rng.setEnd(r.endContainer, r.endOffset);
    editor.selection.setRng(rng);
  };
  const applyAnnotation = (
    elem,
    masterUId,
    data,
    annotationName,
    decorate,
    directAnnotation
  ) => {
    const { uid = masterUId, ...otherData } = data;
    add$2(elem, annotation());
    set$4(elem, `${dataAnnotationId()}`, uid);
    set$4(elem, `${dataAnnotation()}`, annotationName);
    const { attributes = {}, classes = [] } = decorate(uid, otherData);
    setAll$1(elem, attributes);
    add(elem, classes);
    if (directAnnotation) {
      if (classes.length > 0) {
        set$4(elem, `${dataAnnotationClasses()}`, classes.join(","));
      }
      const attributeNames = keys(attributes);
      if (attributeNames.length > 0) {
        set$4(elem, `${dataAnnotationAttributes()}`, attributeNames.join(","));
      }
    }
  };
  const removeDirectAnnotation = (elem) => {
    remove$6(elem, annotation());
    remove$9(elem, `${dataAnnotationId()}`);
    remove$9(elem, `${dataAnnotation()}`);
    remove$9(elem, `${dataAnnotationActive()}`);
    const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`)
      .map((names) => names.split(","))
      .getOr([]);
    const customClasses = getOpt(elem, `${dataAnnotationClasses()}`)
      .map((names) => names.split(","))
      .getOr([]);
    each$e(customAttrNames, (name) => remove$9(elem, name));
    remove$3(elem, customClasses);
    remove$9(elem, `${dataAnnotationClasses()}`);
    remove$9(elem, `${dataAnnotationAttributes()}`);
  };
  const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {
    const master = SugarElement.fromTag("span", eDoc);
    applyAnnotation(master, uid, data, annotationName, decorate, false);
    return master;
  };
  const annotate = (editor, rng, uid, annotationName, decorate, data) => {
    const newWrappers = [];
    const master = makeAnnotation(
      editor.getDoc(),
      uid,
      data,
      annotationName,
      decorate
    );
    const wrapper = value$2();
    const finishWrapper = () => {
      wrapper.clear();
    };
    const getOrOpenWrapper = () =>
      wrapper.get().getOrThunk(() => {
        const nu = shallow$1(master);
        newWrappers.push(nu);
        wrapper.set(nu);
        return nu;
      });
    const processElements = (elems) => {
      each$e(elems, processElement);
    };
    const processElement = (elem) => {
      const ctx = context(editor, elem, "span", name(elem));
      switch (ctx) {
        case "invalid-child": {
          finishWrapper();
          const children = children$1(elem);
          processElements(children);
          finishWrapper();
          break;
        }
        case "valid-block": {
          finishWrapper();
          applyAnnotation(elem, uid, data, annotationName, decorate, true);
          break;
        }
        case "valid": {
          const w = getOrOpenWrapper();
          wrap$2(elem, w);
          break;
        }
      }
    };
    const processNodes = (nodes) => {
      const elems = map$3(nodes, SugarElement.fromDom);
      processElements(elems);
    };
    walk$3(editor.dom, rng, (nodes) => {
      finishWrapper();
      processNodes(nodes);
    });
    return newWrappers;
  };
  const annotateWithBookmark = (editor, name, settings, data) => {
    editor.undoManager.transact(() => {
      const selection = editor.selection;
      const initialRng = selection.getRng();
      const hasFakeSelection = getCellsFromEditor(editor).length > 0;
      const masterUid = generate$1("mce-annotation");
      if (initialRng.collapsed && !hasFakeSelection) {
        applyWordGrab(editor, initialRng);
      }
      if (selection.getRng().collapsed && !hasFakeSelection) {
        const wrapper = makeAnnotation(
          editor.getDoc(),
          masterUid,
          data,
          name,
          settings.decorate
        );
        set$1(wrapper, nbsp);
        selection.getRng().insertNode(wrapper.dom);
        selection.select(wrapper.dom);
      } else {
        preserve(selection, false, () => {
          runOnRanges(editor, (selectionRng) => {
            annotate(
              editor,
              selectionRng,
              masterUid,
              name,
              settings.decorate,
              data
            );
          });
        });
      }
    });
  };

  const Annotator = (editor) => {
    const registry = create$b();
    setup$x(editor, registry);
    const changes = setup$y(editor, registry);
    const isSpan = isTag("span");
    const removeAnnotations = (elements) => {
      each$e(elements, (element) => {
        if (isSpan(element)) {
          unwrap(element);
        } else {
          removeDirectAnnotation(element);
        }
      });
    };
    return {
      register: (name, settings) => {
        registry.register(name, settings);
      },
      annotate: (name, data) => {
        registry.lookup(name).each((settings) => {
          annotateWithBookmark(editor, name, settings, data);
        });
      },
      annotationChanged: (name, callback) => {
        changes.addListener(name, callback);
      },
      remove: (name) => {
        identify(editor, Optional.some(name)).each(({ elements }) => {
          const bookmark = editor.selection.getBookmark();
          removeAnnotations(elements);
          editor.selection.moveToBookmark(bookmark);
        });
      },
      removeAll: (name) => {
        const bookmark = editor.selection.getBookmark();
        each$d(findAll(editor, name), (elements, _) => {
          removeAnnotations(elements);
        });
        editor.selection.moveToBookmark(bookmark);
      },
      getAll: (name) => {
        const directory = findAll(editor, name);
        return map$2(directory, (elems) => map$3(elems, (elem) => elem.dom));
      },
    };
  };

  const BookmarkManager = (selection) => {
    return {
      getBookmark: curry(getBookmark$2, selection),
      moveToBookmark: curry(moveToBookmark, selection),
    };
  };
  BookmarkManager.isBookmarkNode = isBookmarkNode$1;

  const isXYWithinRange = (clientX, clientY, range) => {
    if (range.collapsed) {
      return false;
    } else {
      return exists(range.getClientRects(), (rect) =>
        containsXY(rect, clientX, clientY)
      );
    }
  };

  const getDocument = () => SugarElement.fromDom(document);

  const focus$1 = (element, preventScroll = false) =>
    element.dom.focus({ preventScroll });
  const hasFocus$1 = (element) => {
    const root = getRootNode(element).dom;
    return element.dom === root.activeElement;
  };
  const active$1 = (root = getDocument()) =>
    Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
  const search = (element) =>
    active$1(getRootNode(element)).filter((e) => element.dom.contains(e.dom));

  const create$9 = (start, soffset, finish, foffset) => ({
    start,
    soffset,
    finish,
    foffset,
  });
  const SimRange = { create: create$9 };

  const adt$3 = Adt.generate([
    { before: ["element"] },
    {
      on: ["element", "offset"],
    },
    { after: ["element"] },
  ]);
  const cata = (subject, onBefore, onOn, onAfter) =>
    subject.fold(onBefore, onOn, onAfter);
  const getStart$2 = (situ) => situ.fold(identity, identity, identity);
  const before$1 = adt$3.before;
  const on = adt$3.on;
  const after$1 = adt$3.after;
  const Situ = {
    before: before$1,
    on,
    after: after$1,
    cata,
    getStart: getStart$2,
  };

  const adt$2 = Adt.generate([
    { domRange: ["rng"] },
    {
      relative: ["startSitu", "finishSitu"],
    },
    {
      exact: ["start", "soffset", "finish", "foffset"],
    },
  ]);
  const exactFromRange = (simRange) =>
    adt$2.exact(
      simRange.start,
      simRange.soffset,
      simRange.finish,
      simRange.foffset
    );
  const getStart$1 = (selection) =>
    selection.match({
      domRange: (rng) => SugarElement.fromDom(rng.startContainer),
      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
      exact: (start, _soffset, _finish, _foffset) => start,
    });
  const domRange = adt$2.domRange;
  const relative = adt$2.relative;
  const exact = adt$2.exact;
  const getWin = (selection) => {
    const start = getStart$1(selection);
    return defaultView(start);
  };
  const range = SimRange.create;
  const SimSelection = {
    domRange,
    relative,
    exact,
    exactFromRange,
    getWin,
    range,
  };

  const clamp$1 = (offset, element) => {
    const max = isText$c(element)
      ? get$3(element).length
      : children$1(element).length + 1;
    if (offset > max) {
      return max;
    } else if (offset < 0) {
      return 0;
    }
    return offset;
  };
  const normalizeRng = (rng) =>
    SimSelection.range(
      rng.start,
      clamp$1(rng.soffset, rng.start),
      rng.finish,
      clamp$1(rng.foffset, rng.finish)
    );
  const isOrContains = (root, elm) =>
    !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));
  const isRngInRoot = (root) => (rng) =>
    isOrContains(root, rng.start) && isOrContains(root, rng.finish);
  const shouldStore = (editor) => editor.inline || Env.browser.isFirefox();
  const nativeRangeToSelectionRange = (r) =>
    SimSelection.range(
      SugarElement.fromDom(r.startContainer),
      r.startOffset,
      SugarElement.fromDom(r.endContainer),
      r.endOffset
    );
  const readRange = (win) => {
    const selection = win.getSelection();
    const rng =
      !selection || selection.rangeCount === 0
        ? Optional.none()
        : Optional.from(selection.getRangeAt(0));
    return rng.map(nativeRangeToSelectionRange);
  };
  const getBookmark$1 = (root) => {
    const win = defaultView(root);
    return readRange(win.dom).filter(isRngInRoot(root));
  };
  const validate = (root, bookmark) =>
    Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
  const bookmarkToNativeRng = (bookmark) => {
    const rng = document.createRange();
    try {
      rng.setStart(bookmark.start.dom, bookmark.soffset);
      rng.setEnd(bookmark.finish.dom, bookmark.foffset);
      return Optional.some(rng);
    } catch (_a) {
      return Optional.none();
    }
  };
  const store = (editor) => {
    const newBookmark = shouldStore(editor)
      ? getBookmark$1(SugarElement.fromDom(editor.getBody()))
      : Optional.none();
    editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
  };
  const getRng = (editor) => {
    const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
    return bookmark
      .bind((x) => validate(SugarElement.fromDom(editor.getBody()), x))
      .bind(bookmarkToNativeRng);
  };
  const restore = (editor) => {
    getRng(editor).each((rng) => editor.selection.setRng(rng));
  };

  const isEditorUIElement$1 = (elm) => {
    const className = elm.className.toString();
    return className.indexOf("tox-") !== -1 || className.indexOf("mce-") !== -1;
  };
  const FocusManager = { isEditorUIElement: isEditorUIElement$1 };

  const wrappedSetTimeout = (callback, time) => {
    if (!isNumber(time)) {
      time = 0;
    }
    return setTimeout(callback, time);
  };
  const wrappedSetInterval = (callback, time) => {
    if (!isNumber(time)) {
      time = 0;
    }
    return setInterval(callback, time);
  };
  const Delay = {
    setEditorTimeout: (editor, callback, time) => {
      return wrappedSetTimeout(() => {
        if (!editor.removed) {
          callback();
        }
      }, time);
    },
    setEditorInterval: (editor, callback, time) => {
      const timer = wrappedSetInterval(() => {
        if (!editor.removed) {
          callback();
        } else {
          clearInterval(timer);
        }
      }, time);
      return timer;
    },
  };

  const isManualNodeChange = (e) => {
    return e.type === "nodechange" && e.selectionChange;
  };
  const registerPageMouseUp = (editor, throttledStore) => {
    const mouseUpPage = () => {
      throttledStore.throttle();
    };
    DOMUtils.DOM.bind(document, "mouseup", mouseUpPage);
    editor.on("remove", () => {
      DOMUtils.DOM.unbind(document, "mouseup", mouseUpPage);
    });
  };
  const registerMouseUp = (editor, throttledStore) => {
    editor.on("mouseup touchend", (_e) => {
      throttledStore.throttle();
    });
  };
  const registerEditorEvents = (editor, throttledStore) => {
    registerMouseUp(editor, throttledStore);
    editor.on("keyup NodeChange AfterSetSelectionRange", (e) => {
      if (!isManualNodeChange(e)) {
        store(editor);
      }
    });
  };
  const register$6 = (editor) => {
    const throttledStore = first$1(() => {
      store(editor);
    }, 0);
    editor.on("init", () => {
      if (editor.inline) {
        registerPageMouseUp(editor, throttledStore);
      }
      registerEditorEvents(editor, throttledStore);
    });
    editor.on("remove", () => {
      throttledStore.cancel();
    });
  };

  let documentFocusInHandler;
  const DOM$9 = DOMUtils.DOM;
  const isEditorUIElement = (elm) => {
    return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
  };
  const isEditorContentAreaElement = (elm) => {
    const classList = elm.classList;
    if (classList !== undefined) {
      return (
        classList.contains("tox-edit-area") ||
        classList.contains("tox-edit-area__iframe") ||
        classList.contains("mce-content-body")
      );
    } else {
      return false;
    }
  };
  const isUIElement = (editor, elm) => {
    const customSelector = getCustomUiSelector(editor);
    const parent = DOM$9.getParent(elm, (elm) => {
      return (
        isEditorUIElement(elm) ||
        (customSelector ? editor.dom.is(elm, customSelector) : false)
      );
    });
    return parent !== null;
  };
  const getActiveElement = (editor) => {
    try {
      const root = getRootNode(SugarElement.fromDom(editor.getElement()));
      return active$1(root).fold(
        () => document.body,
        (x) => x.dom
      );
    } catch (_a) {
      return document.body;
    }
  };
  const registerEvents$1 = (editorManager, e) => {
    const editor = e.editor;
    register$6(editor);
    const toggleContentAreaOnFocus = (editor, fn) => {
      if (shouldHighlightOnFocus(editor) && editor.inline !== true) {
        const contentArea = SugarElement.fromDom(editor.getContainer());
        fn(contentArea, "tox-edit-focus");
      }
    };
    editor.on("focusin", () => {
      const focusedEditor = editorManager.focusedEditor;
      if (isEditorContentAreaElement(getActiveElement(editor))) {
        toggleContentAreaOnFocus(editor, add$2);
      }
      if (focusedEditor !== editor) {
        if (focusedEditor) {
          focusedEditor.dispatch("blur", { focusedEditor: editor });
        }
        editorManager.setActive(editor);
        editorManager.focusedEditor = editor;
        editor.dispatch("focus", { blurredEditor: focusedEditor });
        editor.focus(true);
      }
    });
    editor.on("focusout", () => {
      Delay.setEditorTimeout(editor, () => {
        const focusedEditor = editorManager.focusedEditor;
        if (
          !isEditorContentAreaElement(getActiveElement(editor)) ||
          focusedEditor !== editor
        ) {
          toggleContentAreaOnFocus(editor, remove$6);
        }
        if (
          !isUIElement(editor, getActiveElement(editor)) &&
          focusedEditor === editor
        ) {
          editor.dispatch("blur", { focusedEditor: null });
          editorManager.focusedEditor = null;
        }
      });
    });
    if (!documentFocusInHandler) {
      documentFocusInHandler = (e) => {
        const activeEditor = editorManager.activeEditor;
        if (activeEditor) {
          getOriginalEventTarget(e).each((target) => {
            const elem = target;
            if (elem.ownerDocument === document) {
              if (
                elem !== document.body &&
                !isUIElement(activeEditor, elem) &&
                editorManager.focusedEditor === activeEditor
              ) {
                activeEditor.dispatch("blur", { focusedEditor: null });
                editorManager.focusedEditor = null;
              }
            }
          });
        }
      };
      DOM$9.bind(document, "focusin", documentFocusInHandler);
    }
  };
  const unregisterDocumentEvents = (editorManager, e) => {
    if (editorManager.focusedEditor === e.editor) {
      editorManager.focusedEditor = null;
    }
    if (!editorManager.activeEditor && documentFocusInHandler) {
      DOM$9.unbind(document, "focusin", documentFocusInHandler);
      documentFocusInHandler = null;
    }
  };
  const setup$w = (editorManager) => {
    editorManager.on("AddEditor", curry(registerEvents$1, editorManager));
    editorManager.on(
      "RemoveEditor",
      curry(unregisterDocumentEvents, editorManager)
    );
  };

  const getContentEditableHost = (editor, node) =>
    editor.dom.getParent(
      node,
      (node) => editor.dom.getContentEditable(node) === "true"
    );
  const hasContentEditableFalseParent$1 = (editor, node) =>
    editor.dom.getParent(
      node,
      (node) => editor.dom.getContentEditable(node) === "false"
    ) !== null;
  const getCollapsedNode = (rng) =>
    rng.collapsed
      ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(
          SugarElement.fromDom
        )
      : Optional.none();
  const getFocusInElement = (root, rng) =>
    getCollapsedNode(rng).bind((node) => {
      if (isTableSection(node)) {
        return Optional.some(node);
      } else if (!contains(root, node)) {
        return Optional.some(root);
      } else {
        return Optional.none();
      }
    });
  const normalizeSelection = (editor, rng) => {
    getFocusInElement(SugarElement.fromDom(editor.getBody()), rng)
      .bind((elm) => {
        return firstPositionIn(elm.dom);
      })
      .fold(
        () => {
          editor.selection.normalize();
        },
        (caretPos) => editor.selection.setRng(caretPos.toRange())
      );
  };
  const focusBody = (body) => {
    if (body.setActive) {
      try {
        body.setActive();
      } catch (_a) {
        body.focus();
      }
    } else {
      body.focus();
    }
  };
  const hasElementFocus = (elm) => hasFocus$1(elm) || search(elm).isSome();
  const hasIframeFocus = (editor) =>
    isNonNullable(editor.iframeElement) &&
    hasFocus$1(SugarElement.fromDom(editor.iframeElement));
  const hasInlineFocus = (editor) => {
    const rawBody = editor.getBody();
    return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
  };
  const hasUiFocus = (editor) => {
    const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
    return active$1(dos)
      .filter(
        (elem) =>
          !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)
      )
      .isSome();
  };
  const hasFocus = (editor) =>
    editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
  const hasEditorOrUiFocus = (editor) => hasFocus(editor) || hasUiFocus(editor);
  const focusEditor = (editor) => {
    const selection = editor.selection;
    const body = editor.getBody();
    let rng = selection.getRng();
    editor.quirks.refreshContentEditable();
    const restoreBookmark = (editor) => {
      getRng(editor).each((bookmarkRng) => {
        editor.selection.setRng(bookmarkRng);
        rng = bookmarkRng;
      });
    };
    if (!hasFocus(editor) && editor.hasEditableRoot()) {
      restoreBookmark(editor);
    }
    const contentEditableHost = getContentEditableHost(
      editor,
      selection.getNode()
    );
    if (
      contentEditableHost &&
      editor.dom.isChildOf(contentEditableHost, body)
    ) {
      if (!hasContentEditableFalseParent$1(editor, contentEditableHost)) {
        focusBody(body);
      }
      focusBody(contentEditableHost);
      if (!editor.hasEditableRoot()) {
        restoreBookmark(editor);
      }
      normalizeSelection(editor, rng);
      activateEditor(editor);
      return;
    }
    if (!editor.inline) {
      if (!Env.browser.isOpera()) {
        focusBody(body);
      }
      editor.getWin().focus();
    }
    if (Env.browser.isFirefox() || editor.inline) {
      focusBody(body);
      normalizeSelection(editor, rng);
    }
    activateEditor(editor);
  };
  const activateEditor = (editor) => editor.editorManager.setActive(editor);
  const focus = (editor, skipFocus) => {
    if (editor.removed) {
      return;
    }
    if (skipFocus) {
      activateEditor(editor);
    } else {
      focusEditor(editor);
    }
  };

  const VK = {
    BACKSPACE: 8,
    DELETE: 46,
    DOWN: 40,
    ENTER: 13,
    ESC: 27,
    LEFT: 37,
    RIGHT: 39,
    SPACEBAR: 32,
    TAB: 9,
    UP: 38,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    modifierPressed: (e) => {
      return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
    },
    metaKeyPressed: (e) => {
      return Env.os.isMacOS() || Env.os.isiOS()
        ? e.metaKey
        : e.ctrlKey && !e.altKey;
    },
  };

  const elementSelectionAttr = "data-mce-selected";
  const controlElmSelector =
    "table,img,figure.image,hr,video,span.mce-preview-object,details";
  const abs = Math.abs;
  const round$1 = Math.round;
  const resizeHandles = {
    nw: [0, 0, -1, -1],
    ne: [1, 0, 1, -1],
    se: [1, 1, 1, 1],
    sw: [0, 1, -1, 1],
  };
  const isTouchEvent = (evt) =>
    evt.type === "longpress" || evt.type.indexOf("touch") === 0;
  const ControlSelection = (selection, editor) => {
    const dom = editor.dom;
    const editableDoc = editor.getDoc();
    const rootDocument = document;
    const rootElement = editor.getBody();
    let selectedElm,
      selectedElmGhost,
      resizeHelper,
      selectedHandle,
      resizeBackdrop;
    let startX, startY, startW, startH, ratio, resizeStarted;
    let width;
    let height;
    let startScrollWidth;
    let startScrollHeight;
    const isImage = (elm) =>
      isNonNullable(elm) && (isImg(elm) || dom.is(elm, "figure.image"));
    const isMedia = (elm) =>
      isMedia$2(elm) || dom.hasClass(elm, "mce-preview-object");
    const isEventOnImageOutsideRange = (evt, range) => {
      if (isTouchEvent(evt)) {
        const touch = evt.touches[0];
        return (
          isImage(evt.target) &&
          !isXYWithinRange(touch.clientX, touch.clientY, range)
        );
      } else {
        return (
          isImage(evt.target) &&
          !isXYWithinRange(evt.clientX, evt.clientY, range)
        );
      }
    };
    const contextMenuSelectImage = (evt) => {
      const target = evt.target;
      if (
        isEventOnImageOutsideRange(evt, editor.selection.getRng()) &&
        !evt.isDefaultPrevented()
      ) {
        editor.selection.select(target);
      }
    };
    const getResizeTargets = (elm) => {
      if (
        dom.hasClass(elm, "mce-preview-object") &&
        isNonNullable(elm.firstElementChild)
      ) {
        return [elm, elm.firstElementChild];
      } else if (dom.is(elm, "figure.image")) {
        return [elm.querySelector("img")];
      } else {
        return [elm];
      }
    };
    const isResizable = (elm) => {
      const selector = getObjectResizing(editor);
      if (!selector || editor.mode.isReadOnly()) {
        return false;
      }
      if (elm.getAttribute("data-mce-resize") === "false") {
        return false;
      }
      if (elm === editor.getBody()) {
        return false;
      }
      if (
        dom.hasClass(elm, "mce-preview-object") &&
        isNonNullable(elm.firstElementChild)
      ) {
        return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
      } else {
        return is$1(SugarElement.fromDom(elm), selector);
      }
    };
    const createGhostElement = (dom, elm) => {
      if (isMedia(elm)) {
        return dom.create("img", { src: Env.transparentSrc });
      } else if (isTable$2(elm)) {
        const isNorth = startsWith(selectedHandle.name, "n");
        const rowSelect = isNorth ? head : last$2;
        const tableElm = elm.cloneNode(true);
        rowSelect(dom.select("tr", tableElm)).each((tr) => {
          const cells = dom.select("td,th", tr);
          dom.setStyle(tr, "height", null);
          each$e(cells, (cell) => dom.setStyle(cell, "height", null));
        });
        return tableElm;
      } else {
        return elm.cloneNode(true);
      }
    };
    const setSizeProp = (element, name, value) => {
      if (isNonNullable(value)) {
        const targets = getResizeTargets(element);
        each$e(targets, (target) => {
          if (
            target.style[name] ||
            !editor.schema.isValid(target.nodeName.toLowerCase(), name)
          ) {
            dom.setStyle(target, name, value);
          } else {
            dom.setAttrib(target, name, "" + value);
          }
        });
      }
    };
    const setGhostElmSize = (ghostElm, width, height) => {
      setSizeProp(ghostElm, "width", width);
      setSizeProp(ghostElm, "height", height);
    };
    const resizeGhostElement = (e) => {
      let deltaX, deltaY, proportional;
      let resizeHelperX, resizeHelperY;
      deltaX = e.screenX - startX;
      deltaY = e.screenY - startY;
      width = deltaX * selectedHandle[2] + startW;
      height = deltaY * selectedHandle[3] + startH;
      width = width < 5 ? 5 : width;
      height = height < 5 ? 5 : height;
      if (
        (isImage(selectedElm) || isMedia(selectedElm)) &&
        getResizeImgProportional(editor) !== false
      ) {
        proportional = !VK.modifierPressed(e);
      } else {
        proportional = VK.modifierPressed(e);
      }
      if (proportional) {
        if (abs(deltaX) > abs(deltaY)) {
          height = round$1(width * ratio);
          width = round$1(height / ratio);
        } else {
          width = round$1(height / ratio);
          height = round$1(width * ratio);
        }
      }
      setGhostElmSize(selectedElmGhost, width, height);
      resizeHelperX = selectedHandle.startPos.x + deltaX;
      resizeHelperY = selectedHandle.startPos.y + deltaY;
      resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
      resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
      dom.setStyles(resizeHelper, {
        left: resizeHelperX,
        top: resizeHelperY,
        display: "block",
      });
      resizeHelper.innerHTML = width + " &times; " + height;
      deltaX = rootElement.scrollWidth - startScrollWidth;
      deltaY = rootElement.scrollHeight - startScrollHeight;
      if (deltaX + deltaY !== 0) {
        dom.setStyles(resizeHelper, {
          left: resizeHelperX - deltaX,
          top: resizeHelperY - deltaY,
        });
      }
      if (!resizeStarted) {
        fireObjectResizeStart(
          editor,
          selectedElm,
          startW,
          startH,
          "corner-" + selectedHandle.name
        );
        resizeStarted = true;
      }
    };
    const endGhostResize = () => {
      const wasResizeStarted = resizeStarted;
      resizeStarted = false;
      if (wasResizeStarted) {
        setSizeProp(selectedElm, "width", width);
        setSizeProp(selectedElm, "height", height);
      }
      dom.unbind(editableDoc, "mousemove", resizeGhostElement);
      dom.unbind(editableDoc, "mouseup", endGhostResize);
      if (rootDocument !== editableDoc) {
        dom.unbind(rootDocument, "mousemove", resizeGhostElement);
        dom.unbind(rootDocument, "mouseup", endGhostResize);
      }
      dom.remove(selectedElmGhost);
      dom.remove(resizeHelper);
      dom.remove(resizeBackdrop);
      showResizeRect(selectedElm);
      if (wasResizeStarted) {
        fireObjectResized(
          editor,
          selectedElm,
          width,
          height,
          "corner-" + selectedHandle.name
        );
        dom.setAttrib(
          selectedElm,
          "style",
          dom.getAttrib(selectedElm, "style")
        );
      }
      editor.nodeChanged();
    };
    const showResizeRect = (targetElm) => {
      unbindResizeHandleEvents();
      const position = dom.getPos(targetElm, rootElement);
      const selectedElmX = position.x;
      const selectedElmY = position.y;
      const rect = targetElm.getBoundingClientRect();
      const targetWidth = rect.width || rect.right - rect.left;
      const targetHeight = rect.height || rect.bottom - rect.top;
      if (selectedElm !== targetElm) {
        hideResizeRect();
        selectedElm = targetElm;
        width = height = 0;
      }
      const e = editor.dispatch("ObjectSelected", { target: targetElm });
      if (isResizable(targetElm) && !e.isDefaultPrevented()) {
        each$d(resizeHandles, (handle, name) => {
          const startDrag = (e) => {
            const target = getResizeTargets(selectedElm)[0];
            startX = e.screenX;
            startY = e.screenY;
            startW = target.clientWidth;
            startH = target.clientHeight;
            ratio = startH / startW;
            selectedHandle = handle;
            selectedHandle.name = name;
            selectedHandle.startPos = {
              x: targetWidth * handle[0] + selectedElmX,
              y: targetHeight * handle[1] + selectedElmY,
            };
            startScrollWidth = rootElement.scrollWidth;
            startScrollHeight = rootElement.scrollHeight;
            resizeBackdrop = dom.add(rootElement, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all",
            });
            dom.setStyles(resizeBackdrop, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%",
            });
            selectedElmGhost = createGhostElement(dom, selectedElm);
            dom.addClass(selectedElmGhost, "mce-clonedresizable");
            dom.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
            selectedElmGhost.contentEditable = "false";
            dom.setStyles(selectedElmGhost, {
              left: selectedElmX,
              top: selectedElmY,
              margin: 0,
            });
            setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
            selectedElmGhost.removeAttribute(elementSelectionAttr);
            rootElement.appendChild(selectedElmGhost);
            dom.bind(editableDoc, "mousemove", resizeGhostElement);
            dom.bind(editableDoc, "mouseup", endGhostResize);
            if (rootDocument !== editableDoc) {
              dom.bind(rootDocument, "mousemove", resizeGhostElement);
              dom.bind(rootDocument, "mouseup", endGhostResize);
            }
            resizeHelper = dom.add(
              rootElement,
              "div",
              {
                class: "mce-resize-helper",
                "data-mce-bogus": "all",
              },
              startW + " &times; " + startH
            );
          };
          let handleElm = dom.get("mceResizeHandle" + name);
          if (handleElm) {
            dom.remove(handleElm);
          }
          handleElm = dom.add(rootElement, "div", {
            id: "mceResizeHandle" + name,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: true,
            style: "cursor:" + name + "-resize; margin:0; padding:0",
          });
          dom.bind(handleElm, "mousedown", (e) => {
            e.stopImmediatePropagation();
            e.preventDefault();
            startDrag(e);
          });
          handle.elm = handleElm;
          dom.setStyles(handleElm, {
            left:
              targetWidth * handle[0] +
              selectedElmX -
              handleElm.offsetWidth / 2,
            top:
              targetHeight * handle[1] +
              selectedElmY -
              handleElm.offsetHeight / 2,
          });
        });
      } else {
        hideResizeRect(false);
      }
    };
    const throttledShowResizeRect = first$1(showResizeRect, 0);
    const hideResizeRect = (removeSelected = true) => {
      throttledShowResizeRect.cancel();
      unbindResizeHandleEvents();
      if (selectedElm && removeSelected) {
        selectedElm.removeAttribute(elementSelectionAttr);
      }
      each$d(resizeHandles, (value, name) => {
        const handleElm = dom.get("mceResizeHandle" + name);
        if (handleElm) {
          dom.unbind(handleElm);
          dom.remove(handleElm);
        }
      });
    };
    const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);
    const updateResizeRect = (e) => {
      if (resizeStarted || editor.removed || editor.composing) {
        return;
      }
      const targetElm = e.type === "mousedown" ? e.target : selection.getNode();
      const controlElm = closest$3(
        SugarElement.fromDom(targetElm),
        controlElmSelector
      )
        .map((e) => e.dom)
        .filter(
          (e) =>
            dom.isEditable(e.parentElement) ||
            (e.nodeName === "IMG" && dom.isEditable(e))
        )
        .getOrUndefined();
      const selectedValue = isNonNullable(controlElm)
        ? dom.getAttrib(controlElm, elementSelectionAttr, "1")
        : "1";
      each$e(
        dom.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`),
        (img) => {
          img.removeAttribute(elementSelectionAttr);
        }
      );
      if (
        isNonNullable(controlElm) &&
        isChildOrEqual(controlElm, rootElement) &&
        hasEditorOrUiFocus(editor)
      ) {
        disableGeckoResize();
        const startElm = selection.getStart(true);
        if (
          isChildOrEqual(startElm, controlElm) &&
          isChildOrEqual(selection.getEnd(true), controlElm)
        ) {
          dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);
          throttledShowResizeRect.throttle(controlElm);
          return;
        }
      }
      hideResizeRect();
    };
    const unbindResizeHandleEvents = () => {
      each$d(resizeHandles, (handle) => {
        if (handle.elm) {
          dom.unbind(handle.elm);
          delete handle.elm;
        }
      });
    };
    const disableGeckoResize = () => {
      try {
        editor.getDoc().execCommand("enableObjectResizing", false, "false");
      } catch (_a) {}
    };
    editor.on("init", () => {
      disableGeckoResize();
      editor.on(
        "NodeChange ResizeEditor ResizeWindow ResizeContent drop",
        updateResizeRect
      );
      editor.on("keyup compositionend", (e) => {
        if (selectedElm && selectedElm.nodeName === "TABLE") {
          updateResizeRect(e);
        }
      });
      editor.on("hide blur", hideResizeRect);
      editor.on("contextmenu longpress", contextMenuSelectImage, true);
    });
    editor.on("remove", unbindResizeHandleEvents);
    const destroy = () => {
      throttledShowResizeRect.cancel();
      selectedElm = selectedElmGhost = resizeBackdrop = null;
    };
    return {
      isResizable,
      showResizeRect,
      hideResizeRect,
      updateResizeRect,
      destroy,
    };
  };

  const setStart = (rng, situ) => {
    situ.fold(
      (e) => {
        rng.setStartBefore(e.dom);
      },
      (e, o) => {
        rng.setStart(e.dom, o);
      },
      (e) => {
        rng.setStartAfter(e.dom);
      }
    );
  };
  const setFinish = (rng, situ) => {
    situ.fold(
      (e) => {
        rng.setEndBefore(e.dom);
      },
      (e, o) => {
        rng.setEnd(e.dom, o);
      },
      (e) => {
        rng.setEndAfter(e.dom);
      }
    );
  };
  const relativeToNative = (win, startSitu, finishSitu) => {
    const range = win.document.createRange();
    setStart(range, startSitu);
    setFinish(range, finishSitu);
    return range;
  };
  const exactToNative = (win, start, soffset, finish, foffset) => {
    const rng = win.document.createRange();
    rng.setStart(start.dom, soffset);
    rng.setEnd(finish.dom, foffset);
    return rng;
  };

  const adt$1 = Adt.generate([
    {
      ltr: ["start", "soffset", "finish", "foffset"],
    },
    {
      rtl: ["start", "soffset", "finish", "foffset"],
    },
  ]);
  const fromRange = (win, type, range) =>
    type(
      SugarElement.fromDom(range.startContainer),
      range.startOffset,
      SugarElement.fromDom(range.endContainer),
      range.endOffset
    );
  const getRanges = (win, selection) =>
    selection.match({
      domRange: (rng) => {
        return {
          ltr: constant(rng),
          rtl: Optional.none,
        };
      },
      relative: (startSitu, finishSitu) => {
        return {
          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
          rtl: cached(() =>
            Optional.some(relativeToNative(win, finishSitu, startSitu))
          ),
        };
      },
      exact: (start, soffset, finish, foffset) => {
        return {
          ltr: cached(() =>
            exactToNative(win, start, soffset, finish, foffset)
          ),
          rtl: cached(() =>
            Optional.some(exactToNative(win, finish, foffset, start, soffset))
          ),
        };
      },
    });
  const doDiagnose = (win, ranges) => {
    const rng = ranges.ltr();
    if (rng.collapsed) {
      const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
      return reversed
        .map((rev) =>
          adt$1.rtl(
            SugarElement.fromDom(rev.endContainer),
            rev.endOffset,
            SugarElement.fromDom(rev.startContainer),
            rev.startOffset
          )
        )
        .getOrThunk(() => fromRange(win, adt$1.ltr, rng));
    } else {
      return fromRange(win, adt$1.ltr, rng);
    }
  };
  const diagnose = (win, selection) => {
    const ranges = getRanges(win, selection);
    return doDiagnose(win, ranges);
  };
  adt$1.ltr;
  adt$1.rtl;

  const caretPositionFromPoint = (doc, x, y) => {
    var _a;
    return Optional.from(
      (_a = doc.caretPositionFromPoint) === null || _a === void 0
        ? void 0
        : _a.call(doc, x, y)
    ).bind((pos) => {
      if (pos.offsetNode === null) {
        return Optional.none();
      }
      const r = doc.createRange();
      r.setStart(pos.offsetNode, pos.offset);
      r.collapse();
      return Optional.some(r);
    });
  };
  const caretRangeFromPoint = (doc, x, y) => {
    var _a;
    return Optional.from(
      (_a = doc.caretRangeFromPoint) === null || _a === void 0
        ? void 0
        : _a.call(doc, x, y)
    );
  };
  const availableSearch = (doc, x, y) => {
    if (doc.caretPositionFromPoint) {
      return caretPositionFromPoint(doc, x, y);
    } else if (doc.caretRangeFromPoint) {
      return caretRangeFromPoint(doc, x, y);
    } else {
      return Optional.none();
    }
  };
  const fromPoint$1 = (win, x, y) => {
    const doc = win.document;
    return availableSearch(doc, x, y).map((rng) =>
      SimRange.create(
        SugarElement.fromDom(rng.startContainer),
        rng.startOffset,
        SugarElement.fromDom(rng.endContainer),
        rng.endOffset
      )
    );
  };

  const beforeSpecial = (element, offset) => {
    const name$1 = name(element);
    if ("input" === name$1) {
      return Situ.after(element);
    } else if (!contains$2(["br", "img"], name$1)) {
      return Situ.on(element, offset);
    } else {
      return offset === 0 ? Situ.before(element) : Situ.after(element);
    }
  };
  const preprocessRelative = (startSitu, finishSitu) => {
    const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
    const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
    return SimSelection.relative(start, finish);
  };
  const preprocessExact = (start, soffset, finish, foffset) => {
    const startSitu = beforeSpecial(start, soffset);
    const finishSitu = beforeSpecial(finish, foffset);
    return SimSelection.relative(startSitu, finishSitu);
  };
  const preprocess = (selection) =>
    selection.match({
      domRange: (rng) => {
        const start = SugarElement.fromDom(rng.startContainer);
        const finish = SugarElement.fromDom(rng.endContainer);
        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
      },
      relative: preprocessRelative,
      exact: preprocessExact,
    });

  const fromElements = (elements, scope) => {
    const doc = scope || document;
    const fragment = doc.createDocumentFragment();
    each$e(elements, (element) => {
      fragment.appendChild(element.dom);
    });
    return SugarElement.fromDom(fragment);
  };

  const toNative = (selection) => {
    const win = SimSelection.getWin(selection).dom;
    const getDomRange = (start, soffset, finish, foffset) =>
      exactToNative(win, start, soffset, finish, foffset);
    const filtered = preprocess(selection);
    return diagnose(win, filtered).match({
      ltr: getDomRange,
      rtl: getDomRange,
    });
  };
  const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);

  const fromPoint = (clientX, clientY, doc) => {
    const win = defaultView(SugarElement.fromDom(doc));
    return getAtPoint(win.dom, clientX, clientY)
      .map((simRange) => {
        const rng = doc.createRange();
        rng.setStart(simRange.start.dom, simRange.soffset);
        rng.setEnd(simRange.finish.dom, simRange.foffset);
        return rng;
      })
      .getOrUndefined();
  };

  const isEq$4 = (rng1, rng2) => {
    return (
      isNonNullable(rng1) &&
      isNonNullable(rng2) &&
      rng1.startContainer === rng2.startContainer &&
      rng1.startOffset === rng2.startOffset &&
      rng1.endContainer === rng2.endContainer &&
      rng1.endOffset === rng2.endOffset
    );
  };

  const findParent = (node, rootNode, predicate) => {
    let currentNode = node;
    while (currentNode && currentNode !== rootNode) {
      if (predicate(currentNode)) {
        return currentNode;
      }
      currentNode = currentNode.parentNode;
    }
    return null;
  };
  const hasParent$1 = (node, rootNode, predicate) =>
    findParent(node, rootNode, predicate) !== null;
  const hasParentWithName = (node, rootNode, name) =>
    hasParent$1(node, rootNode, (node) => node.nodeName === name);
  const isCeFalseCaretContainer = (node, rootNode) =>
    isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
  const hasBrBeforeAfter = (dom, node, left) => {
    const parentNode = node.parentNode;
    if (parentNode) {
      const walker = new DomTreeWalker(
        node,
        dom.getParent(parentNode, dom.isBlock) || dom.getRoot()
      );
      let currentNode;
      while ((currentNode = walker[left ? "prev" : "next"]())) {
        if (isBr$6(currentNode)) {
          return true;
        }
      }
    }
    return false;
  };
  const isPrevNode = (node, name) => {
    var _a;
    return (
      ((_a = node.previousSibling) === null || _a === void 0
        ? void 0
        : _a.nodeName) === name
    );
  };
  const hasContentEditableFalseParent = (root, node) => {
    let currentNode = node;
    while (currentNode && currentNode !== root) {
      if (isContentEditableFalse$b(currentNode)) {
        return true;
      }
      currentNode = currentNode.parentNode;
    }
    return false;
  };
  const findTextNodeRelative = (
    dom,
    isAfterNode,
    collapsed,
    left,
    startNode
  ) => {
    const body = dom.getRoot();
    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
    const parentNode = startNode.parentNode;
    let lastInlineElement;
    let node;
    if (!parentNode) {
      return Optional.none();
    }
    const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;
    if (
      left &&
      isBr$6(startNode) &&
      isAfterNode &&
      dom.isEmpty(parentBlockContainer)
    ) {
      return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));
    }
    const walker = new DomTreeWalker(startNode, parentBlockContainer);
    while ((node = walker[left ? "prev" : "next"]())) {
      if (
        dom.getContentEditableParent(node) === "false" ||
        isCeFalseCaretContainer(node, body)
      ) {
        return Optional.none();
      }
      if (isText$b(node) && node.data.length > 0) {
        if (!hasParentWithName(node, body, "A")) {
          return Optional.some(
            CaretPosition(node, left ? node.data.length : 0)
          );
        }
        return Optional.none();
      }
      if (
        dom.isBlock(node) ||
        nonEmptyElementsMap[node.nodeName.toLowerCase()]
      ) {
        return Optional.none();
      }
      lastInlineElement = node;
    }
    if (isComment(lastInlineElement)) {
      return Optional.none();
    }
    if (collapsed && lastInlineElement) {
      return Optional.some(CaretPosition(lastInlineElement, 0));
    }
    return Optional.none();
  };
  const normalizeEndPoint = (dom, collapsed, start, rng) => {
    const body = dom.getRoot();
    let node;
    let normalized = false;
    let container = start ? rng.startContainer : rng.endContainer;
    let offset = start ? rng.startOffset : rng.endOffset;
    const isAfterNode =
      isElement$6(container) && offset === container.childNodes.length;
    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
    let directionLeft = start;
    if (isCaretContainer$2(container)) {
      return Optional.none();
    }
    if (isElement$6(container) && offset > container.childNodes.length - 1) {
      directionLeft = false;
    }
    if (isDocument$1(container)) {
      container = body;
      offset = 0;
    }
    if (container === body) {
      if (directionLeft) {
        node = container.childNodes[offset > 0 ? offset - 1 : 0];
        if (node) {
          if (isCaretContainer$2(node)) {
            return Optional.none();
          }
          if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
            return Optional.none();
          }
        }
      }
      if (container.hasChildNodes()) {
        offset = Math.min(
          !directionLeft && offset > 0 ? offset - 1 : offset,
          container.childNodes.length - 1
        );
        container = container.childNodes[offset];
        offset = isText$b(container) && isAfterNode ? container.data.length : 0;
        if (
          !collapsed &&
          container === body.lastChild &&
          isTable$2(container)
        ) {
          return Optional.none();
        }
        if (
          hasContentEditableFalseParent(body, container) ||
          isCaretContainer$2(container)
        ) {
          return Optional.none();
        }
        if (isDetails(container)) {
          return Optional.none();
        }
        if (container.hasChildNodes() && !isTable$2(container)) {
          node = container;
          const walker = new DomTreeWalker(container, body);
          do {
            if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
              normalized = false;
              break;
            }
            if (isText$b(node) && node.data.length > 0) {
              offset = directionLeft ? 0 : node.data.length;
              container = node;
              normalized = true;
              break;
            }
            if (
              nonEmptyElementsMap[node.nodeName.toLowerCase()] &&
              !isTableCellOrCaption(node)
            ) {
              offset = dom.nodeIndex(node);
              container = node.parentNode;
              if (!directionLeft) {
                offset++;
              }
              normalized = true;
              break;
            }
          } while ((node = directionLeft ? walker.next() : walker.prev()));
        }
      }
    }
    if (collapsed) {
      if (isText$b(container) && offset === 0) {
        findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(
          (pos) => {
            container = pos.container();
            offset = pos.offset();
            normalized = true;
          }
        );
      }
      if (isElement$6(container)) {
        node = container.childNodes[offset];
        if (!node) {
          node = container.childNodes[offset - 1];
        }
        if (
          node &&
          isBr$6(node) &&
          !isPrevNode(node, "A") &&
          !hasBrBeforeAfter(dom, node, false) &&
          !hasBrBeforeAfter(dom, node, true)
        ) {
          findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(
            (pos) => {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            }
          );
        }
      }
    }
    if (
      directionLeft &&
      !collapsed &&
      isText$b(container) &&
      offset === container.data.length
    ) {
      findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(
        (pos) => {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        }
      );
    }
    return normalized && container
      ? Optional.some(CaretPosition(container, offset))
      : Optional.none();
  };
  const normalize$2 = (dom, rng) => {
    const collapsed = rng.collapsed,
      normRng = rng.cloneRange();
    const startPos = CaretPosition.fromRangeStart(rng);
    normalizeEndPoint(dom, collapsed, true, normRng).each((pos) => {
      if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
        normRng.setStart(pos.container(), pos.offset());
      }
    });
    if (!collapsed) {
      normalizeEndPoint(dom, collapsed, false, normRng).each((pos) => {
        normRng.setEnd(pos.container(), pos.offset());
      });
    }
    if (collapsed) {
      normRng.collapse(true);
    }
    return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
  };

  const splitText = (node, offset) => {
    return node.splitText(offset);
  };
  const split = (rng) => {
    let startContainer = rng.startContainer,
      startOffset = rng.startOffset,
      endContainer = rng.endContainer,
      endOffset = rng.endOffset;
    if (startContainer === endContainer && isText$b(startContainer)) {
      if (startOffset > 0 && startOffset < startContainer.data.length) {
        endContainer = splitText(startContainer, startOffset);
        startContainer = endContainer.previousSibling;
        if (endOffset > startOffset) {
          endOffset = endOffset - startOffset;
          const newContainer = splitText(
            endContainer,
            endOffset
          ).previousSibling;
          startContainer = endContainer = newContainer;
          endOffset = newContainer.data.length;
          startOffset = 0;
        } else {
          endOffset = 0;
        }
      }
    } else {
      if (
        isText$b(startContainer) &&
        startOffset > 0 &&
        startOffset < startContainer.data.length
      ) {
        startContainer = splitText(startContainer, startOffset);
        startOffset = 0;
      }
      if (
        isText$b(endContainer) &&
        endOffset > 0 &&
        endOffset < endContainer.data.length
      ) {
        const newContainer = splitText(endContainer, endOffset).previousSibling;
        endContainer = newContainer;
        endOffset = newContainer.data.length;
      }
    }
    return {
      startContainer,
      startOffset,
      endContainer,
      endOffset,
    };
  };

  const RangeUtils = (dom) => {
    const walk = (rng, callback) => {
      return walk$3(dom, rng, callback);
    };
    const split$1 = split;
    const normalize = (rng) => {
      return normalize$2(dom, rng).fold(never, (normalizedRng) => {
        rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
        rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
        return true;
      });
    };
    const expand = (rng, options = { type: "word" }) => {
      if (options.type === "word") {
        const rangeLike = expandRng(dom, rng, [{ inline: "span" }], {
          includeTrailingSpace: false,
          expandToBlock: false,
        });
        const newRange = dom.createRng();
        newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
        newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
        return newRange;
      }
      return rng;
    };
    return {
      walk,
      split: split$1,
      expand,
      normalize,
    };
  };
  RangeUtils.compareRanges = isEq$4;
  RangeUtils.getCaretRangeFromPoint = fromPoint;
  RangeUtils.getSelectedNode = getSelectedNode;
  RangeUtils.getNode = getNode$1;

  const Dimension = (name, getOffset) => {
    const set = (element, h) => {
      if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
        throw new Error(
          name + ".set accepts only positive integer values. Value was " + h
        );
      }
      const dom = element.dom;
      if (isSupported(dom)) {
        dom.style[name] = h + "px";
      }
    };
    const get = (element) => {
      const r = getOffset(element);
      if (r <= 0 || r === null) {
        const css = get$7(element, name);
        return parseFloat(css) || 0;
      }
      return r;
    };
    const getOuter = get;
    const aggregate = (element, properties) =>
      foldl(
        properties,
        (acc, property) => {
          const val = get$7(element, property);
          const value = val === undefined ? 0 : parseInt(val, 10);
          return isNaN(value) ? acc : acc + value;
        },
        0
      );
    const max = (element, value, properties) => {
      const cumulativeInclusions = aggregate(element, properties);
      const absoluteMax =
        value > cumulativeInclusions ? value - cumulativeInclusions : 0;
      return absoluteMax;
    };
    return {
      set,
      get,
      getOuter,
      aggregate,
      max,
    };
  };

  const api = Dimension("height", (element) => {
    const dom = element.dom;
    return inBody(element)
      ? dom.getBoundingClientRect().height
      : dom.offsetHeight;
  });
  const get$2 = (element) => api.get(element);

  const walkUp = (navigation, doc) => {
    const frame = navigation.view(doc);
    return frame.fold(constant([]), (f) => {
      const parent = navigation.owner(f);
      const rest = walkUp(navigation, parent);
      return [f].concat(rest);
    });
  };
  const pathTo = (element, navigation) => {
    const d = navigation.owner(element);
    return walkUp(navigation, d);
  };

  const view = (doc) => {
    var _a;
    const element =
      doc.dom === document
        ? Optional.none()
        : Optional.from(
            (_a = doc.dom.defaultView) === null || _a === void 0
              ? void 0
              : _a.frameElement
          );
    return element.map(SugarElement.fromDom);
  };
  const owner = (element) => documentOrOwner(element);

  var Navigation = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    view: view,
    owner: owner,
  });

  const find = (element) => {
    const doc = getDocument();
    const scroll = get$5(doc);
    const frames = pathTo(element, Navigation);
    const offset = viewport(element);
    const r = foldr(
      frames,
      (b, a) => {
        const loc = viewport(a);
        return {
          left: b.left + loc.left,
          top: b.top + loc.top,
        };
      },
      {
        left: 0,
        top: 0,
      }
    );
    return SugarPosition(
      r.left + offset.left + scroll.left,
      r.top + offset.top + scroll.top
    );
  };

  const excludeFromDescend = (element) => name(element) === "textarea";
  const fireScrollIntoViewEvent = (editor, data) => {
    const scrollEvent = editor.dispatch("ScrollIntoView", data);
    return scrollEvent.isDefaultPrevented();
  };
  const fireAfterScrollIntoViewEvent = (editor, data) => {
    editor.dispatch("AfterScrollIntoView", data);
  };
  const descend = (element, offset) => {
    const children = children$1(element);
    if (children.length === 0 || excludeFromDescend(element)) {
      return {
        element,
        offset,
      };
    } else if (
      offset < children.length &&
      !excludeFromDescend(children[offset])
    ) {
      return {
        element: children[offset],
        offset: 0,
      };
    } else {
      const last = children[children.length - 1];
      if (excludeFromDescend(last)) {
        return {
          element,
          offset,
        };
      } else {
        if (name(last) === "img") {
          return {
            element: last,
            offset: 1,
          };
        } else if (isText$c(last)) {
          return {
            element: last,
            offset: get$3(last).length,
          };
        } else {
          return {
            element: last,
            offset: children$1(last).length,
          };
        }
      }
    }
  };
  const markerInfo = (element, cleanupFun) => {
    const pos = absolute(element);
    const height = get$2(element);
    return {
      element,
      bottom: pos.top + height,
      height,
      pos,
      cleanup: cleanupFun,
    };
  };
  const createMarker$1 = (element, offset) => {
    const startPoint = descend(element, offset);
    const span = SugarElement.fromHtml(
      '<span data-mce-bogus="all" style="display: inline-block;">' +
        ZWSP$1 +
        "</span>"
    );
    before$3(startPoint.element, span);
    return markerInfo(span, () => remove$4(span));
  };
  const elementMarker = (element) =>
    markerInfo(SugarElement.fromDom(element), noop);
  const withMarker = (editor, f, rng, alignToTop) => {
    preserveWith(
      editor,
      (_s, _e) => applyWithMarker(editor, f, rng, alignToTop),
      rng
    );
  };
  const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
    const data = {
      elm: marker.element.dom,
      alignToTop,
    };
    if (fireScrollIntoViewEvent(editor, data)) {
      return;
    }
    const scrollTop = get$5(doc).top;
    f(editor, doc, scrollTop, marker, alignToTop);
    fireAfterScrollIntoViewEvent(editor, data);
  };
  const applyWithMarker = (editor, f, rng, alignToTop) => {
    const body = SugarElement.fromDom(editor.getBody());
    const doc = SugarElement.fromDom(editor.getDoc());
    reflow(body);
    const marker = createMarker$1(
      SugarElement.fromDom(rng.startContainer),
      rng.startOffset
    );
    withScrollEvents(editor, doc, f, marker, alignToTop);
    marker.cleanup();
  };
  const withElement = (editor, element, f, alignToTop) => {
    const doc = SugarElement.fromDom(editor.getDoc());
    withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
  };
  const preserveWith = (editor, f, rng) => {
    const startElement = rng.startContainer;
    const startOffset = rng.startOffset;
    const endElement = rng.endContainer;
    const endOffset = rng.endOffset;
    f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
    const newRng = editor.dom.createRng();
    newRng.setStart(startElement, startOffset);
    newRng.setEnd(endElement, endOffset);
    editor.selection.setRng(rng);
  };
  const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {
    const pos = marker.pos;
    if (alignToTop) {
      to(pos.left, pos.top, doc);
    } else {
      const y = pos.top - viewHeight + marker.height;
      to(-editor.getBody().getBoundingClientRect().left, y, doc);
    }
  };
  const intoWindowIfNeeded = (
    editor,
    doc,
    scrollTop,
    viewHeight,
    marker,
    alignToTop
  ) => {
    const viewportBottom = viewHeight + scrollTop;
    const markerTop = marker.pos.top;
    const markerBottom = marker.bottom;
    const largerThanViewport = markerBottom - markerTop >= viewHeight;
    if (markerTop < scrollTop) {
      scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);
    } else if (markerTop > viewportBottom) {
      const align = largerThanViewport
        ? alignToTop !== false
        : alignToTop === true;
      scrollToMarker(editor, marker, viewHeight, align, doc);
    } else if (markerBottom > viewportBottom && !largerThanViewport) {
      scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);
    }
  };
  const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {
    const viewHeight = defaultView(doc).dom.innerHeight;
    intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);
  };
  const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {
    const frameViewHeight = defaultView(doc).dom.innerHeight;
    intoWindowIfNeeded(
      editor,
      doc,
      scrollTop,
      frameViewHeight,
      marker,
      alignToTop
    );
    const op = find(marker.element);
    const viewportBounds = getBounds(window);
    if (op.top < viewportBounds.y) {
      intoView(marker.element, alignToTop !== false);
    } else if (op.top > viewportBounds.bottom) {
      intoView(marker.element, alignToTop === true);
    }
  };
  const rangeIntoWindow = (editor, rng, alignToTop) =>
    withMarker(editor, intoWindow, rng, alignToTop);
  const elementIntoWindow = (editor, element, alignToTop) =>
    withElement(editor, element, intoWindow, alignToTop);
  const rangeIntoFrame = (editor, rng, alignToTop) =>
    withMarker(editor, intoFrame, rng, alignToTop);
  const elementIntoFrame = (editor, element, alignToTop) =>
    withElement(editor, element, intoFrame, alignToTop);
  const scrollElementIntoView = (editor, element, alignToTop) => {
    const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
    scroller(editor, element, alignToTop);
  };
  const scrollRangeIntoView = (editor, rng, alignToTop) => {
    const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
    scroller(editor, rng, alignToTop);
  };

  const isEditableRange = (dom, rng) => {
    if (rng.collapsed) {
      return dom.isEditable(rng.startContainer);
    } else {
      return (
        dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer)
      );
    }
  };

  const getEndpointElement = (root, rng, start, real, resolve) => {
    const container = start ? rng.startContainer : rng.endContainer;
    const offset = start ? rng.startOffset : rng.endOffset;
    return Optional.from(container)
      .map(SugarElement.fromDom)
      .map((elm) =>
        !real || !rng.collapsed
          ? child$1(elm, resolve(elm, offset)).getOr(elm)
          : elm
      )
      .bind((elm) =>
        isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)
      )
      .map((elm) => elm.dom)
      .getOr(root);
  };
  const getStart = (root, rng, real = false) =>
    getEndpointElement(root, rng, true, real, (elm, offset) =>
      Math.min(childNodesCount(elm), offset)
    );
  const getEnd = (root, rng, real = false) =>
    getEndpointElement(root, rng, false, real, (elm, offset) =>
      offset > 0 ? offset - 1 : offset
    );
  const skipEmptyTextNodes = (node, forwards) => {
    const orig = node;
    while (node && isText$b(node) && node.length === 0) {
      node = forwards ? node.nextSibling : node.previousSibling;
    }
    return node || orig;
  };
  const getNode = (root, rng) => {
    if (!rng) {
      return root;
    }
    let startContainer = rng.startContainer;
    let endContainer = rng.endContainer;
    const startOffset = rng.startOffset;
    const endOffset = rng.endOffset;
    let node = rng.commonAncestorContainer;
    if (!rng.collapsed) {
      if (startContainer === endContainer) {
        if (endOffset - startOffset < 2) {
          if (startContainer.hasChildNodes()) {
            node = startContainer.childNodes[startOffset];
          }
        }
      }
      if (isText$b(startContainer) && isText$b(endContainer)) {
        if (startContainer.length === startOffset) {
          startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
        } else {
          startContainer = startContainer.parentNode;
        }
        if (endOffset === 0) {
          endContainer = skipEmptyTextNodes(
            endContainer.previousSibling,
            false
          );
        } else {
          endContainer = endContainer.parentNode;
        }
        if (startContainer && startContainer === endContainer) {
          node = startContainer;
        }
      }
    }
    const elm = isText$b(node) ? node.parentNode : node;
    return isHTMLElement(elm) ? elm : root;
  };
  const getSelectedBlocks = (dom, rng, startElm, endElm) => {
    const selectedBlocks = [];
    const root = dom.getRoot();
    const start = dom.getParent(
      startElm || getStart(root, rng, rng.collapsed),
      dom.isBlock
    );
    const end = dom.getParent(
      endElm || getEnd(root, rng, rng.collapsed),
      dom.isBlock
    );
    if (start && start !== root) {
      selectedBlocks.push(start);
    }
    if (start && end && start !== end) {
      let node;
      const walker = new DomTreeWalker(start, root);
      while ((node = walker.next()) && node !== end) {
        if (dom.isBlock(node)) {
          selectedBlocks.push(node);
        }
      }
    }
    if (end && start !== end && end !== root) {
      selectedBlocks.push(end);
    }
    return selectedBlocks;
  };
  const select = (dom, node, content) =>
    Optional.from(node).bind((node) =>
      Optional.from(node.parentNode).map((parent) => {
        const idx = dom.nodeIndex(node);
        const rng = dom.createRng();
        rng.setStart(parent, idx);
        rng.setEnd(parent, idx + 1);
        if (content) {
          moveEndPoint(dom, rng, node, true);
          moveEndPoint(dom, rng, node, false);
        }
        return rng;
      })
    );

  const processRanges = (editor, ranges) =>
    map$3(ranges, (range) => {
      const evt = editor.dispatch("GetSelectionRange", { range });
      return evt.range !== range ? evt.range : range;
    });

  const typeLookup = {
    "#text": 3,
    "#comment": 8,
    "#cdata": 4,
    "#pi": 7,
    "#doctype": 10,
    "#document-fragment": 11,
  };
  const walk$2 = (node, root, prev) => {
    const startName = prev ? "lastChild" : "firstChild";
    const siblingName = prev ? "prev" : "next";
    if (node[startName]) {
      return node[startName];
    }
    if (node !== root) {
      let sibling = node[siblingName];
      if (sibling) {
        return sibling;
      }
      for (
        let parent = node.parent;
        parent && parent !== root;
        parent = parent.parent
      ) {
        sibling = parent[siblingName];
        if (sibling) {
          return sibling;
        }
      }
    }
    return undefined;
  };
  const isEmptyTextNode = (node) => {
    var _a;
    const text = (_a = node.value) !== null && _a !== void 0 ? _a : "";
    if (!isWhitespaceText(text)) {
      return false;
    }
    const parentNode = node.parent;
    if (
      parentNode &&
      (parentNode.name !== "span" || parentNode.attr("style")) &&
      /^[ ]+$/.test(text)
    ) {
      return false;
    }
    return true;
  };
  const isNonEmptyElement = (node) => {
    const isNamedAnchor =
      node.name === "a" && !node.attr("href") && node.attr("id");
    return (
      node.attr("name") ||
      (node.attr("id") && !node.firstChild) ||
      node.attr("data-mce-bookmark") ||
      isNamedAnchor
    );
  };
  class AstNode {
    static create(name, attrs) {
      const node = new AstNode(name, typeLookup[name] || 1);
      if (attrs) {
        each$d(attrs, (value, attrName) => {
          node.attr(attrName, value);
        });
      }
      return node;
    }
    constructor(name, type) {
      this.name = name;
      this.type = type;
      if (type === 1) {
        this.attributes = [];
        this.attributes.map = {};
      }
    }
    replace(node) {
      const self = this;
      if (node.parent) {
        node.remove();
      }
      self.insert(node, self);
      self.remove();
      return self;
    }
    attr(name, value) {
      const self = this;
      if (!isString(name)) {
        if (isNonNullable(name)) {
          each$d(name, (value, key) => {
            self.attr(key, value);
          });
        }
        return self;
      }
      const attrs = self.attributes;
      if (attrs) {
        if (value !== undefined) {
          if (value === null) {
            if (name in attrs.map) {
              delete attrs.map[name];
              let i = attrs.length;
              while (i--) {
                if (attrs[i].name === name) {
                  attrs.splice(i, 1);
                  return self;
                }
              }
            }
            return self;
          }
          if (name in attrs.map) {
            let i = attrs.length;
            while (i--) {
              if (attrs[i].name === name) {
                attrs[i].value = value;
                break;
              }
            }
          } else {
            attrs.push({
              name,
              value,
            });
          }
          attrs.map[name] = value;
          return self;
        }
        return attrs.map[name];
      }
      return undefined;
    }
    clone() {
      const self = this;
      const clone = new AstNode(self.name, self.type);
      const selfAttrs = self.attributes;
      if (selfAttrs) {
        const cloneAttrs = [];
        cloneAttrs.map = {};
        for (let i = 0, l = selfAttrs.length; i < l; i++) {
          const selfAttr = selfAttrs[i];
          if (selfAttr.name !== "id") {
            cloneAttrs[cloneAttrs.length] = {
              name: selfAttr.name,
              value: selfAttr.value,
            };
            cloneAttrs.map[selfAttr.name] = selfAttr.value;
          }
        }
        clone.attributes = cloneAttrs;
      }
      clone.value = self.value;
      return clone;
    }
    wrap(wrapper) {
      const self = this;
      if (self.parent) {
        self.parent.insert(wrapper, self);
        wrapper.append(self);
      }
      return self;
    }
    unwrap() {
      const self = this;
      for (let node = self.firstChild; node; ) {
        const next = node.next;
        self.insert(node, self, true);
        node = next;
      }
      self.remove();
    }
    remove() {
      const self = this,
        parent = self.parent,
        next = self.next,
        prev = self.prev;
      if (parent) {
        if (parent.firstChild === self) {
          parent.firstChild = next;
          if (next) {
            next.prev = null;
          }
        } else if (prev) {
          prev.next = next;
        }
        if (parent.lastChild === self) {
          parent.lastChild = prev;
          if (prev) {
            prev.next = null;
          }
        } else if (next) {
          next.prev = prev;
        }
        self.parent = self.next = self.prev = null;
      }
      return self;
    }
    append(node) {
      const self = this;
      if (node.parent) {
        node.remove();
      }
      const last = self.lastChild;
      if (last) {
        last.next = node;
        node.prev = last;
        self.lastChild = node;
      } else {
        self.lastChild = self.firstChild = node;
      }
      node.parent = self;
      return node;
    }
    insert(node, refNode, before) {
      if (node.parent) {
        node.remove();
      }
      const parent = refNode.parent || this;
      if (before) {
        if (refNode === parent.firstChild) {
          parent.firstChild = node;
        } else if (refNode.prev) {
          refNode.prev.next = node;
        }
        node.prev = refNode.prev;
        node.next = refNode;
        refNode.prev = node;
      } else {
        if (refNode === parent.lastChild) {
          parent.lastChild = node;
        } else if (refNode.next) {
          refNode.next.prev = node;
        }
        node.next = refNode.next;
        node.prev = refNode;
        refNode.next = node;
      }
      node.parent = parent;
      return node;
    }
    getAll(name) {
      const self = this;
      const collection = [];
      for (let node = self.firstChild; node; node = walk$2(node, self)) {
        if (node.name === name) {
          collection.push(node);
        }
      }
      return collection;
    }
    children() {
      const self = this;
      const collection = [];
      for (let node = self.firstChild; node; node = node.next) {
        collection.push(node);
      }
      return collection;
    }
    empty() {
      const self = this;
      if (self.firstChild) {
        const nodes = [];
        for (let node = self.firstChild; node; node = walk$2(node, self)) {
          nodes.push(node);
        }
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          node.parent =
            node.firstChild =
            node.lastChild =
            node.next =
            node.prev =
              null;
        }
      }
      self.firstChild = self.lastChild = null;
      return self;
    }
    isEmpty(elements, whitespace = {}, predicate) {
      var _a;
      const self = this;
      let node = self.firstChild;
      if (isNonEmptyElement(self)) {
        return false;
      }
      if (node) {
        do {
          if (node.type === 1) {
            if (node.attr("data-mce-bogus")) {
              continue;
            }
            if (elements[node.name]) {
              return false;
            }
            if (isNonEmptyElement(node)) {
              return false;
            }
          }
          if (node.type === 8) {
            return false;
          }
          if (node.type === 3 && !isEmptyTextNode(node)) {
            return false;
          }
          if (
            node.type === 3 &&
            node.parent &&
            whitespace[node.parent.name] &&
            isWhitespaceText(
              (_a = node.value) !== null && _a !== void 0 ? _a : ""
            )
          ) {
            return false;
          }
          if (predicate && predicate(node)) {
            return false;
          }
        } while ((node = walk$2(node, self)));
      }
      return true;
    }
    walk(prev) {
      return walk$2(this, null, prev);
    }
  }

  const unescapedTextParents = Tools.makeMap(
    "NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT",
    " "
  );
  const containsZwsp = (node) =>
    isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);
  const getTemporaryNodeSelector = (tempAttrs) =>
    `${
      tempAttrs.length === 0
        ? ""
        : `${map$3(tempAttrs, (attr) => `[${attr}]`).join(",")},`
    }[data-mce-bogus="all"]`;
  const getTemporaryNodes = (tempAttrs, body) =>
    body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));
  const createZwspCommentWalker = (body) =>
    document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, (node) =>
      containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
    );
  const createUnescapedZwspTextWalker = (body) =>
    document.createTreeWalker(body, NodeFilter.SHOW_TEXT, (node) => {
      if (containsZwsp(node)) {
        const parent = node.parentNode;
        return parent && has$2(unescapedTextParents, parent.nodeName)
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      } else {
        return NodeFilter.FILTER_SKIP;
      }
    });
  const hasZwspComment = (body) =>
    createZwspCommentWalker(body).nextNode() !== null;
  const hasUnescapedZwspText = (body) =>
    createUnescapedZwspTextWalker(body).nextNode() !== null;
  const hasTemporaryNode = (tempAttrs, body) =>
    body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;
  const trimTemporaryNodes = (tempAttrs, body) => {
    each$e(getTemporaryNodes(tempAttrs, body), (elm) => {
      const element = SugarElement.fromDom(elm);
      if (get$9(element, "data-mce-bogus") === "all") {
        remove$4(element);
      } else {
        each$e(tempAttrs, (attr) => {
          if (has$1(element, attr)) {
            remove$9(element, attr);
          }
        });
      }
    });
  };
  const emptyAllNodeValuesInWalker = (walker) => {
    let curr = walker.nextNode();
    while (curr !== null) {
      curr.nodeValue = null;
      curr = walker.nextNode();
    }
  };
  const emptyZwspComments = compose(
    emptyAllNodeValuesInWalker,
    createZwspCommentWalker
  );
  const emptyUnescapedZwspTexts = compose(
    emptyAllNodeValuesInWalker,
    createUnescapedZwspTextWalker
  );
  const trim$1 = (body, tempAttrs) => {
    const conditionalTrims = [
      {
        condition: curry(hasTemporaryNode, tempAttrs),
        action: curry(trimTemporaryNodes, tempAttrs),
      },
      {
        condition: hasZwspComment,
        action: emptyZwspComments,
      },
      {
        condition: hasUnescapedZwspText,
        action: emptyUnescapedZwspTexts,
      },
    ];
    let trimmed = body;
    let cloned = false;
    each$e(conditionalTrims, ({ condition, action }) => {
      if (condition(trimmed)) {
        if (!cloned) {
          trimmed = body.cloneNode(true);
          cloned = true;
        }
        action(trimmed);
      }
    });
    return trimmed;
  };

  const cleanupBogusElements = (parent) => {
    const bogusElements = descendants(parent, "[data-mce-bogus]");
    each$e(bogusElements, (elem) => {
      const bogusValue = get$9(elem, "data-mce-bogus");
      if (bogusValue === "all") {
        remove$4(elem);
      } else if (isBr$5(elem)) {
        before$3(elem, SugarElement.fromText(zeroWidth));
        remove$4(elem);
      } else {
        unwrap(elem);
      }
    });
  };
  const cleanupInputNames = (parent) => {
    const inputs = descendants(parent, "input");
    each$e(inputs, (input) => {
      remove$9(input, "name");
    });
  };

  const trimEmptyContents = (editor, html) => {
    const blockName = getForcedRootBlock(editor);
    const emptyRegExp = new RegExp(
      `^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${blockName}>[\r\n]*|<br \\/>[\r\n]*)$`
    );
    return html.replace(emptyRegExp, "");
  };
  const getPlainTextContent = (editor, body) => {
    const doc = editor.getDoc();
    const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
    const offscreenDiv = SugarElement.fromTag("div", doc);
    set$4(offscreenDiv, "data-mce-bogus", "all");
    setAll(offscreenDiv, {
      position: "fixed",
      left: "-9999999px",
      top: "0",
    });
    set$1(offscreenDiv, body.innerHTML);
    cleanupBogusElements(offscreenDiv);
    cleanupInputNames(offscreenDiv);
    const root = getContentContainer(dos);
    append$1(root, offscreenDiv);
    const content = trim$2(offscreenDiv.dom.innerText);
    remove$4(offscreenDiv);
    return content;
  };
  const getContentFromBody = (editor, args, body) => {
    let content;
    if (args.format === "raw") {
      content = Tools.trim(
        trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML)
      );
    } else if (args.format === "text") {
      content = getPlainTextContent(editor, body);
    } else if (args.format === "tree") {
      content = editor.serializer.serialize(body, args);
    } else {
      content = trimEmptyContents(
        editor,
        editor.serializer.serialize(body, args)
      );
    }
    const shouldTrim =
      args.format !== "text" &&
      !isWsPreserveElement(SugarElement.fromDom(body));
    return shouldTrim && isString(content) ? Tools.trim(content) : content;
  };
  const getContentInternal = (editor, args) =>
    Optional.from(editor.getBody()).fold(
      constant(args.format === "tree" ? new AstNode("body", 11) : ""),
      (body) => getContentFromBody(editor, args, body)
    );

  const makeMap$1 = Tools.makeMap;
  const Writer = (settings) => {
    const html = [];
    settings = settings || {};
    const indent = settings.indent;
    const indentBefore = makeMap$1(settings.indent_before || "");
    const indentAfter = makeMap$1(settings.indent_after || "");
    const encode = Entities.getEncodeFunc(
      settings.entity_encoding || "raw",
      settings.entities
    );
    const htmlOutput = settings.element_format !== "xhtml";
    return {
      start: (name, attrs, empty) => {
        if (indent && indentBefore[name] && html.length > 0) {
          const value = html[html.length - 1];
          if (value.length > 0 && value !== "\n") {
            html.push("\n");
          }
        }
        html.push("<", name);
        if (attrs) {
          for (let i = 0, l = attrs.length; i < l; i++) {
            const attr = attrs[i];
            html.push(" ", attr.name, '="', encode(attr.value, true), '"');
          }
        }
        if (!empty || htmlOutput) {
          html[html.length] = ">";
        } else {
          html[html.length] = " />";
        }
        if (empty && indent && indentAfter[name] && html.length > 0) {
          const value = html[html.length - 1];
          if (value.length > 0 && value !== "\n") {
            html.push("\n");
          }
        }
      },
      end: (name) => {
        let value;
        html.push("</", name, ">");
        if (indent && indentAfter[name] && html.length > 0) {
          value = html[html.length - 1];
          if (value.length > 0 && value !== "\n") {
            html.push("\n");
          }
        }
      },
      text: (text, raw) => {
        if (text.length > 0) {
          html[html.length] = raw ? text : encode(text);
        }
      },
      cdata: (text) => {
        html.push("<![CDATA[", text, "]]>");
      },
      comment: (text) => {
        html.push("<!--", text, "-->");
      },
      pi: (name, text) => {
        if (text) {
          html.push("<?", name, " ", encode(text), "?>");
        } else {
          html.push("<?", name, "?>");
        }
        if (indent) {
          html.push("\n");
        }
      },
      doctype: (text) => {
        html.push("<!DOCTYPE", text, ">", indent ? "\n" : "");
      },
      reset: () => {
        html.length = 0;
      },
      getContent: () => {
        return html.join("").replace(/\n$/, "");
      },
    };
  };

  const HtmlSerializer = (settings = {}, schema = Schema()) => {
    const writer = Writer(settings);
    settings.validate = "validate" in settings ? settings.validate : true;
    const serialize = (node) => {
      const validate = settings.validate;
      const handlers = {
        3: (node) => {
          var _a;
          writer.text(
            (_a = node.value) !== null && _a !== void 0 ? _a : "",
            node.raw
          );
        },
        8: (node) => {
          var _a;
          writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : "");
        },
        7: (node) => {
          writer.pi(node.name, node.value);
        },
        10: (node) => {
          var _a;
          writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : "");
        },
        4: (node) => {
          var _a;
          writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : "");
        },
        11: (node) => {
          let tempNode = node;
          if ((tempNode = tempNode.firstChild)) {
            do {
              walk(tempNode);
            } while ((tempNode = tempNode.next));
          }
        },
      };
      writer.reset();
      const walk = (node) => {
        var _a;
        const handler = handlers[node.type];
        if (!handler) {
          const name = node.name;
          const isEmpty = name in schema.getVoidElements();
          let attrs = node.attributes;
          if (validate && attrs && attrs.length > 1) {
            const sortedAttrs = [];
            sortedAttrs.map = {};
            const elementRule = schema.getElementRule(node.name);
            if (elementRule) {
              for (
                let i = 0, l = elementRule.attributesOrder.length;
                i < l;
                i++
              ) {
                const attrName = elementRule.attributesOrder[i];
                if (attrName in attrs.map) {
                  const attrValue = attrs.map[attrName];
                  sortedAttrs.map[attrName] = attrValue;
                  sortedAttrs.push({
                    name: attrName,
                    value: attrValue,
                  });
                }
              }
              for (let i = 0, l = attrs.length; i < l; i++) {
                const attrName = attrs[i].name;
                if (!(attrName in sortedAttrs.map)) {
                  const attrValue = attrs.map[attrName];
                  sortedAttrs.map[attrName] = attrValue;
                  sortedAttrs.push({
                    name: attrName,
                    value: attrValue,
                  });
                }
              }
              attrs = sortedAttrs;
            }
          }
          writer.start(name, attrs, isEmpty);
          if (isNonHtmlElementRootName(name)) {
            if (isString(node.value)) {
              writer.text(node.value, true);
            }
            writer.end(name);
          } else {
            if (!isEmpty) {
              let child = node.firstChild;
              if (child) {
                if (
                  (name === "pre" || name === "textarea") &&
                  child.type === 3 &&
                  ((_a = child.value) === null || _a === void 0
                    ? void 0
                    : _a[0]) === "\n"
                ) {
                  writer.text("\n", true);
                }
                do {
                  walk(child);
                } while ((child = child.next));
              }
              writer.end(name);
            }
          }
        } else {
          handler(node);
        }
      };
      if (node.type === 1 && !settings.inner) {
        walk(node);
      } else if (node.type === 3) {
        handlers[3](node);
      } else {
        handlers[11](node);
      }
      return writer.getContent();
    };
    return { serialize };
  };

  const nonInheritableStyles = new Set();
  (() => {
    const nonInheritableStylesArr = [
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
    ];
    each$e(nonInheritableStylesArr, (style) => {
      nonInheritableStyles.add(style);
    });
  })();
  const conditionalNonInheritableStyles = new Set();
  (() => {
    const conditionalNonInheritableStylesArr = ["background-color"];
    each$e(conditionalNonInheritableStylesArr, (style) => {
      conditionalNonInheritableStyles.add(style);
    });
  })();
  const shorthandStyleProps = ["font", "text-decoration", "text-emphasis"];
  const getStyles$1 = (dom, node) =>
    dom.parseStyle(dom.getAttrib(node, "style"));
  const getStyleProps = (dom, node) => keys(getStyles$1(dom, node));
  const isNonInheritableStyle = (style) => nonInheritableStyles.has(style);
  const isConditionalNonInheritableStyle = (style) =>
    conditionalNonInheritableStyles.has(style);
  const hasNonInheritableStyles = (dom, node) =>
    exists(getStyleProps(dom, node), (style) => isNonInheritableStyle(style));
  const hasConditionalNonInheritableStyles = (dom, node) =>
    hasNonInheritableStyles(dom, node) &&
    exists(getStyleProps(dom, node), (style) =>
      isConditionalNonInheritableStyle(style)
    );
  const getLonghandStyleProps = (styles) =>
    filter$5(styles, (style) =>
      exists(shorthandStyleProps, (prop) => startsWith(style, prop))
    );
  const hasStyleConflict = (dom, node, parentNode) => {
    const nodeStyleProps = getStyleProps(dom, node);
    const parentNodeStyleProps = getStyleProps(dom, parentNode);
    const valueMismatch = (prop) => {
      var _a, _b;
      const nodeValue =
        (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : "";
      const parentValue =
        (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0
          ? _b
          : "";
      return (
        isNotEmpty(nodeValue) &&
        isNotEmpty(parentValue) &&
        nodeValue !== parentValue
      );
    };
    return exists(nodeStyleProps, (nodeStyleProp) => {
      const propExists = (props) =>
        exists(props, (prop) => prop === nodeStyleProp);
      if (
        !propExists(parentNodeStyleProps) &&
        propExists(shorthandStyleProps)
      ) {
        const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
        return exists(longhandProps, valueMismatch);
      } else {
        return valueMismatch(nodeStyleProp);
      }
    });
  };

  const isChar = (forward, predicate, pos) =>
    Optional.from(pos.container())
      .filter(isText$b)
      .exists((text) => {
        const delta = forward ? 0 : -1;
        return predicate(text.data.charAt(pos.offset() + delta));
      });
  const isBeforeSpace = curry(isChar, true, isWhiteSpace);
  const isAfterSpace = curry(isChar, false, isWhiteSpace);
  const isEmptyText = (pos) => {
    const container = pos.container();
    return (
      isText$b(container) &&
      (container.data.length === 0 ||
        (isZwsp(container.data) &&
          BookmarkManager.isBookmarkNode(container.parentNode)))
    );
  };
  const matchesElementPosition = (before, predicate) => (pos) =>
    getChildNodeAtRelativeOffset(before ? 0 : -1, pos)
      .filter(predicate)
      .isSome();
  const isImageBlock = (node) =>
    isImg(node) && get$7(SugarElement.fromDom(node), "display") === "block";
  const isCefNode = (node) =>
    isContentEditableFalse$b(node) && !isBogusAll(node);
  const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
  const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
  const isBeforeMedia = matchesElementPosition(true, isMedia$2);
  const isAfterMedia = matchesElementPosition(false, isMedia$2);
  const isBeforeTable = matchesElementPosition(true, isTable$2);
  const isAfterTable = matchesElementPosition(false, isTable$2);
  const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
  const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);

  const dropLast = (xs) => xs.slice(0, -1);
  const parentsUntil = (start, root, predicate) => {
    if (contains(root, start)) {
      return dropLast(
        parents$1(start, (elm) => {
          return predicate(elm) || eq(elm, root);
        })
      );
    } else {
      return [];
    }
  };
  const parents = (start, root) => parentsUntil(start, root, never);
  const parentsAndSelf = (start, root) => [start].concat(parents(start, root));

  const navigateIgnoreEmptyTextNodes = (forward, root, from) =>
    navigateIgnore(forward, root, from, isEmptyText);
  const isBlock$1 = (schema) => (el) => schema.isBlock(name(el));
  const getClosestBlock$1 = (root, pos, schema) =>
    find$2(
      parentsAndSelf(SugarElement.fromDom(pos.container()), root),
      isBlock$1(schema)
    );
  const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) =>
    navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) =>
      getClosestBlock$1(root, pos, schema).fold(
        () => !isInSameBlock(newPos, pos, root.dom),
        (fromBlock) =>
          !isInSameBlock(newPos, pos, root.dom) &&
          contains(fromBlock, SugarElement.fromDom(newPos.container()))
      )
    );
  const isAtBlockBoundary = (forward, root, pos, schema) =>
    getClosestBlock$1(root, pos, schema).fold(
      () =>
        navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(
          (newPos) => !isInSameBlock(newPos, pos, root.dom)
        ),
      (parent) =>
        navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone()
    );
  const isAtStartOfBlock = curry(isAtBlockBoundary, false);
  const isAtEndOfBlock = curry(isAtBlockBoundary, true);
  const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
  const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);

  const isBr$1 = (pos) => getElementFromPosition(pos).exists(isBr$5);
  const findBr = (forward, root, pos, schema) => {
    const parentBlocks = filter$5(
      parentsAndSelf(SugarElement.fromDom(pos.container()), root),
      (el) => schema.isBlock(name(el))
    );
    const scope = head(parentBlocks).getOr(root);
    return fromPosition(forward, scope.dom, pos).filter(isBr$1);
  };
  const isBeforeBr$1 = (root, pos, schema) =>
    getElementFromPosition(pos).exists(isBr$5) ||
    findBr(true, root, pos, schema).isSome();
  const isAfterBr = (root, pos, schema) =>
    getElementFromPrevPosition(pos).exists(isBr$5) ||
    findBr(false, root, pos, schema).isSome();
  const findPreviousBr = curry(findBr, false);
  const findNextBr = curry(findBr, true);

  const isInMiddleOfText = (pos) =>
    CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
  const getClosestBlock = (root, pos, schema) => {
    const parentBlocks = filter$5(
      parentsAndSelf(SugarElement.fromDom(pos.container()), root),
      (el) => schema.isBlock(name(el))
    );
    return head(parentBlocks).getOr(root);
  };
  const hasSpaceBefore = (root, pos, schema) => {
    if (isInMiddleOfText(pos)) {
      return isAfterSpace(pos);
    } else {
      return (
        isAfterSpace(pos) ||
        prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(
          isAfterSpace
        )
      );
    }
  };
  const hasSpaceAfter = (root, pos, schema) => {
    if (isInMiddleOfText(pos)) {
      return isBeforeSpace(pos);
    } else {
      return (
        isBeforeSpace(pos) ||
        nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(
          isBeforeSpace
        )
      );
    }
  };
  const isPreValue = (value) => contains$2(["pre", "pre-wrap"], value);
  const isInPre = (pos) =>
    getElementFromPosition(pos)
      .bind((elm) => closest$4(elm, isElement$7))
      .exists((elm) => isPreValue(get$7(elm, "white-space")));
  const isAtBeginningOfBody = (root, pos) =>
    prevPosition(root.dom, pos).isNone();
  const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
  const isAtLineBoundary = (root, pos, schema) =>
    isAtBeginningOfBody(root, pos) ||
    isAtEndOfBody(root, pos) ||
    isAtStartOfBlock(root, pos, schema) ||
    isAtEndOfBlock(root, pos, schema) ||
    isAfterBr(root, pos, schema) ||
    isBeforeBr$1(root, pos, schema);
  const isCefBlock = (node) =>
    isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);
  const isSiblingCefBlock = (root, direction) => (container) => {
    return isCefBlock(new DomTreeWalker(container, root)[direction]());
  };
  const isBeforeCefBlock = (root, pos) => {
    const nextPos = nextPosition(root.dom, pos).getOr(pos);
    const isNextCefBlock = isSiblingCefBlock(root.dom, "next");
    return (
      pos.isAtEnd() &&
      (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()))
    );
  };
  const isAfterCefBlock = (root, pos) => {
    const prevPos = prevPosition(root.dom, pos).getOr(pos);
    const isPrevCefBlock = isSiblingCefBlock(root.dom, "prev");
    return (
      pos.isAtStart() &&
      (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()))
    );
  };
  const needsToHaveNbsp = (root, pos, schema) => {
    if (isInPre(pos)) {
      return false;
    } else {
      return (
        isAtLineBoundary(root, pos, schema) ||
        hasSpaceBefore(root, pos, schema) ||
        hasSpaceAfter(root, pos, schema)
      );
    }
  };
  const needsToBeNbspLeft = (root, pos, schema) => {
    if (isInPre(pos)) {
      return false;
    } else {
      return (
        isAtStartOfBlock(root, pos, schema) ||
        isBeforeBlock(root, pos, schema) ||
        isAfterBr(root, pos, schema) ||
        hasSpaceBefore(root, pos, schema) ||
        isAfterCefBlock(root, pos)
      );
    }
  };
  const leanRight = (pos) => {
    const container = pos.container();
    const offset = pos.offset();
    if (isText$b(container) && offset < container.data.length) {
      return CaretPosition(container, offset + 1);
    } else {
      return pos;
    }
  };
  const needsToBeNbspRight = (root, pos, schema) => {
    if (isInPre(pos)) {
      return false;
    } else {
      return (
        isAtEndOfBlock(root, pos, schema) ||
        isAfterBlock(root, pos, schema) ||
        isBeforeBr$1(root, pos, schema) ||
        hasSpaceAfter(root, pos, schema) ||
        isBeforeCefBlock(root, pos)
      );
    }
  };
  const needsToBeNbsp = (root, pos, schema) =>
    needsToBeNbspLeft(root, pos, schema) ||
    needsToBeNbspRight(root, leanRight(pos), schema);
  const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));
  const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));
  const hasNbsp = (pos) => {
    const container = pos.container();
    return isText$b(container) && contains$1(container.data, nbsp);
  };
  const normalizeNbspMiddle = (text) => {
    const chars = text.split("");
    return map$3(chars, (chr, i) => {
      if (
        isNbsp(chr) &&
        i > 0 &&
        i < chars.length - 1 &&
        isContent(chars[i - 1]) &&
        isContent(chars[i + 1])
      ) {
        return " ";
      } else {
        return chr;
      }
    }).join("");
  };
  const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {
    const text = node.data;
    const firstPos = CaretPosition(node, 0);
    if (
      !makeNbsp &&
      isNbspAt(text, 0) &&
      !needsToBeNbsp(root, firstPos, schema)
    ) {
      node.data = " " + text.slice(1);
      return true;
    } else if (
      makeNbsp &&
      isWhiteSpaceAt(text, 0) &&
      needsToBeNbspLeft(root, firstPos, schema)
    ) {
      node.data = nbsp + text.slice(1);
      return true;
    } else {
      return false;
    }
  };
  const normalizeNbspInMiddleOfTextNode = (node) => {
    const text = node.data;
    const newText = normalizeNbspMiddle(text);
    if (newText !== text) {
      node.data = newText;
      return true;
    } else {
      return false;
    }
  };
  const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {
    const text = node.data;
    const lastPos = CaretPosition(node, text.length - 1);
    if (
      !makeNbsp &&
      isNbspAt(text, text.length - 1) &&
      !needsToBeNbsp(root, lastPos, schema)
    ) {
      node.data = text.slice(0, -1) + " ";
      return true;
    } else if (
      makeNbsp &&
      isWhiteSpaceAt(text, text.length - 1) &&
      needsToBeNbspRight(root, lastPos, schema)
    ) {
      node.data = text.slice(0, -1) + nbsp;
      return true;
    } else {
      return false;
    }
  };
  const normalizeNbsps$1 = (root, pos, schema) => {
    const container = pos.container();
    if (!isText$b(container)) {
      return Optional.none();
    }
    if (hasNbsp(pos)) {
      const normalized =
        normalizeNbspAtStart(root, container, false, schema) ||
        normalizeNbspInMiddleOfTextNode(container) ||
        normalizeNbspAtEnd(root, container, false, schema);
      return someIf(normalized, pos);
    } else if (needsToBeNbsp(root, pos, schema)) {
      const normalized =
        normalizeNbspAtStart(root, container, true, schema) ||
        normalizeNbspAtEnd(root, container, true, schema);
      return someIf(normalized, pos);
    } else {
      return Optional.none();
    }
  };
  const normalizeNbspsInEditor = (editor) => {
    const root = SugarElement.fromDom(editor.getBody());
    if (editor.selection.isCollapsed()) {
      normalizeNbsps$1(
        root,
        CaretPosition.fromRangeStart(editor.selection.getRng()),
        editor.schema
      ).each((pos) => {
        editor.selection.setRng(pos.toRange());
      });
    }
  };

  const normalize$1 = (node, offset, count, schema) => {
    if (count === 0) {
      return;
    }
    const elm = SugarElement.fromDom(node);
    const root = ancestor$4(elm, (el) => schema.isBlock(name(el))).getOr(elm);
    const whitespace = node.data.slice(offset, offset + count);
    const isEndOfContent =
      offset + count >= node.data.length &&
      needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);
    const isStartOfContent =
      offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);
    node.replaceData(
      offset,
      count,
      normalize$4(whitespace, 4, isStartOfContent, isEndOfContent)
    );
  };
  const normalizeWhitespaceAfter = (node, offset, schema) => {
    const content = node.data.slice(offset);
    const whitespaceCount = content.length - lTrim(content).length;
    normalize$1(node, offset, whitespaceCount, schema);
  };
  const normalizeWhitespaceBefore = (node, offset, schema) => {
    const content = node.data.slice(0, offset);
    const whitespaceCount = content.length - rTrim(content).length;
    normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);
  };
  const mergeTextNodes = (
    prevNode,
    nextNode,
    schema,
    normalizeWhitespace,
    mergeToPrev = true
  ) => {
    const whitespaceOffset = rTrim(prevNode.data).length;
    const newNode = mergeToPrev ? prevNode : nextNode;
    const removeNode = mergeToPrev ? nextNode : prevNode;
    if (mergeToPrev) {
      newNode.appendData(removeNode.data);
    } else {
      newNode.insertData(0, removeNode.data);
    }
    remove$4(SugarElement.fromDom(removeNode));
    if (normalizeWhitespace) {
      normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);
    }
    return newNode;
  };

  const needsReposition = (pos, elm) => {
    const container = pos.container();
    const offset = pos.offset();
    return (
      !CaretPosition.isTextPosition(pos) &&
      container === elm.parentNode &&
      offset > CaretPosition.before(elm).offset()
    );
  };
  const reposition = (elm, pos) =>
    needsReposition(pos, elm)
      ? CaretPosition(pos.container(), pos.offset() - 1)
      : pos;
  const beforeOrStartOf = (node) =>
    isText$b(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
  const afterOrEndOf = (node) =>
    isText$b(node)
      ? CaretPosition(node, node.data.length)
      : CaretPosition.after(node);
  const getPreviousSiblingCaretPosition = (elm) => {
    if (isCaretCandidate$3(elm.previousSibling)) {
      return Optional.some(afterOrEndOf(elm.previousSibling));
    } else {
      return elm.previousSibling
        ? lastPositionIn(elm.previousSibling)
        : Optional.none();
    }
  };
  const getNextSiblingCaretPosition = (elm) => {
    if (isCaretCandidate$3(elm.nextSibling)) {
      return Optional.some(beforeOrStartOf(elm.nextSibling));
    } else {
      return elm.nextSibling
        ? firstPositionIn(elm.nextSibling)
        : Optional.none();
    }
  };
  const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
    return Optional.from(
      elm.previousSibling ? elm.previousSibling : elm.parentNode
    )
      .bind((node) => prevPosition(rootElement, CaretPosition.before(node)))
      .orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
  };
  const findCaretPositionForwardsFromElm = (rootElement, elm) =>
    nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() =>
      prevPosition(rootElement, CaretPosition.before(elm))
    );
  const findCaretPositionBackwards = (rootElement, elm) =>
    getPreviousSiblingCaretPosition(elm)
      .orThunk(() => getNextSiblingCaretPosition(elm))
      .orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
  const findCaretPositionForward = (rootElement, elm) =>
    getNextSiblingCaretPosition(elm)
      .orThunk(() => getPreviousSiblingCaretPosition(elm))
      .orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
  const findCaretPosition = (forward, rootElement, elm) =>
    forward
      ? findCaretPositionForward(rootElement, elm)
      : findCaretPositionBackwards(rootElement, elm);
  const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) =>
    findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
  const setSelection$1 = (editor, forward, pos) => {
    pos.fold(
      () => {
        editor.focus();
      },
      (pos) => {
        editor.selection.setRng(pos.toRange(), forward);
      }
    );
  };
  const eqRawNode = (rawNode) => (elm) => elm.dom === rawNode;
  const isBlock = (editor, elm) =>
    elm && has$2(editor.schema.getBlockElements(), name(elm));
  const paddEmptyBlock = (schema, elm, preserveEmptyCaret) => {
    if (isEmpty$2(schema, elm)) {
      const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
      if (preserveEmptyCaret) {
        each$e(children$1(elm), (node) => {
          if (!isEmptyCaretFormatElement(node)) {
            remove$4(node);
          }
        });
      } else {
        empty(elm);
      }
      append$1(elm, br);
      return Optional.some(CaretPosition.before(br.dom));
    } else {
      return Optional.none();
    }
  };
  const deleteNormalized = (
    elm,
    afterDeletePosOpt,
    schema,
    normalizeWhitespace
  ) => {
    const prevTextOpt = prevSibling(elm).filter(isText$c);
    const nextTextOpt = nextSibling(elm).filter(isText$c);
    remove$4(elm);
    return lift3(
      prevTextOpt,
      nextTextOpt,
      afterDeletePosOpt,
      (prev, next, pos) => {
        const prevNode = prev.dom,
          nextNode = next.dom;
        const offset = prevNode.data.length;
        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);
        return pos.container() === nextNode
          ? CaretPosition(prevNode, offset)
          : pos;
      }
    ).orThunk(() => {
      if (normalizeWhitespace) {
        prevTextOpt.each((elm) =>
          normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema)
        );
        nextTextOpt.each((elm) => normalizeWhitespaceAfter(elm.dom, 0, schema));
      }
      return afterDeletePosOpt;
    });
  };
  const isInlineElement = (editor, element) =>
    has$2(editor.schema.getTextInlineElements(), name(element));
  const deleteElement$2 = (
    editor,
    forward,
    elm,
    moveCaret = true,
    preserveEmptyCaret = false
  ) => {
    const afterDeletePos = findCaretPosOutsideElmAfterDelete(
      forward,
      editor.getBody(),
      elm.dom
    );
    const parentBlock = ancestor$4(
      elm,
      curry(isBlock, editor),
      eqRawNode(editor.getBody())
    );
    const normalizedAfterDeletePos = deleteNormalized(
      elm,
      afterDeletePos,
      editor.schema,
      isInlineElement(editor, elm)
    );
    if (editor.dom.isEmpty(editor.getBody())) {
      editor.setContent("");
      editor.selection.setCursorLocation();
    } else {
      parentBlock
        .bind((elm) => paddEmptyBlock(editor.schema, elm, preserveEmptyCaret))
        .fold(
          () => {
            if (moveCaret) {
              setSelection$1(editor, forward, normalizedAfterDeletePos);
            }
          },
          (paddPos) => {
            if (moveCaret) {
              setSelection$1(editor, forward, Optional.some(paddPos));
            }
          }
        );
    }
  };

  const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
  const hasStrongRtl = (text) => strongRtl.test(text);

  const isInlineTarget = (editor, elm) =>
    is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) &&
    !isTransparentBlock(editor.schema, elm) &&
    editor.dom.isEditable(elm);
  const isRtl = (element) => {
    var _a;
    return (
      DOMUtils.DOM.getStyle(element, "direction", true) === "rtl" ||
      hasStrongRtl(
        (_a = element.textContent) !== null && _a !== void 0 ? _a : ""
      )
    );
  };
  const findInlineParents = (isInlineTarget, rootNode, pos) =>
    filter$5(
      DOMUtils.DOM.getParents(pos.container(), "*", rootNode),
      isInlineTarget
    );
  const findRootInline = (isInlineTarget, rootNode, pos) => {
    const parents = findInlineParents(isInlineTarget, rootNode, pos);
    return Optional.from(parents[parents.length - 1]);
  };
  const hasSameParentBlock = (rootNode, node1, node2) => {
    const block1 = getParentBlock$3(node1, rootNode);
    const block2 = getParentBlock$3(node2, rootNode);
    return isNonNullable(block1) && block1 === block2;
  };
  const isAtZwsp = (pos) => isBeforeInline(pos) || isAfterInline(pos);
  const normalizePosition = (forward, pos) => {
    const container = pos.container(),
      offset = pos.offset();
    if (forward) {
      if (isCaretContainerInline(container)) {
        if (isText$b(container.nextSibling)) {
          return CaretPosition(container.nextSibling, 0);
        } else {
          return CaretPosition.after(container);
        }
      } else {
        return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
      }
    } else {
      if (isCaretContainerInline(container)) {
        if (isText$b(container.previousSibling)) {
          return CaretPosition(
            container.previousSibling,
            container.previousSibling.data.length
          );
        } else {
          return CaretPosition.before(container);
        }
      } else {
        return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
      }
    }
  };
  const normalizeForwards = curry(normalizePosition, true);
  const normalizeBackwards = curry(normalizePosition, false);

  const execCommandIgnoreInputEvents = (editor, command) => {
    const inputBlocker = (e) => e.stopImmediatePropagation();
    editor.on("beforeinput input", inputBlocker, true);
    editor.getDoc().execCommand(command);
    editor.off("beforeinput input", inputBlocker);
  };
  const execEditorDeleteCommand = (editor) => {
    editor.execCommand("delete");
  };
  const execNativeDeleteCommand = (editor) =>
    execCommandIgnoreInputEvents(editor, "Delete");
  const execNativeForwardDeleteCommand = (editor) =>
    execCommandIgnoreInputEvents(editor, "ForwardDelete");
  const isBeforeRoot = (rootNode) => (elm) => is$2(parent(elm), rootNode, eq);
  const isTextBlockOrListItem = (element) =>
    isTextBlock$2(element) || isListItem$1(element);
  const getParentBlock$2 = (rootNode, elm) => {
    if (contains(rootNode, elm)) {
      return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
    } else {
      return Optional.none();
    }
  };
  const paddEmptyBody = (editor, moveSelection = true) => {
    if (editor.dom.isEmpty(editor.getBody())) {
      editor.setContent("", { no_selection: !moveSelection });
    }
  };
  const willDeleteLastPositionInElement = (forward, fromPos, elm) =>
    lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      const normalizedFromPos = normalizePosition(false, fromPos);
      if (forward) {
        return nextPosition(elm, normalizedFromPos).exists(
          (nextPos) =>
            nextPos.isEqual(normalizedLastPos) &&
            fromPos.isEqual(normalizedFirstPos)
        );
      } else {
        return prevPosition(elm, normalizedFromPos).exists(
          (prevPos) =>
            prevPos.isEqual(normalizedFirstPos) &&
            fromPos.isEqual(normalizedLastPos)
        );
      }
    }).getOr(true);
  const freefallRtl = (root) => {
    const child = isComment$1(root) ? prevSibling(root) : lastChild(root);
    return child.bind(freefallRtl).orThunk(() => Optional.some(root));
  };
  const deleteRangeContents = (editor, rng, root, moveSelection = true) => {
    var _a;
    rng.deleteContents();
    const lastNode = freefallRtl(root).getOr(root);
    const lastBlock = SugarElement.fromDom(
      (_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null &&
        _a !== void 0
        ? _a
        : root.dom
    );
    if (lastBlock.dom === editor.getBody()) {
      paddEmptyBody(editor, moveSelection);
    } else if (
      isEmpty$2(editor.schema, lastBlock, { checkRootAsContent: false })
    ) {
      fillWithPaddingBr(lastBlock);
      if (moveSelection) {
        editor.selection.setCursorLocation(lastBlock.dom, 0);
      }
    }
    if (!eq(root, lastBlock)) {
      const additionalCleanupNodes = is$2(parent(lastBlock), root)
        ? []
        : siblings(lastBlock);
      each$e(additionalCleanupNodes.concat(children$1(root)), (node) => {
        if (
          !eq(node, lastBlock) &&
          !contains(node, lastBlock) &&
          isEmpty$2(editor.schema, node)
        ) {
          remove$4(node);
        }
      });
    }
  };

  const isRootFromElement = (root) => (cur) => eq(root, cur);
  const getTableCells = (table) => descendants(table, "td,th");
  const getTable$1 = (node, isRoot) =>
    getClosestTable(SugarElement.fromDom(node), isRoot);
  const selectionInTableWithNestedTable = (details) => {
    return lift2(
      details.startTable,
      details.endTable,
      (startTable, endTable) => {
        const isStartTableParentOfEndTable = descendant(startTable, (t) =>
          eq(t, endTable)
        );
        const isEndTableParentOfStartTable = descendant(endTable, (t) =>
          eq(t, startTable)
        );
        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable
          ? details
          : {
              ...details,
              startTable: isStartTableParentOfEndTable
                ? Optional.none()
                : details.startTable,
              endTable: isEndTableParentOfStartTable
                ? Optional.none()
                : details.endTable,
              isSameTable: false,
              isMultiTable: false,
            };
      }
    ).getOr(details);
  };
  const adjustQuirksInDetails = (details) => {
    return selectionInTableWithNestedTable(details);
  };
  const getTableDetailsFromRange = (rng, isRoot) => {
    const startTable = getTable$1(rng.startContainer, isRoot);
    const endTable = getTable$1(rng.endContainer, isRoot);
    const isStartInTable = startTable.isSome();
    const isEndInTable = endTable.isSome();
    const isSameTable = lift2(startTable, endTable, eq).getOr(false);
    const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
    return adjustQuirksInDetails({
      startTable,
      endTable,
      isStartInTable,
      isEndInTable,
      isSameTable,
      isMultiTable,
    });
  };

  const tableCellRng = (start, end) => ({
    start,
    end,
  });
  const tableSelection = (rng, table, cells) => ({
    rng,
    table,
    cells,
  });
  const deleteAction = Adt.generate([
    {
      singleCellTable: ["rng", "cell"],
    },
    { fullTable: ["table"] },
    {
      partialTable: ["cells", "outsideDetails"],
    },
    {
      multiTable: ["startTableCells", "endTableCells", "betweenRng"],
    },
  ]);
  const getClosestCell$1 = (container, isRoot) =>
    closest$3(SugarElement.fromDom(container), "td,th", isRoot);
  const isExpandedCellRng = (cellRng) => !eq(cellRng.start, cellRng.end);
  const getTableFromCellRng = (cellRng, isRoot) =>
    getClosestTable(cellRng.start, isRoot).bind((startParentTable) =>
      getClosestTable(cellRng.end, isRoot).bind((endParentTable) =>
        someIf(eq(startParentTable, endParentTable), startParentTable)
      )
    );
  const isSingleCellTable = (cellRng, isRoot) =>
    !isExpandedCellRng(cellRng) &&
    getTableFromCellRng(cellRng, isRoot).exists((table) => {
      const rows = table.dom.rows;
      return rows.length === 1 && rows[0].cells.length === 1;
    });
  const getCellRng = (rng, isRoot) => {
    const startCell = getClosestCell$1(rng.startContainer, isRoot);
    const endCell = getClosestCell$1(rng.endContainer, isRoot);
    return lift2(startCell, endCell, tableCellRng);
  };
  const getCellRangeFromStartTable = (isRoot) => (startCell) =>
    getClosestTable(startCell, isRoot).bind((table) =>
      last$2(getTableCells(table)).map((endCell) =>
        tableCellRng(startCell, endCell)
      )
    );
  const getCellRangeFromEndTable = (isRoot) => (endCell) =>
    getClosestTable(endCell, isRoot).bind((table) =>
      head(getTableCells(table)).map((startCell) =>
        tableCellRng(startCell, endCell)
      )
    );
  const getTableSelectionFromCellRng = (isRoot) => (cellRng) =>
    getTableFromCellRng(cellRng, isRoot).map((table) =>
      tableSelection(cellRng, table, getTableCells(table))
    );
  const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {
    if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
      return Optional.none();
    } else if (selectionDetails.isSameTable) {
      const sameTableSelection = cellRng.bind(
        getTableSelectionFromCellRng(isRoot)
      );
      return Optional.some({
        start: sameTableSelection,
        end: sameTableSelection,
      });
    } else {
      const startCell = getClosestCell$1(rng.startContainer, isRoot);
      const endCell = getClosestCell$1(rng.endContainer, isRoot);
      const startTableSelection = startCell
        .bind(getCellRangeFromStartTable(isRoot))
        .bind(getTableSelectionFromCellRng(isRoot));
      const endTableSelection = endCell
        .bind(getCellRangeFromEndTable(isRoot))
        .bind(getTableSelectionFromCellRng(isRoot));
      return Optional.some({
        start: startTableSelection,
        end: endTableSelection,
      });
    }
  };
  const getCellIndex = (cells, cell) => findIndex$2(cells, (x) => eq(x, cell));
  const getSelectedCells = (tableSelection) =>
    lift2(
      getCellIndex(tableSelection.cells, tableSelection.rng.start),
      getCellIndex(tableSelection.cells, tableSelection.rng.end),
      (startIndex, endIndex) =>
        tableSelection.cells.slice(startIndex, endIndex + 1)
    );
  const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) =>
    optCellRng.exists(
      (cellRng) =>
        isSingleCellTable(cellRng, isRoot) &&
        hasAllContentsSelected(cellRng.start, rng)
    );
  const unselectCells = (rng, selectionDetails) => {
    const { startTable, endTable } = selectionDetails;
    const otherContentRng = rng.cloneRange();
    startTable.each((table) => otherContentRng.setStartAfter(table.dom));
    endTable.each((table) => otherContentRng.setEndBefore(table.dom));
    return otherContentRng;
  };
  const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) =>
    getTableSelections(cellRng, selectionDetails, rng, isRoot)
      .bind(({ start, end }) => start.or(end))
      .bind((tableSelection) => {
        const { isSameTable } = selectionDetails;
        const selectedCells = getSelectedCells(tableSelection).getOr([]);
        if (
          isSameTable &&
          tableSelection.cells.length === selectedCells.length
        ) {
          return Optional.some(deleteAction.fullTable(tableSelection.table));
        } else if (selectedCells.length > 0) {
          if (isSameTable) {
            return Optional.some(
              deleteAction.partialTable(selectedCells, Optional.none())
            );
          } else {
            const otherContentRng = unselectCells(rng, selectionDetails);
            return Optional.some(
              deleteAction.partialTable(
                selectedCells,
                Optional.some({
                  ...selectionDetails,
                  rng: otherContentRng,
                })
              )
            );
          }
        } else {
          return Optional.none();
        }
      });
  const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) =>
    getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(
      ({ start, end }) => {
        const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);
        const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);
        if (
          startTableSelectedCells.length > 0 &&
          endTableSelectedCells.length > 0
        ) {
          const otherContentRng = unselectCells(rng, selectionDetails);
          return Optional.some(
            deleteAction.multiTable(
              startTableSelectedCells,
              endTableSelectedCells,
              otherContentRng
            )
          );
        } else {
          return Optional.none();
        }
      }
    );
  const getActionFromRange = (root, rng) => {
    const isRoot = isRootFromElement(root);
    const optCellRng = getCellRng(rng, isRoot);
    const selectionDetails = getTableDetailsFromRange(rng, isRoot);
    if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {
      return optCellRng.map((cellRng) =>
        deleteAction.singleCellTable(rng, cellRng.start)
      );
    } else if (selectionDetails.isMultiTable) {
      return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);
    } else {
      return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);
    }
  };

  const cleanCells = (cells) =>
    each$e(cells, (cell) => {
      remove$9(cell, "contenteditable");
      fillWithPaddingBr(cell);
    });
  const getOutsideBlock = (editor, container) =>
    Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(
      SugarElement.fromDom
    );
  const handleEmptyBlock = (editor, startInTable, emptyBlock) => {
    emptyBlock.each((block) => {
      if (startInTable) {
        remove$4(block);
      } else {
        fillWithPaddingBr(block);
        editor.selection.setCursorLocation(block.dom, 0);
      }
    });
  };
  const deleteContentInsideCell = (
    editor,
    cell,
    rng,
    isFirstCellInSelection
  ) => {
    const insideTableRng = rng.cloneRange();
    if (isFirstCellInSelection) {
      insideTableRng.setStart(rng.startContainer, rng.startOffset);
      insideTableRng.setEndAfter(cell.dom.lastChild);
    } else {
      insideTableRng.setStartBefore(cell.dom.firstChild);
      insideTableRng.setEnd(rng.endContainer, rng.endOffset);
    }
    deleteCellContents(editor, insideTableRng, cell, false).each((action) =>
      action()
    );
  };
  const collapseAndRestoreCellSelection = (editor) => {
    const selectedCells = getCellsFromEditor(editor);
    const selectedNode = SugarElement.fromDom(editor.selection.getNode());
    if (
      isTableCell$3(selectedNode.dom) &&
      isEmpty$2(editor.schema, selectedNode)
    ) {
      editor.selection.setCursorLocation(selectedNode.dom, 0);
    } else {
      editor.selection.collapse(true);
    }
    if (
      selectedCells.length > 1 &&
      exists(selectedCells, (cell) => eq(cell, selectedNode))
    ) {
      set$4(selectedNode, "data-mce-selected", "1");
    }
  };
  const emptySingleTableCells = (editor, cells, outsideDetails) =>
    Optional.some(() => {
      const editorRng = editor.selection.getRng();
      const cellsToClean = outsideDetails
        .bind(({ rng, isStartInTable }) => {
          const outsideBlock = getOutsideBlock(
            editor,
            isStartInTable ? rng.endContainer : rng.startContainer
          );
          rng.deleteContents();
          handleEmptyBlock(
            editor,
            isStartInTable,
            outsideBlock.filter(curry(isEmpty$2, editor.schema))
          );
          const endPointCell = isStartInTable
            ? cells[0]
            : cells[cells.length - 1];
          deleteContentInsideCell(
            editor,
            endPointCell,
            editorRng,
            isStartInTable
          );
          if (!isEmpty$2(editor.schema, endPointCell)) {
            return Optional.some(
              isStartInTable ? cells.slice(1) : cells.slice(0, -1)
            );
          } else {
            return Optional.none();
          }
        })
        .getOr(cells);
      cleanCells(cellsToClean);
      collapseAndRestoreCellSelection(editor);
    });
  const emptyMultiTableCells = (
    editor,
    startTableCells,
    endTableCells,
    betweenRng
  ) =>
    Optional.some(() => {
      const rng = editor.selection.getRng();
      const startCell = startTableCells[0];
      const endCell = endTableCells[endTableCells.length - 1];
      deleteContentInsideCell(editor, startCell, rng, true);
      deleteContentInsideCell(editor, endCell, rng, false);
      const startTableCellsToClean = isEmpty$2(editor.schema, startCell)
        ? startTableCells
        : startTableCells.slice(1);
      const endTableCellsToClean = isEmpty$2(editor.schema, endCell)
        ? endTableCells
        : endTableCells.slice(0, -1);
      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
      betweenRng.deleteContents();
      collapseAndRestoreCellSelection(editor);
    });
  const deleteCellContents = (editor, rng, cell, moveSelection = true) =>
    Optional.some(() => {
      deleteRangeContents(editor, rng, cell, moveSelection);
    });
  const deleteTableElement = (editor, table) =>
    Optional.some(() => deleteElement$2(editor, false, table));
  const deleteCellRange = (editor, rootElm, rng) =>
    getActionFromRange(rootElm, rng).bind((action) =>
      action.fold(
        curry(deleteCellContents, editor),
        curry(deleteTableElement, editor),
        curry(emptySingleTableCells, editor),
        curry(emptyMultiTableCells, editor)
      )
    );
  const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
  const deleteTableRange = (editor, rootElm, rng, startElm) =>
    getParentCaption(rootElm, startElm).fold(
      () => deleteCellRange(editor, rootElm, rng),
      (caption) => deleteCaptionRange(editor, caption)
    );
  const deleteRange$3 = (editor, startElm, selectedCells) => {
    const rootNode = SugarElement.fromDom(editor.getBody());
    const rng = editor.selection.getRng();
    return selectedCells.length !== 0
      ? emptySingleTableCells(editor, selectedCells, Optional.none())
      : deleteTableRange(editor, rootNode, rng, startElm);
  };
  const getParentCell = (rootElm, elm) =>
    find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
  const getParentCaption = (rootElm, elm) =>
    find$2(parentsAndSelf(elm, rootElm), isTag("caption"));
  const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) =>
    navigate(forward, editor.getBody(), from).bind((to) =>
      getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(
        (toCell) =>
          eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)
      )
    );
  const emptyElement = (editor, elm) =>
    Optional.some(() => {
      fillWithPaddingBr(elm);
      editor.selection.setCursorLocation(elm.dom, 0);
    });
  const isDeleteOfLastCharPos = (fromCaption, forward, from, to) =>
    firstPositionIn(fromCaption.dom)
      .bind((first) =>
        lastPositionIn(fromCaption.dom).map((last) =>
          forward
            ? from.isEqual(first) && to.isEqual(last)
            : from.isEqual(last) && to.isEqual(first)
        )
      )
      .getOr(true);
  const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
  const validateCaretCaption = (rootElm, fromCaption, to) =>
    getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(
      () => Optional.some(noop),
      (toCaption) => someIf(!eq(toCaption, fromCaption), noop)
    );
  const deleteCaretInsideCaption = (
    editor,
    rootElm,
    forward,
    fromCaption,
    from
  ) =>
    navigate(forward, editor.getBody(), from).fold(
      () => Optional.some(noop),
      (to) =>
        isDeleteOfLastCharPos(fromCaption, forward, from, to)
          ? emptyCaretCaption(editor, fromCaption)
          : validateCaretCaption(rootElm, fromCaption, to)
    );
  const deleteCaretCells = (editor, forward, rootElm, startElm) => {
    const from = CaretPosition.fromRangeStart(editor.selection.getRng());
    return getParentCell(rootElm, startElm).bind((fromCell) =>
      isEmpty$2(editor.schema, fromCell, { checkRootAsContent: false })
        ? emptyElement(editor, fromCell)
        : deleteBetweenCells(editor, rootElm, forward, fromCell, from)
    );
  };
  const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
    const from = CaretPosition.fromRangeStart(editor.selection.getRng());
    return isEmpty$2(editor.schema, fromCaption)
      ? emptyElement(editor, fromCaption)
      : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
  };
  const isNearTable = (forward, pos) =>
    forward ? isBeforeTable(pos) : isAfterTable(pos);
  const isBeforeOrAfterTable = (editor, forward) => {
    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
    return (
      isNearTable(forward, fromPos) ||
      fromPosition(forward, editor.getBody(), fromPos).exists((pos) =>
        isNearTable(forward, pos)
      )
    );
  };
  const deleteCaret$3 = (editor, forward, startElm) => {
    const rootElm = SugarElement.fromDom(editor.getBody());
    return getParentCaption(rootElm, startElm).fold(
      () =>
        deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() =>
          someIf(isBeforeOrAfterTable(editor, forward), noop)
        ),
      (fromCaption) => deleteCaretCaption(editor, forward, rootElm, fromCaption)
    );
  };
  const backspaceDelete$b = (editor, forward) => {
    const startElm = SugarElement.fromDom(editor.selection.getStart(true));
    const cells = getCellsFromEditor(editor);
    return editor.selection.isCollapsed() && cells.length === 0
      ? deleteCaret$3(editor, forward, startElm)
      : deleteRange$3(editor, startElm, cells);
  };

  const getContentEditableRoot$1 = (root, node) => {
    let tempNode = node;
    while (tempNode && tempNode !== root) {
      if (
        isContentEditableTrue$3(tempNode) ||
        isContentEditableFalse$b(tempNode)
      ) {
        return tempNode;
      }
      tempNode = tempNode.parentNode;
    }
    return null;
  };

  const internalAttributesPrefixes = [
    "data-ephox-",
    "data-mce-",
    "data-alloy-",
    "data-snooker-",
    "_",
  ];
  const each$9 = Tools.each;
  const ElementUtils = (editor) => {
    const dom = editor.dom;
    const internalAttributes = new Set(editor.serializer.getTempAttrs());
    const compare = (node1, node2) => {
      if (
        node1.nodeName !== node2.nodeName ||
        node1.nodeType !== node2.nodeType
      ) {
        return false;
      }
      const getAttribs = (node) => {
        const attribs = {};
        each$9(dom.getAttribs(node), (attr) => {
          const name = attr.nodeName.toLowerCase();
          if (name !== "style" && !isAttributeInternal(name)) {
            attribs[name] = dom.getAttrib(node, name);
          }
        });
        return attribs;
      };
      const compareObjects = (obj1, obj2) => {
        for (const name in obj1) {
          if (has$2(obj1, name)) {
            const value = obj2[name];
            if (isUndefined(value)) {
              return false;
            }
            if (obj1[name] !== value) {
              return false;
            }
            delete obj2[name];
          }
        }
        for (const name in obj2) {
          if (has$2(obj2, name)) {
            return false;
          }
        }
        return true;
      };
      if (isElement$6(node1) && isElement$6(node2)) {
        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
          return false;
        }
        if (
          !compareObjects(
            dom.parseStyle(dom.getAttrib(node1, "style")),
            dom.parseStyle(dom.getAttrib(node2, "style"))
          )
        ) {
          return false;
        }
      }
      return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
    };
    const isAttributeInternal = (attributeName) =>
      exists(internalAttributesPrefixes, (value) =>
        startsWith(attributeName, value)
      ) || internalAttributes.has(attributeName);
    return {
      compare,
      isAttributeInternal,
    };
  };

  const isHeading = (node) =>
    ["h1", "h2", "h3", "h4", "h5", "h6"].includes(node.name);
  const isSummary = (node) => node.name === "summary";

  const traverse = (root, fn) => {
    let node = root;
    while ((node = node.walk())) {
      fn(node);
    }
  };
  const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
    const name = node.name;
    for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
      const filter = nodeFilters[ni];
      if (filter.name === name) {
        const match = matches.nodes[name];
        if (match) {
          match.nodes.push(node);
        } else {
          matches.nodes[name] = {
            filter,
            nodes: [node],
          };
        }
      }
    }
    if (node.attributes) {
      for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
        const filter = attributeFilters[ai];
        const attrName = filter.name;
        if (attrName in node.attributes.map) {
          const match = matches.attributes[attrName];
          if (match) {
            match.nodes.push(node);
          } else {
            matches.attributes[attrName] = {
              filter,
              nodes: [node],
            };
          }
        }
      }
    }
  };
  const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
    const matches = {
      nodes: {},
      attributes: {},
    };
    if (node.firstChild) {
      traverse(node, (childNode) => {
        matchNode$1(nodeFilters, attributeFilters, childNode, matches);
      });
    }
    return matches;
  };
  const runFilters = (matches, args) => {
    const run = (matchRecord, filteringAttributes) => {
      each$d(matchRecord, (match) => {
        const nodes = from(match.nodes);
        each$e(match.filter.callbacks, (callback) => {
          for (let i = nodes.length - 1; i >= 0; i--) {
            const node = nodes[i];
            const valueMatches = filteringAttributes
              ? node.attr(match.filter.name) !== undefined
              : node.name === match.filter.name;
            if (!valueMatches || isNullable(node.parent)) {
              nodes.splice(i, 1);
            }
          }
          if (nodes.length > 0) {
            callback(nodes, match.filter.name, args);
          }
        });
      });
    };
    run(matches.nodes, false);
    run(matches.attributes, true);
  };
  const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {
    const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
    runFilters(matches, args);
  };

  const paddEmptyNode = (settings, args, isBlock, node) => {
    const brPreferred = settings.pad_empty_with_br || args.insert;
    if (brPreferred && isBlock(node)) {
      const astNode = new AstNode("br", 1);
      if (args.insert) {
        astNode.attr("data-mce-bogus", "1");
      }
      node.empty().append(astNode);
    } else {
      node.empty().append(new AstNode("#text", 3)).value = nbsp;
    }
  };
  const isPaddedWithNbsp = (node) => {
    var _a;
    return (
      hasOnlyChild(node, "#text") &&
      ((_a = node === null || node === void 0 ? void 0 : node.firstChild) ===
        null || _a === void 0
        ? void 0
        : _a.value) === nbsp
    );
  };
  const hasOnlyChild = (node, name) => {
    const firstChild =
      node === null || node === void 0 ? void 0 : node.firstChild;
    return (
      isNonNullable(firstChild) &&
      firstChild === node.lastChild &&
      firstChild.name === name
    );
  };
  const isPadded = (schema, node) => {
    const rule = schema.getElementRule(node.name);
    return (
      (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true
    );
  };
  const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) =>
    node.isEmpty(nonEmptyElements, whitespaceElements, (node) =>
      isPadded(schema, node)
    );
  const isLineBreakNode = (node, isBlock) =>
    isNonNullable(node) && (isBlock(node) || node.name === "br");
  const findClosestEditingHost = (scope) => {
    let editableNode;
    for (let node = scope; node; node = node.parent) {
      const contentEditable = node.attr("contenteditable");
      if (contentEditable === "false") {
        break;
      } else if (contentEditable === "true") {
        editableNode = node;
      }
    }
    return Optional.from(editableNode);
  };

  const removeOrUnwrapInvalidNode = (
    node,
    schema,
    originalNodeParent = node.parent
  ) => {
    if (schema.getSpecialElements()[node.name]) {
      node.empty().remove();
    } else {
      const children = node.children();
      for (const childNode of children) {
        if (
          originalNodeParent &&
          !schema.isValidChild(originalNodeParent.name, childNode.name)
        ) {
          removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
        }
      }
      node.unwrap();
    }
  };
  const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {
    const textBlockElements = schema.getTextBlockElements();
    const nonEmptyElements = schema.getNonEmptyElements();
    const whitespaceElements = schema.getWhitespaceElements();
    const nonSplittableElements = Tools.makeMap(
      "tr,td,th,tbody,thead,tfoot,table,summary"
    );
    const fixed = new Set();
    const isSplittableElement = (node) =>
      node !== rootNode && !nonSplittableElements[node.name];
    for (let ni = 0; ni < nodes.length; ni++) {
      const node = nodes[ni];
      let parent;
      let newParent;
      let tempNode;
      if (!node.parent || fixed.has(node)) {
        continue;
      }
      if (textBlockElements[node.name] && node.parent.name === "li") {
        let sibling = node.next;
        while (sibling) {
          if (textBlockElements[sibling.name]) {
            sibling.name = "li";
            fixed.add(sibling);
            node.parent.insert(sibling, node.parent);
          } else {
            break;
          }
          sibling = sibling.next;
        }
        node.unwrap();
        continue;
      }
      const parents = [node];
      for (
        parent = node.parent;
        parent &&
        !schema.isValidChild(parent.name, node.name) &&
        isSplittableElement(parent);
        parent = parent.parent
      ) {
        parents.push(parent);
      }
      if (parent && parents.length > 1) {
        if (!isInvalid(schema, node, parent)) {
          parents.reverse();
          newParent = parents[0].clone();
          onCreate(newParent);
          let currentNode = newParent;
          for (let i = 0; i < parents.length - 1; i++) {
            if (
              schema.isValidChild(currentNode.name, parents[i].name) &&
              i > 0
            ) {
              tempNode = parents[i].clone();
              onCreate(tempNode);
              currentNode.append(tempNode);
            } else {
              tempNode = currentNode;
            }
            for (
              let childNode = parents[i].firstChild;
              childNode && childNode !== parents[i + 1];

            ) {
              const nextNode = childNode.next;
              tempNode.append(childNode);
              childNode = nextNode;
            }
            currentNode = tempNode;
          }
          if (
            !isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)
          ) {
            parent.insert(newParent, parents[0], true);
            parent.insert(node, newParent);
          } else {
            parent.insert(node, parents[0], true);
          }
          parent = parents[0];
          if (
            isEmpty(schema, nonEmptyElements, whitespaceElements, parent) ||
            hasOnlyChild(parent, "br")
          ) {
            parent.empty().remove();
          }
        } else {
          removeOrUnwrapInvalidNode(node, schema);
        }
      } else if (node.parent) {
        if (node.name === "li") {
          let sibling = node.prev;
          if (sibling && (sibling.name === "ul" || sibling.name === "ol")) {
            sibling.append(node);
            continue;
          }
          sibling = node.next;
          if (
            sibling &&
            (sibling.name === "ul" || sibling.name === "ol") &&
            sibling.firstChild
          ) {
            sibling.insert(node, sibling.firstChild, true);
            continue;
          }
          const wrapper = new AstNode("ul", 1);
          onCreate(wrapper);
          node.wrap(wrapper);
          continue;
        }
        if (
          schema.isValidChild(node.parent.name, "div") &&
          schema.isValidChild("div", node.name)
        ) {
          const wrapper = new AstNode("div", 1);
          onCreate(wrapper);
          node.wrap(wrapper);
        } else {
          removeOrUnwrapInvalidNode(node, schema);
        }
      }
    }
  };
  const hasClosest = (node, parentName) => {
    let tempNode = node;
    while (tempNode) {
      if (tempNode.name === parentName) {
        return true;
      }
      tempNode = tempNode.parent;
    }
    return false;
  };
  const isInvalid = (schema, node, parent = node.parent) => {
    if (!parent) {
      return false;
    }
    if (
      schema.children[node.name] &&
      !schema.isValidChild(parent.name, node.name)
    ) {
      return true;
    }
    if (node.name === "a" && hasClosest(parent, "a")) {
      return true;
    }
    if (isSummary(parent) && isHeading(node)) {
      return !(
        (parent === null || parent === void 0 ? void 0 : parent.firstChild) ===
          node &&
        (parent === null || parent === void 0 ? void 0 : parent.lastChild) ===
          node
      );
    }
    return false;
  };

  const createRange = (sc, so, ec, eo) => {
    const rng = document.createRange();
    rng.setStart(sc, so);
    rng.setEnd(ec, eo);
    return rng;
  };
  const normalizeBlockSelectionRange = (rng) => {
    const startPos = CaretPosition.fromRangeStart(rng);
    const endPos = CaretPosition.fromRangeEnd(rng);
    const rootNode = rng.commonAncestorContainer;
    return fromPosition(false, rootNode, endPos)
      .map((newEndPos) => {
        if (
          !isInSameBlock(startPos, endPos, rootNode) &&
          isInSameBlock(startPos, newEndPos, rootNode)
        ) {
          return createRange(
            startPos.container(),
            startPos.offset(),
            newEndPos.container(),
            newEndPos.offset()
          );
        } else {
          return rng;
        }
      })
      .getOr(rng);
  };
  const normalize = (rng) =>
    rng.collapsed ? rng : normalizeBlockSelectionRange(rng);

  const hasOnlyOneChild$1 = (node) => {
    return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
  };
  const isPaddingNode = (node) => {
    return node.name === "br" || node.value === nbsp;
  };
  const isPaddedEmptyBlock = (schema, node) => {
    const blockElements = schema.getBlockElements();
    return (
      blockElements[node.name] &&
      hasOnlyOneChild$1(node) &&
      isPaddingNode(node.firstChild)
    );
  };
  const isEmptyFragmentElement = (schema, node) => {
    const nonEmptyElements = schema.getNonEmptyElements();
    return (
      isNonNullable(node) &&
      (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node))
    );
  };
  const isListFragment = (schema, fragment) => {
    let firstChild = fragment.firstChild;
    let lastChild = fragment.lastChild;
    if (firstChild && firstChild.name === "meta") {
      firstChild = firstChild.next;
    }
    if (lastChild && lastChild.attr("id") === "mce_marker") {
      lastChild = lastChild.prev;
    }
    if (isEmptyFragmentElement(schema, lastChild)) {
      lastChild =
        lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;
    }
    if (!firstChild || firstChild !== lastChild) {
      return false;
    }
    return firstChild.name === "ul" || firstChild.name === "ol";
  };
  const cleanupDomFragment = (domFragment) => {
    var _a, _b;
    const firstChild = domFragment.firstChild;
    const lastChild = domFragment.lastChild;
    if (firstChild && firstChild.nodeName === "META") {
      (_a = firstChild.parentNode) === null || _a === void 0
        ? void 0
        : _a.removeChild(firstChild);
    }
    if (lastChild && lastChild.id === "mce_marker") {
      (_b = lastChild.parentNode) === null || _b === void 0
        ? void 0
        : _b.removeChild(lastChild);
    }
    return domFragment;
  };
  const toDomFragment = (dom, serializer, fragment) => {
    const html = serializer.serialize(fragment);
    const domFragment = dom.createFragment(html);
    return cleanupDomFragment(domFragment);
  };
  const listItems = (elm) => {
    var _a;
    return filter$5(
      (_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !==
        null && _a !== void 0
        ? _a
        : [],
      (child) => {
        return child.nodeName === "LI";
      }
    );
  };
  const isPadding = (node) => {
    return node.data === nbsp || isBr$6(node);
  };
  const isListItemPadded = (node) => {
    return (
      isNonNullable(
        node === null || node === void 0 ? void 0 : node.firstChild
      ) &&
      node.firstChild === node.lastChild &&
      isPadding(node.firstChild)
    );
  };
  const isEmptyOrPadded = (elm) => {
    return !elm.firstChild || isListItemPadded(elm);
  };
  const trimListItems = (elms) => {
    return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1])
      ? elms.slice(0, -1)
      : elms;
  };
  const getParentLi = (dom, node) => {
    const parentBlock = dom.getParent(node, dom.isBlock);
    return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
  };
  const isParentBlockLi = (dom, node) => {
    return !!getParentLi(dom, node);
  };
  const getSplit = (parentNode, rng) => {
    const beforeRng = rng.cloneRange();
    const afterRng = rng.cloneRange();
    beforeRng.setStartBefore(parentNode);
    afterRng.setEndAfter(parentNode);
    return [beforeRng.cloneContents(), afterRng.cloneContents()];
  };
  const findFirstIn = (node, rootNode) => {
    const caretPos = CaretPosition.before(node);
    const caretWalker = CaretWalker(rootNode);
    const newCaretPos = caretWalker.next(caretPos);
    return newCaretPos ? newCaretPos.toRange() : null;
  };
  const findLastOf = (node, rootNode) => {
    const caretPos = CaretPosition.after(node);
    const caretWalker = CaretWalker(rootNode);
    const newCaretPos = caretWalker.prev(caretPos);
    return newCaretPos ? newCaretPos.toRange() : null;
  };
  const insertMiddle = (target, elms, rootNode, rng) => {
    const parts = getSplit(target, rng);
    const parentElm = target.parentNode;
    if (parentElm) {
      parentElm.insertBefore(parts[0], target);
      Tools.each(elms, (li) => {
        parentElm.insertBefore(li, target);
      });
      parentElm.insertBefore(parts[1], target);
      parentElm.removeChild(target);
    }
    return findLastOf(elms[elms.length - 1], rootNode);
  };
  const insertBefore$2 = (target, elms, rootNode) => {
    const parentElm = target.parentNode;
    if (parentElm) {
      Tools.each(elms, (elm) => {
        parentElm.insertBefore(elm, target);
      });
    }
    return findFirstIn(target, rootNode);
  };
  const insertAfter$2 = (target, elms, rootNode, dom) => {
    dom.insertAfter(elms.reverse(), target);
    return findLastOf(elms[0], rootNode);
  };
  const insertAtCaret$1 = (serializer, dom, rng, fragment) => {
    const domFragment = toDomFragment(dom, serializer, fragment);
    const liTarget = getParentLi(dom, rng.startContainer);
    const liElms = trimListItems(listItems(domFragment.firstChild));
    const BEGINNING = 1,
      END = 2;
    const rootNode = dom.getRoot();
    const isAt = (location) => {
      const caretPos = CaretPosition.fromRangeStart(rng);
      const caretWalker = CaretWalker(dom.getRoot());
      const newPos =
        location === BEGINNING
          ? caretWalker.prev(caretPos)
          : caretWalker.next(caretPos);
      const newPosNode =
        newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
      return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;
    };
    if (!liTarget) {
      return null;
    } else if (isAt(BEGINNING)) {
      return insertBefore$2(liTarget, liElms, rootNode);
    } else if (isAt(END)) {
      return insertAfter$2(liTarget, liElms, rootNode, dom);
    } else {
      return insertMiddle(liTarget, liElms, rootNode, rng);
    }
  };

  const mergeableWrappedElements = ["pre"];
  const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {
    var _a;
    const firstNode = fragment.firstChild;
    const lastNode = fragment.lastChild;
    const last =
      lastNode.attr("data-mce-type") === "bookmark" ? lastNode.prev : lastNode;
    const isPastingSingleElement = firstNode === last;
    const isWrappedElement = contains$2(
      mergeableWrappedElements,
      firstNode.name
    );
    if (isPastingSingleElement && isWrappedElement) {
      const isContentEditable = firstNode.attr("contenteditable") !== "false";
      const isPastingInTheSameBlockTag =
        ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0
          ? void 0
          : _a.nodeName.toLowerCase()) === firstNode.name;
      const isPastingInContentEditable = Optional.from(
        getContentEditableRoot$1(root, parentNode)
      ).forall(isContentEditableTrue$3);
      return (
        isContentEditable &&
        isPastingInTheSameBlockTag &&
        isPastingInContentEditable
      );
    } else {
      return false;
    }
  };
  const isTableCell = isTableCell$3;
  const isTableCellContentSelected = (dom, rng, cell) => {
    if (isNonNullable(cell)) {
      const endCell = dom.getParent(rng.endContainer, isTableCell);
      return (
        cell === endCell &&
        hasAllContentsSelected(SugarElement.fromDom(cell), rng)
      );
    } else {
      return false;
    }
  };
  const isEditableEmptyBlock = (dom, node) => {
    if (dom.isBlock(node) && dom.isEditable(node)) {
      const childNodes = node.childNodes;
      return (
        (childNodes.length === 1 && isBr$6(childNodes[0])) ||
        childNodes.length === 0
      );
    } else {
      return false;
    }
  };
  const validInsertion = (editor, value, parentNode) => {
    var _a;
    if (parentNode.getAttribute("data-mce-bogus") === "all") {
      (_a = parentNode.parentNode) === null || _a === void 0
        ? void 0
        : _a.insertBefore(editor.dom.createFragment(value), parentNode);
    } else {
      if (isEditableEmptyBlock(editor.dom, parentNode)) {
        editor.dom.setHTML(parentNode, value);
      } else {
        editor.selection.setContent(value, { no_events: true });
      }
    }
  };
  const trimBrsFromTableCell = (dom, elm, schema) => {
    Optional.from(dom.getParent(elm, "td,th"))
      .map(SugarElement.fromDom)
      .each((el) => trimBlockTrailingBr(el, schema));
  };
  const reduceInlineTextElements = (editor, merge) => {
    const textInlineElements = editor.schema.getTextInlineElements();
    const dom = editor.dom;
    if (merge) {
      const root = editor.getBody();
      const elementUtils = ElementUtils(editor);
      const fragmentSelector = "*[data-mce-fragment]";
      const fragments = dom.select(fragmentSelector);
      Tools.each(fragments, (node) => {
        const isInline = (currentNode) =>
          isNonNullable(textInlineElements[currentNode.nodeName.toLowerCase()]);
        const hasOneChild = (currentNode) =>
          currentNode.childNodes.length === 1;
        const hasNoNonInheritableStyles = (currentNode) =>
          !(
            hasNonInheritableStyles(dom, currentNode) ||
            hasConditionalNonInheritableStyles(dom, currentNode)
          );
        if (
          hasNoNonInheritableStyles(node) &&
          isInline(node) &&
          hasOneChild(node)
        ) {
          const styles = getStyleProps(dom, node);
          const isOverridden = (oldStyles, newStyles) =>
            forall(oldStyles, (style) => contains$2(newStyles, style));
          const overriddenByAllChildren = (childNode) =>
            hasOneChild(node) &&
            dom.is(childNode, fragmentSelector) &&
            isInline(childNode) &&
            ((childNode.nodeName === node.nodeName &&
              isOverridden(styles, getStyleProps(dom, childNode))) ||
              overriddenByAllChildren(childNode.children[0]));
          const identicalToParent = (parentNode) =>
            isNonNullable(parentNode) &&
            parentNode !== root &&
            (elementUtils.compare(node, parentNode) ||
              identicalToParent(parentNode.parentElement));
          const conflictWithInsertedParent = (parentNode) =>
            isNonNullable(parentNode) &&
            parentNode !== root &&
            dom.is(parentNode, fragmentSelector) &&
            (hasStyleConflict(dom, node, parentNode) ||
              conflictWithInsertedParent(parentNode.parentElement));
          if (
            overriddenByAllChildren(node.children[0]) ||
            (identicalToParent(node.parentElement) &&
              !conflictWithInsertedParent(node.parentElement))
          ) {
            dom.remove(node, true);
          }
        }
      });
    }
  };
  const markFragmentElements = (fragment) => {
    let node = fragment;
    while ((node = node.walk())) {
      if (node.type === 1) {
        node.attr("data-mce-fragment", "1");
      }
    }
  };
  const unmarkFragmentElements = (elm) => {
    Tools.each(elm.getElementsByTagName("*"), (elm) => {
      elm.removeAttribute("data-mce-fragment");
    });
  };
  const isPartOfFragment = (node) => {
    return !!node.getAttribute("data-mce-fragment");
  };
  const canHaveChildren = (editor, node) => {
    return (
      isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName]
    );
  };
  const moveSelectionToMarker = (editor, marker) => {
    var _a, _b, _c;
    let nextRng;
    const dom = editor.dom;
    const selection = editor.selection;
    if (!marker) {
      return;
    }
    selection.scrollIntoView(marker);
    const parentEditableElm = getContentEditableRoot$1(
      editor.getBody(),
      marker
    );
    if (
      parentEditableElm &&
      dom.getContentEditable(parentEditableElm) === "false"
    ) {
      dom.remove(marker);
      selection.select(parentEditableElm);
      return;
    }
    let rng = dom.createRng();
    const node = marker.previousSibling;
    if (isText$b(node)) {
      rng.setStart(
        node,
        (_b =
          (_a = node.nodeValue) === null || _a === void 0
            ? void 0
            : _a.length) !== null && _b !== void 0
          ? _b
          : 0
      );
      const node2 = marker.nextSibling;
      if (isText$b(node2)) {
        node.appendData(node2.data);
        (_c = node2.parentNode) === null || _c === void 0
          ? void 0
          : _c.removeChild(node2);
      }
    } else {
      rng.setStartBefore(marker);
      rng.setEndBefore(marker);
    }
    const findNextCaretRng = (rng) => {
      let caretPos = CaretPosition.fromRangeStart(rng);
      const caretWalker = CaretWalker(editor.getBody());
      caretPos = caretWalker.next(caretPos);
      return caretPos === null || caretPos === void 0
        ? void 0
        : caretPos.toRange();
    };
    const parentBlock = dom.getParent(marker, dom.isBlock);
    dom.remove(marker);
    if (parentBlock && dom.isEmpty(parentBlock)) {
      const isCell = isTableCell(parentBlock);
      empty(SugarElement.fromDom(parentBlock));
      rng.setStart(parentBlock, 0);
      rng.setEnd(parentBlock, 0);
      if (
        !isCell &&
        !isPartOfFragment(parentBlock) &&
        (nextRng = findNextCaretRng(rng))
      ) {
        rng = nextRng;
        dom.remove(parentBlock);
      } else {
        dom.add(
          parentBlock,
          dom.create("br", isCell ? {} : { "data-mce-bogus": "1" })
        );
      }
    }
    selection.setRng(rng);
  };
  const deleteSelectedContent = (editor) => {
    const dom = editor.dom;
    const rng = normalize(editor.selection.getRng());
    editor.selection.setRng(rng);
    const startCell = dom.getParent(rng.startContainer, isTableCell);
    if (isTableCellContentSelected(dom, rng, startCell)) {
      deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
    } else if (
      rng.startContainer === rng.endContainer &&
      rng.endOffset - rng.startOffset === 1 &&
      isText$b(rng.startContainer.childNodes[rng.startOffset])
    ) {
      rng.deleteContents();
    } else {
      editor.getDoc().execCommand("Delete", false);
    }
  };
  const findMarkerNode = (scope) => {
    for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
      if (markerNode.attr("id") === "mce_marker") {
        return Optional.some(markerNode);
      }
    }
    return Optional.none();
  };
  const notHeadingsInSummary = (dom, node, fragment) => {
    var _a;
    return (
      exists(fragment.children(), isHeading) &&
      ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0
        ? void 0
        : _a.nodeName) === "SUMMARY"
    );
  };
  const insertHtmlAtCaret = (editor, value, details) => {
    var _a, _b;
    const selection = editor.selection;
    const dom = editor.dom;
    const parser = editor.parser;
    const merge = details.merge;
    const serializer = HtmlSerializer({ validate: true }, editor.schema);
    const bookmarkHtml =
      '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
    if (!details.preserve_zwsp) {
      value = trim$2(value);
    }
    if (value.indexOf("{$caret}") === -1) {
      value += "{$caret}";
    }
    value = value.replace(/\{\$caret\}/, bookmarkHtml);
    let rng = selection.getRng();
    const caretElement = rng.startContainer;
    const body = editor.getBody();
    if (caretElement === body && selection.isCollapsed()) {
      if (
        dom.isBlock(body.firstChild) &&
        canHaveChildren(editor, body.firstChild) &&
        dom.isEmpty(body.firstChild)
      ) {
        rng = dom.createRng();
        rng.setStart(body.firstChild, 0);
        rng.setEnd(body.firstChild, 0);
        selection.setRng(rng);
      }
    }
    if (!selection.isCollapsed()) {
      deleteSelectedContent(editor);
    }
    const parentNode = selection.getNode();
    const parserArgs = {
      context: parentNode.nodeName.toLowerCase(),
      data: details.data,
      insert: true,
    };
    const fragment = parser.parse(value, parserArgs);
    if (
      details.paste === true &&
      isListFragment(editor.schema, fragment) &&
      isParentBlockLi(dom, parentNode)
    ) {
      rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);
      if (rng) {
        selection.setRng(rng);
      }
      return value;
    }
    if (
      details.paste === true &&
      shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())
    ) {
      (_a = fragment.firstChild) === null || _a === void 0
        ? void 0
        : _a.unwrap();
    }
    markFragmentElements(fragment);
    let node = fragment.lastChild;
    if (node && node.attr("id") === "mce_marker") {
      const marker = node;
      for (node = node.prev; node; node = node.walk(true)) {
        if (node.name === "table") {
          break;
        }
        if (node.type === 3 || !dom.isBlock(node.name)) {
          if (
            node.parent &&
            editor.schema.isValidChild(node.parent.name, "span")
          ) {
            node.parent.insert(marker, node, node.name === "br");
          }
          break;
        }
      }
    }
    editor._selectionOverrides.showBlockCaretContainer(parentNode);
    if (
      !parserArgs.invalid &&
      !notHeadingsInSummary(dom, parentNode, fragment)
    ) {
      value = serializer.serialize(fragment);
      validInsertion(editor, value, parentNode);
    } else {
      editor.selection.setContent(bookmarkHtml);
      let parentNode = selection.getNode();
      let tempNode;
      const rootNode = editor.getBody();
      if (isDocument$1(parentNode)) {
        parentNode = tempNode = rootNode;
      } else {
        tempNode = parentNode;
      }
      while (tempNode && tempNode !== rootNode) {
        parentNode = tempNode;
        tempNode = tempNode.parentNode;
      }
      value =
        parentNode === rootNode
          ? rootNode.innerHTML
          : dom.getOuterHTML(parentNode);
      const root = parser.parse(value);
      const markerNode = findMarkerNode(root);
      const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
      markerNode.each((marker) => marker.replace(fragment));
      const toExtract = fragment.children();
      const parent =
        (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;
      fragment.unwrap();
      const invalidChildren = filter$5(toExtract, (node) =>
        isInvalid(editor.schema, node, parent)
      );
      cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
      filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);
      value = serializer.serialize(root);
      if (parentNode === rootNode) {
        dom.setHTML(rootNode, value);
      } else {
        dom.setOuterHTML(parentNode, value);
      }
    }
    reduceInlineTextElements(editor, merge);
    moveSelectionToMarker(editor, dom.get("mce_marker"));
    unmarkFragmentElements(editor.getBody());
    trimBrsFromTableCell(dom, selection.getStart(), editor.schema);
    updateCaret(editor.schema, editor.getBody(), selection.getStart());
    return value;
  };

  const isTreeNode = (content) => content instanceof AstNode;

  const moveSelection = (editor) => {
    if (hasFocus(editor)) {
      firstPositionIn(editor.getBody()).each((pos) => {
        const node = pos.getNode();
        const caretPos = isTable$2(node)
          ? firstPositionIn(node).getOr(pos)
          : pos;
        editor.selection.setRng(caretPos.toRange());
      });
    }
  };
  const setEditorHtml = (editor, html, noSelection) => {
    editor.dom.setHTML(editor.getBody(), html);
    if (noSelection !== true) {
      moveSelection(editor);
    }
  };
  const setContentString = (editor, body, content, args) => {
    content = trim$2(content);
    if (content.length === 0 || /^\s+$/.test(content)) {
      const padd = '<br data-mce-bogus="1">';
      if (body.nodeName === "TABLE") {
        content = "<tr><td>" + padd + "</td></tr>";
      } else if (/^(UL|OL)$/.test(body.nodeName)) {
        content = "<li>" + padd + "</li>";
      }
      const forcedRootBlockName = getForcedRootBlock(editor);
      if (
        editor.schema.isValidChild(
          body.nodeName.toLowerCase(),
          forcedRootBlockName.toLowerCase()
        )
      ) {
        content = padd;
        content = editor.dom.createHTML(
          forcedRootBlockName,
          getForcedRootBlockAttrs(editor),
          content
        );
      } else if (!content) {
        content = padd;
      }
      setEditorHtml(editor, content, args.no_selection);
      return {
        content,
        html: content,
      };
    } else {
      if (args.format !== "raw") {
        content = HtmlSerializer({ validate: false }, editor.schema).serialize(
          editor.parser.parse(content, {
            isRootContent: true,
            insert: true,
          })
        );
      }
      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body))
        ? content
        : Tools.trim(content);
      setEditorHtml(editor, trimmedHtml, args.no_selection);
      return {
        content: trimmedHtml,
        html: trimmedHtml,
      };
    }
  };
  const setContentTree = (editor, body, content, args) => {
    filter$2(
      editor.parser.getNodeFilters(),
      editor.parser.getAttributeFilters(),
      content
    );
    const html = HtmlSerializer({ validate: false }, editor.schema).serialize(
      content
    );
    const trimmedHtml = trim$2(
      isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html)
    );
    setEditorHtml(editor, trimmedHtml, args.no_selection);
    return {
      content,
      html: trimmedHtml,
    };
  };
  const setContentInternal = (editor, content, args) => {
    return Optional.from(editor.getBody())
      .map((body) => {
        if (isTreeNode(content)) {
          return setContentTree(editor, body, content, args);
        } else {
          return setContentString(editor, body, content, args);
        }
      })
      .getOr({
        content,
        html: isTreeNode(args.content) ? "" : args.content,
      });
  };

  const ensureIsRoot = (isRoot) => (isFunction(isRoot) ? isRoot : never);
  const ancestor = (scope, transform, isRoot) => {
    let element = scope.dom;
    const stop = ensureIsRoot(isRoot);
    while (element.parentNode) {
      element = element.parentNode;
      const el = SugarElement.fromDom(element);
      const transformed = transform(el);
      if (transformed.isSome()) {
        return transformed;
      } else if (stop(el)) {
        break;
      }
    }
    return Optional.none();
  };
  const closest$1 = (scope, transform, isRoot) => {
    const current = transform(scope);
    const stop = ensureIsRoot(isRoot);
    return current.orThunk(() =>
      stop(scope) ? Optional.none() : ancestor(scope, transform, stop)
    );
  };

  const isEq$3 = isEq$5;
  const matchesUnInheritedFormatSelector = (ed, node, name) => {
    const formatList = ed.formatter.get(name);
    if (formatList) {
      for (let i = 0; i < formatList.length; i++) {
        const format = formatList[i];
        if (
          isSelectorFormat(format) &&
          format.inherit === false &&
          ed.dom.is(node, format.selector)
        ) {
          return true;
        }
      }
    }
    return false;
  };
  const matchParents = (editor, node, name, vars, similar) => {
    const root = editor.dom.getRoot();
    if (node === root) {
      return false;
    }
    const matchedNode = editor.dom.getParent(node, (elm) => {
      if (matchesUnInheritedFormatSelector(editor, elm, name)) {
        return true;
      }
      return (
        elm.parentNode === root || !!matchNode(editor, elm, name, vars, true)
      );
    });
    return !!matchNode(editor, matchedNode, name, vars, similar);
  };
  const matchName = (dom, node, format) => {
    if (isInlineFormat(format) && isEq$3(node, format.inline)) {
      return true;
    }
    if (isBlockFormat(format) && isEq$3(node, format.block)) {
      return true;
    }
    if (isSelectorFormat(format)) {
      return isElement$6(node) && dom.is(node, format.selector);
    }
    return false;
  };
  const matchItems = (dom, node, format, itemName, similar, vars) => {
    const items = format[itemName];
    const matchAttributes = itemName === "attributes";
    if (isFunction(format.onmatch)) {
      return format.onmatch(node, format, itemName);
    }
    if (items) {
      if (!isArrayLike(items)) {
        for (const key in items) {
          if (has$2(items, key)) {
            const value = matchAttributes
              ? dom.getAttrib(node, key)
              : getStyle(dom, node, key);
            const expectedValue = replaceVars(items[key], vars);
            const isEmptyValue = isNullable(value) || isEmpty$3(value);
            if (isEmptyValue && isNullable(expectedValue)) {
              continue;
            }
            if (similar && isEmptyValue && !format.exact) {
              return false;
            }
            if (
              (!similar || format.exact) &&
              !isEq$3(value, normalizeStyleValue(expectedValue, key))
            ) {
              return false;
            }
          }
        }
      } else {
        for (let i = 0; i < items.length; i++) {
          if (
            matchAttributes
              ? dom.getAttrib(node, items[i])
              : getStyle(dom, node, items[i])
          ) {
            return true;
          }
        }
      }
    }
    return true;
  };
  const matchNode = (ed, node, name, vars, similar) => {
    const formatList = ed.formatter.get(name);
    const dom = ed.dom;
    if (formatList && isElement$6(node)) {
      for (let i = 0; i < formatList.length; i++) {
        const format = formatList[i];
        if (
          matchName(ed.dom, node, format) &&
          matchItems(dom, node, format, "attributes", similar, vars) &&
          matchItems(dom, node, format, "styles", similar, vars)
        ) {
          const classes = format.classes;
          if (classes) {
            for (let x = 0; x < classes.length; x++) {
              if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                return;
              }
            }
          }
          return format;
        }
      }
    }
    return undefined;
  };
  const match$2 = (editor, name, vars, node, similar) => {
    if (node) {
      return matchParents(editor, node, name, vars, similar);
    }
    node = editor.selection.getNode();
    if (matchParents(editor, node, name, vars, similar)) {
      return true;
    }
    const startNode = editor.selection.getStart();
    if (startNode !== node) {
      if (matchParents(editor, startNode, name, vars, similar)) {
        return true;
      }
    }
    return false;
  };
  const matchAll = (editor, names, vars) => {
    const matchedFormatNames = [];
    const checkedMap = {};
    const startElement = editor.selection.getStart();
    editor.dom.getParent(
      startElement,
      (node) => {
        for (let i = 0; i < names.length; i++) {
          const name = names[i];
          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {
            checkedMap[name] = true;
            matchedFormatNames.push(name);
          }
        }
      },
      editor.dom.getRoot()
    );
    return matchedFormatNames;
  };
  const closest = (editor, names) => {
    const isRoot = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
    const match = (elm, name) =>
      matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();
    return Optional.from(editor.selection.getStart(true))
      .bind((rawElm) =>
        closest$1(
          SugarElement.fromDom(rawElm),
          (elm) => findMap(names, (name) => match(elm, name)),
          isRoot
        )
      )
      .getOrNull();
  };
  const canApply = (editor, name) => {
    const formatList = editor.formatter.get(name);
    const dom = editor.dom;
    if (formatList && editor.selection.isEditable()) {
      const startNode = editor.selection.getStart();
      const parents = getParents$2(dom, startNode);
      for (let x = formatList.length - 1; x >= 0; x--) {
        const format = formatList[x];
        if (!isSelectorFormat(format)) {
          return true;
        }
        for (let i = parents.length - 1; i >= 0; i--) {
          if (dom.is(parents[i], format.selector)) {
            return true;
          }
        }
      }
    }
    return false;
  };
  const matchAllOnNode = (editor, node, formatNames) =>
    foldl(
      formatNames,
      (acc, name) => {
        const matchSimilar = isVariableFormatName(editor, name);
        if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {
          return acc.concat([name]);
        } else {
          return acc;
        }
      },
      []
    );

  const ZWSP = ZWSP$1;
  const importNode = (ownerDocument, node) => {
    return ownerDocument.importNode(node, true);
  };
  const findFirstTextNode = (node) => {
    if (node) {
      const walker = new DomTreeWalker(node, node);
      for (
        let tempNode = walker.current();
        tempNode;
        tempNode = walker.next()
      ) {
        if (isText$b(tempNode)) {
          return tempNode;
        }
      }
    }
    return null;
  };
  const createCaretContainer = (fill) => {
    const caretContainer = SugarElement.fromTag("span");
    setAll$1(caretContainer, {
      id: CARET_ID,
      "data-mce-bogus": "1",
      "data-mce-type": "format-caret",
    });
    if (fill) {
      append$1(caretContainer, SugarElement.fromText(ZWSP));
    }
    return caretContainer;
  };
  const trimZwspFromCaretContainer = (caretContainerNode) => {
    const textNode = findFirstTextNode(caretContainerNode);
    if (textNode && textNode.data.charAt(0) === ZWSP) {
      textNode.deleteData(0, 1);
    }
    return textNode;
  };
  const removeCaretContainerNode = (editor, node, moveCaret) => {
    const dom = editor.dom,
      selection = editor.selection;
    if (isCaretContainerEmpty(node)) {
      deleteElement$2(
        editor,
        false,
        SugarElement.fromDom(node),
        moveCaret,
        true
      );
    } else {
      const rng = selection.getRng();
      const block = dom.getParent(node, dom.isBlock);
      const startContainer = rng.startContainer;
      const startOffset = rng.startOffset;
      const endContainer = rng.endContainer;
      const endOffset = rng.endOffset;
      const textNode = trimZwspFromCaretContainer(node);
      dom.remove(node, true);
      if (startContainer === textNode && startOffset > 0) {
        rng.setStart(textNode, startOffset - 1);
      }
      if (endContainer === textNode && endOffset > 0) {
        rng.setEnd(textNode, endOffset - 1);
      }
      if (block && dom.isEmpty(block)) {
        fillWithPaddingBr(SugarElement.fromDom(block));
      }
      selection.setRng(rng);
    }
  };
  const removeCaretContainer = (editor, node, moveCaret) => {
    const dom = editor.dom,
      selection = editor.selection;
    if (!node) {
      node = getParentCaretContainer(editor.getBody(), selection.getStart());
      if (!node) {
        while ((node = dom.get(CARET_ID))) {
          removeCaretContainerNode(editor, node, moveCaret);
        }
      }
    } else {
      removeCaretContainerNode(editor, node, moveCaret);
    }
  };
  const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
    var _a, _b;
    const dom = editor.dom;
    const block = dom.getParent(
      formatNode,
      curry(isTextBlock$1, editor.schema)
    );
    if (block && dom.isEmpty(block)) {
      (_a = formatNode.parentNode) === null || _a === void 0
        ? void 0
        : _a.replaceChild(caretContainer, formatNode);
    } else {
      removeTrailingBr(SugarElement.fromDom(formatNode));
      if (dom.isEmpty(formatNode)) {
        (_b = formatNode.parentNode) === null || _b === void 0
          ? void 0
          : _b.replaceChild(caretContainer, formatNode);
      } else {
        dom.insertAfter(caretContainer, formatNode);
      }
    }
  };
  const appendNode = (parentNode, node) => {
    parentNode.appendChild(node);
    return node;
  };
  const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
    var _a;
    const innerMostFormatNode = foldr(
      formatNodes,
      (parentNode, formatNode) => {
        return appendNode(parentNode, formatNode.cloneNode(false));
      },
      caretContainer
    );
    const doc =
      (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0
        ? _a
        : document;
    return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
  };
  const cleanFormatNode = (
    editor,
    caretContainer,
    formatNode,
    name,
    vars,
    similar
  ) => {
    const formatter = editor.formatter;
    const dom = editor.dom;
    const validFormats = filter$5(
      keys(formatter.get()),
      (formatName) =>
        formatName !== name && !contains$1(formatName, "removeformat")
    );
    const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
    const uniqueFormats = filter$5(
      matchedFormats,
      (fmtName) => !areSimilarFormats(editor, fmtName, name)
    );
    if (uniqueFormats.length > 0) {
      const clonedFormatNode = formatNode.cloneNode(false);
      dom.add(caretContainer, clonedFormatNode);
      formatter.remove(name, vars, clonedFormatNode, similar);
      dom.remove(clonedFormatNode);
      return Optional.some(clonedFormatNode);
    } else {
      return Optional.none();
    }
  };
  const normalizeNbsps = (node) =>
    set(node, get$3(node).replace(new RegExp(`${nbsp}$`), " "));
  const normalizeNbspsBetween = (editor, caretContainer) => {
    const handler = () => {
      if (caretContainer !== null && !editor.dom.isEmpty(caretContainer)) {
        prevSibling(SugarElement.fromDom(caretContainer)).each((node) => {
          if (isText$c(node)) {
            normalizeNbsps(node);
          } else {
            descendant$2(node, (e) => isText$c(e)).each((textNode) => {
              if (isText$c(textNode)) {
                normalizeNbsps(textNode);
              }
            });
          }
        });
      }
    };
    editor.once("input", (e) => {
      if (e.data && !isWhiteSpace(e.data)) {
        if (!e.isComposing) {
          handler();
        } else {
          editor.once("compositionend", () => {
            handler();
          });
        }
      }
    });
  };
  const applyCaretFormat = (editor, name, vars) => {
    let caretContainer;
    const selection = editor.selection;
    const formatList = editor.formatter.get(name);
    if (!formatList) {
      return;
    }
    const selectionRng = selection.getRng();
    let offset = selectionRng.startOffset;
    const container = selectionRng.startContainer;
    const text = container.nodeValue;
    caretContainer = getParentCaretContainer(
      editor.getBody(),
      selection.getStart()
    );
    const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
    if (
      text &&
      offset > 0 &&
      offset < text.length &&
      wordcharRegex.test(text.charAt(offset)) &&
      wordcharRegex.test(text.charAt(offset - 1))
    ) {
      const bookmark = selection.getBookmark();
      selectionRng.collapse(true);
      let rng = expandRng(editor.dom, selectionRng, formatList);
      rng = split(rng);
      editor.formatter.apply(name, vars, rng);
      selection.moveToBookmark(bookmark);
    } else {
      let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
      if (
        !caretContainer ||
        (textNode === null || textNode === void 0 ? void 0 : textNode.data) !==
          ZWSP
      ) {
        caretContainer = importNode(
          editor.getDoc(),
          createCaretContainer(true).dom
        );
        textNode = caretContainer.firstChild;
        selectionRng.insertNode(caretContainer);
        offset = 1;
        normalizeNbspsBetween(editor, caretContainer);
        editor.formatter.apply(name, vars, caretContainer);
      } else {
        editor.formatter.apply(name, vars, caretContainer);
      }
      selection.setCursorLocation(textNode, offset);
    }
  };
  const removeCaretFormat = (editor, name, vars, similar) => {
    const dom = editor.dom;
    const selection = editor.selection;
    let hasContentAfter = false;
    const formatList = editor.formatter.get(name);
    if (!formatList) {
      return;
    }
    const rng = selection.getRng();
    const container = rng.startContainer;
    const offset = rng.startOffset;
    let node = container;
    if (isText$b(container)) {
      if (offset !== container.data.length) {
        hasContentAfter = true;
      }
      node = node.parentNode;
    }
    const parents = [];
    let formatNode;
    while (node) {
      if (matchNode(editor, node, name, vars, similar)) {
        formatNode = node;
        break;
      }
      if (node.nextSibling) {
        hasContentAfter = true;
      }
      parents.push(node);
      node = node.parentNode;
    }
    if (!formatNode) {
      return;
    }
    if (hasContentAfter) {
      const bookmark = selection.getBookmark();
      rng.collapse(true);
      let expandedRng = expandRng(dom, rng, formatList, {
        includeTrailingSpace: true,
      });
      expandedRng = split(expandedRng);
      editor.formatter.remove(name, vars, expandedRng, similar);
      selection.moveToBookmark(bookmark);
    } else {
      const caretContainer = getParentCaretContainer(
        editor.getBody(),
        formatNode
      );
      const parentsAfter = isNonNullable(caretContainer)
        ? dom.getParents(formatNode.parentNode, always, caretContainer)
        : [];
      const newCaretContainer = createCaretContainer(false).dom;
      insertCaretContainerNode(
        editor,
        newCaretContainer,
        caretContainer !== null && caretContainer !== void 0
          ? caretContainer
          : formatNode
      );
      const cleanedFormatNode = cleanFormatNode(
        editor,
        newCaretContainer,
        formatNode,
        name,
        vars,
        similar
      );
      const caretTextNode = insertFormatNodesIntoCaretContainer(
        [...parents, ...cleanedFormatNode.toArray(), ...parentsAfter],
        newCaretContainer
      );
      if (caretContainer) {
        removeCaretContainerNode(
          editor,
          caretContainer,
          isNonNullable(caretContainer)
        );
      }
      selection.setCursorLocation(caretTextNode, 1);
      normalizeNbspsBetween(editor, newCaretContainer);
      if (dom.isEmpty(formatNode)) {
        dom.remove(formatNode);
      }
    }
  };
  const disableCaretContainer = (editor, keyCode, moveCaret) => {
    const selection = editor.selection,
      body = editor.getBody();
    removeCaretContainer(editor, null, moveCaret);
    if (
      (keyCode === 8 || keyCode === 46) &&
      selection.isCollapsed() &&
      selection.getStart().innerHTML === ZWSP
    ) {
      removeCaretContainer(
        editor,
        getParentCaretContainer(body, selection.getStart()),
        true
      );
    }
    if (keyCode === 37 || keyCode === 39) {
      removeCaretContainer(
        editor,
        getParentCaretContainer(body, selection.getStart()),
        true
      );
    }
  };
  const endsWithNbsp = (element) =>
    isText$b(element) && endsWith(element.data, nbsp);
  const setup$v = (editor) => {
    editor.on("mouseup keydown", (e) => {
      disableCaretContainer(
        editor,
        e.keyCode,
        endsWithNbsp(editor.selection.getRng().endContainer)
      );
    });
  };
  const createCaretFormat = (formatNodes) => {
    const caretContainer = createCaretContainer(false);
    const innerMost = insertFormatNodesIntoCaretContainer(
      formatNodes,
      caretContainer.dom
    );
    return {
      caretContainer,
      caretPosition: CaretPosition(innerMost, 0),
    };
  };
  const replaceWithCaretFormat = (targetNode, formatNodes) => {
    const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
    before$3(SugarElement.fromDom(targetNode), caretContainer);
    remove$4(SugarElement.fromDom(targetNode));
    return caretPosition;
  };
  const createCaretFormatAtStart$1 = (rng, formatNodes) => {
    const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
    rng.insertNode(caretContainer.dom);
    return caretPosition;
  };
  const isFormatElement = (editor, element) => {
    if (isCaretNode(element.dom)) {
      return false;
    }
    const inlineElements = editor.schema.getTextInlineElements();
    return (
      has$2(inlineElements, name(element)) &&
      !isCaretNode(element.dom) &&
      !isBogus$1(element.dom)
    );
  };

  const postProcessHooks = {};
  const isPre = matchNodeNames(["pre"]);
  const addPostProcessHook = (name, hook) => {
    const hooks = postProcessHooks[name];
    if (!hooks) {
      postProcessHooks[name] = [];
    }
    postProcessHooks[name].push(hook);
  };
  const postProcess$1 = (name, editor) => {
    if (has$2(postProcessHooks, name)) {
      each$e(postProcessHooks[name], (hook) => {
        hook(editor);
      });
    }
  };
  addPostProcessHook("pre", (editor) => {
    const rng = editor.selection.getRng();
    const hasPreSibling = (blocks) => (pre) => {
      const prev = pre.previousSibling;
      return isPre(prev) && contains$2(blocks, prev);
    };
    const joinPre = (pre1, pre2) => {
      const sPre2 = SugarElement.fromDom(pre2);
      const doc = documentOrOwner(sPre2).dom;
      remove$4(sPre2);
      append(SugarElement.fromDom(pre1), [
        SugarElement.fromTag("br", doc),
        SugarElement.fromTag("br", doc),
        ...children$1(sPre2),
      ]);
    };
    if (!rng.collapsed) {
      const blocks = editor.selection.getSelectedBlocks();
      const preBlocks = filter$5(
        filter$5(blocks, isPre),
        hasPreSibling(blocks)
      );
      each$e(preBlocks, (pre) => {
        joinPre(pre.previousSibling, pre);
      });
    }
  });

  const listItemStyles = [
    "fontWeight",
    "fontStyle",
    "color",
    "fontSize",
    "fontFamily",
  ];
  const hasListStyles = (fmt) =>
    isObject(fmt.styles) &&
    exists(keys(fmt.styles), (name) => contains$2(listItemStyles, name));
  const findExpandedListItemFormat = (formats) =>
    find$2(
      formats,
      (fmt) =>
        isInlineFormat(fmt) && fmt.inline === "span" && hasListStyles(fmt)
    );
  const getExpandedListItemFormat = (formatter, format) => {
    const formatList = formatter.get(format);
    return isArray$1(formatList)
      ? findExpandedListItemFormat(formatList)
      : Optional.none();
  };
  const isRngStartAtStartOfElement = (rng, elm) =>
    prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
  const isRngEndAtEndOfElement = (rng, elm) => {
    return (
      nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(
        (pos) => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()
      ) === false
    );
  };
  const isEditableListItem = (dom) => (elm) =>
    isListItem$2(elm) && dom.isEditable(elm);
  const getFullySelectedBlocks = (selection) => {
    const blocks = selection.getSelectedBlocks();
    const rng = selection.getRng();
    if (selection.isCollapsed()) {
      return [];
    }
    if (blocks.length === 1) {
      return isRngStartAtStartOfElement(rng, blocks[0]) &&
        isRngEndAtEndOfElement(rng, blocks[0])
        ? blocks
        : [];
    } else {
      const first = head(blocks)
        .filter((elm) => isRngStartAtStartOfElement(rng, elm))
        .toArray();
      const last = last$2(blocks)
        .filter((elm) => isRngEndAtEndOfElement(rng, elm))
        .toArray();
      const middle = blocks.slice(1, -1);
      return first.concat(middle).concat(last);
    }
  };
  const getFullySelectedListItems = (selection) =>
    filter$5(
      getFullySelectedBlocks(selection),
      isEditableListItem(selection.dom)
    );
  const getPartiallySelectedListItems = (selection) =>
    filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));

  const each$8 = Tools.each;
  const isElementNode = (node) =>
    isElement$6(node) &&
    !isBookmarkNode$1(node) &&
    !isCaretNode(node) &&
    !isBogus$1(node);
  const findElementSibling = (node, siblingName) => {
    for (let sibling = node; sibling; sibling = sibling[siblingName]) {
      if (isText$b(sibling) && isNotEmpty(sibling.data)) {
        return node;
      }
      if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {
        return sibling;
      }
    }
    return node;
  };
  const mergeSiblingsNodes = (editor, prev, next) => {
    const elementUtils = ElementUtils(editor);
    const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);
    const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);
    if (isPrevEditable && isNextEditable) {
      const prevSibling = findElementSibling(prev, "previousSibling");
      const nextSibling = findElementSibling(next, "nextSibling");
      if (elementUtils.compare(prevSibling, nextSibling)) {
        for (
          let sibling = prevSibling.nextSibling;
          sibling && sibling !== nextSibling;

        ) {
          const tmpSibling = sibling;
          sibling = sibling.nextSibling;
          prevSibling.appendChild(tmpSibling);
        }
        editor.dom.remove(nextSibling);
        Tools.each(Tools.grep(nextSibling.childNodes), (node) => {
          prevSibling.appendChild(node);
        });
        return prevSibling;
      }
    }
    return next;
  };
  const mergeSiblings = (editor, format, vars, node) => {
    var _a;
    if (node && format.merge_siblings !== false) {
      const newNode =
        (_a = mergeSiblingsNodes(
          editor,
          getNonWhiteSpaceSibling(node),
          node
        )) !== null && _a !== void 0
          ? _a
          : node;
      mergeSiblingsNodes(
        editor,
        newNode,
        getNonWhiteSpaceSibling(newNode, true)
      );
    }
  };
  const clearChildStyles = (dom, format, node) => {
    if (format.clear_child_styles) {
      const selector = format.links ? "*:not(a)" : "*";
      each$8(dom.select(selector, node), (childNode) => {
        if (isElementNode(childNode) && dom.isEditable(childNode)) {
          each$8(format.styles, (_value, name) => {
            dom.setStyle(childNode, name, "");
          });
        }
      });
    }
  };
  const processChildElements = (node, filter, process) => {
    each$8(node.childNodes, (node) => {
      if (isElementNode(node)) {
        if (filter(node)) {
          process(node);
        }
        if (node.hasChildNodes()) {
          processChildElements(node, filter, process);
        }
      }
    });
  };
  const unwrapEmptySpan = (dom, node) => {
    if (node.nodeName === "SPAN" && dom.getAttribs(node).length === 0) {
      dom.remove(node, true);
    }
  };
  const hasStyle = (dom, name) => (node) =>
    !!(node && getStyle(dom, node, name));
  const applyStyle = (dom, name, value) => (node) => {
    dom.setStyle(node, name, value);
    if (node.getAttribute("style") === "") {
      node.removeAttribute("style");
    }
    unwrapEmptySpan(dom, node);
  };

  const removeResult = Adt.generate([
    { keep: [] },
    { rename: ["name"] },
    { removed: [] },
  ]);
  const MCE_ATTR_RE = /^(src|href|style)$/;
  const each$7 = Tools.each;
  const isEq$2 = isEq$5;
  const isTableCellOrRow = (node) => /^(TR|TH|TD)$/.test(node.nodeName);
  const isChildOfInlineParent = (dom, node, parent) =>
    dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
  const getContainer = (ed, rng, start) => {
    let container = rng[start ? "startContainer" : "endContainer"];
    let offset = rng[start ? "startOffset" : "endOffset"];
    if (isElement$6(container)) {
      const lastIdx = container.childNodes.length - 1;
      if (!start && offset) {
        offset--;
      }
      container = container.childNodes[offset > lastIdx ? lastIdx : offset];
    }
    if (isText$b(container) && start && offset >= container.data.length) {
      container =
        new DomTreeWalker(container, ed.getBody()).next() || container;
    }
    if (isText$b(container) && !start && offset === 0) {
      container =
        new DomTreeWalker(container, ed.getBody()).prev() || container;
    }
    return container;
  };
  const normalizeTableSelection = (node, start) => {
    const prop = start ? "firstChild" : "lastChild";
    const childNode = node[prop];
    if (isTableCellOrRow(node) && childNode) {
      if (node.nodeName === "TR") {
        return childNode[prop] || childNode;
      } else {
        return childNode;
      }
    }
    return node;
  };
  const wrap$1 = (dom, node, name, attrs) => {
    var _a;
    const wrapper = dom.create(name, attrs);
    (_a = node.parentNode) === null || _a === void 0
      ? void 0
      : _a.insertBefore(wrapper, node);
    wrapper.appendChild(node);
    return wrapper;
  };
  const wrapWithSiblings = (dom, node, next, name, attrs) => {
    const start = SugarElement.fromDom(node);
    const wrapper = SugarElement.fromDom(dom.create(name, attrs));
    const siblings = next ? nextSiblings(start) : prevSiblings(start);
    append(wrapper, siblings);
    if (next) {
      before$3(start, wrapper);
      prepend(wrapper, start);
    } else {
      after$4(start, wrapper);
      append$1(wrapper, start);
    }
    return wrapper.dom;
  };
  const isColorFormatAndAnchor = (node, format) =>
    format.links && node.nodeName === "A";
  const removeNode = (ed, node, format) => {
    const parentNode = node.parentNode;
    let rootBlockElm;
    const dom = ed.dom;
    const forcedRootBlock = getForcedRootBlock(ed);
    if (isBlockFormat(format)) {
      if (parentNode === dom.getRoot()) {
        if (!format.list_block || !isEq$2(node, format.list_block)) {
          each$e(from(node.childNodes), (node) => {
            if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
              if (!rootBlockElm) {
                rootBlockElm = wrap$1(dom, node, forcedRootBlock);
                dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
              } else {
                rootBlockElm.appendChild(node);
              }
            } else {
              rootBlockElm = null;
            }
          });
        }
      }
    }
    if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
      return;
    }
    dom.remove(node, true);
  };
  const processFormatAttrOrStyle = (name, value, vars) => {
    if (isNumber(name)) {
      return {
        name: value,
        value: null,
      };
    } else {
      return {
        name,
        value: replaceVars(value, vars),
      };
    }
  };
  const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {
    if (dom.getAttrib(elm, "style") === "") {
      elm.removeAttribute("style");
      elm.removeAttribute("data-mce-style");
    }
  };
  const removeStyles = (dom, elm, format, vars, compareNode) => {
    let stylesModified = false;
    each$7(format.styles, (value, name) => {
      const { name: styleName, value: styleValue } = processFormatAttrOrStyle(
        name,
        value,
        vars
      );
      const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
      if (
        format.remove_similar ||
        isNull(styleValue) ||
        !isElement$6(compareNode) ||
        isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)
      ) {
        dom.setStyle(elm, styleName, "");
      }
      stylesModified = true;
    });
    if (stylesModified) {
      removeEmptyStyleAttributeIfNeeded(dom, elm);
    }
  };
  const removeListStyleFormats = (editor, name, vars) => {
    if (name === "removeformat") {
      each$e(getPartiallySelectedListItems(editor.selection), (li) => {
        each$e(listItemStyles, (name) => editor.dom.setStyle(li, name, ""));
        removeEmptyStyleAttributeIfNeeded(editor.dom, li);
      });
    } else {
      getExpandedListItemFormat(editor.formatter, name).each((liFmt) => {
        each$e(getPartiallySelectedListItems(editor.selection), (li) =>
          removeStyles(editor.dom, li, liFmt, vars, null)
        );
      });
    }
  };
  const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {
    const dom = ed.dom;
    const elementUtils = ElementUtils(ed);
    const schema = ed.schema;
    if (
      isInlineFormat(format) &&
      isTransparentElementName(schema, format.inline) &&
      isTransparentBlock(schema, node) &&
      node.parentElement === ed.getBody()
    ) {
      removeNode(ed, node, format);
      return removeResult.removed();
    }
    if (
      !format.ceFalseOverride &&
      node &&
      dom.getContentEditableParent(node) === "false"
    ) {
      return removeResult.keep();
    }
    if (
      node &&
      !matchName(dom, node, format) &&
      !isColorFormatAndAnchor(node, format)
    ) {
      return removeResult.keep();
    }
    const elm = node;
    const preserveAttributes = format.preserve_attributes;
    if (
      isInlineFormat(format) &&
      format.remove === "all" &&
      isArray$1(preserveAttributes)
    ) {
      const attrsToPreserve = filter$5(dom.getAttribs(elm), (attr) =>
        contains$2(preserveAttributes, attr.name.toLowerCase())
      );
      dom.removeAllAttribs(elm);
      each$e(attrsToPreserve, (attr) =>
        dom.setAttrib(elm, attr.name, attr.value)
      );
      if (attrsToPreserve.length > 0) {
        return removeResult.rename("span");
      }
    }
    if (format.remove !== "all") {
      removeStyles(dom, elm, format, vars, compareNode);
      each$7(format.attributes, (value, name) => {
        const { name: attrName, value: attrValue } = processFormatAttrOrStyle(
          name,
          value,
          vars
        );
        if (
          format.remove_similar ||
          isNull(attrValue) ||
          !isElement$6(compareNode) ||
          isEq$2(dom.getAttrib(compareNode, attrName), attrValue)
        ) {
          if (attrName === "class") {
            const currentValue = dom.getAttrib(elm, attrName);
            if (currentValue) {
              let valueOut = "";
              each$e(currentValue.split(/\s+/), (cls) => {
                if (/mce\-\w+/.test(cls)) {
                  valueOut += (valueOut ? " " : "") + cls;
                }
              });
              if (valueOut) {
                dom.setAttrib(elm, attrName, valueOut);
                return;
              }
            }
          }
          if (MCE_ATTR_RE.test(attrName)) {
            elm.removeAttribute("data-mce-" + attrName);
          }
          if (
            attrName === "style" &&
            matchNodeNames(["li"])(elm) &&
            dom.getStyle(elm, "list-style-type") === "none"
          ) {
            elm.removeAttribute(attrName);
            dom.setStyle(elm, "list-style-type", "none");
            return;
          }
          if (attrName === "class") {
            elm.removeAttribute("className");
          }
          elm.removeAttribute(attrName);
        }
      });
      each$7(format.classes, (value) => {
        value = replaceVars(value, vars);
        if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {
          dom.removeClass(elm, value);
        }
      });
      const attrs = dom.getAttribs(elm);
      for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].nodeName;
        if (!elementUtils.isAttributeInternal(attrName)) {
          return removeResult.keep();
        }
      }
    }
    if (format.remove !== "none") {
      removeNode(ed, elm, format);
      return removeResult.removed();
    }
    return removeResult.keep();
  };
  const findFormatRoot = (editor, container, name, vars, similar) => {
    let formatRoot;
    if (container.parentNode) {
      each$e(
        getParents$2(editor.dom, container.parentNode).reverse(),
        (parent) => {
          if (
            !formatRoot &&
            isElement$6(parent) &&
            parent.id !== "_start" &&
            parent.id !== "_end"
          ) {
            const format = matchNode(editor, parent, name, vars, similar);
            if (format && format.split !== false) {
              formatRoot = parent;
            }
          }
        }
      );
    }
    return formatRoot;
  };
  const removeNodeFormatFromClone = (editor, format, vars, clone) =>
    removeNodeFormatInternal(editor, format, vars, clone, clone).fold(
      constant(clone),
      (newName) => {
        const fragment = editor.dom.createFragment();
        fragment.appendChild(clone);
        return editor.dom.rename(clone, newName);
      },
      constant(null)
    );
  const wrapAndSplit = (
    editor,
    formatList,
    formatRoot,
    container,
    target,
    split,
    format,
    vars
  ) => {
    var _a, _b;
    let lastClone;
    let firstClone;
    const dom = editor.dom;
    if (formatRoot) {
      const formatRootParent = formatRoot.parentNode;
      for (
        let parent = container.parentNode;
        parent && parent !== formatRootParent;
        parent = parent.parentNode
      ) {
        let clone = dom.clone(parent, false);
        for (let i = 0; i < formatList.length; i++) {
          clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);
          if (clone === null) {
            break;
          }
        }
        if (clone) {
          if (lastClone) {
            clone.appendChild(lastClone);
          }
          if (!firstClone) {
            firstClone = clone;
          }
          lastClone = clone;
        }
      }
      if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
        container =
          (_a = dom.split(formatRoot, container)) !== null && _a !== void 0
            ? _a
            : container;
      }
      if (lastClone && firstClone) {
        (_b = target.parentNode) === null || _b === void 0
          ? void 0
          : _b.insertBefore(lastClone, target);
        firstClone.appendChild(target);
        if (isInlineFormat(format)) {
          mergeSiblings(editor, format, vars, lastClone);
        }
      }
    }
    return container;
  };
  const removeFormatInternal = (ed, name, vars, node, similar) => {
    const formatList = ed.formatter.get(name);
    const format = formatList[0];
    const dom = ed.dom;
    const selection = ed.selection;
    const splitToFormatRoot = (container) => {
      const formatRoot = findFormatRoot(ed, container, name, vars, similar);
      return wrapAndSplit(
        ed,
        formatList,
        formatRoot,
        container,
        container,
        true,
        format,
        vars
      );
    };
    const isRemoveBookmarkNode = (node) =>
      isBookmarkNode$1(node) &&
      isElement$6(node) &&
      (node.id === "_start" || node.id === "_end");
    const removeFormatOnNode = (node) =>
      exists(formatList, (fmt) => removeNodeFormat(ed, fmt, vars, node, node));
    const process = (node) => {
      const children = from(node.childNodes);
      const removed = removeFormatOnNode(node);
      const currentNodeMatches =
        removed || exists(formatList, (f) => matchName(dom, node, f));
      const parentNode = node.parentNode;
      if (
        !currentNodeMatches &&
        isNonNullable(parentNode) &&
        shouldExpandToSelector(format)
      ) {
        removeFormatOnNode(parentNode);
      }
      if (format.deep) {
        if (children.length) {
          for (let i = 0; i < children.length; i++) {
            process(children[i]);
          }
        }
      }
      const textDecorations = ["underline", "line-through", "overline"];
      each$e(textDecorations, (decoration) => {
        if (
          isElement$6(node) &&
          ed.dom.getStyle(node, "text-decoration") === decoration &&
          node.parentNode &&
          getTextDecoration(dom, node.parentNode) === decoration
        ) {
          removeNodeFormat(
            ed,
            {
              deep: false,
              exact: true,
              inline: "span",
              styles: { textDecoration: decoration },
            },
            undefined,
            node
          );
        }
      });
    };
    const unwrap = (start) => {
      const node = dom.get(start ? "_start" : "_end");
      if (node) {
        let out = node[start ? "firstChild" : "lastChild"];
        if (isRemoveBookmarkNode(out)) {
          out = out[start ? "firstChild" : "lastChild"];
        }
        if (isText$b(out) && out.data.length === 0) {
          out = start
            ? node.previousSibling || node.nextSibling
            : node.nextSibling || node.previousSibling;
        }
        dom.remove(node, true);
        return out;
      } else {
        return null;
      }
    };
    const removeRngStyle = (rng) => {
      let startContainer;
      let endContainer;
      let expandedRng = expandRng(dom, rng, formatList, {
        includeTrailingSpace: rng.collapsed,
      });
      if (format.split) {
        expandedRng = split(expandedRng);
        startContainer = getContainer(ed, expandedRng, true);
        endContainer = getContainer(ed, expandedRng);
        if (startContainer !== endContainer) {
          startContainer = normalizeTableSelection(startContainer, true);
          endContainer = normalizeTableSelection(endContainer, false);
          if (isChildOfInlineParent(dom, startContainer, endContainer)) {
            const marker = Optional.from(startContainer.firstChild).getOr(
              startContainer
            );
            splitToFormatRoot(
              wrapWithSiblings(dom, marker, true, "span", {
                id: "_start",
                "data-mce-type": "bookmark",
              })
            );
            unwrap(true);
            return;
          }
          if (isChildOfInlineParent(dom, endContainer, startContainer)) {
            const marker = Optional.from(endContainer.lastChild).getOr(
              endContainer
            );
            splitToFormatRoot(
              wrapWithSiblings(dom, marker, false, "span", {
                id: "_end",
                "data-mce-type": "bookmark",
              })
            );
            unwrap(false);
            return;
          }
          startContainer = wrap$1(dom, startContainer, "span", {
            id: "_start",
            "data-mce-type": "bookmark",
          });
          endContainer = wrap$1(dom, endContainer, "span", {
            id: "_end",
            "data-mce-type": "bookmark",
          });
          const newRng = dom.createRng();
          newRng.setStartAfter(startContainer);
          newRng.setEndBefore(endContainer);
          walk$3(dom, newRng, (nodes) => {
            each$e(nodes, (n) => {
              if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                splitToFormatRoot(n);
              }
            });
          });
          splitToFormatRoot(startContainer);
          splitToFormatRoot(endContainer);
          startContainer = unwrap(true);
          endContainer = unwrap();
        } else {
          startContainer = endContainer = splitToFormatRoot(startContainer);
        }
        expandedRng.startContainer = startContainer.parentNode
          ? startContainer.parentNode
          : startContainer;
        expandedRng.startOffset = dom.nodeIndex(startContainer);
        expandedRng.endContainer = endContainer.parentNode
          ? endContainer.parentNode
          : endContainer;
        expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
      }
      walk$3(dom, expandedRng, (nodes) => {
        each$e(nodes, process);
      });
    };
    if (node) {
      if (isNode(node)) {
        const rng = dom.createRng();
        rng.setStartBefore(node);
        rng.setEndAfter(node);
        removeRngStyle(rng);
      } else {
        removeRngStyle(node);
      }
      fireFormatRemove(ed, name, node, vars);
      return;
    }
    if (
      !selection.isCollapsed() ||
      !isInlineFormat(format) ||
      getCellsFromEditor(ed).length
    ) {
      preserveSelection(
        ed,
        () => runOnRanges(ed, removeRngStyle),
        (startNode) =>
          isInlineFormat(format) && match$2(ed, name, vars, startNode)
      );
      ed.nodeChanged();
    } else {
      removeCaretFormat(ed, name, vars, similar);
    }
    removeListStyleFormats(ed, name, vars);
    fireFormatRemove(ed, name, node, vars);
  };
  const removeFormat$1 = (ed, name, vars, node, similar) => {
    if (node || ed.selection.isEditable()) {
      removeFormatInternal(ed, name, vars, node, similar);
    }
  };
  const removeNodeFormat = (editor, format, vars, node, compareNode) => {
    return removeNodeFormatInternal(
      editor,
      format,
      vars,
      node,
      compareNode
    ).fold(
      never,
      (newName) => {
        editor.dom.rename(node, newName);
        return true;
      },
      always
    );
  };

  const each$6 = Tools.each;
  const mergeTextDecorationsAndColor = (dom, format, vars, node) => {
    const processTextDecorationsAndColor = (n) => {
      if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {
        const parentTextDecoration = getTextDecoration(dom, n.parentNode);
        if (dom.getStyle(n, "color") && parentTextDecoration) {
          dom.setStyle(n, "text-decoration", parentTextDecoration);
        } else if (
          dom.getStyle(n, "text-decoration") === parentTextDecoration
        ) {
          dom.setStyle(n, "text-decoration", null);
        }
      }
    };
    if (
      format.styles &&
      (format.styles.color || format.styles.textDecoration)
    ) {
      Tools.walk(node, processTextDecorationsAndColor, "childNodes");
      processTextDecorationsAndColor(node);
    }
  };
  const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {
    if (format.styles && format.styles.backgroundColor) {
      const hasFontSize = hasStyle(dom, "fontSize");
      processChildElements(
        node,
        (elm) => hasFontSize(elm) && dom.isEditable(elm),
        applyStyle(
          dom,
          "backgroundColor",
          replaceVars(format.styles.backgroundColor, vars)
        )
      );
    }
  };
  const mergeSubSup = (dom, format, vars, node) => {
    if (
      isInlineFormat(format) &&
      (format.inline === "sub" || format.inline === "sup")
    ) {
      const hasFontSize = hasStyle(dom, "fontSize");
      processChildElements(
        node,
        (elm) => hasFontSize(elm) && dom.isEditable(elm),
        applyStyle(dom, "fontSize", "")
      );
      const inverseTagDescendants = filter$5(
        dom.select(format.inline === "sup" ? "sub" : "sup", node),
        dom.isEditable
      );
      dom.remove(inverseTagDescendants, true);
    }
  };
  const mergeWithChildren = (editor, formatList, vars, node) => {
    each$6(formatList, (format) => {
      if (isInlineFormat(format)) {
        each$6(editor.dom.select(format.inline, node), (child) => {
          if (isElementNode(child)) {
            removeNodeFormat(
              editor,
              format,
              vars,
              child,
              format.exact ? child : null
            );
          }
        });
      }
      clearChildStyles(editor.dom, format, node);
    });
  };
  const mergeWithParents = (editor, format, name, vars, node) => {
    const parentNode = node.parentNode;
    if (matchNode(editor, parentNode, name, vars)) {
      if (removeNodeFormat(editor, format, vars, node)) {
        return;
      }
    }
    if (format.merge_with_parents && parentNode) {
      editor.dom.getParent(parentNode, (parent) => {
        if (matchNode(editor, parent, name, vars)) {
          removeNodeFormat(editor, format, vars, node);
          return true;
        } else {
          return false;
        }
      });
    }
  };

  const each$5 = Tools.each;
  const canFormatBR = (editor, format, node, parentName) => {
    if (
      canFormatEmptyLines(editor) &&
      isInlineFormat(format) &&
      node.parentNode
    ) {
      const validBRParentElements = getTextRootBlockElements(editor.schema);
      const hasCaretNodeSibling = sibling(
        SugarElement.fromDom(node),
        (sibling) => isCaretNode(sibling.dom)
      );
      return (
        hasNonNullableKey(validBRParentElements, parentName) &&
        isEmptyNode(editor.schema, node.parentNode, {
          skipBogus: false,
          includeZwsp: true,
        }) &&
        !hasCaretNodeSibling
      );
    } else {
      return false;
    }
  };
  const applyStyles = (dom, elm, format, vars) => {
    each$5(format.styles, (value, name) => {
      dom.setStyle(elm, name, replaceVars(value, vars));
    });
    if (format.styles) {
      const styleVal = dom.getAttrib(elm, "style");
      if (styleVal) {
        dom.setAttrib(elm, "data-mce-style", styleVal);
      }
    }
  };
  const applyFormatAction = (ed, name, vars, node) => {
    const formatList = ed.formatter.get(name);
    const format = formatList[0];
    const isCollapsed = !node && ed.selection.isCollapsed();
    const dom = ed.dom;
    const selection = ed.selection;
    const setElementFormat = (elm, fmt = format) => {
      if (isFunction(fmt.onformat)) {
        fmt.onformat(elm, fmt, vars, node);
      }
      applyStyles(dom, elm, fmt, vars);
      each$5(fmt.attributes, (value, name) => {
        dom.setAttrib(elm, name, replaceVars(value, vars));
      });
      each$5(fmt.classes, (value) => {
        const newValue = replaceVars(value, vars);
        if (!dom.hasClass(elm, newValue)) {
          dom.addClass(elm, newValue);
        }
      });
    };
    const applyNodeStyle = (formatList, node) => {
      let found = false;
      each$5(formatList, (format) => {
        if (!isSelectorFormat(format)) {
          return false;
        }
        if (
          dom.getContentEditable(node) === "false" &&
          !format.ceFalseOverride
        ) {
          return true;
        }
        if (
          isNonNullable(format.collapsed) &&
          format.collapsed !== isCollapsed
        ) {
          return true;
        }
        if (dom.is(node, format.selector) && !isCaretNode(node)) {
          setElementFormat(node, format);
          found = true;
          return false;
        }
        return true;
      });
      return found;
    };
    const createWrapElement = (wrapName) => {
      if (isString(wrapName)) {
        const wrapElm = dom.create(wrapName);
        setElementFormat(wrapElm);
        return wrapElm;
      } else {
        return null;
      }
    };
    const applyRngStyle = (dom, rng, nodeSpecific) => {
      const newWrappers = [];
      let contentEditable = true;
      const wrapName = format.inline || format.block;
      const wrapElm = createWrapElement(wrapName);
      const isMatchingWrappingBlock = (node) =>
        isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);
      const canRenameBlock = (node, parentName, isEditableDescendant) => {
        const isValidBlockFormatForNode =
          isNonWrappingBlockFormat(format) &&
          isTextBlock$1(ed.schema, node) &&
          isValid(ed, parentName, wrapName);
        return isEditableDescendant && isValidBlockFormatForNode;
      };
      const canWrapNode = (
        node,
        parentName,
        isEditableDescendant,
        isWrappableNoneditableElm
      ) => {
        const nodeName = node.nodeName.toLowerCase();
        const isValidWrapNode =
          isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);
        const isZwsp$1 = !nodeSpecific && isText$b(node) && isZwsp(node.data);
        const isCaret = isCaretNode(node);
        const isCorrectFormatForNode =
          !isInlineFormat(format) || !dom.isBlock(node);
        return (
          (isEditableDescendant || isWrappableNoneditableElm) &&
          isValidWrapNode &&
          !isZwsp$1 &&
          !isCaret &&
          isCorrectFormatForNode
        );
      };
      walk$3(dom, rng, (nodes) => {
        let currentWrapElm;
        const process = (node) => {
          let hasContentEditableState = false;
          let lastContentEditable = contentEditable;
          let isWrappableNoneditableElm = false;
          const parentNode = node.parentNode;
          const parentName = parentNode.nodeName.toLowerCase();
          const contentEditableValue = dom.getContentEditable(node);
          if (isNonNullable(contentEditableValue)) {
            lastContentEditable = contentEditable;
            contentEditable = contentEditableValue === "true";
            hasContentEditableState = true;
            isWrappableNoneditableElm = isWrappableNoneditable(ed, node);
          }
          const isEditableDescendant =
            contentEditable && !hasContentEditableState;
          if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {
            currentWrapElm = null;
            if (isBlockFormat(format)) {
              dom.remove(node);
            }
            return;
          }
          if (isMatchingWrappingBlock(node)) {
            currentWrapElm = null;
            return;
          }
          if (canRenameBlock(node, parentName, isEditableDescendant)) {
            const elm = dom.rename(node, wrapName);
            setElementFormat(elm);
            newWrappers.push(elm);
            currentWrapElm = null;
            return;
          }
          if (isSelectorFormat(format)) {
            let found = applyNodeStyle(formatList, node);
            if (
              !found &&
              isNonNullable(parentNode) &&
              shouldExpandToSelector(format)
            ) {
              found = applyNodeStyle(formatList, parentNode);
            }
            if (!isInlineFormat(format) || found) {
              currentWrapElm = null;
              return;
            }
          }
          if (
            isNonNullable(wrapElm) &&
            canWrapNode(
              node,
              parentName,
              isEditableDescendant,
              isWrappableNoneditableElm
            )
          ) {
            if (!currentWrapElm) {
              currentWrapElm = dom.clone(wrapElm, false);
              parentNode.insertBefore(currentWrapElm, node);
              newWrappers.push(currentWrapElm);
            }
            if (isWrappableNoneditableElm && hasContentEditableState) {
              contentEditable = lastContentEditable;
            }
            currentWrapElm.appendChild(node);
          } else {
            currentWrapElm = null;
            each$e(from(node.childNodes), process);
            if (hasContentEditableState) {
              contentEditable = lastContentEditable;
            }
            currentWrapElm = null;
          }
        };
        each$e(nodes, process);
      });
      if (format.links === true) {
        each$e(newWrappers, (node) => {
          const process = (node) => {
            if (node.nodeName === "A") {
              setElementFormat(node, format);
            }
            each$e(from(node.childNodes), process);
          };
          process(node);
        });
      }
      each$e(newWrappers, (node) => {
        const getChildCount = (node) => {
          let count = 0;
          each$e(node.childNodes, (node) => {
            if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {
              count++;
            }
          });
          return count;
        };
        const mergeStyles = (node) => {
          const childElement = find$2(node.childNodes, isElementNode$1).filter(
            (child) =>
              dom.getContentEditable(child) !== "false" &&
              matchName(dom, child, format)
          );
          return childElement
            .map((child) => {
              const clone = dom.clone(child, false);
              setElementFormat(clone);
              dom.replace(clone, node, true);
              dom.remove(child, true);
              return clone;
            })
            .getOr(node);
        };
        const childCount = getChildCount(node);
        if (
          (newWrappers.length > 1 || !dom.isBlock(node)) &&
          childCount === 0
        ) {
          dom.remove(node, true);
          return;
        }
        if (
          isInlineFormat(format) ||
          (isBlockFormat(format) && format.wrapper)
        ) {
          if (!format.exact && childCount === 1) {
            node = mergeStyles(node);
          }
          mergeWithChildren(ed, formatList, vars, node);
          mergeWithParents(ed, format, name, vars, node);
          mergeBackgroundColorAndFontSize(dom, format, vars, node);
          mergeTextDecorationsAndColor(dom, format, vars, node);
          mergeSubSup(dom, format, vars, node);
          mergeSiblings(ed, format, vars, node);
        }
      });
    };
    const targetNode = isNode(node) ? node : selection.getNode();
    if (
      dom.getContentEditable(targetNode) === "false" &&
      !isWrappableNoneditable(ed, targetNode)
    ) {
      node = targetNode;
      applyNodeStyle(formatList, node);
      fireFormatApply(ed, name, node, vars);
      return;
    }
    if (format) {
      if (node) {
        if (isNode(node)) {
          if (!applyNodeStyle(formatList, node)) {
            const rng = dom.createRng();
            rng.setStartBefore(node);
            rng.setEndAfter(node);
            applyRngStyle(dom, expandRng(dom, rng, formatList), true);
          }
        } else {
          applyRngStyle(dom, node, true);
        }
      } else {
        if (
          !isCollapsed ||
          !isInlineFormat(format) ||
          getCellsFromEditor(ed).length
        ) {
          selection.setRng(normalize(selection.getRng()));
          preserveSelection(
            ed,
            () => {
              runOnRanges(ed, (selectionRng, fake) => {
                const expandedRng = fake
                  ? selectionRng
                  : expandRng(dom, selectionRng, formatList);
                applyRngStyle(dom, expandedRng, false);
              });
            },
            always
          );
          ed.nodeChanged();
        } else {
          applyCaretFormat(ed, name, vars);
        }
        getExpandedListItemFormat(ed.formatter, name).each((liFmt) => {
          each$e(getFullySelectedListItems(ed.selection), (li) =>
            applyStyles(dom, li, liFmt, vars)
          );
        });
      }
      postProcess$1(name, ed);
    }
    fireFormatApply(ed, name, node, vars);
  };
  const applyFormat$1 = (editor, name, vars, node) => {
    if (node || editor.selection.isEditable()) {
      applyFormatAction(editor, name, vars, node);
    }
  };

  const hasVars = (value) => has$2(value, "vars");
  const setup$u = (registeredFormatListeners, editor) => {
    registeredFormatListeners.set({});
    editor.on("NodeChange", (e) => {
      updateAndFireChangeCallbacks(
        editor,
        e.element,
        registeredFormatListeners.get()
      );
    });
    editor.on("FormatApply FormatRemove", (e) => {
      const element = Optional.from(e.node)
        .map((nodeOrRange) =>
          isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer
        )
        .bind((node) =>
          isElement$6(node)
            ? Optional.some(node)
            : Optional.from(node.parentElement)
        )
        .getOrThunk(() => fallbackElement(editor));
      updateAndFireChangeCallbacks(
        editor,
        element,
        registeredFormatListeners.get()
      );
    });
  };
  const fallbackElement = (editor) => editor.selection.getStart();
  const matchingNode = (editor, parents, format, similar, vars) => {
    const isMatchingNode = (node) => {
      const matchingFormat = editor.formatter.matchNode(
        node,
        format,
        vars !== null && vars !== void 0 ? vars : {},
        similar
      );
      return !isUndefined(matchingFormat);
    };
    const isUnableToMatch = (node) => {
      if (matchesUnInheritedFormatSelector(editor, node, format)) {
        return true;
      } else {
        if (!similar) {
          return isNonNullable(
            editor.formatter.matchNode(node, format, vars, true)
          );
        } else {
          return false;
        }
      }
    };
    return findUntil$1(parents, isMatchingNode, isUnableToMatch);
  };
  const getParents = (editor, elm) => {
    const element =
      elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
    return filter$5(
      getParents$2(editor.dom, element),
      (node) => isElement$6(node) && !isBogus$1(node)
    );
  };
  const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
    const parents = getParents(editor, elm);
    each$d(registeredCallbacks, (data, format) => {
      const runIfChanged = (spec) => {
        const match = matchingNode(
          editor,
          parents,
          format,
          spec.similar,
          hasVars(spec) ? spec.vars : undefined
        );
        const isSet = match.isSome();
        if (spec.state.get() !== isSet) {
          spec.state.set(isSet);
          const node = match.getOr(elm);
          if (hasVars(spec)) {
            spec.callback(isSet, {
              node,
              format,
              parents,
            });
          } else {
            each$e(spec.callbacks, (callback) =>
              callback(isSet, {
                node,
                format,
                parents,
              })
            );
          }
        }
      };
      each$e([data.withSimilar, data.withoutSimilar], runIfChanged);
      each$e(data.withVars, runIfChanged);
    });
  };
  const addListeners = (
    editor,
    registeredFormatListeners,
    formats,
    callback,
    similar,
    vars
  ) => {
    const formatChangeItems = registeredFormatListeners.get();
    each$e(formats.split(","), (format) => {
      const group = get$a(formatChangeItems, format).getOrThunk(() => {
        const base = {
          withSimilar: {
            state: Cell(false),
            similar: true,
            callbacks: [],
          },
          withoutSimilar: {
            state: Cell(false),
            similar: false,
            callbacks: [],
          },
          withVars: [],
        };
        formatChangeItems[format] = base;
        return base;
      });
      const getCurrent = () => {
        const parents = getParents(editor);
        return matchingNode(editor, parents, format, similar, vars).isSome();
      };
      if (isUndefined(vars)) {
        const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
        toAppendTo.callbacks.push(callback);
        if (toAppendTo.callbacks.length === 1) {
          toAppendTo.state.set(getCurrent());
        }
      } else {
        group.withVars.push({
          state: Cell(getCurrent()),
          similar,
          vars,
          callback,
        });
      }
    });
    registeredFormatListeners.set(formatChangeItems);
  };
  const removeListeners = (registeredFormatListeners, formats, callback) => {
    const formatChangeItems = registeredFormatListeners.get();
    each$e(formats.split(","), (format) =>
      get$a(formatChangeItems, format).each((group) => {
        formatChangeItems[format] = {
          withSimilar: {
            ...group.withSimilar,
            callbacks: filter$5(
              group.withSimilar.callbacks,
              (cb) => cb !== callback
            ),
          },
          withoutSimilar: {
            ...group.withoutSimilar,
            callbacks: filter$5(
              group.withoutSimilar.callbacks,
              (cb) => cb !== callback
            ),
          },
          withVars: filter$5(
            group.withVars,
            (item) => item.callback !== callback
          ),
        };
      })
    );
    registeredFormatListeners.set(formatChangeItems);
  };
  const formatChangedInternal = (
    editor,
    registeredFormatListeners,
    formats,
    callback,
    similar,
    vars
  ) => {
    addListeners(
      editor,
      registeredFormatListeners,
      formats,
      callback,
      similar,
      vars
    );
    return {
      unbind: () =>
        removeListeners(registeredFormatListeners, formats, callback),
    };
  };

  const toggle = (editor, name, vars, node) => {
    const fmt = editor.formatter.get(name);
    if (fmt) {
      if (
        match$2(editor, name, vars, node) &&
        (!("toggle" in fmt[0]) || fmt[0].toggle)
      ) {
        removeFormat$1(editor, name, vars, node);
      } else {
        applyFormat$1(editor, name, vars, node);
      }
    }
  };

  const explode$1 = Tools.explode;
  const create$8 = () => {
    const filters = {};
    const addFilter = (name, callback) => {
      each$e(explode$1(name), (name) => {
        if (!has$2(filters, name)) {
          filters[name] = {
            name,
            callbacks: [],
          };
        }
        filters[name].callbacks.push(callback);
      });
    };
    const getFilters = () => values(filters);
    const removeFilter = (name, callback) => {
      each$e(explode$1(name), (name) => {
        if (has$2(filters, name)) {
          if (isNonNullable(callback)) {
            const filter = filters[name];
            const newCallbacks = filter$5(
              filter.callbacks,
              (c) => c !== callback
            );
            if (newCallbacks.length > 0) {
              filter.callbacks = newCallbacks;
            } else {
              delete filters[name];
            }
          } else {
            delete filters[name];
          }
        }
      });
    };
    return {
      addFilter,
      getFilters,
      removeFilter,
    };
  };

  const removeAttrs = (node, names) => {
    each$e(names, (name) => {
      node.attr(name, null);
    });
  };
  const addFontToSpansFilter = (domParser, styles, fontSizes) => {
    domParser.addNodeFilter("font", (nodes) => {
      each$e(nodes, (node) => {
        const props = styles.parse(node.attr("style"));
        const color = node.attr("color");
        const face = node.attr("face");
        const size = node.attr("size");
        if (color) {
          props.color = color;
        }
        if (face) {
          props["font-family"] = face;
        }
        if (size) {
          toInt(size).each((num) => {
            props["font-size"] = fontSizes[num - 1];
          });
        }
        node.name = "span";
        node.attr("style", styles.serialize(props));
        removeAttrs(node, ["color", "face", "size"]);
      });
    });
  };
  const addStrikeFilter = (domParser, schema, styles) => {
    domParser.addNodeFilter("strike", (nodes) => {
      const convertToSTag = schema.type !== "html4";
      each$e(nodes, (node) => {
        if (convertToSTag) {
          node.name = "s";
        } else {
          const props = styles.parse(node.attr("style"));
          props["text-decoration"] = "line-through";
          node.name = "span";
          node.attr("style", styles.serialize(props));
        }
      });
    });
  };
  const addFilters = (domParser, settings, schema) => {
    var _a;
    const styles = Styles();
    if (settings.convert_fonts_to_spans) {
      addFontToSpansFilter(
        domParser,
        styles,
        Tools.explode(
          (_a = settings.font_size_legacy_values) !== null && _a !== void 0
            ? _a
            : ""
        )
      );
    }
    addStrikeFilter(domParser, schema, styles);
  };
  const register$5 = (domParser, settings, schema) => {
    if (settings.inline_styles) {
      addFilters(domParser, settings, schema);
    }
  };

  const blobUriToBlob = (url) =>
    fetch(url)
      .then((res) => (res.ok ? res.blob() : Promise.reject()))
      .catch(() =>
        Promise.reject({
          message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,
          uriType: "blob",
        })
      );
  const extractBase64Data = (data) => {
    const matches = /([a-z0-9+\/=\s]+)/i.exec(data);
    return matches ? matches[1] : "";
  };
  const decodeData = (data) => {
    try {
      return decodeURIComponent(data);
    } catch (_a) {
      return data;
    }
  };
  const parseDataUri = (uri) => {
    const [type, ...rest] = uri.split(",");
    const data = rest.join(",");
    const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type);
    if (matches) {
      const base64Encoded = matches[2] === ";base64";
      const decodedData = decodeData(data);
      const extractedData = base64Encoded
        ? extractBase64Data(decodedData)
        : decodedData;
      return Optional.some({
        type: matches[1],
        data: extractedData,
        base64Encoded,
      });
    } else {
      return Optional.none();
    }
  };
  const buildBlob = (type, data, base64Encoded = true) => {
    let str = data;
    if (base64Encoded) {
      try {
        str = atob(data);
      } catch (_a) {
        return Optional.none();
      }
    }
    const arr = new Uint8Array(str.length);
    for (let i = 0; i < arr.length; i++) {
      arr[i] = str.charCodeAt(i);
    }
    return Optional.some(new Blob([arr], { type }));
  };
  const dataUriToBlob = (uri) => {
    return new Promise((resolve, reject) => {
      parseDataUri(uri)
        .bind(({ type, data, base64Encoded }) =>
          buildBlob(type, data, base64Encoded)
        )
        .fold(() => reject("Invalid data URI"), resolve);
    });
  };
  const uriToBlob = (url) => {
    if (startsWith(url, "blob:")) {
      return blobUriToBlob(url);
    } else if (startsWith(url, "data:")) {
      return dataUriToBlob(url);
    } else {
      return Promise.reject("Unknown URI format");
    }
  };
  const blobToDataUri = (blob) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = () => {
        var _a;
        reject(
          (_a = reader.error) === null || _a === void 0 ? void 0 : _a.message
        );
      };
      reader.readAsDataURL(blob);
    });
  };

  let count$1 = 0;
  const uniqueId$1 = (prefix) => {
    return (prefix || "blobid") + count$1++;
  };
  const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
    return parseDataUri(dataUri).bind(({ data, type, base64Encoded }) => {
      if (base64Only && !base64Encoded) {
        return Optional.none();
      } else {
        const base64 = base64Encoded ? data : btoa(data);
        return generateBlobInfo(base64, type);
      }
    });
  };
  const createBlobInfo$1 = (blobCache, blob, base64) => {
    const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
    blobCache.add(blobInfo);
    return blobInfo;
  };
  const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
    return processDataUri(dataUri, base64Only, (base64, type) =>
      Optional.from(blobCache.getByData(base64, type)).orThunk(() =>
        buildBlob(type, base64).map((blob) =>
          createBlobInfo$1(blobCache, blob, base64)
        )
      )
    );
  };
  const imageToBlobInfo = (blobCache, imageSrc) => {
    const invalidDataUri = () => Promise.reject("Invalid data URI");
    if (startsWith(imageSrc, "blob:")) {
      const blobInfo = blobCache.getByUri(imageSrc);
      if (isNonNullable(blobInfo)) {
        return Promise.resolve(blobInfo);
      } else {
        return uriToBlob(imageSrc).then((blob) => {
          return blobToDataUri(blob).then((dataUri) => {
            return processDataUri(dataUri, false, (base64) => {
              return Optional.some(createBlobInfo$1(blobCache, blob, base64));
            }).getOrThunk(invalidDataUri);
          });
        });
      }
    } else if (startsWith(imageSrc, "data:")) {
      return dataUriToBlobInfo(blobCache, imageSrc).fold(
        invalidDataUri,
        (blobInfo) => Promise.resolve(blobInfo)
      );
    } else {
      return Promise.reject("Unknown image data format");
    }
  };

  const hostCaptureRegex =
    /^(?:(?:(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)([A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*))(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?)$/;
  const extractHost = (url) =>
    Optional.from(url.match(hostCaptureRegex))
      .bind((ms) => get$b(ms, 1))
      .map((h) => (startsWith(h, "www.") ? h.substring(4) : h));

  const sandboxIframe = (iframeNode, exclusions) => {
    if (
      Optional.from(iframeNode.attr("src"))
        .bind(extractHost)
        .forall((host) => !contains$2(exclusions, host))
    ) {
      iframeNode.attr("sandbox", "");
    }
  };
  const isMimeType = (mime, type) => startsWith(mime, `${type}/`);
  const getEmbedType = (type) => {
    if (isUndefined(type)) {
      return "iframe";
    } else if (isMimeType(type, "image")) {
      return "img";
    } else if (isMimeType(type, "video")) {
      return "video";
    } else if (isMimeType(type, "audio")) {
      return "audio";
    } else {
      return "iframe";
    }
  };
  const createSafeEmbed = (
    { type, src, width, height } = {},
    sandboxIframes,
    sandboxIframesExclusions
  ) => {
    const name = getEmbedType(type);
    const embed = new AstNode(name, 1);
    embed.attr(
      name === "audio"
        ? { src }
        : {
            src,
            width,
            height,
          }
    );
    if (name === "audio" || name === "video") {
      embed.attr("controls", "");
    }
    if (name === "iframe" && sandboxIframes) {
      sandboxIframe(embed, sandboxIframesExclusions);
    }
    return embed;
  };

  const isBogusImage = (img) => isNonNullable(img.attr("data-mce-bogus"));
  const isInternalImageSource = (img) =>
    img.attr("src") === Env.transparentSrc ||
    isNonNullable(img.attr("data-mce-placeholder"));
  const registerBase64ImageFilter = (parser, settings) => {
    const { blob_cache: blobCache } = settings;
    if (blobCache) {
      const processImage = (img) => {
        const inputSrc = img.attr("src");
        if (
          isInternalImageSource(img) ||
          isBogusImage(img) ||
          isNullable(inputSrc)
        ) {
          return;
        }
        dataUriToBlobInfo(blobCache, inputSrc, true).each((blobInfo) => {
          img.attr("src", blobInfo.blobUri());
        });
      };
      parser.addAttributeFilter("src", (nodes) => each$e(nodes, processImage));
    }
  };
  const register$4 = (parser, settings) => {
    var _a, _b;
    const schema = parser.schema;
    parser.addAttributeFilter("href", (nodes) => {
      let i = nodes.length;
      const appendRel = (rel) => {
        const parts = rel.split(" ").filter((p) => p.length > 0);
        return parts.concat(["noopener"]).sort().join(" ");
      };
      const addNoOpener = (rel) => {
        const newRel = rel ? Tools.trim(rel) : "";
        if (!/\b(noopener)\b/g.test(newRel)) {
          return appendRel(newRel);
        } else {
          return newRel;
        }
      };
      if (!settings.allow_unsafe_link_target) {
        while (i--) {
          const node = nodes[i];
          if (node.name === "a" && node.attr("target") === "_blank") {
            node.attr("rel", addNoOpener(node.attr("rel")));
          }
        }
      }
    });
    if (!settings.allow_html_in_named_anchor) {
      parser.addAttributeFilter("id,name", (nodes) => {
        let i = nodes.length,
          sibling,
          prevSibling,
          parent,
          node;
        while (i--) {
          node = nodes[i];
          if (node.name === "a" && node.firstChild && !node.attr("href")) {
            parent = node.parent;
            sibling = node.lastChild;
            while (sibling && parent) {
              prevSibling = sibling.prev;
              parent.insert(sibling, node);
              sibling = prevSibling;
            }
          }
        }
      });
    }
    if (settings.fix_list_elements) {
      parser.addNodeFilter("ul,ol", (nodes) => {
        let i = nodes.length,
          node,
          parentNode;
        while (i--) {
          node = nodes[i];
          parentNode = node.parent;
          if (
            parentNode &&
            (parentNode.name === "ul" || parentNode.name === "ol")
          ) {
            if (node.prev && node.prev.name === "li") {
              node.prev.append(node);
            } else {
              const li = new AstNode("li", 1);
              li.attr("style", "list-style-type: none");
              node.wrap(li);
            }
          }
        }
      });
    }
    const validClasses = schema.getValidClasses();
    if (settings.validate && validClasses) {
      parser.addAttributeFilter("class", (nodes) => {
        var _a;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const clazz =
            (_a = node.attr("class")) !== null && _a !== void 0 ? _a : "";
          const classList = Tools.explode(clazz, " ");
          let classValue = "";
          for (let ci = 0; ci < classList.length; ci++) {
            const className = classList[ci];
            let valid = false;
            let validClassesMap = validClasses["*"];
            if (validClassesMap && validClassesMap[className]) {
              valid = true;
            }
            validClassesMap = validClasses[node.name];
            if (!valid && validClassesMap && validClassesMap[className]) {
              valid = true;
            }
            if (valid) {
              if (classValue) {
                classValue += " ";
              }
              classValue += className;
            }
          }
          if (!classValue.length) {
            classValue = null;
          }
          node.attr("class", classValue);
        }
      });
    }
    registerBase64ImageFilter(parser, settings);
    const shouldSandboxIframes =
      (_a = settings.sandbox_iframes) !== null && _a !== void 0 ? _a : false;
    const sandboxIframesExclusions = unique$1(
      (_b = settings.sandbox_iframes_exclusions) !== null && _b !== void 0
        ? _b
        : []
    );
    if (settings.convert_unsafe_embeds) {
      parser.addNodeFilter("object,embed", (nodes) =>
        each$e(nodes, (node) => {
          node.replace(
            createSafeEmbed(
              {
                type: node.attr("type"),
                src:
                  node.name === "object" ? node.attr("data") : node.attr("src"),
                width: node.attr("width"),
                height: node.attr("height"),
              },
              shouldSandboxIframes,
              sandboxIframesExclusions
            )
          );
        })
      );
    }
    if (shouldSandboxIframes) {
      parser.addNodeFilter("iframe", (nodes) =>
        each$e(nodes, (node) => sandboxIframe(node, sandboxIframesExclusions))
      );
    }
  };

  /*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */

  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor,
  } = Object;
  let { freeze, seal, create: create$7 } = Object; // eslint-disable-line import/no-mutable-exports
  let { apply, construct } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }
  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }
  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct(Func, args) {
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const arraySplice = unapply(Array.prototype.splice);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  /**
   * Creates a new function that calls the given function with a specified thisArg and arguments.
   *
   * @param func - The function to be wrapped and called.
   * @returns A new function that calls the given function with a specified thisArg and arguments.
   */
  function unapply(func) {
    return function (thisArg) {
      for (
        var _len = arguments.length,
          args = new Array(_len > 1 ? _len - 1 : 0),
          _key = 1;
        _key < _len;
        _key++
      ) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  /**
   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
   *
   * @param func - The constructor function to be wrapped and called.
   * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
   */
  function unconstruct(func) {
    return function () {
      for (
        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
        _key2 < _len2;
        _key2++
      ) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  /**
   * Add properties to a lookup table
   *
   * @param set - The set to which elements will be added.
   * @param array - The array containing elements to be added to the set.
   * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
   * @returns The modified set with added elements.
   */
  function addToSet(set, array) {
    let transformCaseFunc =
      arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : stringToLowerCase;
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }
    let l = array.length;
    while (l--) {
      let element = array[l];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set[element] = true;
    }
    return set;
  }
  /**
   * Clean up an array to harden against CSPP
   *
   * @param array - The array to be cleaned.
   * @returns The cleaned version of the array
   */
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array, index);
      if (!isPropertyExist) {
        array[index] = null;
      }
    }
    return array;
  }
  /**
   * Shallow clone an object
   *
   * @param object - The object to be cloned.
   * @returns A new object that copies the original.
   */
  function clone(object) {
    const newObject = create$7(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (
          value &&
          typeof value === "object" &&
          value.constructor === Object
        ) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  /**
   * This method automatically checks if the prop is function or getter and behaves accordingly.
   *
   * @param object - The object to look up the getter function in its prototype chain.
   * @param prop - The property name for which to find the getter function.
   * @returns The getter function found in the prototype chain or a fallback function.
   */
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }

  const html$1 = freeze([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
  ]);
  const svg$1 = freeze([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern",
  ]);
  const svgFilters = freeze([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
  ]);
  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  const svgDisallowed = freeze([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use",
  ]);
  const mathMl$1 = freeze([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts",
  ]);
  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  const mathMlDisallowed = freeze([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none",
  ]);
  const text = freeze(["#text"]);

  const html = freeze([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "wrap",
    "xmlns",
    "slot",
  ]);
  const svg = freeze([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "amplitude",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "exponent",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "intercept",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "slope",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "tablevalues",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan",
  ]);
  const mathMl = freeze([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns",
  ]);
  const xml = freeze([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink",
  ]);

  // eslint-disable-next-line unicorn/better-regex
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  const IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  const DOCTYPE_NAME = seal(/^html$/i);
  const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

  var EXPRESSIONS = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ARIA_ATTR: ARIA_ATTR,
    ATTR_WHITESPACE: ATTR_WHITESPACE,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT,
    DATA_ATTR: DATA_ATTR,
    DOCTYPE_NAME: DOCTYPE_NAME,
    ERB_EXPR: ERB_EXPR,
    IS_ALLOWED_URI: IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR: MUSTACHE_EXPR,
    TMPLIT_EXPR: TMPLIT_EXPR,
  });

  /* eslint-disable @typescript-eslint/indent */
  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
  const NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12, // Deprecated
  };
  const getGlobal = function getGlobal() {
    return typeof window === "undefined" ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param trustedTypes The policy factory.
   * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
   * @return The policy created (or null, if Trusted Types
   * are not supported or creating the policy failed).
   */
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(
    trustedTypes,
    purifyHostElement
  ) {
    if (
      typeof trustedTypes !== "object" ||
      typeof trustedTypes.createPolicy !== "function"
    ) {
      return null;
    }
    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html) {
          return html;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        },
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn(
        "TrustedTypes policy " + policyName + " could not be created."
      );
      return null;
    }
  };
  const _createHooksMap = function _createHooksMap() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: [],
    };
  };
  function createDOMPurify() {
    let window =
      arguments.length > 0 && arguments[0] !== undefined
        ? arguments[0]
        : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.2.4";
    DOMPurify.removed = [];
    if (
      !window ||
      !window.document ||
      window.document.nodeType !== NODE_TYPE.document ||
      !window.Element
    ) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let { document } = window;
    const originalDocument = document;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node,
      Element,
      NodeFilter,
      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser,
      trustedTypes,
    } = window;
    const ElementPrototype = Element.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === "function") {
      const template = document.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName,
    } = document;
    const { importNode } = originalDocument;
    let hooks = _createHooksMap();
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported =
      typeof entries === "function" &&
      typeof getParentNode === "function" &&
      implementation &&
      implementation.createHTMLDocument !== undefined;
    const {
      MUSTACHE_EXPR,
      ERB_EXPR,
      TMPLIT_EXPR,
      DATA_ATTR,
      ARIA_ATTR,
      IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE,
      CUSTOM_ELEMENT,
    } = EXPRESSIONS;
    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */
    /* allowed element names */
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [
      ...html$1,
      ...svg$1,
      ...svgFilters,
      ...mathMl$1,
      ...text,
    ]);
    /* Allowed attribute names */
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [
      ...html,
      ...svg,
      ...mathMl,
      ...xml,
    ]);
    /*
     * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */
    let CUSTOM_ELEMENT_HANDLING = Object.seal(
      create$7(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null,
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null,
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false,
        },
      })
    );
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    let FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    let FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */
    let ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */
    let ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
     * Usually removed due to a mXSS issue in jQuery 3.0 */
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    let SAFE_FOR_TEMPLATES = false;
    /* Output should be safe even for XML used within HTML and alike.
     * This means, DOMPurify removes comments when containing risky content.
     */
    let SAFE_FOR_XML = true;
    /* Decide if document with <html>... should be returned */
    let WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */
    let SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    let FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    let RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    let RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    let RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */
    let SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (Â§7.3.3)
     *   - DOM Tree Accessors (Â§3.1.5)
     *   - Form Element Parent-Child Relations (Â§4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (Â§4.8.5)
     *   - HTMLCollection (Â§4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    /* Keep element content when removing element? */
    let KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    let IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */
    let USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, [
      "annotation-xml",
      "audio",
      "colgroup",
      "desc",
      "foreignobject",
      "head",
      "iframe",
      "math",
      "mi",
      "mn",
      "mo",
      "ms",
      "mtext",
      "noembed",
      "noframes",
      "noscript",
      "plaintext",
      "script",
      "style",
      "svg",
      "template",
      "thead",
      "title",
      "video",
      "xmp",
    ]);
    /* Tags that are safe for data: URIs */
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, [
      "audio",
      "video",
      "img",
      "source",
      "image",
      "track",
    ]);
    /* Attributes safe for values like "javascript:" */
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
      "alt",
      "class",
      "for",
      "id",
      "label",
      "name",
      "pattern",
      "placeholder",
      "role",
      "summary",
      "title",
      "value",
      "style",
      "xmlns",
    ]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    /* Document namespace */
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet(
      {},
      [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE],
      stringToString
    );
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
    ]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
      "title",
      "style",
      "font",
      "a",
      "script",
    ]);
    /* Parsing of strict XHTML documents */
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    /* Keep a reference to config to pass to hooks */
    let CONFIG = null;
    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */
    const formElement = document.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param cfg optional config literal
     */
    // eslint-disable-next-line complexity
    const _parseConfig = function _parseConfig() {
      let cfg =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE =
        // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1
          ? DEFAULT_PARSER_MEDIA_TYPE
          : cfg.PARSER_MEDIA_TYPE;
      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
      transformCaseFunc =
        PARSER_MEDIA_TYPE === "application/xhtml+xml"
          ? stringToString
          : stringToLowerCase;
      /* Set configuration parameters */
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS")
        ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc)
        : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR")
        ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc)
        : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES")
        ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString)
        : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR")
        ? addToSet(
            clone(DEFAULT_URI_SAFE_ATTRIBUTES),
            cfg.ADD_URI_SAFE_ATTR,
            transformCaseFunc
          )
        : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS")
        ? addToSet(
            clone(DEFAULT_DATA_URI_TAGS),
            cfg.ADD_DATA_URI_TAGS,
            transformCaseFunc
          )
        : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS")
        ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc)
        : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS")
        ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc)
        : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR")
        ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc)
        : {};
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES")
        ? cfg.USE_PROFILES
        : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS =
        cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS =
        cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (
        cfg.CUSTOM_ELEMENT_HANDLING &&
        isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)
      ) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck =
          cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (
        cfg.CUSTOM_ELEMENT_HANDLING &&
        isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)
      ) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck =
          cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (
        cfg.CUSTOM_ELEMENT_HANDLING &&
        typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements ===
          "boolean"
      ) {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements =
          cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate(
            'TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.'
          );
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate(
            'TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.'
          );
        }
        // Overwrite existing TrustedTypes policy.
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        // Sign local variables required by `sanitize`.
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        // Uninitialized policy, attempt to initialize the internal dompurify policy.
        if (trustedTypesPolicy === undefined) {
          trustedTypesPolicy = _createTrustedTypesPolicy(
            trustedTypes,
            currentScript
          );
        }
        // If creating the internal policy succeeded sign internal variables.
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    const ALL_SVG_TAGS = addToSet({}, [
      ...svg$1,
      ...svgFilters,
      ...svgDisallowed,
    ]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    /**
     * @param element a DOM element whose namespace is being checked
     * @returns Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    const _checkValidNamespace = function _checkValidNamespace(element) {
      let parent = getParentNode(element);
      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template",
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        // The only way to switch from MathML to SVG is via`
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return (
            tagName === "svg" &&
            (parentTagName === "annotation-xml" ||
              MATHML_TEXT_INTEGRATION_POINTS[parentTagName])
          );
        }
        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (
          parent.namespaceURI === SVG_NAMESPACE &&
          !HTML_INTEGRATION_POINTS[parentTagName]
        ) {
          return false;
        }
        if (
          parent.namespaceURI === MATHML_NAMESPACE &&
          !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]
        ) {
          return false;
        }
        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return (
          !ALL_MATHML_TAGS[tagName] &&
          (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName])
        );
      }
      // For XHTML and XML documents that support custom namespaces
      if (
        PARSER_MEDIA_TYPE === "application/xhtml+xml" &&
        ALLOWED_NAMESPACES[element.namespaceURI]
      ) {
        return true;
      }
      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
      // Return false just in case.
      return false;
    };
    /**
     * _forceRemove
     *
     * @param node a DOM node
     */
    const _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node,
      });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        getParentNode(node).removeChild(node);
      } catch (_) {
        remove(node);
      }
    };
    /**
     * _removeAttribute
     *
     * @param name an Attribute name
     * @param element a DOM node
     */
    const _removeAttribute = function _removeAttribute(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element,
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element,
        });
      }
      element.removeAttribute(name);
      // We void attribute values for unremovable "is" attributes
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_) {}
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param dirty - a string of dirty markup
     * @return a DOM, filled with the dirty markup
     */
    const _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (
        PARSER_MEDIA_TYPE === "application/xhtml+xml" &&
        NAMESPACE === HTML_NAMESPACE
      ) {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty =
          '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
          dirty +
          "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy
        ? trustedTypesPolicy.createHTML(dirty)
        : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(
            dirtyPayload,
            PARSER_MEDIA_TYPE
          );
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT
            ? emptyHTML
            : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(
          document.createTextNode(leadingWhitespace),
          body.childNodes[0] || null
        );
      }
      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(
          doc,
          WHOLE_DOCUMENT ? "html" : "body"
        )[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
     *
     * @param root The root element or node to start traversing on.
     * @return The created NodeIterator
     */
    const _createNodeIterator = function _createNodeIterator(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT |
          NodeFilter.SHOW_COMMENT |
          NodeFilter.SHOW_TEXT |
          NodeFilter.SHOW_PROCESSING_INSTRUCTION |
          NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    /**
     * _isClobbered
     *
     * @param element element to check for clobbering attacks
     * @return true if clobbered, false if safe
     */
    const _isClobbered = function _isClobbered(element) {
      return (
        element instanceof HTMLFormElement &&
        (typeof element.nodeName !== "string" ||
          typeof element.textContent !== "string" ||
          typeof element.removeChild !== "function" ||
          !(element.attributes instanceof NamedNodeMap) ||
          typeof element.removeAttribute !== "function" ||
          typeof element.setAttribute !== "function" ||
          typeof element.namespaceURI !== "string" ||
          typeof element.insertBefore !== "function" ||
          typeof element.hasChildNodes !== "function")
      );
    };
    /**
     * Checks whether the given object is a DOM node.
     *
     * @param value object to check whether it's a DOM node
     * @return true is object is a DOM node
     */
    const _isNode = function _isNode(value) {
      return typeof Node === "function" && value instanceof Node;
    };
    function _executeHooks(hooks, currentNode, data) {
      arrayForEach(hooks, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    }
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     * @param currentNode to check for permission to exist
     * @return true if node was killed, false if left alive
     */
    const _sanitizeElements = function _sanitizeElements(currentNode) {
      let content = null;
      /* Execute a hook if present */
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      /* Now let's check the element's type and name */
      const tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS,
      });
      /* Detect mXSS attempts abusing namespace confusion */
      if (
        currentNode.hasChildNodes() &&
        !_isNode(currentNode.firstElementChild) &&
        regExpTest(/<[/\w]/g, currentNode.innerHTML) &&
        regExpTest(/<[/\w]/g, currentNode.textContent)
      ) {
        _forceRemove(currentNode);
        return true;
      }
      /* Remove any occurrence of processing instructions */
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      /* Remove any kind of possibly harmful comments */
      if (
        SAFE_FOR_XML &&
        currentNode.nodeType === NODE_TYPE.comment &&
        regExpTest(/<[/\w]/g, currentNode.data)
      ) {
        _forceRemove(currentNode);
        return true;
      }
      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (
            CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&
            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)
          ) {
            return false;
          }
          if (
            CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&
            CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)
          ) {
            return false;
          }
        }
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode =
            getParentNode(currentNode) || currentNode.parentNode;
          const childNodes =
            getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              const childClone = cloneNode(childNodes[i], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      /* Check whether element has a valid namespace */
      if (
        currentNode instanceof Element &&
        !_checkValidNamespace(currentNode)
      ) {
        _forceRemove(currentNode);
        return true;
      }
      /* Make sure that older browsers don't get fallback-tag mXSS */
      if (
        (tagName === "noscript" ||
          tagName === "noembed" ||
          tagName === "noframes") &&
        regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)
      ) {
        _forceRemove(currentNode);
        return true;
      }
      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        /* Get the element's text content */
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode(),
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param lcTag Lowercase tag name of containing element.
     * @param lcName Lowercase attribute name.
     * @param value Attribute value.
     * @return Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (
        SANITIZE_DOM &&
        (lcName === "id" || lcName === "name") &&
        (value in document || value in formElement)
      ) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */
      if (
        ALLOW_DATA_ATTR &&
        !FORBID_ATTR[lcName] &&
        regExpTest(DATA_ATTR, lcName)
      );
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName));
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          (_isBasicCustomElement(lcTag) &&
            ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&
              regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag)) ||
              (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&
                CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))) &&
            ((CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp &&
              regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName)) ||
              (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function &&
                CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)))) ||
          // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          (lcName === "is" &&
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&
            ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&
              regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value)) ||
              (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&
                CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))
        );
        else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]);
      else if (
        regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ""))
      );
      else if (
        (lcName === "src" || lcName === "xlink:href" || lcName === "href") &&
        lcTag !== "script" &&
        stringIndexOf(value, "data:") === 0 &&
        DATA_URI_TAGS[lcTag]
      );
      else if (
        ALLOW_UNKNOWN_PROTOCOLS &&
        !regExpTest(
          IS_SCRIPT_OR_DATA,
          stringReplace(value, ATTR_WHITESPACE, "")
        )
      );
      else if (value) {
        return false;
      } else;
      return true;
    };
    /**
     * _isBasicCustomElement
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     *
     * @param tagName name of the tag of the node to sanitize
     * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
     */
    const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
      return (
        tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT)
      );
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param currentNode to sanitize
     */
    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      /* Execute a hook if present */
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const { attributes } = currentNode;
      /* Check if we have attributes; if not we might have a text node */
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: undefined,
      };
      let l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        const attr = attributes[l];
        const { name, namespaceURI, value: attrValue } = attr;
        const lcName = transformCaseFunc(name);
        let value = name === "value" ? attrValue : stringTrim(attrValue);
        const initValue = value;
        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode);
          // Prefix the value and later re-create the attribute with the sanitized value
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Work around a security issue with comments inside attributes */
        if (
          SAFE_FOR_XML &&
          regExpTest(/((--!?|])>)|<\/(style|title)/i, value)
        ) {
          _removeAttribute(name, currentNode);
          continue;
        }
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */
        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        /* Is `value` valid for this attribute? */
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        /* Handle attributes that require Trusted Types */
        if (
          trustedTypesPolicy &&
          typeof trustedTypes === "object" &&
          typeof trustedTypes.getAttributeType === "function"
        ) {
          if (namespaceURI);
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */
        if (value !== initValue) {
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify.removed);
            }
          } catch (_) {}
        }
      }
      /* Execute a hook if present */
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param fragment to iterate over recursively
     */
    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      /* Execute a hook if present */
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while ((shadowNode = shadowIterator.nextNode())) {
        /* Execute a hook if present */
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        /* Sanitize tags and elements */
        _sanitizeElements(shadowNode);
        /* Check attributes next */
        _sanitizeAttributes(shadowNode);
        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
      }
      /* Execute a hook if present */
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty) {
      let cfg =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      /* Stringify, in case dirty is an object */
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      /* Return dirty HTML if DOMPurify cannot run */
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */
      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate(
              "root node is forbidden and cannot be sanitized in-place"
            );
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (
          importedNode.nodeType === NODE_TYPE.element &&
          importedNode.nodeName === "BODY"
        ) {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (
          !RETURN_DOM &&
          !SAFE_FOR_TEMPLATES &&
          !WHOLE_DOCUMENT &&
          // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf("<") === -1
        ) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE
            ? trustedTypesPolicy.createHTML(dirty)
            : dirty;
        }
        /* Initialize the document to work on */
        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */
      while ((currentNode = nodeIterator.nextNode())) {
        /* Sanitize tags and elements */
        _sanitizeElements(currentNode);
        /* Check attributes next */
        _sanitizeAttributes(currentNode);
        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          /*
              AdoptNode() is not used because internal state is not reset
              (e.g. the past names map of a HTMLFormElement), this is safe
              in theory but we would rather not risk another attack vector.
              The state that is cloned by importNode() is explicitly defined
              by the specs.
            */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */
      if (
        WHOLE_DOCUMENT &&
        ALLOWED_TAGS["!doctype"] &&
        body.ownerDocument &&
        body.ownerDocument.doctype &&
        body.ownerDocument.doctype.name &&
        regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)
      ) {
        serializedHTML =
          "<!DOCTYPE " +
          body.ownerDocument.doctype.name +
          ">\n" +
          serializedHTML;
      }
      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE
        ? trustedTypesPolicy.createHTML(serializedHTML)
        : serializedHTML;
    };
    DOMPurify.setConfig = function () {
      let cfg =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function (entryPoint, hookFunction) {
      if (hookFunction !== undefined) {
        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1
          ? undefined
          : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function (entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function () {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();

  const each$4 = Tools.each,
    trim = Tools.trim;
  const queryParts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor",
  ];
  const DEFAULT_PORTS = {
    ftp: 21,
    http: 80,
    https: 443,
    mailto: 25,
  };
  const safeSvgDataUrlElements = ["img", "video"];
  const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
    if (isNonNullable(allowSvgDataUrls)) {
      return !allowSvgDataUrls;
    } else {
      return isNonNullable(tagName)
        ? !contains$2(safeSvgDataUrlElements, tagName)
        : true;
    }
  };
  const decodeUri = (encodedUri) => {
    try {
      return decodeURIComponent(encodedUri);
    } catch (_a) {
      return unescape(encodedUri);
    }
  };
  const isInvalidUri = (settings, uri, tagName) => {
    const decodedUri = decodeUri(uri).replace(/\s/g, "");
    if (settings.allow_script_urls) {
      return false;
    } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
      return true;
    } else if (settings.allow_html_data_urls) {
      return false;
    } else if (/^data:image\//i.test(decodedUri)) {
      return (
        blockSvgDataUris(settings.allow_svg_data_urls, tagName) &&
        /^data:image\/svg\+xml/i.test(decodedUri)
      );
    } else {
      return /^data:/i.test(decodedUri);
    }
  };
  class URI {
    static parseDataUri(uri) {
      let type;
      const uriComponents = decodeURIComponent(uri).split(",");
      const matches = /data:([^;]+)/.exec(uriComponents[0]);
      if (matches) {
        type = matches[1];
      }
      return {
        type,
        data: uriComponents[1],
      };
    }
    static isDomSafe(uri, context, options = {}) {
      if (options.allow_script_urls) {
        return true;
      } else {
        const decodedUri = Entities.decode(uri).replace(
          /[\s\u0000-\u001F]+/g,
          ""
        );
        return !isInvalidUri(options, decodedUri, context);
      }
    }
    static getDocumentBaseUrl(loc) {
      var _a;
      let baseUrl;
      if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
        baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : "";
      } else {
        baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
      }
      if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
        baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
        if (!/[\/\\]$/.test(baseUrl)) {
          baseUrl += "/";
        }
      }
      return baseUrl;
    }
    constructor(url, settings = {}) {
      this.path = "";
      this.directory = "";
      url = trim(url);
      this.settings = settings;
      const baseUri = settings.base_uri;
      const self = this;
      if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
        self.source = url;
        return;
      }
      const isProtocolRelative = url.indexOf("//") === 0;
      if (url.indexOf("/") === 0 && !isProtocolRelative) {
        url =
          (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url;
      }
      if (!/^[\w\-]*:?\/\//.test(url)) {
        const baseUrl = baseUri
          ? baseUri.path
          : new URI(document.location.href).directory;
        if (
          (baseUri === null || baseUri === void 0
            ? void 0
            : baseUri.protocol) === ""
        ) {
          url = "//mce_host" + self.toAbsPath(baseUrl, url);
        } else {
          const match = /([^#?]*)([#?]?.*)/.exec(url);
          if (match) {
            url =
              ((baseUri && baseUri.protocol) || "http") +
              "://mce_host" +
              self.toAbsPath(baseUrl, match[1]) +
              match[2];
          }
        }
      }
      url = url.replace(/@@/g, "(mce_at)");
      const urlMatch =
        /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(
          url
        );
      if (urlMatch) {
        each$4(queryParts, (v, i) => {
          let part = urlMatch[i];
          if (part) {
            part = part.replace(/\(mce_at\)/g, "@@");
          }
          self[v] = part;
        });
      }
      if (baseUri) {
        if (!self.protocol) {
          self.protocol = baseUri.protocol;
        }
        if (!self.userInfo) {
          self.userInfo = baseUri.userInfo;
        }
        if (!self.port && self.host === "mce_host") {
          self.port = baseUri.port;
        }
        if (!self.host || self.host === "mce_host") {
          self.host = baseUri.host;
        }
        self.source = "";
      }
      if (isProtocolRelative) {
        self.protocol = "";
      }
    }
    setPath(path) {
      const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
      if (pathMatch) {
        this.path = pathMatch[0];
        this.directory = pathMatch[1];
        this.file = pathMatch[2];
      }
      this.source = "";
      this.getURI();
    }
    toRelative(uri) {
      if (uri === "./") {
        return uri;
      }
      const relativeUri = new URI(uri, { base_uri: this });
      if (
        (relativeUri.host !== "mce_host" &&
          this.host !== relativeUri.host &&
          relativeUri.host) ||
        this.port !== relativeUri.port ||
        (this.protocol !== relativeUri.protocol && relativeUri.protocol !== "")
      ) {
        return relativeUri.getURI();
      }
      const tu = this.getURI(),
        uu = relativeUri.getURI();
      if (
        tu === uu ||
        (tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu)
      ) {
        return tu;
      }
      let output = this.toRelPath(this.path, relativeUri.path);
      if (relativeUri.query) {
        output += "?" + relativeUri.query;
      }
      if (relativeUri.anchor) {
        output += "#" + relativeUri.anchor;
      }
      return output;
    }
    toAbsolute(uri, noHost) {
      const absoluteUri = new URI(uri, { base_uri: this });
      return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
    }
    isSameOrigin(uri) {
      if (this.host == uri.host && this.protocol == uri.protocol) {
        if (this.port == uri.port) {
          return true;
        }
        const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
        if (
          defaultPort &&
          (this.port || defaultPort) == (uri.port || defaultPort)
        ) {
          return true;
        }
      }
      return false;
    }
    toRelPath(base, path) {
      let breakPoint = 0,
        out = "",
        i,
        l;
      const normalizedBase = base
        .substring(0, base.lastIndexOf("/"))
        .split("/");
      const items = path.split("/");
      if (normalizedBase.length >= items.length) {
        for (i = 0, l = normalizedBase.length; i < l; i++) {
          if (i >= items.length || normalizedBase[i] !== items[i]) {
            breakPoint = i + 1;
            break;
          }
        }
      }
      if (normalizedBase.length < items.length) {
        for (i = 0, l = items.length; i < l; i++) {
          if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
            breakPoint = i + 1;
            break;
          }
        }
      }
      if (breakPoint === 1) {
        return path;
      }
      for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
        out += "../";
      }
      for (i = breakPoint - 1, l = items.length; i < l; i++) {
        if (i !== breakPoint - 1) {
          out += "/" + items[i];
        } else {
          out += items[i];
        }
      }
      return out;
    }
    toAbsPath(base, path) {
      let nb = 0;
      const tr = /\/$/.test(path) ? "/" : "";
      const normalizedBase = base.split("/");
      const normalizedPath = path.split("/");
      const baseParts = [];
      each$4(normalizedBase, (k) => {
        if (k) {
          baseParts.push(k);
        }
      });
      const pathParts = [];
      for (let i = normalizedPath.length - 1; i >= 0; i--) {
        if (normalizedPath[i].length === 0 || normalizedPath[i] === ".") {
          continue;
        }
        if (normalizedPath[i] === "..") {
          nb++;
          continue;
        }
        if (nb > 0) {
          nb--;
          continue;
        }
        pathParts.push(normalizedPath[i]);
      }
      const i = baseParts.length - nb;
      let outPath;
      if (i <= 0) {
        outPath = reverse(pathParts).join("/");
      } else {
        outPath =
          baseParts.slice(0, i).join("/") + "/" + reverse(pathParts).join("/");
      }
      if (outPath.indexOf("/") !== 0) {
        outPath = "/" + outPath;
      }
      if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
        outPath += tr;
      }
      return outPath;
    }
    getURI(noProtoHost = false) {
      let s;
      if (!this.source || noProtoHost) {
        s = "";
        if (!noProtoHost) {
          if (this.protocol) {
            s += this.protocol + "://";
          } else {
            s += "//";
          }
          if (this.userInfo) {
            s += this.userInfo + "@";
          }
          if (this.host) {
            s += this.host;
          }
          if (this.port) {
            s += ":" + this.port;
          }
        }
        if (this.path) {
          s += this.path;
        }
        if (this.query) {
          s += "?" + this.query;
        }
        if (this.anchor) {
          s += "#" + this.anchor;
        }
        this.source = s;
      }
      return this.source;
    }
  }

  const filteredUrlAttrs = Tools.makeMap(
    "src,href,data,background,action,formaction,poster,xlink:href"
  );
  const internalElementAttr = "data-mce-type";
  let uid = 0;
  const processNode = (node, settings, schema, scope, evt) => {
    var _a, _b, _c, _d;
    const validate = settings.validate;
    const specialElements = schema.getSpecialElements();
    if (
      node.nodeType === COMMENT &&
      !settings.allow_conditional_comments &&
      /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : "")
    ) {
      node.nodeValue = " " + node.nodeValue;
    }
    const lcTagName =
      (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null &&
      _b !== void 0
        ? _b
        : node.nodeName.toLowerCase();
    if (scope !== "html" && schema.isValid(scope)) {
      if (isNonNullable(evt)) {
        evt.allowedTags[lcTagName] = true;
      }
      return;
    }
    if (node.nodeType !== ELEMENT || lcTagName === "body") {
      return;
    }
    const element = SugarElement.fromDom(node);
    const isInternalElement = has$1(element, internalElementAttr);
    const bogus = get$9(element, "data-mce-bogus");
    if (!isInternalElement && isString(bogus)) {
      if (bogus === "all") {
        remove$4(element);
      } else {
        unwrap(element);
      }
      return;
    }
    const rule = schema.getElementRule(lcTagName);
    if (validate && !rule) {
      if (has$2(specialElements, lcTagName)) {
        remove$4(element);
      } else {
        unwrap(element);
      }
      return;
    } else {
      if (isNonNullable(evt)) {
        evt.allowedTags[lcTagName] = true;
      }
    }
    if (validate && rule && !isInternalElement) {
      each$e(
        (_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [],
        (attr) => {
          set$4(
            element,
            attr.name,
            attr.value === "{$uid}" ? `mce_${uid++}` : attr.value
          );
        }
      );
      each$e(
        (_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [],
        (attr) => {
          if (!has$1(element, attr.name)) {
            set$4(
              element,
              attr.name,
              attr.value === "{$uid}" ? `mce_${uid++}` : attr.value
            );
          }
        }
      );
      if (
        rule.attributesRequired &&
        !exists(rule.attributesRequired, (attr) => has$1(element, attr))
      ) {
        unwrap(element);
        return;
      }
      if (rule.removeEmptyAttrs && hasNone(element)) {
        unwrap(element);
        return;
      }
      if (rule.outputName && rule.outputName !== lcTagName) {
        mutate(element, rule.outputName);
      }
    }
  };
  const processAttr = (ele, settings, schema, scope, evt) => {
    const tagName = ele.tagName.toLowerCase();
    const { attrName, attrValue } = evt;
    evt.keepAttr = shouldKeepAttribute(
      settings,
      schema,
      scope,
      tagName,
      attrName,
      attrValue
    );
    if (evt.keepAttr) {
      evt.allowedAttributes[attrName] = true;
      if (isBooleanAttribute(attrName, schema)) {
        evt.attrValue = attrName;
      }
      if (
        settings.allow_svg_data_urls &&
        startsWith(attrValue, "data:image/svg+xml")
      ) {
        evt.forceKeepAttr = true;
      }
    } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
      evt.forceKeepAttr = true;
    }
  };
  const shouldKeepAttribute = (
    settings,
    schema,
    scope,
    tagName,
    attrName,
    attrValue
  ) => {
    if (scope !== "html" && !isNonHtmlElementRootName(tagName)) {
      return true;
    }
    return (
      !(
        attrName in filteredUrlAttrs &&
        isInvalidUri(settings, attrValue, tagName)
      ) &&
      (!settings.validate ||
        schema.isValid(tagName, attrName) ||
        startsWith(attrName, "data-") ||
        startsWith(attrName, "aria-"))
    );
  };
  const isRequiredAttributeOfInternalElement = (ele, attrName) =>
    ele.hasAttribute(internalElementAttr) &&
    (attrName === "id" || attrName === "class" || attrName === "style");
  const isBooleanAttribute = (attrName, schema) =>
    attrName in schema.getBoolAttrs();
  const filterAttributes = (ele, settings, schema, scope) => {
    const { attributes } = ele;
    for (let i = attributes.length - 1; i >= 0; i--) {
      const attr = attributes[i];
      const attrName = attr.name;
      const attrValue = attr.value;
      if (
        !shouldKeepAttribute(
          settings,
          schema,
          scope,
          ele.tagName.toLowerCase(),
          attrName,
          attrValue
        ) &&
        !isRequiredAttributeOfInternalElement(ele, attrName)
      ) {
        ele.removeAttribute(attrName);
      } else if (isBooleanAttribute(attrName, schema)) {
        ele.setAttribute(attrName, attrName);
      }
    }
  };
  const setupPurify = (settings, schema, namespaceTracker) => {
    const purify$1 = purify();
    purify$1.addHook("uponSanitizeElement", (ele, evt) => {
      processNode(ele, settings, schema, namespaceTracker.track(ele), evt);
    });
    purify$1.addHook("uponSanitizeAttribute", (ele, evt) => {
      processAttr(ele, settings, schema, namespaceTracker.current(), evt);
    });
    return purify$1;
  };
  const getPurifyConfig = (settings, mimeType) => {
    const basePurifyConfig = {
      IN_PLACE: true,
      ALLOW_UNKNOWN_PROTOCOLS: true,
      ALLOWED_TAGS: ["#comment", "#cdata-section", "body"],
      ALLOWED_ATTR: [],
      SAFE_FOR_XML: false,
    };
    const config = { ...basePurifyConfig };
    config.PARSER_MEDIA_TYPE = mimeType;
    if (settings.allow_script_urls) {
      config.ALLOWED_URI_REGEXP = /.*/;
    } else if (settings.allow_html_data_urls) {
      config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
    }
    return config;
  };
  const sanitizeSvgElement = (ele) => {
    const xlinkAttrs = [
      "type",
      "href",
      "role",
      "arcrole",
      "title",
      "show",
      "actuate",
      "label",
      "from",
      "to",
    ].map((name) => `xlink:${name}`);
    const config = {
      IN_PLACE: true,
      USE_PROFILES: {
        html: true,
        svg: true,
        svgFilters: true,
      },
      ALLOWED_ATTR: xlinkAttrs,
    };
    purify().sanitize(ele, config);
  };
  const sanitizeMathmlElement = (node, settings) => {
    const config = {
      IN_PLACE: true,
      USE_PROFILES: { mathMl: true },
    };
    const purify$1 = purify();
    const allowedEncodings = settings.allow_mathml_annotation_encodings;
    const hasAllowedEncodings =
      isArray$1(allowedEncodings) && allowedEncodings.length > 0;
    const hasValidEncoding = (el) => {
      const encoding = el.getAttribute("encoding");
      return (
        hasAllowedEncodings &&
        isString(encoding) &&
        contains$2(allowedEncodings, encoding)
      );
    };
    purify$1.addHook("uponSanitizeElement", (node, evt) => {
      var _a;
      const lcTagName =
        (_a = evt.tagName) !== null && _a !== void 0
          ? _a
          : node.nodeName.toLowerCase();
      if (hasAllowedEncodings && lcTagName === "semantics") {
        evt.allowedTags[lcTagName] = true;
      }
      if (lcTagName === "annotation") {
        const elm = node;
        const keepElement = hasValidEncoding(elm);
        evt.allowedTags[lcTagName] = keepElement;
        if (!keepElement) {
          elm.remove();
        }
      }
    });
    purify$1.sanitize(node, config);
  };
  const mkSanitizeNamespaceElement = (settings) => (ele) => {
    const namespaceType = toScopeType(ele);
    if (namespaceType === "svg") {
      sanitizeSvgElement(ele);
    } else if (namespaceType === "math") {
      sanitizeMathmlElement(ele, settings);
    } else {
      throw new Error("Not a namespace element");
    }
  };
  const getSanitizer = (settings, schema) => {
    const namespaceTracker = createNamespaceTracker();
    if (settings.sanitize) {
      const purify = setupPurify(settings, schema, namespaceTracker);
      const sanitizeHtmlElement = (body, mimeType) => {
        purify.sanitize(body, getPurifyConfig(settings, mimeType));
        purify.removed = [];
        namespaceTracker.reset();
      };
      return {
        sanitizeHtmlElement,
        sanitizeNamespaceElement: mkSanitizeNamespaceElement(settings),
      };
    } else {
      const sanitizeHtmlElement = (body, _mimeType) => {
        const nodeIterator = document.createNodeIterator(
          body,
          NodeFilter.SHOW_ELEMENT |
            NodeFilter.SHOW_COMMENT |
            NodeFilter.SHOW_TEXT
        );
        let node;
        while ((node = nodeIterator.nextNode())) {
          const currentScope = namespaceTracker.track(node);
          processNode(node, settings, schema, currentScope);
          if (isElement$6(node)) {
            filterAttributes(node, settings, schema, currentScope);
          }
        }
        namespaceTracker.reset();
      };
      const sanitizeNamespaceElement = noop;
      return {
        sanitizeHtmlElement,
        sanitizeNamespaceElement,
      };
    }
  };

  const makeMap = Tools.makeMap,
    extend$1 = Tools.extend;
  const transferChildren = (
    parent,
    nativeParent,
    specialElements,
    nsSanitizer
  ) => {
    const parentName = parent.name;
    const isSpecial =
      parentName in specialElements &&
      parentName !== "title" &&
      parentName !== "textarea" &&
      parentName !== "noscript";
    const childNodes = nativeParent.childNodes;
    for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
      const nativeChild = childNodes[ni];
      const child = new AstNode(
        nativeChild.nodeName.toLowerCase(),
        nativeChild.nodeType
      );
      if (isElement$6(nativeChild)) {
        const attributes = nativeChild.attributes;
        for (let ai = 0, al = attributes.length; ai < al; ai++) {
          const attr = attributes[ai];
          child.attr(attr.name, attr.value);
        }
        if (isNonHtmlElementRootName(child.name)) {
          nsSanitizer(nativeChild);
          child.value = nativeChild.innerHTML;
        }
      } else if (isText$b(nativeChild)) {
        child.value = nativeChild.data;
        if (isSpecial) {
          child.raw = true;
        }
      } else if (
        isComment(nativeChild) ||
        isCData(nativeChild) ||
        isPi(nativeChild)
      ) {
        child.value = nativeChild.data;
      }
      if (!isNonHtmlElementRootName(child.name)) {
        transferChildren(child, nativeChild, specialElements, nsSanitizer);
      }
      parent.append(child);
    }
  };
  const walkTree = (root, preprocessors, postprocessors) => {
    const traverseOrder = [];
    for (
      let node = root, lastNode = node;
      node;
      lastNode = node, node = node.walk()
    ) {
      const tempNode = node;
      each$e(preprocessors, (preprocess) => preprocess(tempNode));
      if (isNullable(tempNode.parent) && tempNode !== root) {
        node = lastNode;
      } else {
        traverseOrder.push(tempNode);
      }
    }
    for (let i = traverseOrder.length - 1; i >= 0; i--) {
      const node = traverseOrder[i];
      each$e(postprocessors, (postprocess) => postprocess(node));
    }
  };
  const whitespaceCleaner = (root, schema, settings, args) => {
    const validate = settings.validate;
    const nonEmptyElements = schema.getNonEmptyElements();
    const whitespaceElements = schema.getWhitespaceElements();
    const blockElements = extend$1(
      makeMap("script,style,head,html,body,title,meta,param"),
      schema.getBlockElements()
    );
    const textRootBlockElements = getTextRootBlockElements(schema);
    const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
    const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
    const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
    const hasWhitespaceParent = (node) => {
      let tempNode = node.parent;
      while (isNonNullable(tempNode)) {
        if (tempNode.name in whitespaceElements) {
          return true;
        } else {
          tempNode = tempNode.parent;
        }
      }
      return false;
    };
    const isTextRootBlockEmpty = (node) => {
      let tempNode = node;
      while (isNonNullable(tempNode)) {
        if (tempNode.name in textRootBlockElements) {
          return isEmpty(
            schema,
            nonEmptyElements,
            whitespaceElements,
            tempNode
          );
        } else {
          tempNode = tempNode.parent;
        }
      }
      return false;
    };
    const isBlock = (node) =>
      node.name in blockElements ||
      isTransparentAstBlock(schema, node) ||
      (isNonHtmlElementRootName(node.name) && node.parent === root);
    const isAtEdgeOfBlock = (node, start) => {
      const neighbour = start ? node.prev : node.next;
      if (isNonNullable(neighbour) || isNullable(node.parent)) {
        return false;
      }
      return (
        isBlock(node.parent) &&
        (node.parent !== root || args.isRootContent === true)
      );
    };
    const preprocess = (node) => {
      var _a;
      if (node.type === 3) {
        if (!hasWhitespaceParent(node)) {
          let text = (_a = node.value) !== null && _a !== void 0 ? _a : "";
          text = text.replace(allWhiteSpaceRegExp, " ");
          if (
            isLineBreakNode(node.prev, isBlock) ||
            isAtEdgeOfBlock(node, true)
          ) {
            text = text.replace(startWhiteSpaceRegExp, "");
          }
          if (text.length === 0) {
            node.remove();
          } else if (
            text === " " &&
            node.prev &&
            node.prev.type === COMMENT &&
            node.next &&
            node.next.type === COMMENT
          ) {
            node.remove();
          } else {
            node.value = text;
          }
        }
      }
    };
    const postprocess = (node) => {
      var _a;
      if (node.type === 1) {
        const elementRule = schema.getElementRule(node.name);
        if (validate && elementRule) {
          const isNodeEmpty = isEmpty(
            schema,
            nonEmptyElements,
            whitespaceElements,
            node
          );
          if (
            elementRule.paddInEmptyBlock &&
            isNodeEmpty &&
            isTextRootBlockEmpty(node)
          ) {
            paddEmptyNode(settings, args, isBlock, node);
          } else if (elementRule.removeEmpty && isNodeEmpty) {
            if (isBlock(node)) {
              node.remove();
            } else {
              node.unwrap();
            }
          } else if (
            elementRule.paddEmpty &&
            (isNodeEmpty || isPaddedWithNbsp(node))
          ) {
            paddEmptyNode(settings, args, isBlock, node);
          }
        }
      } else if (node.type === 3) {
        if (!hasWhitespaceParent(node)) {
          let text = (_a = node.value) !== null && _a !== void 0 ? _a : "";
          if (
            (node.next && isBlock(node.next)) ||
            isAtEdgeOfBlock(node, false)
          ) {
            text = text.replace(endWhiteSpaceRegExp, "");
          }
          if (text.length === 0) {
            node.remove();
          } else {
            node.value = text;
          }
        }
      }
    };
    return [preprocess, postprocess];
  };
  const getRootBlockName = (settings, args) => {
    var _a;
    const name =
      (_a = args.forced_root_block) !== null && _a !== void 0
        ? _a
        : settings.forced_root_block;
    if (name === false) {
      return "";
    } else if (name === true) {
      return "p";
    } else {
      return name;
    }
  };
  const DomParser = (settings = {}, schema = Schema()) => {
    const nodeFilterRegistry = create$8();
    const attributeFilterRegistry = create$8();
    const defaultedSettings = {
      validate: true,
      root_name: "body",
      sanitize: true,
      ...settings,
    };
    const parser = new DOMParser();
    const sanitizer = getSanitizer(defaultedSettings, schema);
    const parseAndSanitizeWithContext = (html, rootName, format = "html") => {
      const mimeType =
        format === "xhtml" ? "application/xhtml+xml" : "text/html";
      const isSpecialRoot = has$2(
        schema.getSpecialElements(),
        rootName.toLowerCase()
      );
      const content = isSpecialRoot
        ? `<${rootName}>${html}</${rootName}>`
        : html;
      const makeWrap = () => {
        if (format === "xhtml") {
          return `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${content}</body></html>`;
        } else if (
          /^[\s]*<head/i.test(html) ||
          /^[\s]*<html/i.test(html) ||
          /^[\s]*<!DOCTYPE/i.test(html)
        ) {
          return `<html>${content}</html>`;
        } else {
          return `<body>${content}</body>`;
        }
      };
      const body = parser.parseFromString(makeWrap(), mimeType).body;
      sanitizer.sanitizeHtmlElement(body, mimeType);
      return isSpecialRoot ? body.firstChild : body;
    };
    const addNodeFilter = nodeFilterRegistry.addFilter;
    const getNodeFilters = nodeFilterRegistry.getFilters;
    const removeNodeFilter = nodeFilterRegistry.removeFilter;
    const addAttributeFilter = attributeFilterRegistry.addFilter;
    const getAttributeFilters = attributeFilterRegistry.getFilters;
    const removeAttributeFilter = attributeFilterRegistry.removeFilter;
    const findInvalidChildren = (node, invalidChildren) => {
      if (isInvalid(schema, node)) {
        invalidChildren.push(node);
      }
    };
    const isWrappableNode = (blockElements, node) => {
      const isInternalElement = isString(node.attr(internalElementAttr));
      const isInlineElement =
        node.type === 1 &&
        !has$2(blockElements, node.name) &&
        !isTransparentAstBlock(schema, node) &&
        !isNonHtmlElementRootName(node.name);
      return node.type === 3 || (isInlineElement && !isInternalElement);
    };
    const addRootBlocks = (rootNode, rootBlockName) => {
      const blockElements = extend$1(
        makeMap("script,style,head,html,body,title,meta,param"),
        schema.getBlockElements()
      );
      const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
      const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
      let node = rootNode.firstChild,
        rootBlockNode = null;
      const trim = (rootBlock) => {
        var _a, _b;
        if (rootBlock) {
          node = rootBlock.firstChild;
          if (node && node.type === 3) {
            node.value =
              (_a = node.value) === null || _a === void 0
                ? void 0
                : _a.replace(startWhiteSpaceRegExp, "");
          }
          node = rootBlock.lastChild;
          if (node && node.type === 3) {
            node.value =
              (_b = node.value) === null || _b === void 0
                ? void 0
                : _b.replace(endWhiteSpaceRegExp, "");
          }
        }
      };
      if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
        return;
      }
      while (node) {
        const next = node.next;
        if (isWrappableNode(blockElements, node)) {
          if (!rootBlockNode) {
            rootBlockNode = new AstNode(rootBlockName, 1);
            rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
            rootNode.insert(rootBlockNode, node);
            rootBlockNode.append(node);
          } else {
            rootBlockNode.append(node);
          }
        } else {
          trim(rootBlockNode);
          rootBlockNode = null;
        }
        node = next;
      }
      trim(rootBlockNode);
    };
    const parse = (html, args = {}) => {
      var _a;
      const validate = defaultedSettings.validate;
      const rootName =
        (_a = args.context) !== null && _a !== void 0
          ? _a
          : defaultedSettings.root_name;
      const element = parseAndSanitizeWithContext(html, rootName, args.format);
      updateChildren(schema, element);
      const rootNode = new AstNode(rootName, 11);
      transferChildren(
        rootNode,
        element,
        schema.getSpecialElements(),
        sanitizer.sanitizeNamespaceElement
      );
      element.innerHTML = "";
      const [whitespacePre, whitespacePost] = whitespaceCleaner(
        rootNode,
        schema,
        defaultedSettings,
        args
      );
      const invalidChildren = [];
      const invalidFinder = validate
        ? (node) => findInvalidChildren(node, invalidChildren)
        : noop;
      const matches = {
        nodes: {},
        attributes: {},
      };
      const matchFinder = (node) =>
        matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
      walkTree(
        rootNode,
        [whitespacePre, matchFinder],
        [whitespacePost, invalidFinder]
      );
      invalidChildren.reverse();
      if (validate && invalidChildren.length > 0) {
        if (args.context) {
          const { pass: topLevelChildren, fail: otherChildren } = partition$2(
            invalidChildren,
            (child) => child.parent === rootNode
          );
          cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
          args.invalid = topLevelChildren.length > 0;
        } else {
          cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
        }
      }
      const rootBlockName = getRootBlockName(defaultedSettings, args);
      if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
        addRootBlocks(rootNode, rootBlockName);
      }
      if (!args.invalid) {
        runFilters(matches, args);
      }
      return rootNode;
    };
    const exports = {
      schema,
      addAttributeFilter,
      getAttributeFilters,
      removeAttributeFilter,
      addNodeFilter,
      getNodeFilters,
      removeNodeFilter,
      parse,
    };
    register$4(exports, defaultedSettings);
    register$5(exports, defaultedSettings, schema);
    return exports;
  };

  const serializeContent = (content) =>
    isTreeNode(content)
      ? HtmlSerializer({ validate: false }).serialize(content)
      : content;
  const withSerializedContent = (content, fireEvent, parserSettings) => {
    const serializedContent = serializeContent(content);
    const eventArgs = fireEvent(serializedContent);
    if (eventArgs.isDefaultPrevented()) {
      return eventArgs;
    } else if (isTreeNode(content)) {
      if (eventArgs.content !== serializedContent) {
        const rootNode = DomParser({
          validate: false,
          forced_root_block: false,
          ...parserSettings,
        }).parse(eventArgs.content, { context: content.name });
        return {
          ...eventArgs,
          content: rootNode,
        };
      } else {
        return {
          ...eventArgs,
          content,
        };
      }
    } else {
      return eventArgs;
    }
  };
  const makeParserSettings = (editor) => ({
    sanitize: shouldSanitizeXss(editor),
    sandbox_iframes: shouldSandboxIframes(editor),
    sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
  });
  const preProcessGetContent = (editor, args) => {
    if (args.no_events) {
      return Result.value(args);
    } else {
      const eventArgs = fireBeforeGetContent(editor, args);
      if (eventArgs.isDefaultPrevented()) {
        return Result.error(
          fireGetContent(editor, {
            content: "",
            ...eventArgs,
          }).content
        );
      } else {
        return Result.value(eventArgs);
      }
    }
  };
  const postProcessGetContent = (editor, content, args) => {
    if (args.no_events) {
      return content;
    } else {
      const processedEventArgs = withSerializedContent(
        content,
        (content) =>
          fireGetContent(editor, {
            ...args,
            content,
          }),
        makeParserSettings(editor)
      );
      return processedEventArgs.content;
    }
  };
  const preProcessSetContent = (editor, args) => {
    if (args.no_events) {
      return Result.value(args);
    } else {
      const processedEventArgs = withSerializedContent(
        args.content,
        (content) =>
          fireBeforeSetContent(editor, {
            ...args,
            content,
          }),
        makeParserSettings(editor)
      );
      if (processedEventArgs.isDefaultPrevented()) {
        fireSetContent(editor, processedEventArgs);
        return Result.error(undefined);
      } else {
        return Result.value(processedEventArgs);
      }
    }
  };
  const postProcessSetContent = (editor, content, args) => {
    if (!args.no_events) {
      fireSetContent(editor, {
        ...args,
        content,
      });
    }
  };

  const tableModel = (element, width, rows) => ({
    element,
    width,
    rows,
  });
  const tableRow = (element, cells) => ({
    element,
    cells,
  });
  const cellPosition = (x, y) => ({
    x,
    y,
  });
  const getSpan = (td, key) => {
    return getOpt(td, key).bind(toInt).getOr(1);
  };
  const fillout = (table, x, y, tr, td) => {
    const rowspan = getSpan(td, "rowspan");
    const colspan = getSpan(td, "colspan");
    const rows = table.rows;
    for (let y2 = y; y2 < y + rowspan; y2++) {
      if (!rows[y2]) {
        rows[y2] = tableRow(deep$1(tr), []);
      }
      for (let x2 = x; x2 < x + colspan; x2++) {
        const cells = rows[y2].cells;
        cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);
      }
    }
  };
  const cellExists = (table, x, y) => {
    const rows = table.rows;
    const cells = rows[y] ? rows[y].cells : [];
    return !!cells[x];
  };
  const skipCellsX = (table, x, y) => {
    while (cellExists(table, x, y)) {
      x++;
    }
    return x;
  };
  const getWidth = (rows) => {
    return foldl(
      rows,
      (acc, row) => {
        return row.cells.length > acc ? row.cells.length : acc;
      },
      0
    );
  };
  const findElementPos = (table, element) => {
    const rows = table.rows;
    for (let y = 0; y < rows.length; y++) {
      const cells = rows[y].cells;
      for (let x = 0; x < cells.length; x++) {
        if (eq(cells[x], element)) {
          return Optional.some(cellPosition(x, y));
        }
      }
    }
    return Optional.none();
  };
  const extractRows = (table, sx, sy, ex, ey) => {
    const newRows = [];
    const rows = table.rows;
    for (let y = sy; y <= ey; y++) {
      const cells = rows[y].cells;
      const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
      newRows.push(tableRow(rows[y].element, slice));
    }
    return newRows;
  };
  const subTable = (table, startPos, endPos) => {
    const sx = startPos.x,
      sy = startPos.y;
    const ex = endPos.x,
      ey = endPos.y;
    const newRows =
      sy < ey
        ? extractRows(table, sx, sy, ex, ey)
        : extractRows(table, sx, ey, ex, sy);
    return tableModel(table.element, getWidth(newRows), newRows);
  };
  const createDomTable = (table, rows) => {
    const tableElement = shallow$1(table.element);
    const tableBody = SugarElement.fromTag("tbody");
    append(tableBody, rows);
    append$1(tableElement, tableBody);
    return tableElement;
  };
  const modelRowsToDomRows = (table) => {
    return map$3(table.rows, (row) => {
      const cells = map$3(row.cells, (cell) => {
        const td = deep$1(cell);
        remove$9(td, "colspan");
        remove$9(td, "rowspan");
        return td;
      });
      const tr = shallow$1(row.element);
      append(tr, cells);
      return tr;
    });
  };
  const fromDom = (tableElm) => {
    const table = tableModel(shallow$1(tableElm), 0, []);
    each$e(descendants(tableElm, "tr"), (tr, y) => {
      each$e(descendants(tr, "td,th"), (td, x) => {
        fillout(table, skipCellsX(table, x, y), y, tr, td);
      });
    });
    return tableModel(table.element, getWidth(table.rows), table.rows);
  };
  const toDom = (table) => {
    return createDomTable(table, modelRowsToDomRows(table));
  };
  const subsection = (table, startElement, endElement) => {
    return findElementPos(table, startElement).bind((startPos) => {
      return findElementPos(table, endElement).map((endPos) => {
        return subTable(table, startPos, endPos);
      });
    });
  };

  const findParentListContainer = (parents) =>
    find$2(parents, (elm) => name(elm) === "ul" || name(elm) === "ol");
  const getFullySelectedListWrappers = (parents, rng) =>
    find$2(
      parents,
      (elm) => name(elm) === "li" && hasAllContentsSelected(elm, rng)
    ).fold(constant([]), (_li) =>
      findParentListContainer(parents)
        .map((listCont) => {
          const listElm = SugarElement.fromTag(name(listCont));
          const listStyles = filter$4(getAllRaw(listCont), (_style, name) =>
            startsWith(name, "list-style")
          );
          setAll(listElm, listStyles);
          return [SugarElement.fromTag("li"), listElm];
        })
        .getOr([])
    );
  const wrap = (innerElm, elms) => {
    const wrapped = foldl(
      elms,
      (acc, elm) => {
        append$1(elm, acc);
        return elm;
      },
      innerElm
    );
    return elms.length > 0 ? fromElements([wrapped]) : wrapped;
  };
  const directListWrappers = (commonAnchorContainer) => {
    if (isListItem$1(commonAnchorContainer)) {
      return parent(commonAnchorContainer)
        .filter(isList)
        .fold(constant([]), (listElm) => [commonAnchorContainer, listElm]);
    } else {
      return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
    }
  };
  const getWrapElements = (rootNode, rng, schema) => {
    const commonAnchorContainer = SugarElement.fromDom(
      rng.commonAncestorContainer
    );
    const parents = parentsAndSelf(commonAnchorContainer, rootNode);
    const wrapElements = filter$5(parents, (el) => schema.isWrapper(name(el)));
    const listWrappers = getFullySelectedListWrappers(parents, rng);
    const allWrappers = wrapElements.concat(
      listWrappers.length
        ? listWrappers
        : directListWrappers(commonAnchorContainer)
    );
    return map$3(allWrappers, shallow$1);
  };
  const emptyFragment = () => fromElements([]);
  const getFragmentFromRange = (rootNode, rng, schema) =>
    wrap(
      SugarElement.fromDom(rng.cloneContents()),
      getWrapElements(rootNode, rng, schema)
    );
  const getParentTable = (rootElm, cell) =>
    ancestor$3(cell, "table", curry(eq, rootElm));
  const getTableFragment = (rootNode, selectedTableCells) =>
    getParentTable(rootNode, selectedTableCells[0])
      .bind((tableElm) => {
        const firstCell = selectedTableCells[0];
        const lastCell = selectedTableCells[selectedTableCells.length - 1];
        const fullTableModel = fromDom(tableElm);
        return subsection(fullTableModel, firstCell, lastCell).map(
          (sectionedTableModel) => fromElements([toDom(sectionedTableModel)])
        );
      })
      .getOrThunk(emptyFragment);
  const getSelectionFragment = (rootNode, ranges, schema) =>
    ranges.length > 0 && ranges[0].collapsed
      ? emptyFragment()
      : getFragmentFromRange(rootNode, ranges[0], schema);
  const read$3 = (rootNode, ranges, schema) => {
    const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
    return selectedCells.length > 0
      ? getTableFragment(rootNode, selectedCells)
      : getSelectionFragment(rootNode, ranges, schema);
  };

  const isCollapsibleWhitespace = (text, index) =>
    index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));
  const getInnerText = (bin) => {
    return trim$2(bin.innerText);
  };
  const getContextNodeName = (parentBlockOpt) =>
    parentBlockOpt
      .map((block) => block.nodeName)
      .getOr("div")
      .toLowerCase();
  const getTextContent = (editor) =>
    Optional.from(editor.selection.getRng())
      .map((rng) => {
        var _a;
        const parentBlockOpt = Optional.from(
          editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock)
        );
        const body = editor.getBody();
        const contextNodeName = getContextNodeName(parentBlockOpt);
        const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
        cleanupBogusElements(rangeContentClone);
        cleanupInputNames(rangeContentClone);
        const bin = editor.dom.add(
          body,
          contextNodeName,
          {
            "data-mce-bogus": "all",
            style: "overflow: hidden; opacity: 0;",
          },
          rangeContentClone.dom
        );
        const text = getInnerText(bin);
        const nonRenderedText = trim$2(
          (_a = bin.textContent) !== null && _a !== void 0 ? _a : ""
        );
        editor.dom.remove(bin);
        if (
          isCollapsibleWhitespace(nonRenderedText, 0) ||
          isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)
        ) {
          const parentBlock = parentBlockOpt.getOr(body);
          const parentBlockText = getInnerText(parentBlock);
          const textIndex = parentBlockText.indexOf(text);
          if (textIndex === -1) {
            return text;
          } else {
            const hasProceedingSpace = isCollapsibleWhitespace(
              parentBlockText,
              textIndex - 1
            );
            const hasTrailingSpace = isCollapsibleWhitespace(
              parentBlockText,
              textIndex + text.length
            );
            return (
              (hasProceedingSpace ? " " : "") +
              text +
              (hasTrailingSpace ? " " : "")
            );
          }
        } else {
          return text;
        }
      })
      .getOr("");
  const getSerializedContent = (editor, args) => {
    const rng = editor.selection.getRng(),
      tmpElm = editor.dom.create("body");
    const sel = editor.selection.getSel();
    const ranges = processRanges(editor, getRanges$1(sel));
    const fragment = args.contextual
      ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema)
          .dom
      : rng.cloneContents();
    if (fragment) {
      tmpElm.appendChild(fragment);
    }
    return editor.selection.serializer.serialize(tmpElm, args);
  };
  const extractSelectedContent = (editor, args) => {
    if (args.format === "text") {
      return getTextContent(editor);
    } else {
      const content = getSerializedContent(editor, args);
      if (args.format === "tree") {
        return content;
      } else {
        return editor.selection.isCollapsed() ? "" : content;
      }
    }
  };
  const setupArgs$3 = (args, format) => ({
    ...args,
    format,
    get: true,
    selection: true,
    getInner: true,
  });
  const getSelectedContentInternal = (editor, format, args = {}) => {
    const defaultedArgs = setupArgs$3(args, format);
    return preProcessGetContent(editor, defaultedArgs).fold(
      identity,
      (updatedArgs) => {
        const content = extractSelectedContent(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      }
    );
  };

  const KEEP = 0,
    INSERT = 1,
    DELETE = 2;
  const diff = (left, right) => {
    const size = left.length + right.length + 2;
    const vDown = new Array(size);
    const vUp = new Array(size);
    const snake = (start, end, diag) => {
      return {
        start,
        end,
        diag,
      };
    };
    const buildScript = (start1, end1, start2, end2, script) => {
      const middle = getMiddleSnake(start1, end1, start2, end2);
      if (
        middle === null ||
        (middle.start === end1 && middle.diag === end1 - end2) ||
        (middle.end === start1 && middle.diag === start1 - start2)
      ) {
        let i = start1;
        let j = start2;
        while (i < end1 || j < end2) {
          if (i < end1 && j < end2 && left[i] === right[j]) {
            script.push([KEEP, left[i]]);
            ++i;
            ++j;
          } else {
            if (end1 - start1 > end2 - start2) {
              script.push([DELETE, left[i]]);
              ++i;
            } else {
              script.push([INSERT, right[j]]);
              ++j;
            }
          }
        }
      } else {
        buildScript(
          start1,
          middle.start,
          start2,
          middle.start - middle.diag,
          script
        );
        for (let i2 = middle.start; i2 < middle.end; ++i2) {
          script.push([KEEP, left[i2]]);
        }
        buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
      }
    };
    const buildSnake = (start, diag, end1, end2) => {
      let end = start;
      while (
        end - diag < end2 &&
        end < end1 &&
        left[end] === right[end - diag]
      ) {
        ++end;
      }
      return snake(start, end, diag);
    };
    const getMiddleSnake = (start1, end1, start2, end2) => {
      const m = end1 - start1;
      const n = end2 - start2;
      if (m === 0 || n === 0) {
        return null;
      }
      const delta = m - n;
      const sum = n + m;
      const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
      vDown[1 + offset] = start1;
      vUp[1 + offset] = end1 + 1;
      let d, k, i, x, y;
      for (d = 0; d <= offset; ++d) {
        for (k = -d; k <= d; k += 2) {
          i = k + offset;
          if (k === -d || (k !== d && vDown[i - 1] < vDown[i + 1])) {
            vDown[i] = vDown[i + 1];
          } else {
            vDown[i] = vDown[i - 1] + 1;
          }
          x = vDown[i];
          y = x - start1 + start2 - k;
          while (x < end1 && y < end2 && left[x] === right[y]) {
            vDown[i] = ++x;
            ++y;
          }
          if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
            if (vUp[i - delta] <= vDown[i]) {
              return buildSnake(
                vUp[i - delta],
                k + start1 - start2,
                end1,
                end2
              );
            }
          }
        }
        for (k = delta - d; k <= delta + d; k += 2) {
          i = k + offset - delta;
          if (
            k === delta - d ||
            (k !== delta + d && vUp[i + 1] <= vUp[i - 1])
          ) {
            vUp[i] = vUp[i + 1] - 1;
          } else {
            vUp[i] = vUp[i - 1];
          }
          x = vUp[i] - 1;
          y = x - start1 + start2 - k;
          while (x >= start1 && y >= start2 && left[x] === right[y]) {
            vUp[i] = x--;
            y--;
          }
          if (delta % 2 === 0 && -d <= k && k <= d) {
            if (vUp[i] <= vDown[i + delta]) {
              return buildSnake(vUp[i], k + start1 - start2, end1, end2);
            }
          }
        }
      }
      return null;
    };
    const script = [];
    buildScript(0, left.length, 0, right.length, script);
    return script;
  };

  const getOuterHtml = (elm) => {
    if (isElement$6(elm)) {
      return elm.outerHTML;
    } else if (isText$b(elm)) {
      return Entities.encodeRaw(elm.data, false);
    } else if (isComment(elm)) {
      return "<!--" + elm.data + "-->";
    }
    return "";
  };
  const createFragment = (html) => {
    let node;
    const container = document.createElement("div");
    const frag = document.createDocumentFragment();
    if (html) {
      container.innerHTML = html;
    }
    while ((node = container.firstChild)) {
      frag.appendChild(node);
    }
    return frag;
  };
  const insertAt = (elm, html, index) => {
    const fragment = createFragment(html);
    if (elm.hasChildNodes() && index < elm.childNodes.length) {
      const target = elm.childNodes[index];
      elm.insertBefore(fragment, target);
    } else {
      elm.appendChild(fragment);
    }
  };
  const removeAt = (elm, index) => {
    if (elm.hasChildNodes() && index < elm.childNodes.length) {
      const target = elm.childNodes[index];
      elm.removeChild(target);
    }
  };
  const applyDiff = (diff, elm) => {
    let index = 0;
    each$e(diff, (action) => {
      if (action[0] === KEEP) {
        index++;
      } else if (action[0] === INSERT) {
        insertAt(elm, action[1], index);
        index++;
      } else if (action[0] === DELETE) {
        removeAt(elm, index);
      }
    });
  };
  const read$2 = (elm, trimZwsp) =>
    filter$5(
      map$3(
        from(elm.childNodes),
        trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml
      ),
      (item) => {
        return item.length > 0;
      }
    );
  const write = (fragments, elm) => {
    const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
    applyDiff(diff(currentFragments, fragments), elm);
    return elm;
  };

  const lazyTempDocument = cached(() =>
    document.implementation.createHTMLDocument("undo")
  );
  const hasIframes = (body) => body.querySelector("iframe") !== null;
  const createFragmentedLevel = (fragments) => {
    return {
      type: "fragmented",
      fragments,
      content: "",
      bookmark: null,
      beforeBookmark: null,
    };
  };
  const createCompleteLevel = (content) => {
    return {
      type: "complete",
      fragments: null,
      content,
      bookmark: null,
      beforeBookmark: null,
    };
  };
  const createFromEditor = (editor) => {
    const tempAttrs = editor.serializer.getTempAttrs();
    const body = trim$1(editor.getBody(), tempAttrs);
    return hasIframes(body)
      ? createFragmentedLevel(read$2(body, true))
      : createCompleteLevel(trim$2(body.innerHTML));
  };
  const applyToEditor = (editor, level, before) => {
    const bookmark = before ? level.beforeBookmark : level.bookmark;
    if (level.type === "fragmented") {
      write(level.fragments, editor.getBody());
    } else {
      editor.setContent(level.content, {
        format: "raw",
        no_selection:
          isNonNullable(bookmark) && isPathBookmark(bookmark)
            ? !bookmark.isFakeCaret
            : true,
      });
    }
    if (bookmark) {
      editor.selection.moveToBookmark(bookmark);
      editor.selection.scrollIntoView();
    }
  };
  const getLevelContent = (level) => {
    return level.type === "fragmented"
      ? level.fragments.join("")
      : level.content;
  };
  const getCleanLevelContent = (level) => {
    const elm = SugarElement.fromTag("body", lazyTempDocument());
    set$1(elm, getLevelContent(level));
    each$e(descendants(elm, "*[data-mce-bogus]"), unwrap);
    return get$6(elm);
  };
  const hasEqualContent = (level1, level2) =>
    getLevelContent(level1) === getLevelContent(level2);
  const hasEqualCleanedContent = (level1, level2) =>
    getCleanLevelContent(level1) === getCleanLevelContent(level2);
  const isEq$1 = (level1, level2) => {
    if (!level1 || !level2) {
      return false;
    } else if (hasEqualContent(level1, level2)) {
      return true;
    } else {
      return hasEqualCleanedContent(level1, level2);
    }
  };

  const isUnlocked = (locks) => locks.get() === 0;

  const setTyping = (undoManager, typing, locks) => {
    if (isUnlocked(locks)) {
      undoManager.typing = typing;
    }
  };
  const endTyping = (undoManager, locks) => {
    if (undoManager.typing) {
      setTyping(undoManager, false, locks);
      undoManager.add();
    }
  };
  const endTypingLevelIgnoreLocks = (undoManager) => {
    if (undoManager.typing) {
      undoManager.typing = false;
      undoManager.add();
    }
  };

  const beforeChange$1 = (editor, locks, beforeBookmark) => {
    if (isUnlocked(locks)) {
      beforeBookmark.set(getUndoBookmark(editor.selection));
    }
  };
  const addUndoLevel$1 = (
    editor,
    undoManager,
    index,
    locks,
    beforeBookmark,
    level,
    event
  ) => {
    const currentLevel = createFromEditor(editor);
    const newLevel = Tools.extend(level || {}, currentLevel);
    if (!isUnlocked(locks) || editor.removed) {
      return null;
    }
    const lastLevel = undoManager.data[index.get()];
    if (
      editor
        .dispatch("BeforeAddUndo", {
          level: newLevel,
          lastLevel,
          originalEvent: event,
        })
        .isDefaultPrevented()
    ) {
      return null;
    }
    if (lastLevel && isEq$1(lastLevel, newLevel)) {
      return null;
    }
    if (undoManager.data[index.get()]) {
      beforeBookmark.get().each((bm) => {
        undoManager.data[index.get()].beforeBookmark = bm;
      });
    }
    const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
    if (customUndoRedoLevels) {
      if (undoManager.data.length > customUndoRedoLevels) {
        for (let i = 0; i < undoManager.data.length - 1; i++) {
          undoManager.data[i] = undoManager.data[i + 1];
        }
        undoManager.data.length--;
        index.set(undoManager.data.length);
      }
    }
    newLevel.bookmark = getUndoBookmark(editor.selection);
    if (index.get() < undoManager.data.length - 1) {
      undoManager.data.length = index.get() + 1;
    }
    undoManager.data.push(newLevel);
    index.set(undoManager.data.length - 1);
    const args = {
      level: newLevel,
      lastLevel,
      originalEvent: event,
    };
    if (index.get() > 0) {
      editor.setDirty(true);
      editor.dispatch("AddUndo", args);
      editor.dispatch("change", args);
    } else {
      editor.dispatch("AddUndo", args);
    }
    return newLevel;
  };
  const clear$1 = (editor, undoManager, index) => {
    undoManager.data = [];
    index.set(0);
    undoManager.typing = false;
    editor.dispatch("ClearUndos");
  };
  const extra$1 = (editor, undoManager, index, callback1, callback2) => {
    if (undoManager.transact(callback1)) {
      const bookmark = undoManager.data[index.get()].bookmark;
      const lastLevel = undoManager.data[index.get() - 1];
      applyToEditor(editor, lastLevel, true);
      if (undoManager.transact(callback2)) {
        undoManager.data[index.get() - 1].beforeBookmark = bookmark;
      }
    }
  };
  const redo$1 = (editor, index, data) => {
    let level;
    if (index.get() < data.length - 1) {
      index.set(index.get() + 1);
      level = data[index.get()];
      applyToEditor(editor, level, false);
      editor.setDirty(true);
      editor.dispatch("Redo", { level });
    }
    return level;
  };
  const undo$1 = (editor, undoManager, locks, index) => {
    let level;
    if (undoManager.typing) {
      undoManager.add();
      undoManager.typing = false;
      setTyping(undoManager, false, locks);
    }
    if (index.get() > 0) {
      index.set(index.get() - 1);
      level = undoManager.data[index.get()];
      applyToEditor(editor, level, true);
      editor.setDirty(true);
      editor.dispatch("Undo", { level });
    }
    return level;
  };
  const reset$1 = (undoManager) => {
    undoManager.clear();
    undoManager.add();
  };
  const hasUndo$1 = (editor, undoManager, index) =>
    index.get() > 0 ||
    (undoManager.typing &&
      undoManager.data[0] &&
      !isEq$1(createFromEditor(editor), undoManager.data[0]));
  const hasRedo$1 = (undoManager, index) =>
    index.get() < undoManager.data.length - 1 && !undoManager.typing;
  const transact$1 = (undoManager, locks, callback) => {
    endTyping(undoManager, locks);
    undoManager.beforeChange();
    undoManager.ignore(callback);
    return undoManager.add();
  };
  const ignore$1 = (locks, callback) => {
    try {
      locks.set(locks.get() + 1);
      callback();
    } finally {
      locks.set(locks.get() - 1);
    }
  };

  const addVisualInternal = (editor, elm) => {
    const dom = editor.dom;
    const scope = isNonNullable(elm) ? elm : editor.getBody();
    each$e(dom.select("table,a", scope), (matchedElm) => {
      switch (matchedElm.nodeName) {
        case "TABLE":
          const cls = getVisualAidsTableClass(editor);
          const value = dom.getAttrib(matchedElm, "border");
          if ((!value || value === "0") && editor.hasVisual) {
            dom.addClass(matchedElm, cls);
          } else {
            dom.removeClass(matchedElm, cls);
          }
          break;
        case "A":
          if (!dom.getAttrib(matchedElm, "href")) {
            const value = dom.getAttrib(matchedElm, "name") || matchedElm.id;
            const cls = getVisualAidsAnchorClass(editor);
            if (value && editor.hasVisual) {
              dom.addClass(matchedElm, cls);
            } else {
              dom.removeClass(matchedElm, cls);
            }
          }
          break;
      }
    });
    editor.dispatch("VisualAid", {
      element: elm,
      hasVisual: editor.hasVisual,
    });
  };

  const makePlainAdaptor = (editor) => ({
    init: { bindEvents: noop },
    undoManager: {
      beforeChange: (locks, beforeBookmark) =>
        beforeChange$1(editor, locks, beforeBookmark),
      add: (undoManager, index, locks, beforeBookmark, level, event) =>
        addUndoLevel$1(
          editor,
          undoManager,
          index,
          locks,
          beforeBookmark,
          level,
          event
        ),
      undo: (undoManager, locks, index) =>
        undo$1(editor, undoManager, locks, index),
      redo: (index, data) => redo$1(editor, index, data),
      clear: (undoManager, index) => clear$1(editor, undoManager, index),
      reset: (undoManager) => reset$1(undoManager),
      hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
      hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
      transact: (undoManager, locks, callback) =>
        transact$1(undoManager, locks, callback),
      ignore: (locks, callback) => ignore$1(locks, callback),
      extra: (undoManager, index, callback1, callback2) =>
        extra$1(editor, undoManager, index, callback1, callback2),
    },
    formatter: {
      match: (name, vars, node, similar) =>
        match$2(editor, name, vars, node, similar),
      matchAll: (names, vars) => matchAll(editor, names, vars),
      matchNode: (node, name, vars, similar) =>
        matchNode(editor, node, name, vars, similar),
      canApply: (name) => canApply(editor, name),
      closest: (names) => closest(editor, names),
      apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),
      remove: (name, vars, node, similar) =>
        removeFormat$1(editor, name, vars, node, similar),
      toggle: (name, vars, node) => toggle(editor, name, vars, node),
      formatChanged: (
        registeredFormatListeners,
        formats,
        callback,
        similar,
        vars
      ) =>
        formatChangedInternal(
          editor,
          registeredFormatListeners,
          formats,
          callback,
          similar,
          vars
        ),
    },
    editor: {
      getContent: (args) => getContentInternal(editor, args),
      setContent: (content, args) => setContentInternal(editor, content, args),
      insertContent: (value, details) =>
        insertHtmlAtCaret(editor, value, details),
      addVisual: (elm) => addVisualInternal(editor, elm),
    },
    selection: {
      getContent: (format, args) =>
        getSelectedContentInternal(editor, format, args),
    },
    autocompleter: {
      addDecoration: noop,
      removeDecoration: noop,
    },
    raw: { getModel: () => Optional.none() },
  });
  const makeRtcAdaptor = (rtcEditor) => {
    const defaultVars = (vars) => (isObject(vars) ? vars : {});
    const {
      init,
      undoManager,
      formatter,
      editor,
      selection,
      autocompleter,
      raw,
    } = rtcEditor;
    return {
      init: { bindEvents: init.bindEvents },
      undoManager: {
        beforeChange: undoManager.beforeChange,
        add: undoManager.add,
        undo: undoManager.undo,
        redo: undoManager.redo,
        clear: undoManager.clear,
        reset: undoManager.reset,
        hasUndo: undoManager.hasUndo,
        hasRedo: undoManager.hasRedo,
        transact: (_undoManager, _locks, fn) => undoManager.transact(fn),
        ignore: (_locks, callback) => undoManager.ignore(callback),
        extra: (_undoManager, _index, callback1, callback2) =>
          undoManager.extra(callback1, callback2),
      },
      formatter: {
        match: (name, vars, _node, similar) =>
          formatter.match(name, defaultVars(vars), similar),
        matchAll: formatter.matchAll,
        matchNode: formatter.matchNode,
        canApply: (name) => formatter.canApply(name),
        closest: (names) => formatter.closest(names),
        apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),
        remove: (name, vars, _node, _similar) =>
          formatter.remove(name, defaultVars(vars)),
        toggle: (name, vars, _node) =>
          formatter.toggle(name, defaultVars(vars)),
        formatChanged: (_rfl, formats, callback, similar, vars) =>
          formatter.formatChanged(formats, callback, similar, vars),
      },
      editor: {
        getContent: (args) => editor.getContent(args),
        setContent: (content, args) => {
          return {
            content: editor.setContent(content, args),
            html: "",
          };
        },
        insertContent: (content, _details) => {
          editor.insertContent(content);
          return "";
        },
        addVisual: editor.addVisual,
      },
      selection: { getContent: (_format, args) => selection.getContent(args) },
      autocompleter: {
        addDecoration: autocompleter.addDecoration,
        removeDecoration: autocompleter.removeDecoration,
      },
      raw: { getModel: () => Optional.some(raw.getRawModel()) },
    };
  };
  const makeNoopAdaptor = () => {
    const nul = constant(null);
    const empty = constant("");
    return {
      init: { bindEvents: noop },
      undoManager: {
        beforeChange: noop,
        add: nul,
        undo: nul,
        redo: nul,
        clear: noop,
        reset: noop,
        hasUndo: never,
        hasRedo: never,
        transact: nul,
        ignore: noop,
        extra: noop,
      },
      formatter: {
        match: never,
        matchAll: constant([]),
        matchNode: constant(undefined),
        canApply: never,
        closest: empty,
        apply: noop,
        remove: noop,
        toggle: noop,
        formatChanged: constant({ unbind: noop }),
      },
      editor: {
        getContent: empty,
        setContent: constant({
          content: "",
          html: "",
        }),
        insertContent: constant(""),
        addVisual: noop,
      },
      selection: { getContent: empty },
      autocompleter: {
        addDecoration: noop,
        removeDecoration: noop,
      },
      raw: { getModel: constant(Optional.none()) },
    };
  };
  const isRtc = (editor) => has$2(editor.plugins, "rtc");
  const getRtcSetup = (editor) =>
    get$a(editor.plugins, "rtc").bind((rtcPlugin) =>
      Optional.from(rtcPlugin.setup)
    );
  const setup$t = (editor) => {
    const editorCast = editor;
    return getRtcSetup(editor).fold(
      () => {
        editorCast.rtcInstance = makePlainAdaptor(editor);
        return Optional.none();
      },
      (setup) => {
        editorCast.rtcInstance = makeNoopAdaptor();
        return Optional.some(() =>
          setup().then((rtcEditor) => {
            editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
            return rtcEditor.rtc.isRemote;
          })
        );
      }
    );
  };
  const getRtcInstanceWithFallback = (editor) =>
    editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
  const getRtcInstanceWithError = (editor) => {
    const rtcInstance = editor.rtcInstance;
    if (!rtcInstance) {
      throw new Error("Failed to get RTC instance not yet initialized.");
    } else {
      return rtcInstance;
    }
  };
  const beforeChange = (editor, locks, beforeBookmark) => {
    getRtcInstanceWithError(editor).undoManager.beforeChange(
      locks,
      beforeBookmark
    );
  };
  const addUndoLevel = (
    editor,
    undoManager,
    index,
    locks,
    beforeBookmark,
    level,
    event
  ) =>
    getRtcInstanceWithError(editor).undoManager.add(
      undoManager,
      index,
      locks,
      beforeBookmark,
      level,
      event
    );
  const undo = (editor, undoManager, locks, index) =>
    getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
  const redo = (editor, index, data) =>
    getRtcInstanceWithError(editor).undoManager.redo(index, data);
  const clear = (editor, undoManager, index) => {
    getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
  };
  const reset = (editor, undoManager) => {
    getRtcInstanceWithError(editor).undoManager.reset(undoManager);
  };
  const hasUndo = (editor, undoManager, index) =>
    getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
  const hasRedo = (editor, undoManager, index) =>
    getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
  const transact = (editor, undoManager, locks, callback) =>
    getRtcInstanceWithError(editor).undoManager.transact(
      undoManager,
      locks,
      callback
    );
  const ignore = (editor, locks, callback) => {
    getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
  };
  const extra = (editor, undoManager, index, callback1, callback2) => {
    getRtcInstanceWithError(editor).undoManager.extra(
      undoManager,
      index,
      callback1,
      callback2
    );
  };
  const matchFormat = (editor, name, vars, node, similar) =>
    getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);
  const matchAllFormats = (editor, names, vars) =>
    getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
  const matchNodeFormat = (editor, node, name, vars, similar) =>
    getRtcInstanceWithError(editor).formatter.matchNode(
      node,
      name,
      vars,
      similar
    );
  const canApplyFormat = (editor, name) =>
    getRtcInstanceWithError(editor).formatter.canApply(name);
  const closestFormat = (editor, names) =>
    getRtcInstanceWithError(editor).formatter.closest(names);
  const applyFormat = (editor, name, vars, node) => {
    getRtcInstanceWithError(editor).formatter.apply(name, vars, node);
  };
  const removeFormat = (editor, name, vars, node, similar) => {
    getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);
  };
  const toggleFormat = (editor, name, vars, node) => {
    getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);
  };
  const formatChanged = (
    editor,
    registeredFormatListeners,
    formats,
    callback,
    similar,
    vars
  ) =>
    getRtcInstanceWithError(editor).formatter.formatChanged(
      registeredFormatListeners,
      formats,
      callback,
      similar,
      vars
    );
  const getContent$2 = (editor, args) =>
    getRtcInstanceWithFallback(editor).editor.getContent(args);
  const setContent$2 = (editor, content, args) =>
    getRtcInstanceWithFallback(editor).editor.setContent(content, args);
  const insertContent$1 = (editor, value, details) =>
    getRtcInstanceWithFallback(editor).editor.insertContent(value, details);
  const getSelectedContent = (editor, format, args) =>
    getRtcInstanceWithError(editor).selection.getContent(format, args);
  const addVisual$1 = (editor, elm) =>
    getRtcInstanceWithError(editor).editor.addVisual(elm);
  const bindEvents = (editor) =>
    getRtcInstanceWithError(editor).init.bindEvents();

  const getContent$1 = (editor, args = {}) => {
    const format = args.format ? args.format : "html";
    return getSelectedContent(editor, format, args);
  };

  const removeEmpty = (text) => {
    if (text.dom.length === 0) {
      remove$4(text);
      return Optional.none();
    } else {
      return Optional.some(text);
    }
  };
  const walkPastBookmark = (node, start) =>
    node
      .filter((elm) => BookmarkManager.isBookmarkNode(elm.dom))
      .bind(start ? nextSibling : prevSibling);
  const merge$1 = (outer, inner, rng, start, schema) => {
    const outerElm = outer.dom;
    const innerElm = inner.dom;
    const oldLength = start ? outerElm.length : innerElm.length;
    if (start) {
      mergeTextNodes(outerElm, innerElm, schema, false, !start);
      rng.setStart(innerElm, oldLength);
    } else {
      mergeTextNodes(innerElm, outerElm, schema, false, !start);
      rng.setEnd(innerElm, oldLength);
    }
  };
  const normalizeTextIfRequired = (inner, start, schema) => {
    parent(inner).each((root) => {
      const text = inner.dom;
      if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {
        normalizeWhitespaceAfter(text, 0, schema);
      } else if (
        !start &&
        needsToBeNbspRight(root, CaretPosition(text, text.length), schema)
      ) {
        normalizeWhitespaceBefore(text, text.length, schema);
      }
    });
  };
  const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {
    outerNode
      .bind((outer) => {
        const normalizer = start
          ? normalizeWhitespaceBefore
          : normalizeWhitespaceAfter;
        normalizer(outer.dom, start ? outer.dom.length : 0, schema);
        return innerNode
          .filter(isText$c)
          .map((inner) => merge$1(outer, inner, rng, start, schema));
      })
      .orThunk(() => {
        const innerTextNode = walkPastBookmark(innerNode, start)
          .or(innerNode)
          .filter(isText$c);
        return innerTextNode.map((inner) =>
          normalizeTextIfRequired(inner, start, schema)
        );
      });
  };
  const rngSetContent = (rng, fragment, schema) => {
    const firstChild = Optional.from(fragment.firstChild).map(
      SugarElement.fromDom
    );
    const lastChild = Optional.from(fragment.lastChild).map(
      SugarElement.fromDom
    );
    rng.deleteContents();
    rng.insertNode(fragment);
    const prevText = firstChild
      .bind(prevSibling)
      .filter(isText$c)
      .bind(removeEmpty);
    const nextText = lastChild
      .bind(nextSibling)
      .filter(isText$c)
      .bind(removeEmpty);
    mergeAndNormalizeText(prevText, firstChild, rng, true, schema);
    mergeAndNormalizeText(nextText, lastChild, rng, false, schema);
    rng.collapse(false);
  };
  const setupArgs$2 = (args, content) => ({
    format: "html",
    ...args,
    set: true,
    selection: true,
    content,
  });
  const cleanContent = (editor, args) => {
    if (args.format !== "raw") {
      const rng = editor.selection.getRng();
      const contextBlock = editor.dom.getParent(
        rng.commonAncestorContainer,
        editor.dom.isBlock
      );
      const contextArgs = contextBlock
        ? { context: contextBlock.nodeName.toLowerCase() }
        : {};
      const node = editor.parser.parse(args.content, {
        forced_root_block: false,
        ...contextArgs,
        ...args,
      });
      return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
    } else {
      return args.content;
    }
  };
  const setContent$1 = (editor, content, args = {}) => {
    const defaultedArgs = setupArgs$2(args, content);
    preProcessSetContent(editor, defaultedArgs).each((updatedArgs) => {
      const cleanedContent = cleanContent(editor, updatedArgs);
      const rng = editor.selection.getRng();
      rngSetContent(
        rng,
        rng.createContextualFragment(cleanedContent),
        editor.schema
      );
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
      postProcessSetContent(editor, cleanedContent, updatedArgs);
    });
  };

  const deleteFromCallbackMap = (callbackMap, selector, callback) => {
    if (has$2(callbackMap, selector)) {
      const newCallbacks = filter$5(
        callbackMap[selector],
        (cb) => cb !== callback
      );
      if (newCallbacks.length === 0) {
        delete callbackMap[selector];
      } else {
        callbackMap[selector] = newCallbacks;
      }
    }
  };
  var SelectorChanged = (dom, editor) => {
    let selectorChangedData;
    let currentSelectors;
    const findMatchingNode = (selector, nodes) =>
      find$2(nodes, (node) => dom.is(node, selector));
    const getParents = (elem) => dom.getParents(elem, undefined, dom.getRoot());
    const setup = () => {
      selectorChangedData = {};
      currentSelectors = {};
      editor.on("NodeChange", (e) => {
        const node = e.element;
        const parents = getParents(node);
        const matchedSelectors = {};
        each$d(selectorChangedData, (callbacks, selector) => {
          findMatchingNode(selector, parents).each((node) => {
            if (!currentSelectors[selector]) {
              each$e(callbacks, (callback) => {
                callback(true, {
                  node,
                  selector,
                  parents,
                });
              });
              currentSelectors[selector] = callbacks;
            }
            matchedSelectors[selector] = callbacks;
          });
        });
        each$d(currentSelectors, (callbacks, selector) => {
          if (!matchedSelectors[selector]) {
            delete currentSelectors[selector];
            each$e(callbacks, (callback) => {
              callback(false, {
                node,
                selector,
                parents,
              });
            });
          }
        });
      });
    };
    return {
      selectorChangedWithUnbind: (selector, callback) => {
        if (!selectorChangedData) {
          setup();
        }
        if (!selectorChangedData[selector]) {
          selectorChangedData[selector] = [];
        }
        selectorChangedData[selector].push(callback);
        findMatchingNode(
          selector,
          getParents(editor.selection.getStart())
        ).each(() => {
          currentSelectors[selector] = selectorChangedData[selector];
        });
        return {
          unbind: () => {
            deleteFromCallbackMap(selectorChangedData, selector, callback);
            deleteFromCallbackMap(currentSelectors, selector, callback);
          },
        };
      },
    };
  };

  const isAttachedToDom = (node) => {
    return (
      !!(node && node.ownerDocument) &&
      contains(
        SugarElement.fromDom(node.ownerDocument),
        SugarElement.fromDom(node)
      )
    );
  };
  const isValidRange = (rng) => {
    if (!rng) {
      return false;
    } else {
      return (
        isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer)
      );
    }
  };
  const EditorSelection = (dom, win, serializer, editor) => {
    let selectedRange;
    let explicitRange;
    const { selectorChangedWithUnbind } = SelectorChanged(dom, editor);
    const setCursorLocation = (node, offset) => {
      const rng = dom.createRng();
      if (isNonNullable(node) && isNonNullable(offset)) {
        rng.setStart(node, offset);
        rng.setEnd(node, offset);
        setRng(rng);
        collapse(false);
      } else {
        moveEndPoint(dom, rng, editor.getBody(), true);
        setRng(rng);
      }
    };
    const getContent = (args) => getContent$1(editor, args);
    const setContent = (content, args) => setContent$1(editor, content, args);
    const getStart$1 = (real) => getStart(editor.getBody(), getRng$1(), real);
    const getEnd$1 = (real) => getEnd(editor.getBody(), getRng$1(), real);
    const getBookmark = (type, normalized) =>
      bookmarkManager.getBookmark(type, normalized);
    const moveToBookmark = (bookmark) =>
      bookmarkManager.moveToBookmark(bookmark);
    const select$1 = (node, content) => {
      select(dom, node, content).each(setRng);
      return node;
    };
    const isCollapsed = () => {
      const rng = getRng$1(),
        sel = getSel();
      if (!rng || rng.item) {
        return false;
      }
      if (rng.compareEndPoints) {
        return rng.compareEndPoints("StartToEnd", rng) === 0;
      }
      return !sel || rng.collapsed;
    };
    const isEditable = () => {
      if (editor.mode.isReadOnly()) {
        return false;
      }
      const rng = getRng$1();
      const fakeSelectedElements = editor
        .getBody()
        .querySelectorAll('[data-mce-selected="1"]');
      if (fakeSelectedElements.length > 0) {
        return forall(fakeSelectedElements, (el) =>
          dom.isEditable(el.parentElement)
        );
      } else {
        return isEditableRange(dom, rng);
      }
    };
    const collapse = (toStart) => {
      const rng = getRng$1();
      rng.collapse(!!toStart);
      setRng(rng);
    };
    const getSel = () =>
      win.getSelection ? win.getSelection() : win.document.selection;
    const getRng$1 = () => {
      let rng;
      const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
        try {
          return sourceRange.compareBoundaryPoints(how, destinationRange);
        } catch (_a) {
          return -1;
        }
      };
      const doc = win.document;
      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
        const bookmark = getRng(editor);
        if (bookmark.isSome()) {
          return bookmark
            .map((r) => processRanges(editor, [r])[0])
            .getOr(doc.createRange());
        }
      }
      try {
        const selection = getSel();
        if (selection && !isRestrictedNode(selection.anchorNode)) {
          if (selection.rangeCount > 0) {
            rng = selection.getRangeAt(0);
          } else {
            rng = doc.createRange();
          }
          rng = processRanges(editor, [rng])[0];
        }
      } catch (_a) {}
      if (!rng) {
        rng = doc.createRange();
      }
      if (isDocument$1(rng.startContainer) && rng.collapsed) {
        const elm = dom.getRoot();
        rng.setStart(elm, 0);
        rng.setEnd(elm, 0);
      }
      if (selectedRange && explicitRange) {
        if (
          tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) ===
            0 &&
          tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0
        ) {
          rng = explicitRange;
        } else {
          selectedRange = null;
          explicitRange = null;
        }
      }
      return rng;
    };
    const setRng = (rng, forward) => {
      if (!isValidRange(rng)) {
        return;
      }
      const sel = getSel();
      const evt = editor.dispatch("SetSelectionRange", {
        range: rng,
        forward,
      });
      rng = evt.range;
      if (sel) {
        explicitRange = rng;
        try {
          sel.removeAllRanges();
          sel.addRange(rng);
        } catch (_a) {}
        if (forward === false && sel.extend) {
          sel.collapse(rng.endContainer, rng.endOffset);
          sel.extend(rng.startContainer, rng.startOffset);
        }
        selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
      }
      if (
        !rng.collapsed &&
        rng.startContainer === rng.endContainer &&
        (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)
      ) {
        if (rng.endOffset - rng.startOffset < 2) {
          if (rng.startContainer.hasChildNodes()) {
            const node = rng.startContainer.childNodes[rng.startOffset];
            if (node && node.nodeName === "IMG") {
              sel.setBaseAndExtent(
                rng.startContainer,
                rng.startOffset,
                rng.endContainer,
                rng.endOffset
              );
              if (
                sel.anchorNode !== rng.startContainer ||
                sel.focusNode !== rng.endContainer
              ) {
                sel.setBaseAndExtent(node, 0, node, 1);
              }
            }
          }
        }
      }
      editor.dispatch("AfterSetSelectionRange", {
        range: rng,
        forward,
      });
    };
    const setNode = (elm) => {
      setContent(dom.getOuterHTML(elm));
      return elm;
    };
    const getNode$1 = () => getNode(editor.getBody(), getRng$1());
    const getSelectedBlocks$1 = (startElm, endElm) =>
      getSelectedBlocks(dom, getRng$1(), startElm, endElm);
    const isForward = () => {
      const sel = getSel();
      const anchorNode =
        sel === null || sel === void 0 ? void 0 : sel.anchorNode;
      const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
      if (
        !sel ||
        !anchorNode ||
        !focusNode ||
        isRestrictedNode(anchorNode) ||
        isRestrictedNode(focusNode)
      ) {
        return true;
      }
      const anchorRange = dom.createRng();
      const focusRange = dom.createRng();
      try {
        anchorRange.setStart(anchorNode, sel.anchorOffset);
        anchorRange.collapse(true);
        focusRange.setStart(focusNode, sel.focusOffset);
        focusRange.collapse(true);
      } catch (_a) {
        return true;
      }
      return (
        anchorRange.compareBoundaryPoints(
          anchorRange.START_TO_START,
          focusRange
        ) <= 0
      );
    };
    const normalize = () => {
      const rng = getRng$1();
      const sel = getSel();
      if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
        const normRng = normalize$2(dom, rng);
        normRng.each((normRng) => {
          setRng(normRng, isForward());
        });
        return normRng.getOr(rng);
      }
      return rng;
    };
    const selectorChanged = (selector, callback) => {
      selectorChangedWithUnbind(selector, callback);
      return exports;
    };
    const getScrollContainer = () => {
      let scrollContainer;
      let node = dom.getRoot();
      while (node && node.nodeName !== "BODY") {
        if (node.scrollHeight > node.clientHeight) {
          scrollContainer = node;
          break;
        }
        node = node.parentNode;
      }
      return scrollContainer;
    };
    const scrollIntoView = (elm, alignToTop) => {
      if (isNonNullable(elm)) {
        scrollElementIntoView(editor, elm, alignToTop);
      } else {
        scrollRangeIntoView(editor, getRng$1(), alignToTop);
      }
    };
    const placeCaretAt = (clientX, clientY) =>
      setRng(fromPoint(clientX, clientY, editor.getDoc()));
    const getBoundingClientRect = () => {
      const rng = getRng$1();
      return rng.collapsed
        ? CaretPosition.fromRangeStart(rng).getClientRects()[0]
        : rng.getBoundingClientRect();
    };
    const destroy = () => {
      win = selectedRange = explicitRange = null;
      controlSelection.destroy();
    };
    const expand = (options = { type: "word" }) =>
      setRng(RangeUtils(dom).expand(getRng$1(), options));
    const exports = {
      dom,
      win,
      serializer,
      editor,
      expand,
      collapse,
      setCursorLocation,
      getContent,
      setContent,
      getBookmark,
      moveToBookmark,
      select: select$1,
      isCollapsed,
      isEditable,
      isForward,
      setNode,
      getNode: getNode$1,
      getSel,
      setRng,
      getRng: getRng$1,
      getStart: getStart$1,
      getEnd: getEnd$1,
      getSelectedBlocks: getSelectedBlocks$1,
      normalize,
      selectorChanged,
      selectorChangedWithUnbind,
      getScrollContainer,
      scrollIntoView,
      placeCaretAt,
      getBoundingClientRect,
      destroy,
    };
    const bookmarkManager = BookmarkManager(exports);
    const controlSelection = ControlSelection(exports, editor);
    exports.bookmarkManager = bookmarkManager;
    exports.controlSelection = controlSelection;
    return exports;
  };

  const addNodeFilter = (settings, htmlParser, schema) => {
    htmlParser.addNodeFilter("br", (nodes, _, args) => {
      const blockElements = Tools.extend({}, schema.getBlockElements());
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      blockElements.body = 1;
      const isBlock = (node) =>
        node.name in blockElements || isTransparentAstBlock(schema, node);
      for (let i = 0, l = nodes.length; i < l; i++) {
        let node = nodes[i];
        let parent = node.parent;
        if (parent && isBlock(parent) && node === parent.lastChild) {
          let prev = node.prev;
          while (prev) {
            const prevName = prev.name;
            if (
              prevName !== "span" ||
              prev.attr("data-mce-type") !== "bookmark"
            ) {
              if (prevName === "br") {
                node = null;
              }
              break;
            }
            prev = prev.prev;
          }
          if (node) {
            node.remove();
            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {
              const elementRule = schema.getElementRule(parent.name);
              if (elementRule) {
                if (elementRule.removeEmpty) {
                  parent.remove();
                } else if (elementRule.paddEmpty) {
                  paddEmptyNode(settings, args, isBlock, parent);
                }
              }
            }
          }
        } else {
          let lastParent = node;
          while (
            parent &&
            parent.firstChild === lastParent &&
            parent.lastChild === lastParent
          ) {
            lastParent = parent;
            if (blockElements[parent.name]) {
              break;
            }
            parent = parent.parent;
          }
          if (lastParent === parent) {
            const textNode = new AstNode("#text", 3);
            textNode.value = nbsp;
            node.replace(textNode);
          }
        }
      }
    });
  };

  const register$3 = (htmlParser, settings, dom) => {
    htmlParser.addAttributeFilter("data-mce-tabindex", (nodes, name) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        node.attr("tabindex", node.attr("data-mce-tabindex"));
        node.attr(name, null);
      }
    });
    htmlParser.addAttributeFilter("src,href,style", (nodes, name) => {
      const internalName = "data-mce-" + name;
      const urlConverter = settings.url_converter;
      const urlConverterScope = settings.url_converter_scope;
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        let value = node.attr(internalName);
        if (value !== undefined) {
          node.attr(name, value.length > 0 ? value : null);
          node.attr(internalName, null);
        } else {
          value = node.attr(name);
          if (name === "style") {
            value = dom.serializeStyle(dom.parseStyle(value), node.name);
          } else if (urlConverter) {
            value = urlConverter.call(
              urlConverterScope,
              value,
              name,
              node.name
            );
          }
          node.attr(name, value.length > 0 ? value : null);
        }
      }
    });
    htmlParser.addAttributeFilter("class", (nodes) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        let value = node.attr("class");
        if (value) {
          value = value.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
          node.attr("class", value.length > 0 ? value : null);
        }
      }
    });
    htmlParser.addAttributeFilter("data-mce-type", (nodes, name, args) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        if (node.attr("data-mce-type") === "bookmark" && !args.cleanup) {
          const hasChildren = Optional.from(node.firstChild).exists(
            (firstChild) => {
              var _a;
              return !isZwsp(
                (_a = firstChild.value) !== null && _a !== void 0 ? _a : ""
              );
            }
          );
          if (hasChildren) {
            node.unwrap();
          } else {
            node.remove();
          }
        }
      }
    });
    htmlParser.addNodeFilter("script,style", (nodes, name) => {
      var _a;
      const trim = (value) => {
        return value
          .replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n")
          .replace(/^[\r\n]*|[\r\n]*$/g, "")
          .replace(
            /^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi,
            ""
          )
          .replace(
            /\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g,
            ""
          );
      };
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        const firstChild = node.firstChild;
        const value =
          (_a =
            firstChild === null || firstChild === void 0
              ? void 0
              : firstChild.value) !== null && _a !== void 0
            ? _a
            : "";
        if (name === "script") {
          const type = node.attr("type");
          if (type) {
            node.attr(
              "type",
              type === "mce-no/type" ? null : type.replace(/^mce\-/, "")
            );
          }
          if (
            settings.element_format === "xhtml" &&
            firstChild &&
            value.length > 0
          ) {
            firstChild.value = "// <![CDATA[\n" + trim(value) + "\n// ]]>";
          }
        } else {
          if (
            settings.element_format === "xhtml" &&
            firstChild &&
            value.length > 0
          ) {
            firstChild.value = "<!--\n" + trim(value) + "\n-->";
          }
        }
      }
    });
    htmlParser.addNodeFilter("#comment", (nodes) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        const value = node.value;
        if (
          settings.preserve_cdata &&
          (value === null || value === void 0
            ? void 0
            : value.indexOf("[CDATA[")) === 0
        ) {
          node.name = "#cdata";
          node.type = 4;
          node.value = dom.decode(value.replace(/^\[CDATA\[|\]\]$/g, ""));
        } else if (
          (value === null || value === void 0
            ? void 0
            : value.indexOf("mce:protected ")) === 0
        ) {
          node.name = "#text";
          node.type = 3;
          node.raw = true;
          node.value = unescape(value).substr(14);
        }
      }
    });
    htmlParser.addNodeFilter("xml:namespace,input", (nodes, name) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        if (node.type === 7) {
          node.remove();
        } else if (node.type === 1) {
          if (name === "input" && !node.attr("type")) {
            node.attr("type", "text");
          }
        }
      }
    });
    htmlParser.addAttributeFilter("data-mce-type", (nodes) => {
      each$e(nodes, (node) => {
        if (node.attr("data-mce-type") === "format-caret") {
          if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
            node.remove();
          } else {
            node.unwrap();
          }
        }
      });
    });
    htmlParser.addAttributeFilter(
      "data-mce-src,data-mce-href,data-mce-style," +
        "data-mce-selected,data-mce-expando,data-mce-block," +
        "data-mce-type,data-mce-resize,data-mce-placeholder",
      (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          nodes[i].attr(name, null);
        }
      }
    );
    if (settings.remove_trailing_brs) {
      addNodeFilter(settings, htmlParser, htmlParser.schema);
    }
  };
  const trimTrailingBr = (rootNode) => {
    const isBr = (node) => {
      return (node === null || node === void 0 ? void 0 : node.name) === "br";
    };
    const brNode1 = rootNode.lastChild;
    if (isBr(brNode1)) {
      const brNode2 = brNode1.prev;
      if (isBr(brNode2)) {
        brNode1.remove();
        brNode2.remove();
      }
    }
  };

  const preProcess$1 = (editor, node, args) => {
    let oldDoc;
    const dom = editor.dom;
    let clonedNode = node.cloneNode(true);
    const impl = document.implementation;
    if (impl.createHTMLDocument) {
      const doc = impl.createHTMLDocument("");
      Tools.each(
        clonedNode.nodeName === "BODY" ? clonedNode.childNodes : [clonedNode],
        (node) => {
          doc.body.appendChild(doc.importNode(node, true));
        }
      );
      if (clonedNode.nodeName !== "BODY") {
        clonedNode = doc.body.firstChild;
      } else {
        clonedNode = doc.body;
      }
      oldDoc = dom.doc;
      dom.doc = doc;
    }
    firePreProcess(editor, {
      ...args,
      node: clonedNode,
    });
    if (oldDoc) {
      dom.doc = oldDoc;
    }
    return clonedNode;
  };
  const shouldFireEvent = (editor, args) => {
    return (
      isNonNullable(editor) &&
      editor.hasEventListeners("PreProcess") &&
      !args.no_events
    );
  };
  const process$1 = (editor, node, args) => {
    return shouldFireEvent(editor, args)
      ? preProcess$1(editor, node, args)
      : node;
  };

  const addTempAttr = (htmlParser, tempAttrs, name) => {
    if (Tools.inArray(tempAttrs, name) === -1) {
      htmlParser.addAttributeFilter(name, (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          nodes[i].attr(name, null);
        }
      });
      tempAttrs.push(name);
    }
  };
  const postProcess = (editor, args, content) => {
    if (!args.no_events && editor) {
      const outArgs = firePostProcess(editor, {
        ...args,
        content,
      });
      return outArgs.content;
    } else {
      return content;
    }
  };
  const getHtmlFromNode = (dom, node, args) => {
    const html = trim$2(
      args.getInner ? node.innerHTML : dom.getOuterHTML(node)
    );
    return args.selection || isWsPreserveElement(SugarElement.fromDom(node))
      ? html
      : Tools.trim(html);
  };
  const parseHtml = (htmlParser, html, args) => {
    const parserArgs = args.selection
      ? {
          forced_root_block: false,
          ...args,
        }
      : args;
    const rootNode = htmlParser.parse(html, parserArgs);
    trimTrailingBr(rootNode);
    return rootNode;
  };
  const serializeNode = (settings, schema, node) => {
    const htmlSerializer = HtmlSerializer(settings, schema);
    return htmlSerializer.serialize(node);
  };
  const toHtml = (editor, settings, schema, rootNode, args) => {
    const content = serializeNode(settings, schema, rootNode);
    return postProcess(editor, args, content);
  };
  const DomSerializerImpl = (settings, editor) => {
    const tempAttrs = ["data-mce-selected"];
    const defaultedSettings = {
      entity_encoding: "named",
      remove_trailing_brs: true,
      pad_empty_with_br: false,
      ...settings,
    };
    const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;
    const schema =
      editor && editor.schema ? editor.schema : Schema(defaultedSettings);
    const htmlParser = DomParser(defaultedSettings, schema);
    register$3(htmlParser, defaultedSettings, dom);
    const serialize = (node, parserArgs = {}) => {
      const args = {
        format: "html",
        ...parserArgs,
      };
      const targetNode = process$1(editor, node, args);
      const html = getHtmlFromNode(dom, targetNode, args);
      const rootNode = parseHtml(htmlParser, html, args);
      return args.format === "tree"
        ? rootNode
        : toHtml(editor, defaultedSettings, schema, rootNode, args);
    };
    return {
      schema,
      addNodeFilter: htmlParser.addNodeFilter,
      addAttributeFilter: htmlParser.addAttributeFilter,
      serialize: serialize,
      addRules: schema.addValidElements,
      setRules: schema.setValidElements,
      addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
      getTempAttrs: constant(tempAttrs),
      getNodeFilters: htmlParser.getNodeFilters,
      getAttributeFilters: htmlParser.getAttributeFilters,
      removeNodeFilter: htmlParser.removeNodeFilter,
      removeAttributeFilter: htmlParser.removeAttributeFilter,
    };
  };

  const DomSerializer = (settings, editor) => {
    const domSerializer = DomSerializerImpl(settings, editor);
    return {
      schema: domSerializer.schema,
      addNodeFilter: domSerializer.addNodeFilter,
      addAttributeFilter: domSerializer.addAttributeFilter,
      serialize: domSerializer.serialize,
      addRules: domSerializer.addRules,
      setRules: domSerializer.setRules,
      addTempAttr: domSerializer.addTempAttr,
      getTempAttrs: domSerializer.getTempAttrs,
      getNodeFilters: domSerializer.getNodeFilters,
      getAttributeFilters: domSerializer.getAttributeFilters,
      removeNodeFilter: domSerializer.removeNodeFilter,
      removeAttributeFilter: domSerializer.removeAttributeFilter,
    };
  };

  const defaultFormat$1 = "html";
  const setupArgs$1 = (args, format) => ({
    ...args,
    format,
    get: true,
    getInner: true,
  });
  const getContent = (editor, args = {}) => {
    const format = args.format ? args.format : defaultFormat$1;
    const defaultedArgs = setupArgs$1(args, format);
    return preProcessGetContent(editor, defaultedArgs).fold(
      identity,
      (updatedArgs) => {
        const content = getContent$2(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      }
    );
  };

  const defaultFormat = "html";
  const setupArgs = (args, content) => ({
    format: defaultFormat,
    ...args,
    set: true,
    content,
  });
  const setContent = (editor, content, args = {}) => {
    const defaultedArgs = setupArgs(args, content);
    return preProcessSetContent(editor, defaultedArgs)
      .map((updatedArgs) => {
        const result = setContent$2(editor, updatedArgs.content, updatedArgs);
        postProcessSetContent(editor, result.html, updatedArgs);
        return result.content;
      })
      .getOr(content);
  };

  const removedOptions = (
    "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements," +
    "boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler," +
    "force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements," +
    "non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist," +
    "tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements," +
    "paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists," +
    "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format"
  ).split(",");
  const deprecatedOptions = [];
  const removedPlugins =
    "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc".split(
      ","
    );
  const deprecatedPlugins = [];
  const getMatchingOptions = (options, searchingFor) => {
    const settingNames = filter$5(searchingFor, (setting) =>
      has$2(options, setting)
    );
    return sort(settingNames);
  };
  const getRemovedOptions = (options) => {
    const settingNames = getMatchingOptions(options, removedOptions);
    const forcedRootBlock = options.forced_root_block;
    if (forcedRootBlock === false || forcedRootBlock === "") {
      settingNames.push("forced_root_block (false only)");
    }
    return sort(settingNames);
  };
  const getDeprecatedOptions = (options) =>
    getMatchingOptions(options, deprecatedOptions);
  const getMatchingPlugins = (options, searchingFor) => {
    const plugins = Tools.makeMap(options.plugins, " ");
    const hasPlugin = (plugin) => has$2(plugins, plugin);
    const pluginNames = filter$5(searchingFor, hasPlugin);
    return sort(pluginNames);
  };
  const getRemovedPlugins = (options) =>
    getMatchingPlugins(options, removedPlugins);
  const getDeprecatedPlugins = (options) =>
    getMatchingPlugins(
      options,
      deprecatedPlugins.map((entry) => entry.name)
    );
  const logRemovedWarnings = (rawOptions, normalizedOptions) => {
    const removedOptions = getRemovedOptions(rawOptions);
    const removedPlugins = getRemovedPlugins(normalizedOptions);
    const hasRemovedPlugins = removedPlugins.length > 0;
    const hasRemovedOptions = removedOptions.length > 0;
    const isLegacyMobileTheme = normalizedOptions.theme === "mobile";
    if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
      const listJoiner = "\n- ";
      const themesMessage = isLegacyMobileTheme
        ? `\n\nThemes:${listJoiner}mobile`
        : "";
      const pluginsMessage = hasRemovedPlugins
        ? `\n\nPlugins:${listJoiner}${removedPlugins.join(listJoiner)}`
        : "";
      const optionsMessage = hasRemovedOptions
        ? `\n\nOptions:${listJoiner}${removedOptions.join(listJoiner)}`
        : "";
      console.warn(
        "The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. " +
          "See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information." +
          themesMessage +
          pluginsMessage +
          optionsMessage
      );
    }
  };
  const getPluginDescription = (name) =>
    find$2(deprecatedPlugins, (entry) => entry.name === name).fold(
      () => name,
      (entry) => {
        if (entry.replacedWith) {
          return `${name}, replaced by ${entry.replacedWith}`;
        } else {
          return name;
        }
      }
    );
  const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
    const deprecatedOptions = getDeprecatedOptions(rawOptions);
    const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);
    const hasDeprecatedPlugins = deprecatedPlugins.length > 0;
    const hasDeprecatedOptions = deprecatedOptions.length > 0;
    if (hasDeprecatedPlugins || hasDeprecatedOptions) {
      const listJoiner = "\n- ";
      const pluginsMessage = hasDeprecatedPlugins
        ? `\n\nPlugins:${listJoiner}${deprecatedPlugins
            .map(getPluginDescription)
            .join(listJoiner)}`
        : "";
      const optionsMessage = hasDeprecatedOptions
        ? `\n\nOptions:${listJoiner}${deprecatedOptions.join(listJoiner)}`
        : "";
      console.warn(
        "The following deprecated features are currently enabled but will be removed soon." +
          pluginsMessage +
          optionsMessage
      );
    }
  };
  const logWarnings = (rawOptions, normalizedOptions) => {
    logRemovedWarnings(rawOptions, normalizedOptions);
    logDeprecatedWarnings(rawOptions, normalizedOptions);
  };

  const DOM$8 = DOMUtils.DOM;
  const restoreOriginalStyles = (editor) => {
    DOM$8.setStyle(editor.id, "display", editor.orgDisplay);
  };
  const safeDestroy = (x) => Optional.from(x).each((x) => x.destroy());
  const clearDomReferences = (editor) => {
    const ed = editor;
    ed.contentAreaContainer =
      ed.formElement =
      ed.container =
      ed.editorContainer =
        null;
    ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
    ed.iframeElement = ed.targetElm = null;
    const selection = editor.selection;
    if (selection) {
      const dom = selection.dom;
      ed.selection = selection.win = selection.dom = dom.doc = null;
    }
  };
  const restoreForm = (editor) => {
    const form = editor.formElement;
    if (form) {
      if (form._mceOldSubmit) {
        form.submit = form._mceOldSubmit;
        delete form._mceOldSubmit;
      }
      DOM$8.unbind(form, "submit reset", editor.formEventDelegate);
    }
  };
  const remove$1 = (editor) => {
    if (!editor.removed) {
      const { _selectionOverrides, editorUpload } = editor;
      const body = editor.getBody();
      const element = editor.getElement();
      if (body) {
        editor.save({ is_removing: true });
      }
      editor.removed = true;
      editor.unbindAllNativeEvents();
      if (
        editor.hasHiddenInput &&
        isNonNullable(
          element === null || element === void 0 ? void 0 : element.nextSibling
        )
      ) {
        DOM$8.remove(element.nextSibling);
      }
      fireRemove(editor);
      editor.editorManager.remove(editor);
      if (!editor.inline && body) {
        restoreOriginalStyles(editor);
      }
      fireDetach(editor);
      DOM$8.remove(editor.getContainer());
      safeDestroy(_selectionOverrides);
      safeDestroy(editorUpload);
      editor.destroy();
    }
  };
  const destroy = (editor, automatic) => {
    const { selection, dom } = editor;
    if (editor.destroyed) {
      return;
    }
    if (!automatic && !editor.removed) {
      editor.remove();
      return;
    }
    if (!automatic) {
      editor.editorManager.off("beforeunload", editor._beforeUnload);
      if (editor.theme && editor.theme.destroy) {
        editor.theme.destroy();
      }
      safeDestroy(selection);
      safeDestroy(dom);
    }
    restoreForm(editor);
    clearDomReferences(editor);
    editor.destroyed = true;
  };

  const CreateIconManager = () => {
    const lookup = {};
    const add = (id, iconPack) => {
      lookup[id] = iconPack;
    };
    const get = (id) => {
      if (lookup[id]) {
        return lookup[id];
      } else {
        return { icons: {} };
      }
    };
    const has = (id) => has$2(lookup, id);
    return {
      add,
      get,
      has,
    };
  };
  const IconManager = CreateIconManager();

  const ModelManager = AddOnManager.ModelManager;

  const getProp = (propName, elm) => {
    const rawElm = elm.dom;
    return rawElm[propName];
  };
  const getComputedSizeProp = (propName, elm) =>
    parseInt(get$7(elm, propName), 10);
  const getClientWidth = curry(getProp, "clientWidth");
  const getClientHeight = curry(getProp, "clientHeight");
  const getMarginTop = curry(getComputedSizeProp, "margin-top");
  const getMarginLeft = curry(getComputedSizeProp, "margin-left");
  const getBoundingClientRect = (elm) => elm.dom.getBoundingClientRect();
  const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
    const clientWidth = getClientWidth(bodyElm);
    const clientHeight = getClientHeight(bodyElm);
    return (
      clientX >= 0 &&
      clientY >= 0 &&
      clientX <= clientWidth &&
      clientY <= clientHeight
    );
  };
  const transpose = (inline, elm, clientX, clientY) => {
    const clientRect = getBoundingClientRect(elm);
    const deltaX = inline
      ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm)
      : 0;
    const deltaY = inline
      ? clientRect.top + elm.dom.clientTop + getMarginTop(elm)
      : 0;
    const x = clientX - deltaX;
    const y = clientY - deltaY;
    return {
      x,
      y,
    };
  };
  const isXYInContentArea = (editor, clientX, clientY) => {
    const bodyElm = SugarElement.fromDom(editor.getBody());
    const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
    const transposedPoint = transpose(
      editor.inline,
      targetElm,
      clientX,
      clientY
    );
    return isInsideElementContentArea(
      targetElm,
      transposedPoint.x,
      transposedPoint.y
    );
  };
  const fromDomSafe = (node) => Optional.from(node).map(SugarElement.fromDom);
  const isEditorAttachedToDom = (editor) => {
    const rawContainer = editor.inline
      ? editor.getBody()
      : editor.getContentAreaContainer();
    return fromDomSafe(rawContainer).map(inBody).getOr(false);
  };

  var NotificationManagerImpl = () => {
    const unimplemented = () => {
      throw new Error(
        "Theme did not provide a NotificationManager implementation."
      );
    };
    return {
      open: unimplemented,
      close: unimplemented,
      getArgs: unimplemented,
    };
  };

  const NotificationManager = (editor) => {
    const notifications = [];
    const getImplementation = () => {
      const theme = editor.theme;
      return theme && theme.getNotificationManagerImpl
        ? theme.getNotificationManagerImpl()
        : NotificationManagerImpl();
    };
    const getTopNotification = () => {
      return Optional.from(notifications[0]);
    };
    const isEqual = (a, b) => {
      return (
        a.type === b.type &&
        a.text === b.text &&
        !a.progressBar &&
        !a.timeout &&
        !b.progressBar &&
        !b.timeout
      );
    };
    const reposition = () => {
      getTopNotification().each((notification) => {
        notification.reposition();
      });
    };
    const addNotification = (notification) => {
      notifications.push(notification);
    };
    const closeNotification = (notification) => {
      findIndex$2(notifications, (otherNotification) => {
        return otherNotification === notification;
      }).each((index) => {
        notifications.splice(index, 1);
      });
    };
    const open = (spec, fireEvent = true) => {
      if (editor.removed || !isEditorAttachedToDom(editor)) {
        return {};
      }
      if (fireEvent) {
        editor.dispatch("BeforeOpenNotification", { notification: spec });
      }
      return find$2(notifications, (notification) => {
        return isEqual(getImplementation().getArgs(notification), spec);
      }).getOrThunk(() => {
        editor.editorManager.setActive(editor);
        const notification = getImplementation().open(
          spec,
          () => {
            closeNotification(notification);
          },
          () => hasEditorOrUiFocus(editor)
        );
        addNotification(notification);
        reposition();
        editor.dispatch("OpenNotification", {
          notification: { ...notification },
        });
        return notification;
      });
    };
    const close = () => {
      getTopNotification().each((notification) => {
        getImplementation().close(notification);
        closeNotification(notification);
        reposition();
      });
    };
    const getNotifications = constant(notifications);
    const registerEvents = (editor) => {
      editor.on("SkinLoaded", () => {
        const serviceMessage = getServiceMessage(editor);
        if (serviceMessage) {
          open(
            {
              text: serviceMessage,
              type: "warning",
              timeout: 0,
            },
            false
          );
        }
        reposition();
      });
      editor.on(
        "show ResizeEditor ResizeWindow NodeChange ToggleView FullscreenStateChanged",
        () => {
          requestAnimationFrame(reposition);
        }
      );
      editor.on("remove", () => {
        each$e(notifications.slice(), (notification) => {
          getImplementation().close(notification);
        });
      });
      editor.on("keydown", (e) => {
        var _a;
        const isF12 =
          ((_a = e.key) === null || _a === void 0
            ? void 0
            : _a.toLowerCase()) === "f12" || e.keyCode === 123;
        if (e.altKey && isF12) {
          e.preventDefault();
          getTopNotification()
            .map((notificationApi) =>
              SugarElement.fromDom(notificationApi.getEl())
            )
            .each((elm) => focus$1(elm));
        }
      });
    };
    registerEvents(editor);
    return {
      open,
      close,
      getNotifications,
    };
  };

  const PluginManager = AddOnManager.PluginManager;

  const ThemeManager = AddOnManager.ThemeManager;

  var WindowManagerImpl = () => {
    const unimplemented = () => {
      throw new Error("Theme did not provide a WindowManager implementation.");
    };
    return {
      open: unimplemented,
      openUrl: unimplemented,
      alert: unimplemented,
      confirm: unimplemented,
      close: unimplemented,
    };
  };

  const WindowManager = (editor) => {
    let dialogs = [];
    const getImplementation = () => {
      const theme = editor.theme;
      return theme && theme.getWindowManagerImpl
        ? theme.getWindowManagerImpl()
        : WindowManagerImpl();
    };
    const funcBind = (scope, f) => {
      return (...args) => {
        return f ? f.apply(scope, args) : undefined;
      };
    };
    const fireOpenEvent = (dialog) => {
      editor.dispatch("OpenWindow", { dialog });
    };
    const fireCloseEvent = (dialog) => {
      editor.dispatch("CloseWindow", { dialog });
    };
    const addDialog = (dialog) => {
      dialogs.push(dialog);
      fireOpenEvent(dialog);
    };
    const closeDialog = (dialog) => {
      fireCloseEvent(dialog);
      dialogs = filter$5(dialogs, (otherDialog) => {
        return otherDialog !== dialog;
      });
      if (dialogs.length === 0) {
        editor.focus();
      }
    };
    const getTopDialog = () => {
      return Optional.from(dialogs[dialogs.length - 1]);
    };
    const storeSelectionAndOpenDialog = (openDialog) => {
      editor.editorManager.setActive(editor);
      store(editor);
      editor.ui.show();
      const dialog = openDialog();
      addDialog(dialog);
      return dialog;
    };
    const open = (args, params) => {
      return storeSelectionAndOpenDialog(() =>
        getImplementation().open(args, params, closeDialog)
      );
    };
    const openUrl = (args) => {
      return storeSelectionAndOpenDialog(() =>
        getImplementation().openUrl(args, closeDialog)
      );
    };
    const alert = (message, callback, scope) => {
      const windowManagerImpl = getImplementation();
      windowManagerImpl.alert(
        message,
        funcBind(scope ? scope : windowManagerImpl, callback)
      );
    };
    const confirm = (message, callback, scope) => {
      const windowManagerImpl = getImplementation();
      windowManagerImpl.confirm(
        message,
        funcBind(scope ? scope : windowManagerImpl, callback)
      );
    };
    const close = () => {
      getTopDialog().each((dialog) => {
        getImplementation().close(dialog);
        closeDialog(dialog);
      });
    };
    editor.on("remove", () => {
      each$e(dialogs, (dialog) => {
        getImplementation().close(dialog);
      });
    });
    return {
      open,
      openUrl,
      alert,
      confirm,
      close,
    };
  };

  const displayNotification = (editor, message) => {
    editor.notificationManager.open({
      type: "error",
      text: message,
    });
  };
  const displayError = (editor, message) => {
    if (editor._skinLoaded) {
      displayNotification(editor, message);
    } else {
      editor.on("SkinLoaded", () => {
        displayNotification(editor, message);
      });
    }
  };
  const uploadError = (editor, message) => {
    displayError(
      editor,
      I18n.translate(["Failed to upload image: {0}", message])
    );
  };
  const logError = (editor, errorType, msg) => {
    fireError(editor, errorType, { message: msg });
    console.error(msg);
  };
  const createLoadError = (type, url, name) =>
    name
      ? `Failed to load ${type}: ${name} from url ${url}`
      : `Failed to load ${type} url: ${url}`;
  const pluginLoadError = (editor, url, name) => {
    logError(editor, "PluginLoadError", createLoadError("plugin", url, name));
  };
  const iconsLoadError = (editor, url, name) => {
    logError(editor, "IconsLoadError", createLoadError("icons", url, name));
  };
  const languageLoadError = (editor, url, name) => {
    logError(
      editor,
      "LanguageLoadError",
      createLoadError("language", url, name)
    );
  };
  const themeLoadError = (editor, url, name) => {
    logError(editor, "ThemeLoadError", createLoadError("theme", url, name));
  };
  const modelLoadError = (editor, url, name) => {
    logError(editor, "ModelLoadError", createLoadError("model", url, name));
  };
  const pluginInitError = (editor, name, err) => {
    const message = I18n.translate(["Failed to initialize plugin: {0}", name]);
    fireError(editor, "PluginLoadError", { message });
    initError(message, err);
    displayError(editor, message);
  };
  const initError = (message, ...x) => {
    const console = window.console;
    if (console) {
      if (console.error) {
        console.error(message, ...x);
      } else {
        console.log(message, ...x);
      }
    }
  };

  const removeFakeSelection = (editor) => {
    Optional.from(editor.selection.getNode()).each((elm) => {
      elm.removeAttribute("data-mce-selected");
    });
  };
  const setEditorCommandState = (editor, cmd, state) => {
    try {
      editor.getDoc().execCommand(cmd, false, String(state));
    } catch (_a) {}
  };
  const setCommonEditorCommands = (editor, state) => {
    setEditorCommandState(editor, "StyleWithCSS", state);
    setEditorCommandState(editor, "enableInlineTableEditing", state);
    setEditorCommandState(editor, "enableObjectResizing", state);
  };
  const restoreFakeSelection = (editor) => {
    editor.selection.setRng(editor.selection.getRng());
  };
  const toggleClass = (elm, cls, state) => {
    if (has(elm, cls) && !state) {
      remove$6(elm, cls);
    } else if (state) {
      add$2(elm, cls);
    }
  };
  const disableEditor = (editor) => {
    const body = SugarElement.fromDom(editor.getBody());
    toggleClass(body, "mce-content-readonly", true);
    editor.selection.controlSelection.hideResizeRect();
    editor._selectionOverrides.hideFakeCaret();
    removeFakeSelection(editor);
  };
  const enableEditor = (editor) => {
    const body = SugarElement.fromDom(editor.getBody());
    toggleClass(body, "mce-content-readonly", false);
    if (editor.hasEditableRoot()) {
      set$3(body, true);
    }
    setCommonEditorCommands(editor, false);
    if (hasEditorOrUiFocus(editor)) {
      editor.focus();
    }
    restoreFakeSelection(editor);
    editor.nodeChanged();
  };

  const isDisabled = (editor) => isDisabled$1(editor);
  const internalContentEditableAttr = "data-mce-contenteditable";
  const switchOffContentEditableTrue = (elm) => {
    each$e(descendants(elm, '*[contenteditable="true"]'), (elm) => {
      set$4(elm, internalContentEditableAttr, "true");
      set$3(elm, false);
    });
  };
  const switchOnContentEditableTrue = (elm) => {
    each$e(
      descendants(elm, `*[${internalContentEditableAttr}="true"]`),
      (elm) => {
        remove$9(elm, internalContentEditableAttr);
        set$3(elm, true);
      }
    );
  };
  const toggleDisabled = (editor, state) => {
    const body = SugarElement.fromDom(editor.getBody());
    if (state) {
      disableEditor(editor);
      set$3(body, false);
      switchOffContentEditableTrue(body);
    } else {
      switchOnContentEditableTrue(body);
      enableEditor(editor);
    }
  };
  const registerDisabledContentFilters = (editor) => {
    if (editor.serializer) {
      registerFilters(editor);
    } else {
      editor.on("PreInit", () => {
        registerFilters(editor);
      });
    }
  };
  const registerFilters = (editor) => {
    editor.parser.addAttributeFilter("contenteditable", (nodes) => {
      if (isDisabled(editor)) {
        each$e(nodes, (node) => {
          node.attr(internalContentEditableAttr, node.attr("contenteditable"));
          node.attr("contenteditable", "false");
        });
      }
    });
    editor.serializer.addAttributeFilter(
      internalContentEditableAttr,
      (nodes) => {
        if (isDisabled(editor)) {
          each$e(nodes, (node) => {
            node.attr(
              "contenteditable",
              node.attr(internalContentEditableAttr)
            );
          });
        }
      }
    );
    editor.serializer.addTempAttr(internalContentEditableAttr);
  };
  const isClickEvent = (e) => e.type === "click";
  const allowedEvents = ["copy"];
  const isAllowedEventInDisabledMode = (e) => contains$2(allowedEvents, e.type);
  const getAnchorHrefOpt = (editor, elm) => {
    const isRoot = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
    return closest$3(elm, "a", isRoot).bind((a) => getOpt(a, "href"));
  };
  const processDisabledEvents = (editor, e) => {
    if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
      const elm = SugarElement.fromDom(e.target);
      getAnchorHrefOpt(editor, elm).each((href) => {
        e.preventDefault();
        if (/^#/.test(href)) {
          const targetEl = editor.dom.select(
            `${href},[name="${removeLeading(href, "#")}"]`
          );
          if (targetEl.length) {
            editor.selection.scrollIntoView(targetEl[0], true);
          }
        } else {
          window.open(
            href,
            "_blank",
            "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes"
          );
        }
      });
    } else if (isAllowedEventInDisabledMode(e)) {
      editor.dispatch(e.type, e);
    }
  };
  const registerDisabledModeEventHandlers = (editor) => {
    editor.on("ShowCaret ObjectSelected", (e) => {
      if (isDisabled(editor)) {
        e.preventDefault();
      }
    });
    editor.on("DisabledStateChange", (e) => {
      if (!e.isDefaultPrevented()) {
        toggleDisabled(editor, e.state);
      }
    });
  };
  const registerEventsAndFilters$1 = (editor) => {
    registerDisabledContentFilters(editor);
    registerDisabledModeEventHandlers(editor);
  };

  const isContentCssSkinName = (url) => /^[a-z0-9\-]+$/i.test(url);
  const toContentSkinResourceName = (url) => "content/" + url + "/content.css";
  const isBundledCssSkinName = (url) =>
    tinymce.Resource.has(toContentSkinResourceName(url));
  const getContentCssUrls = (editor) => {
    return transformToUrls(editor, getContentCss(editor));
  };
  const getFontCssUrls = (editor) => {
    return transformToUrls(editor, getFontCss(editor));
  };
  const transformToUrls = (editor, cssLinks) => {
    const skinUrl = editor.editorManager.baseURL + "/skins/content";
    const suffix = editor.editorManager.suffix;
    const contentCssFile = `content${suffix}.css`;
    return map$3(cssLinks, (url) => {
      if (isBundledCssSkinName(url)) {
        return url;
      } else if (isContentCssSkinName(url) && !editor.inline) {
        return `${skinUrl}/${url}/${contentCssFile}`;
      } else {
        return editor.documentBaseURI.toAbsolute(url);
      }
    });
  };
  const appendContentCssFromSettings = (editor) => {
    editor.contentCSS = editor.contentCSS.concat(
      getContentCssUrls(editor),
      getFontCssUrls(editor)
    );
  };

  const getAllImages = (elm) => {
    return elm ? from(elm.getElementsByTagName("img")) : [];
  };
  const ImageScanner = (uploadStatus, blobCache) => {
    const cachedPromises = {};
    const findAll = (elm, predicate = always) => {
      const images = filter$5(getAllImages(elm), (img) => {
        const src = img.src;
        if (img.hasAttribute("data-mce-bogus")) {
          return false;
        }
        if (img.hasAttribute("data-mce-placeholder")) {
          return false;
        }
        if (!src || src === Env.transparentSrc) {
          return false;
        }
        if (startsWith(src, "blob:")) {
          return !uploadStatus.isUploaded(src) && predicate(img);
        }
        if (startsWith(src, "data:")) {
          return predicate(img);
        }
        return false;
      });
      const promises = map$3(images, (img) => {
        const imageSrc = img.src;
        if (has$2(cachedPromises, imageSrc)) {
          return cachedPromises[imageSrc].then((imageInfo) => {
            if (isString(imageInfo)) {
              return imageInfo;
            } else {
              return {
                image: img,
                blobInfo: imageInfo.blobInfo,
              };
            }
          });
        } else {
          const newPromise = imageToBlobInfo(blobCache, imageSrc)
            .then((blobInfo) => {
              delete cachedPromises[imageSrc];
              return {
                image: img,
                blobInfo,
              };
            })
            .catch((error) => {
              delete cachedPromises[imageSrc];
              return error;
            });
          cachedPromises[imageSrc] = newPromise;
          return newPromise;
        }
      });
      return Promise.all(promises);
    };
    return { findAll };
  };

  const UploadStatus = () => {
    const PENDING = 1,
      UPLOADED = 2;
    let blobUriStatuses = {};
    const createStatus = (status, resultUri) => {
      return {
        status,
        resultUri,
      };
    };
    const hasBlobUri = (blobUri) => {
      return blobUri in blobUriStatuses;
    };
    const getResultUri = (blobUri) => {
      const result = blobUriStatuses[blobUri];
      return result ? result.resultUri : null;
    };
    const isPending = (blobUri) => {
      return hasBlobUri(blobUri)
        ? blobUriStatuses[blobUri].status === PENDING
        : false;
    };
    const isUploaded = (blobUri) => {
      return hasBlobUri(blobUri)
        ? blobUriStatuses[blobUri].status === UPLOADED
        : false;
    };
    const markPending = (blobUri) => {
      blobUriStatuses[blobUri] = createStatus(PENDING, null);
    };
    const markUploaded = (blobUri, resultUri) => {
      blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
    };
    const removeFailed = (blobUri) => {
      delete blobUriStatuses[blobUri];
    };
    const destroy = () => {
      blobUriStatuses = {};
    };
    return {
      hasBlobUri,
      getResultUri,
      isPending,
      isUploaded,
      markPending,
      markUploaded,
      removeFailed,
      destroy,
    };
  };

  let count = 0;
  const seed = () => {
    const rnd = () => {
      return Math.round(random() * 4294967295).toString(36);
    };
    const now = new Date().getTime();
    return "s" + now.toString(36) + rnd() + rnd() + rnd();
  };
  const uuid = (prefix) => {
    return prefix + count++ + seed();
  };

  const BlobCache = () => {
    let cache = [];
    const mimeToExt = (mime) => {
      const mimes = {
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff",
      };
      return mimes[mime.toLowerCase()] || "dat";
    };
    const create = (o, blob, base64, name, filename) => {
      if (isString(o)) {
        const id = o;
        return toBlobInfo({
          id,
          name,
          filename,
          blob: blob,
          base64: base64,
        });
      } else if (isObject(o)) {
        return toBlobInfo(o);
      } else {
        throw new Error("Unknown input type");
      }
    };
    const toBlobInfo = (o) => {
      if (!o.blob || !o.base64) {
        throw new Error(
          "blob and base64 representations of the image are required for BlobInfo to be created"
        );
      }
      const id = o.id || uuid("blobid");
      const name = o.name || id;
      const blob = o.blob;
      return {
        id: constant(id),
        name: constant(name),
        filename: constant(o.filename || name + "." + mimeToExt(blob.type)),
        blob: constant(blob),
        base64: constant(o.base64),
        blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
        uri: constant(o.uri),
      };
    };
    const add = (blobInfo) => {
      if (!get(blobInfo.id())) {
        cache.push(blobInfo);
      }
    };
    const findFirst = (predicate) => find$2(cache, predicate).getOrUndefined();
    const get = (id) =>
      findFirst((cachedBlobInfo) => cachedBlobInfo.id() === id);
    const getByUri = (blobUri) =>
      findFirst((blobInfo) => blobInfo.blobUri() === blobUri);
    const getByData = (base64, type) =>
      findFirst(
        (blobInfo) =>
          blobInfo.base64() === base64 && blobInfo.blob().type === type
      );
    const removeByUri = (blobUri) => {
      cache = filter$5(cache, (blobInfo) => {
        if (blobInfo.blobUri() === blobUri) {
          URL.revokeObjectURL(blobInfo.blobUri());
          return false;
        }
        return true;
      });
    };
    const destroy = () => {
      each$e(cache, (cachedBlobInfo) => {
        URL.revokeObjectURL(cachedBlobInfo.blobUri());
      });
      cache = [];
    };
    return {
      create,
      add,
      get,
      getByUri,
      getByData,
      findFirst,
      removeByUri,
      destroy,
    };
  };

  const Uploader = (uploadStatus, settings) => {
    const pendingPromises = {};
    const pathJoin = (path1, path2) => {
      if (path1) {
        return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
      }
      return path2;
    };
    const defaultHandler = (blobInfo, progress) =>
      new Promise((success, failure) => {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = (e) => {
          progress((e.loaded / e.total) * 100);
        };
        xhr.onerror = () => {
          failure(
            "Image upload failed due to a XHR Transport error. Code: " +
              xhr.status
          );
        };
        xhr.onload = () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            failure("HTTP Error: " + xhr.status);
            return;
          }
          const json = JSON.parse(xhr.responseText);
          if (!json || !isString(json.location)) {
            failure("Invalid JSON: " + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        const formData = new FormData();
        formData.append("file", blobInfo.blob(), blobInfo.filename());
        xhr.send(formData);
      });
    const uploadHandler = isFunction(settings.handler)
      ? settings.handler
      : defaultHandler;
    const noUpload = () =>
      new Promise((resolve) => {
        resolve([]);
      });
    const handlerSuccess = (blobInfo, url) => ({
      url,
      blobInfo,
      status: true,
    });
    const handlerFailure = (blobInfo, error) => ({
      url: "",
      blobInfo,
      status: false,
      error,
    });
    const resolvePending = (blobUri, result) => {
      Tools.each(pendingPromises[blobUri], (resolve) => {
        resolve(result);
      });
      delete pendingPromises[blobUri];
    };
    const uploadBlobInfo = (blobInfo, handler, openNotification) => {
      uploadStatus.markPending(blobInfo.blobUri());
      return new Promise((resolve) => {
        let notification;
        let progress;
        try {
          const closeNotification = () => {
            if (notification) {
              notification.close();
              progress = noop;
            }
          };
          const success = (url) => {
            closeNotification();
            uploadStatus.markUploaded(blobInfo.blobUri(), url);
            resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
            resolve(handlerSuccess(blobInfo, url));
          };
          const failure = (error) => {
            closeNotification();
            uploadStatus.removeFailed(blobInfo.blobUri());
            resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
            resolve(handlerFailure(blobInfo, error));
          };
          progress = (percent) => {
            if (percent < 0 || percent > 100) {
              return;
            }
            Optional.from(notification)
              .orThunk(() => Optional.from(openNotification).map(apply$1))
              .each((n) => {
                notification = n;
                n.progressBar.value(percent);
              });
          };
          handler(blobInfo, progress).then(success, (err) => {
            failure(isString(err) ? { message: err } : err);
          });
        } catch (ex) {
          resolve(handlerFailure(blobInfo, ex));
        }
      });
    };
    const isDefaultHandler = (handler) => handler === defaultHandler;
    const pendingUploadBlobInfo = (blobInfo) => {
      const blobUri = blobInfo.blobUri();
      return new Promise((resolve) => {
        pendingPromises[blobUri] = pendingPromises[blobUri] || [];
        pendingPromises[blobUri].push(resolve);
      });
    };
    const uploadBlobs = (blobInfos, openNotification) => {
      blobInfos = Tools.grep(
        blobInfos,
        (blobInfo) => !uploadStatus.isUploaded(blobInfo.blobUri())
      );
      return Promise.all(
        Tools.map(blobInfos, (blobInfo) =>
          uploadStatus.isPending(blobInfo.blobUri())
            ? pendingUploadBlobInfo(blobInfo)
            : uploadBlobInfo(blobInfo, uploadHandler, openNotification)
        )
      );
    };
    const upload = (blobInfos, openNotification) =>
      !settings.url && isDefaultHandler(uploadHandler)
        ? noUpload()
        : uploadBlobs(blobInfos, openNotification);
    return { upload };
  };

  const openNotification = (editor) => () =>
    editor.notificationManager.open({
      text: editor.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: true,
    });
  const createUploader = (editor, uploadStatus) =>
    Uploader(uploadStatus, {
      url: getImageUploadUrl(editor),
      basePath: getImageUploadBasePath(editor),
      credentials: getImagesUploadCredentials(editor),
      handler: getImagesUploadHandler(editor),
    });
  const ImageUploader = (editor) => {
    const uploadStatus = UploadStatus();
    const uploader = createUploader(editor, uploadStatus);
    return {
      upload: (blobInfos, showNotification = true) =>
        uploader.upload(
          blobInfos,
          showNotification ? openNotification(editor) : undefined
        ),
    };
  };

  const isEmptyForPadding = (editor, element) =>
    editor.dom.isEmpty(element.dom) &&
    isNonNullable(editor.schema.getTextBlockElements()[name(element)]);
  const addPaddingToEmpty = (editor) => (element) => {
    if (isEmptyForPadding(editor, element)) {
      append$1(element, SugarElement.fromHtml('<br data-mce-bogus="1" />'));
    }
  };
  const EditorUpload = (editor) => {
    const blobCache = BlobCache();
    let uploader, imageScanner;
    const uploadStatus = UploadStatus();
    const urlFilters = [];
    const aliveGuard = (callback) => {
      return (result) => {
        if (editor.selection) {
          return callback(result);
        }
        return [];
      };
    };
    const cacheInvalidator = (url) =>
      url + (url.indexOf("?") === -1 ? "?" : "&") + new Date().getTime();
    const replaceString = (content, search, replace) => {
      let index = 0;
      do {
        index = content.indexOf(search, index);
        if (index !== -1) {
          content =
            content.substring(0, index) +
            replace +
            content.substr(index + search.length);
          index += replace.length - search.length + 1;
        }
      } while (index !== -1);
      return content;
    };
    const replaceImageUrl = (content, targetUrl, replacementUrl) => {
      const replacementString = `src="${replacementUrl}"${
        replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : ""
      }`;
      content = replaceString(content, `src="${targetUrl}"`, replacementString);
      content = replaceString(
        content,
        'data-mce-src="' + targetUrl + '"',
        'data-mce-src="' + replacementUrl + '"'
      );
      return content;
    };
    const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
      each$e(editor.undoManager.data, (level) => {
        if (level.type === "fragmented") {
          level.fragments = map$3(level.fragments, (fragment) =>
            replaceImageUrl(fragment, targetUrl, replacementUrl)
          );
        } else {
          level.content = replaceImageUrl(
            level.content,
            targetUrl,
            replacementUrl
          );
        }
      });
    };
    const replaceImageUriInView = (image, resultUri) => {
      const src = editor.convertURL(resultUri, "src");
      replaceUrlInUndoStack(image.src, resultUri);
      setAll$1(SugarElement.fromDom(image), {
        src: shouldReuseFileName(editor)
          ? cacheInvalidator(resultUri)
          : resultUri,
        "data-mce-src": src,
      });
    };
    const uploadImages = () => {
      if (!uploader) {
        uploader = createUploader(editor, uploadStatus);
      }
      return scanForImages().then(
        aliveGuard((imageInfos) => {
          const blobInfos = map$3(
            imageInfos,
            (imageInfo) => imageInfo.blobInfo
          );
          return uploader.upload(blobInfos, openNotification(editor)).then(
            aliveGuard((result) => {
              const imagesToRemove = [];
              let shouldDispatchChange = false;
              const filteredResult = map$3(result, (uploadInfo, index) => {
                const { blobInfo, image } = imageInfos[index];
                let removed = false;
                if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                  if (
                    uploadInfo.url &&
                    !contains$1(image.src, uploadInfo.url)
                  ) {
                    shouldDispatchChange = true;
                  }
                  blobCache.removeByUri(image.src);
                  if (isRtc(editor));
                  else {
                    replaceImageUriInView(image, uploadInfo.url);
                  }
                } else if (uploadInfo.error) {
                  if (uploadInfo.error.remove) {
                    replaceUrlInUndoStack(image.src, Env.transparentSrc);
                    imagesToRemove.push(image);
                    removed = true;
                  }
                  uploadError(editor, uploadInfo.error.message);
                }
                return {
                  element: image,
                  status: uploadInfo.status,
                  uploadUri: uploadInfo.url,
                  blobInfo,
                  removed,
                };
              });
              if (imagesToRemove.length > 0 && !isRtc(editor)) {
                editor.undoManager.transact(() => {
                  each$e(fromDom$1(imagesToRemove), (sugarElement) => {
                    const parentOpt = parent(sugarElement);
                    remove$4(sugarElement);
                    parentOpt.each(addPaddingToEmpty(editor));
                    blobCache.removeByUri(sugarElement.dom.src);
                  });
                });
              } else if (shouldDispatchChange) {
                editor.undoManager.dispatchChange();
              }
              return filteredResult;
            })
          );
        })
      );
    };
    const uploadImagesAuto = () =>
      isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
    const isValidDataUriImage = (imgElm) =>
      forall(urlFilters, (filter) => filter(imgElm));
    const addFilter = (filter) => {
      urlFilters.push(filter);
    };
    const scanForImages = () => {
      if (!imageScanner) {
        imageScanner = ImageScanner(uploadStatus, blobCache);
      }
      return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(
        aliveGuard((result) => {
          const filteredResult = filter$5(result, (resultItem) => {
            if (isString(resultItem)) {
              displayError(editor, resultItem);
              return false;
            } else if (resultItem.uriType === "blob") {
              return false;
            } else {
              return true;
            }
          });
          if (isRtc(editor));
          else {
            each$e(filteredResult, (resultItem) => {
              replaceUrlInUndoStack(
                resultItem.image.src,
                resultItem.blobInfo.blobUri()
              );
              resultItem.image.src = resultItem.blobInfo.blobUri();
              resultItem.image.removeAttribute("data-mce-src");
            });
          }
          return filteredResult;
        })
      );
    };
    const destroy = () => {
      blobCache.destroy();
      uploadStatus.destroy();
      imageScanner = uploader = null;
    };
    const replaceBlobUris = (content) => {
      return content.replace(/src="(blob:[^"]+)"/g, (match, blobUri) => {
        const resultUri = uploadStatus.getResultUri(blobUri);
        if (resultUri) {
          return 'src="' + resultUri + '"';
        }
        let blobInfo = blobCache.getByUri(blobUri);
        if (!blobInfo) {
          blobInfo = foldl(
            editor.editorManager.get(),
            (result, editor) => {
              return (
                result ||
                (editor.editorUpload &&
                  editor.editorUpload.blobCache.getByUri(blobUri))
              );
            },
            undefined
          );
        }
        if (blobInfo) {
          const blob = blobInfo.blob();
          return (
            'src="data:' + blob.type + ";base64," + blobInfo.base64() + '"'
          );
        }
        return match;
      });
    };
    editor.on("SetContent", () => {
      if (isAutomaticUploadsEnabled(editor)) {
        uploadImagesAuto();
      } else {
        scanForImages();
      }
    });
    editor.on("RawSaveContent", (e) => {
      e.content = replaceBlobUris(e.content);
    });
    editor.on("GetContent", (e) => {
      if (e.source_view || e.format === "raw" || e.format === "tree") {
        return;
      }
      e.content = replaceBlobUris(e.content);
    });
    editor.on("PostRender", () => {
      editor.parser.addNodeFilter("img", (images) => {
        each$e(images, (img) => {
          const src = img.attr("src");
          if (!src || blobCache.getByUri(src)) {
            return;
          }
          const resultUri = uploadStatus.getResultUri(src);
          if (resultUri) {
            img.attr("src", resultUri);
          }
        });
      });
    });
    return {
      blobCache,
      addFilter,
      uploadImages,
      uploadImagesAuto,
      scanForImages,
      destroy,
    };
  };

  const get$1 = (editor) => {
    const dom = editor.dom;
    const schemaType = editor.schema.type;
    const formats = {
      valigntop: [
        {
          selector: "td,th",
          styles: { verticalAlign: "top" },
        },
      ],
      valignmiddle: [
        {
          selector: "td,th",
          styles: { verticalAlign: "middle" },
        },
      ],
      valignbottom: [
        {
          selector: "td,th",
          styles: { verticalAlign: "bottom" },
        },
      ],
      alignleft: [
        {
          selector: "figure.image",
          collapsed: false,
          classes: "align-left",
          ceFalseOverride: true,
          preview: "font-family font-size",
        },
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "left" },
          inherit: false,
          preview: false,
        },
        {
          selector: "img,audio,video",
          collapsed: false,
          styles: { float: "left" },
          preview: "font-family font-size",
        },
        {
          selector: ".mce-placeholder",
          styles: { float: "left" },
          ceFalseOverride: true,
        },
        {
          selector: "table",
          collapsed: false,
          styles: {
            marginLeft: "0px",
            marginRight: "auto",
          },
          onformat: (table) => {
            dom.setStyle(table, "float", null);
          },
          preview: "font-family font-size",
        },
        {
          selector: ".mce-preview-object,[data-ephox-embed-iri]",
          ceFalseOverride: true,
          styles: { float: "left" },
        },
      ],
      aligncenter: [
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "center" },
          inherit: false,
          preview: "font-family font-size",
        },
        {
          selector: "figure.image",
          collapsed: false,
          classes: "align-center",
          ceFalseOverride: true,
          preview: "font-family font-size",
        },
        {
          selector: "img,audio,video",
          collapsed: false,
          styles: {
            display: "block",
            marginLeft: "auto",
            marginRight: "auto",
          },
          preview: false,
        },
        {
          selector: ".mce-placeholder",
          styles: {
            display: "block",
            marginLeft: "auto",
            marginRight: "auto",
          },
          ceFalseOverride: true,
        },
        {
          selector: "table",
          collapsed: false,
          styles: {
            marginLeft: "auto",
            marginRight: "auto",
          },
          preview: "font-family font-size",
        },
        {
          selector: ".mce-preview-object",
          ceFalseOverride: true,
          styles: {
            display: "table",
            marginLeft: "auto",
            marginRight: "auto",
          },
          preview: false,
        },
        {
          selector: "[data-ephox-embed-iri]",
          ceFalseOverride: true,
          styles: {
            marginLeft: "auto",
            marginRight: "auto",
          },
          preview: false,
        },
      ],
      alignright: [
        {
          selector: "figure.image",
          collapsed: false,
          classes: "align-right",
          ceFalseOverride: true,
          preview: "font-family font-size",
        },
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "right" },
          inherit: false,
          preview: "font-family font-size",
        },
        {
          selector: "img,audio,video",
          collapsed: false,
          styles: { float: "right" },
          preview: "font-family font-size",
        },
        {
          selector: ".mce-placeholder",
          styles: { float: "right" },
          ceFalseOverride: true,
        },
        {
          selector: "table",
          collapsed: false,
          styles: {
            marginRight: "0px",
            marginLeft: "auto",
          },
          onformat: (table) => {
            dom.setStyle(table, "float", null);
          },
          preview: "font-family font-size",
        },
        {
          selector: ".mce-preview-object,[data-ephox-embed-iri]",
          ceFalseOverride: true,
          styles: { float: "right" },
          preview: false,
        },
      ],
      alignjustify: [
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: false,
          preview: "font-family font-size",
        },
      ],
      bold: [
        {
          inline: "strong",
          remove: "all",
          preserve_attributes: ["class", "style"],
        },
        {
          inline: "span",
          styles: { fontWeight: "bold" },
        },
        {
          inline: "b",
          remove: "all",
          preserve_attributes: ["class", "style"],
        },
      ],
      italic: [
        {
          inline: "em",
          remove: "all",
          preserve_attributes: ["class", "style"],
        },
        {
          inline: "span",
          styles: { fontStyle: "italic" },
        },
        {
          inline: "i",
          remove: "all",
          preserve_attributes: ["class", "style"],
        },
      ],
      underline: [
        {
          inline: "span",
          styles: { textDecoration: "underline" },
          exact: true,
        },
        {
          inline: "u",
          remove: "all",
          preserve_attributes: ["class", "style"],
        },
      ],
      strikethrough: (() => {
        const span = {
          inline: "span",
          styles: { textDecoration: "line-through" },
          exact: true,
        };
        const strike = {
          inline: "strike",
          remove: "all",
          preserve_attributes: ["class", "style"],
        };
        const s = {
          inline: "s",
          remove: "all",
          preserve_attributes: ["class", "style"],
        };
        return schemaType !== "html4" ? [s, span, strike] : [span, s, strike];
      })(),
      forecolor: {
        inline: "span",
        styles: { color: "%value" },
        links: true,
        remove_similar: true,
        clear_child_styles: true,
      },
      hilitecolor: {
        inline: "span",
        styles: { backgroundColor: "%value" },
        links: true,
        remove_similar: true,
        clear_child_styles: true,
      },
      fontname: {
        inline: "span",
        toggle: false,
        styles: { fontFamily: "%value" },
        clear_child_styles: true,
      },
      fontsize: {
        inline: "span",
        toggle: false,
        styles: { fontSize: "%value" },
        clear_child_styles: true,
      },
      lineheight: {
        selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
        styles: { lineHeight: "%value" },
      },
      fontsize_class: {
        inline: "span",
        attributes: { class: "%value" },
      },
      blockquote: {
        block: "blockquote",
        wrapper: true,
        remove: "all",
      },
      subscript: { inline: "sub" },
      superscript: { inline: "sup" },
      code: { inline: "code" },
      samp: { inline: "samp" },
      link: {
        inline: "a",
        selector: "a",
        remove: "all",
        split: true,
        deep: true,
        onmatch: (node, _fmt, _itemName) => {
          return isElement$6(node) && node.hasAttribute("href");
        },
        onformat: (elm, _fmt, vars) => {
          Tools.each(vars, (value, key) => {
            dom.setAttrib(elm, key, value);
          });
        },
      },
      lang: {
        inline: "span",
        clear_child_styles: true,
        remove_similar: true,
        attributes: {
          lang: "%value",
          "data-mce-lang": (vars) => {
            var _a;
            return (_a =
              vars === null || vars === void 0 ? void 0 : vars.customValue) !==
              null && _a !== void 0
              ? _a
              : null;
          },
        },
      },
      removeformat: [
        {
          selector:
            "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
          remove: "all",
          split: true,
          expand: false,
          block_expand: true,
          deep: true,
        },
        {
          selector: "span",
          attributes: ["style", "class"],
          remove: "empty",
          split: true,
          expand: false,
          deep: true,
        },
        {
          selector: "*",
          attributes: ["style", "class"],
          split: false,
          expand: false,
          deep: true,
        },
      ],
    };
    Tools.each(
      "p h1 h2 h3 h4 h5 h6 div address pre dt dd".split(/\s/),
      (name) => {
        formats[name] = {
          block: name,
          remove: "all",
        };
      }
    );
    return formats;
  };

  const genericBase = {
    remove_similar: true,
    inherit: false,
  };
  const cellBase = {
    selector: "td,th",
    ...genericBase,
  };
  const cellFormats = {
    tablecellbackgroundcolor: {
      styles: { backgroundColor: "%value" },
      ...cellBase,
    },
    tablecellverticalalign: {
      styles: { "vertical-align": "%value" },
      ...cellBase,
    },
    tablecellbordercolor: {
      styles: { borderColor: "%value" },
      ...cellBase,
    },
    tablecellclass: {
      classes: ["%value"],
      ...cellBase,
    },
    tableclass: {
      selector: "table",
      classes: ["%value"],
      ...genericBase,
    },
    tablecellborderstyle: {
      styles: { borderStyle: "%value" },
      ...cellBase,
    },
    tablecellborderwidth: {
      styles: { borderWidth: "%value" },
      ...cellBase,
    },
  };
  const get = constant(cellFormats);

  const FormatRegistry = (editor) => {
    const formats = {};
    const get$2 = (name) => (isNonNullable(name) ? formats[name] : formats);
    const has = (name) => has$2(formats, name);
    const register = (name, format) => {
      if (name) {
        if (!isString(name)) {
          each$d(name, (format, name) => {
            register(name, format);
          });
        } else {
          if (!isArray$1(format)) {
            format = [format];
          }
          each$e(format, (format) => {
            if (isUndefined(format.deep)) {
              format.deep = !isSelectorFormat(format);
            }
            if (isUndefined(format.split)) {
              format.split =
                !isSelectorFormat(format) || isInlineFormat(format);
            }
            if (
              isUndefined(format.remove) &&
              isSelectorFormat(format) &&
              !isInlineFormat(format)
            ) {
              format.remove = "none";
            }
            if (isSelectorFormat(format) && isInlineFormat(format)) {
              format.mixed = true;
              format.block_expand = true;
            }
            if (isString(format.classes)) {
              format.classes = format.classes.split(/\s+/);
            }
          });
          formats[name] = format;
        }
      }
    };
    const unregister = (name) => {
      if (name && formats[name]) {
        delete formats[name];
      }
      return formats;
    };
    register(get$1(editor));
    register(get());
    register(getFormats(editor));
    return {
      get: get$2,
      has,
      register,
      unregister,
    };
  };

  const each$3 = Tools.each;
  const dom = DOMUtils.DOM;
  const isPreviewItem = (item) => isNonNullable(item) && isObject(item);
  const parsedSelectorToHtml = (ancestry, editor) => {
    const schema = (editor && editor.schema) || Schema({});
    const decorate = (elm, item) => {
      if (item.classes.length > 0) {
        dom.addClass(elm, item.classes.join(" "));
      }
      dom.setAttribs(elm, item.attrs);
    };
    const createElement = (sItem) => {
      const item = isString(sItem)
        ? {
            name: sItem,
            classes: [],
            attrs: {},
          }
        : sItem;
      const elm = dom.create(item.name);
      decorate(elm, item);
      return elm;
    };
    const getRequiredParent = (elm, candidate) => {
      const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
      const parentsRequired =
        elmRule === null || elmRule === void 0
          ? void 0
          : elmRule.parentsRequired;
      if (parentsRequired && parentsRequired.length) {
        return candidate && contains$2(parentsRequired, candidate)
          ? candidate
          : parentsRequired[0];
      } else {
        return false;
      }
    };
    const wrapInHtml = (elm, ancestors, siblings) => {
      let parentCandidate;
      const ancestor = ancestors[0];
      const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;
      const parentRequired = getRequiredParent(elm, ancestorName);
      if (parentRequired) {
        if (ancestorName === parentRequired) {
          parentCandidate = ancestor;
          ancestors = ancestors.slice(1);
        } else {
          parentCandidate = parentRequired;
        }
      } else if (ancestor) {
        parentCandidate = ancestor;
        ancestors = ancestors.slice(1);
      } else if (!siblings) {
        return elm;
      }
      const parent = parentCandidate
        ? createElement(parentCandidate)
        : dom.create("div");
      parent.appendChild(elm);
      if (siblings) {
        Tools.each(siblings, (sibling) => {
          const siblingElm = createElement(sibling);
          parent.insertBefore(siblingElm, elm);
        });
      }
      const parentSiblings = isPreviewItem(parentCandidate)
        ? parentCandidate.siblings
        : undefined;
      return wrapInHtml(parent, ancestors, parentSiblings);
    };
    const fragment = dom.create("div");
    if (ancestry.length > 0) {
      const item = ancestry[0];
      const elm = createElement(item);
      const siblings = isPreviewItem(item) ? item.siblings : undefined;
      fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));
    }
    return fragment;
  };
  const parseSelectorItem = (item) => {
    item = Tools.trim(item);
    let tagName = "div";
    const obj = {
      name: tagName,
      classes: [],
      attrs: {},
      selector: item,
    };
    if (item !== "*") {
      tagName = item.replace(
        /(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g,
        ($0, $1, $2, $3, $4) => {
          switch ($1) {
            case "#":
              obj.attrs.id = $2;
              break;
            case ".":
              obj.classes.push($2);
              break;
            case ":":
              if (
                Tools.inArray(
                  "checked disabled enabled read-only required".split(" "),
                  $2
                ) !== -1
              ) {
                obj.attrs[$2] = $2;
              }
              break;
          }
          if ($3 === "[") {
            const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            if (m) {
              obj.attrs[m[1]] = m[2];
            }
          }
          return "";
        }
      );
    }
    obj.name = tagName || "div";
    return obj;
  };
  const parseSelector = (selector) => {
    if (!isString(selector)) {
      return [];
    }
    selector = selector.split(/\s*,\s*/)[0];
    selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
    return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), (item) => {
      const siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
      const obj = siblings.pop();
      if (siblings.length) {
        obj.siblings = siblings;
      }
      return obj;
    }).reverse();
  };
  const getCssText = (editor, format) => {
    let previewCss = "";
    let previewStyles = getPreviewStyles(editor);
    if (previewStyles === "") {
      return "";
    }
    const removeVars = (val) => {
      return isString(val) ? val.replace(/%(\w+)/g, "") : "";
    };
    const getComputedStyle = (name, elm) => {
      return dom.getStyle(
        elm !== null && elm !== void 0 ? elm : editor.getBody(),
        name,
        true
      );
    };
    if (isString(format)) {
      const formats = editor.formatter.get(format);
      if (!formats) {
        return "";
      }
      format = formats[0];
    }
    if ("preview" in format) {
      const preview = format.preview;
      if (preview === false) {
        return "";
      } else {
        previewStyles = preview || previewStyles;
      }
    }
    let name = format.block || format.inline || "span";
    let previewFrag;
    const items = parseSelector(format.selector);
    if (items.length > 0) {
      if (!items[0].name) {
        items[0].name = name;
      }
      name = format.selector;
      previewFrag = parsedSelectorToHtml(items, editor);
    } else {
      previewFrag = parsedSelectorToHtml([name], editor);
    }
    const previewElm =
      dom.select(name, previewFrag)[0] || previewFrag.firstChild;
    each$3(format.styles, (value, name) => {
      const newValue = removeVars(value);
      if (newValue) {
        dom.setStyle(previewElm, name, newValue);
      }
    });
    each$3(format.attributes, (value, name) => {
      const newValue = removeVars(value);
      if (newValue) {
        dom.setAttrib(previewElm, name, newValue);
      }
    });
    each$3(format.classes, (value) => {
      const newValue = removeVars(value);
      if (!dom.hasClass(previewElm, newValue)) {
        dom.addClass(previewElm, newValue);
      }
    });
    editor.dispatch("PreviewFormats");
    dom.setStyles(previewFrag, {
      position: "absolute",
      left: -65535,
    });
    editor.getBody().appendChild(previewFrag);
    const rawParentFontSize = getComputedStyle("fontSize");
    const parentFontSize = /px$/.test(rawParentFontSize)
      ? parseInt(rawParentFontSize, 10)
      : 0;
    each$3(previewStyles.split(" "), (name) => {
      let value = getComputedStyle(name, previewElm);
      if (
        name === "background-color" &&
        /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)
      ) {
        value = getComputedStyle(name);
        if (rgbaToHexString(value).toLowerCase() === "#ffffff") {
          return;
        }
      }
      if (name === "color") {
        if (rgbaToHexString(value).toLowerCase() === "#000000") {
          return;
        }
      }
      if (name === "font-size") {
        if (/em|%$/.test(value)) {
          if (parentFontSize === 0) {
            return;
          }
          const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
          value = numValue * parentFontSize + "px";
        }
      }
      if (name === "border" && value) {
        previewCss += "padding:0 2px;";
      }
      previewCss += name + ":" + value + ";";
    });
    editor.dispatch("AfterPreviewFormats");
    dom.remove(previewFrag);
    return previewCss;
  };

  const setup$s = (editor) => {
    editor.addShortcut("meta+b", "", "Bold");
    editor.addShortcut("meta+i", "", "Italic");
    editor.addShortcut("meta+u", "", "Underline");
    for (let i = 1; i <= 6; i++) {
      editor.addShortcut("access+" + i, "", ["FormatBlock", false, "h" + i]);
    }
    editor.addShortcut("access+7", "", ["FormatBlock", false, "p"]);
    editor.addShortcut("access+8", "", ["FormatBlock", false, "div"]);
    editor.addShortcut("access+9", "", ["FormatBlock", false, "address"]);
  };

  const Formatter = (editor) => {
    const formats = FormatRegistry(editor);
    const formatChangeState = Cell({});
    setup$s(editor);
    setup$v(editor);
    if (!isRtc(editor)) {
      setup$u(formatChangeState, editor);
    }
    return {
      get: formats.get,
      has: formats.has,
      register: formats.register,
      unregister: formats.unregister,
      apply: (name, vars, node) => {
        applyFormat(editor, name, vars, node);
      },
      remove: (name, vars, node, similar) => {
        removeFormat(editor, name, vars, node, similar);
      },
      toggle: (name, vars, node) => {
        toggleFormat(editor, name, vars, node);
      },
      match: (name, vars, node, similar) =>
        matchFormat(editor, name, vars, node, similar),
      closest: (names) => closestFormat(editor, names),
      matchAll: (names, vars) => matchAllFormats(editor, names, vars),
      matchNode: (node, name, vars, similar) =>
        matchNodeFormat(editor, node, name, vars, similar),
      canApply: (name) => canApplyFormat(editor, name),
      formatChanged: (formats, callback, similar, vars) =>
        formatChanged(
          editor,
          formatChangeState,
          formats,
          callback,
          similar,
          vars
        ),
      getCssText: curry(getCssText, editor),
    };
  };

  const shouldIgnoreCommand = (cmd) => {
    switch (cmd.toLowerCase()) {
      case "undo":
      case "redo":
      case "mcefocus":
        return true;
      default:
        return false;
    }
  };
  const registerEvents = (editor, undoManager, locks) => {
    const isFirstTypedCharacter = Cell(false);
    const addNonTypingUndoLevel = (e) => {
      setTyping(undoManager, false, locks);
      undoManager.add({}, e);
    };
    editor.on("init", () => {
      undoManager.add();
    });
    editor.on("BeforeExecCommand", (e) => {
      const cmd = e.command;
      if (!shouldIgnoreCommand(cmd)) {
        endTyping(undoManager, locks);
        undoManager.beforeChange();
      }
    });
    editor.on("ExecCommand", (e) => {
      const cmd = e.command;
      if (!shouldIgnoreCommand(cmd)) {
        addNonTypingUndoLevel(e);
      }
    });
    editor.on("ObjectResizeStart cut", () => {
      undoManager.beforeChange();
    });
    editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
    editor.on("dragend", addNonTypingUndoLevel);
    editor.on("keyup", (e) => {
      const keyCode = e.keyCode;
      if (e.isDefaultPrevented()) {
        return;
      }
      const isMeta = Env.os.isMacOS() && e.key === "Meta";
      if (
        (keyCode >= 33 && keyCode <= 36) ||
        (keyCode >= 37 && keyCode <= 40) ||
        keyCode === 45 ||
        e.ctrlKey ||
        isMeta
      ) {
        addNonTypingUndoLevel();
        editor.nodeChanged();
      }
      if (keyCode === 46 || keyCode === 8) {
        editor.nodeChanged();
      }
      if (
        isFirstTypedCharacter.get() &&
        undoManager.typing &&
        !isEq$1(createFromEditor(editor), undoManager.data[0])
      ) {
        if (!editor.isDirty()) {
          editor.setDirty(true);
        }
        editor.dispatch("TypingUndo");
        isFirstTypedCharacter.set(false);
        editor.nodeChanged();
      }
    });
    editor.on("keydown", (e) => {
      const keyCode = e.keyCode;
      if (e.isDefaultPrevented()) {
        return;
      }
      if (
        (keyCode >= 33 && keyCode <= 36) ||
        (keyCode >= 37 && keyCode <= 40) ||
        keyCode === 45
      ) {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
        return;
      }
      const modKey = (e.ctrlKey && !e.altKey) || e.metaKey;
      if (
        (keyCode < 16 || keyCode > 20) &&
        keyCode !== 224 &&
        keyCode !== 91 &&
        !undoManager.typing &&
        !modKey
      ) {
        undoManager.beforeChange();
        setTyping(undoManager, true, locks);
        undoManager.add({}, e);
        isFirstTypedCharacter.set(true);
        return;
      }
      const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS()
        ? e.metaKey
        : e.ctrlKey && !e.altKey;
      if (hasOnlyMetaOrCtrlModifier) {
        undoManager.beforeChange();
      }
    });
    editor.on("mousedown", (e) => {
      if (undoManager.typing) {
        addNonTypingUndoLevel(e);
      }
    });
    const isInsertReplacementText = (event) =>
      event.inputType === "insertReplacementText";
    const isInsertTextDataNull = (event) =>
      event.inputType === "insertText" && event.data === null;
    const isInsertFromPasteOrDrop = (event) =>
      event.inputType === "insertFromPaste" ||
      event.inputType === "insertFromDrop";
    editor.on("input", (e) => {
      if (
        e.inputType &&
        (isInsertReplacementText(e) ||
          isInsertTextDataNull(e) ||
          isInsertFromPasteOrDrop(e))
      ) {
        addNonTypingUndoLevel(e);
      }
    });
    editor.on("AddUndo Undo Redo ClearUndos", (e) => {
      if (!e.isDefaultPrevented()) {
        editor.nodeChanged();
      }
    });
  };
  const addKeyboardShortcuts = (editor) => {
    editor.addShortcut("meta+z", "", "Undo");
    editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
  };

  const UndoManager = (editor) => {
    const beforeBookmark = value$2();
    const locks = Cell(0);
    const index = Cell(0);
    const undoManager = {
      data: [],
      typing: false,
      beforeChange: () => {
        beforeChange(editor, locks, beforeBookmark);
      },
      add: (level, event) => {
        return addUndoLevel(
          editor,
          undoManager,
          index,
          locks,
          beforeBookmark,
          level,
          event
        );
      },
      dispatchChange: () => {
        editor.setDirty(true);
        const level = createFromEditor(editor);
        level.bookmark = getUndoBookmark(editor.selection);
        editor.dispatch("change", {
          level,
          lastLevel: get$b(undoManager.data, index.get()).getOrUndefined(),
        });
      },
      undo: () => {
        return undo(editor, undoManager, locks, index);
      },
      redo: () => {
        return redo(editor, index, undoManager.data);
      },
      clear: () => {
        clear(editor, undoManager, index);
      },
      reset: () => {
        reset(editor, undoManager);
      },
      hasUndo: () => {
        return hasUndo(editor, undoManager, index);
      },
      hasRedo: () => {
        return hasRedo(editor, undoManager, index);
      },
      transact: (callback) => {
        return transact(editor, undoManager, locks, callback);
      },
      ignore: (callback) => {
        ignore(editor, locks, callback);
      },
      extra: (callback1, callback2) => {
        extra(editor, undoManager, index, callback1, callback2);
      },
    };
    if (!isRtc(editor)) {
      registerEvents(editor, undoManager, locks);
    }
    addKeyboardShortcuts(editor);
    return undoManager;
  };

  const nonTypingKeycodes = [
    9,
    27,
    VK.HOME,
    VK.END,
    19,
    20,
    44,
    144,
    145,
    33,
    34,
    45,
    16,
    17,
    18,
    91,
    92,
    93,
    VK.DOWN,
    VK.UP,
    VK.LEFT,
    VK.RIGHT,
  ].concat(Env.browser.isFirefox() ? [224] : []);
  const placeholderAttr = "data-mce-placeholder";
  const isKeyboardEvent = (e) => e.type === "keydown" || e.type === "keyup";
  const isDeleteEvent = (e) => {
    const keyCode = e.keyCode;
    return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
  };
  const isNonTypingKeyboardEvent = (e) => {
    if (isKeyboardEvent(e)) {
      const keyCode = e.keyCode;
      return (
        !isDeleteEvent(e) &&
        (VK.metaKeyPressed(e) ||
          e.altKey ||
          (keyCode >= 112 && keyCode <= 123) ||
          contains$2(nonTypingKeycodes, keyCode))
      );
    } else {
      return false;
    }
  };
  const isTypingKeyboardEvent = (e) =>
    isKeyboardEvent(e) &&
    !(isDeleteEvent(e) || (e.type === "keyup" && e.keyCode === 229));
  const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {
    if (
      dom.isEmpty(rootElm, undefined, {
        skipBogus: false,
        includeZwsp: true,
      })
    ) {
      const firstElement = rootElm.firstElementChild;
      if (!firstElement) {
        return true;
      } else if (
        dom.getStyle(rootElm.firstElementChild, "padding-left") ||
        dom.getStyle(rootElm.firstElementChild, "padding-right")
      ) {
        return false;
      } else {
        return forcedRootBlock === firstElement.nodeName.toLowerCase();
      }
    } else {
      return false;
    }
  };
  const setup$r = (editor) => {
    var _a;
    const dom = editor.dom;
    const rootBlock = getForcedRootBlock(editor);
    const placeholder =
      (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : "";
    const updatePlaceholder = (e, initial) => {
      if (isNonTypingKeyboardEvent(e)) {
        return;
      }
      const body = editor.getBody();
      const showPlaceholder = isTypingKeyboardEvent(e)
        ? false
        : isVisuallyEmpty(dom, body, rootBlock);
      const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== "";
      if (isPlaceholderShown !== showPlaceholder || initial) {
        dom.setAttrib(
          body,
          placeholderAttr,
          showPlaceholder ? placeholder : null
        );
        firePlaceholderToggle(editor, showPlaceholder);
        editor.on(showPlaceholder ? "keydown" : "keyup", updatePlaceholder);
        editor.off(showPlaceholder ? "keyup" : "keydown", updatePlaceholder);
      }
    };
    if (isNotEmpty(placeholder)) {
      editor.on("init", (e) => {
        updatePlaceholder(e, true);
        editor.on("change SetContent ExecCommand", updatePlaceholder);
        editor.on("paste", (e) =>
          Delay.setEditorTimeout(editor, () => updatePlaceholder(e))
        );
      });
    }
  };

  const blockPosition = (block, position) => ({
    block,
    position,
  });
  const blockBoundary = (from, to) => ({
    from,
    to,
  });
  const getBlockPosition = (rootNode, pos) => {
    const rootElm = SugarElement.fromDom(rootNode);
    const containerElm = SugarElement.fromDom(pos.container());
    return getParentBlock$2(rootElm, containerElm).map((block) =>
      blockPosition(block, pos)
    );
  };
  const isNotAncestorial = (blockBoundary) =>
    !(
      contains(blockBoundary.to.block, blockBoundary.from.block) ||
      contains(blockBoundary.from.block, blockBoundary.to.block)
    );
  const isDifferentBlocks = (blockBoundary) =>
    !eq(blockBoundary.from.block, blockBoundary.to.block);
  const getClosestHost = (root, scope) => {
    const isRoot = (node) => eq(node, root);
    const isHost = (node) =>
      isTableCell$2(node) || isContentEditableTrue$3(node.dom);
    return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);
  };
  const hasSameHost = (rootNode, blockBoundary) => {
    const root = SugarElement.fromDom(rootNode);
    return eq(
      getClosestHost(root, blockBoundary.from.block),
      getClosestHost(root, blockBoundary.to.block)
    );
  };
  const isEditable$1 = (blockBoundary) =>
    isContentEditableFalse$b(blockBoundary.from.block.dom) === false &&
    isContentEditableFalse$b(blockBoundary.to.block.dom) === false;
  const hasValidBlocks = (blockBoundary) => {
    const isValidBlock = (block) =>
      isTextBlock$2(block) || hasBlockAttr(block.dom) || isListItem$1(block);
    return (
      isValidBlock(blockBoundary.from.block) &&
      isValidBlock(blockBoundary.to.block)
    );
  };
  const skipLastBr = (schema, rootNode, forward, blockPosition) => {
    if (
      isBr$6(blockPosition.position.getNode()) &&
      !isEmpty$2(schema, blockPosition.block)
    ) {
      return positionIn(false, blockPosition.block.dom)
        .bind((lastPositionInBlock) => {
          if (lastPositionInBlock.isEqual(blockPosition.position)) {
            return fromPosition(forward, rootNode, lastPositionInBlock).bind(
              (to) => getBlockPosition(rootNode, to)
            );
          } else {
            return Optional.some(blockPosition);
          }
        })
        .getOr(blockPosition);
    } else {
      return blockPosition;
    }
  };
  const readFromRange = (schema, rootNode, forward, rng) => {
    const fromBlockPos = getBlockPosition(
      rootNode,
      CaretPosition.fromRangeStart(rng)
    );
    const toBlockPos = fromBlockPos.bind((blockPos) =>
      fromPosition(forward, rootNode, blockPos.position).bind((to) =>
        getBlockPosition(rootNode, to).map((blockPos) =>
          skipLastBr(schema, rootNode, forward, blockPos)
        )
      )
    );
    return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(
      (blockBoundary) =>
        isDifferentBlocks(blockBoundary) &&
        hasSameHost(rootNode, blockBoundary) &&
        isEditable$1(blockBoundary) &&
        hasValidBlocks(blockBoundary) &&
        isNotAncestorial(blockBoundary)
    );
  };
  const read$1 = (schema, rootNode, forward, rng) =>
    rng.collapsed
      ? readFromRange(schema, rootNode, forward, rng)
      : Optional.none();

  const getChildrenUntilBlockBoundary = (block, schema) => {
    const children = children$1(block);
    return findIndex$2(children, (el) => schema.isBlock(name(el))).fold(
      constant(children),
      (index) => children.slice(0, index)
    );
  };
  const extractChildren = (block, schema) => {
    const children = getChildrenUntilBlockBoundary(block, schema);
    each$e(children, remove$4);
    return children;
  };
  const removeEmptyRoot = (schema, rootNode, block) => {
    const parents = parentsAndSelf(block, rootNode);
    return find$2(parents.reverse(), (element) =>
      isEmpty$2(schema, element)
    ).each(remove$4);
  };
  const isEmptyBefore = (schema, el) =>
    filter$5(prevSiblings(el), (el) => !isEmpty$2(schema, el)).length === 0;
  const nestedBlockMerge = (
    rootNode,
    fromBlock,
    toBlock,
    schema,
    insertionPoint
  ) => {
    if (isEmpty$2(schema, toBlock)) {
      fillWithPaddingBr(toBlock);
      return firstPositionIn(toBlock.dom);
    }
    if (isEmptyBefore(schema, insertionPoint) && isEmpty$2(schema, fromBlock)) {
      before$3(insertionPoint, SugarElement.fromTag("br"));
    }
    const position = prevPosition(
      toBlock.dom,
      CaretPosition.before(insertionPoint.dom)
    );
    each$e(extractChildren(fromBlock, schema), (child) => {
      before$3(insertionPoint, child);
    });
    removeEmptyRoot(schema, rootNode, fromBlock);
    return position;
  };
  const isInline = (schema, node) => schema.isInline(name(node));
  const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {
    if (isEmpty$2(schema, toBlock)) {
      if (isEmpty$2(schema, fromBlock)) {
        const getInlineToBlockDescendants = (el) => {
          const helper = (node, elements) =>
            firstChild(node).fold(
              () => elements,
              (child) =>
                isInline(schema, child)
                  ? helper(child, elements.concat(shallow$1(child)))
                  : elements
            );
          return helper(el, []);
        };
        const newFromBlockDescendants = foldr(
          getInlineToBlockDescendants(toBlock),
          (element, descendant) => {
            wrap$2(element, descendant);
            return descendant;
          },
          createPaddingBr()
        );
        empty(fromBlock);
        append$1(fromBlock, newFromBlockDescendants);
      }
      remove$4(toBlock);
      return firstPositionIn(fromBlock.dom);
    }
    const position = lastPositionIn(toBlock.dom);
    each$e(extractChildren(fromBlock, schema), (child) => {
      append$1(toBlock, child);
    });
    removeEmptyRoot(schema, rootNode, fromBlock);
    return position;
  };
  const findInsertionPoint = (toBlock, block) => {
    const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
    return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
  };
  const getInsertionPoint = (fromBlock, toBlock) =>
    contains(toBlock, fromBlock)
      ? findInsertionPoint(toBlock, fromBlock)
      : Optional.none();
  const trimBr = (first, block) => {
    positionIn(first, block.dom)
      .bind((position) => Optional.from(position.getNode()))
      .map(SugarElement.fromDom)
      .filter(isBr$5)
      .each(remove$4);
  };
  const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {
    trimBr(true, fromBlock);
    trimBr(false, toBlock);
    return getInsertionPoint(fromBlock, toBlock).fold(
      curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema),
      curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema)
    );
  };
  const mergeBlocks = (rootNode, forward, block1, block2, schema) =>
    forward
      ? mergeBlockInto(rootNode, block2, block1, schema)
      : mergeBlockInto(rootNode, block1, block2, schema);

  const backspaceDelete$a = (editor, forward) => {
    const rootNode = SugarElement.fromDom(editor.getBody());
    const position = read$1(
      editor.schema,
      rootNode.dom,
      forward,
      editor.selection.getRng()
    ).map((blockBoundary) => () => {
      mergeBlocks(
        rootNode,
        forward,
        blockBoundary.from.block,
        blockBoundary.to.block,
        editor.schema
      ).each((pos) => {
        editor.selection.setRng(pos.toRange());
      });
    });
    return position;
  };

  const deleteRangeMergeBlocks = (rootNode, selection, schema) => {
    const rng = selection.getRng();
    return lift2(
      getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)),
      getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)),
      (block1, block2) => {
        if (!eq(block1, block2)) {
          return Optional.some(() => {
            rng.deleteContents();
            mergeBlocks(rootNode, true, block1, block2, schema).each((pos) => {
              selection.setRng(pos.toRange());
            });
          });
        } else {
          return Optional.none();
        }
      }
    ).getOr(Optional.none());
  };
  const isRawNodeInTable = (root, rawNode) => {
    const node = SugarElement.fromDom(rawNode);
    const isRoot = curry(eq, root);
    return ancestor$4(node, isTableCell$2, isRoot).isSome();
  };
  const isSelectionInTable = (root, rng) =>
    isRawNodeInTable(root, rng.startContainer) ||
    isRawNodeInTable(root, rng.endContainer);
  const isEverythingSelected = (root, rng) => {
    const noPrevious = prevPosition(
      root.dom,
      CaretPosition.fromRangeStart(rng)
    ).isNone();
    const noNext = nextPosition(
      root.dom,
      CaretPosition.fromRangeEnd(rng)
    ).isNone();
    return !isSelectionInTable(root, rng) && noPrevious && noNext;
  };
  const emptyEditor = (editor) => {
    return Optional.some(() => {
      editor.setContent("");
      editor.selection.setCursorLocation();
    });
  };
  const deleteRange$2 = (editor) => {
    const rootNode = SugarElement.fromDom(editor.getBody());
    const rng = editor.selection.getRng();
    return isEverythingSelected(rootNode, rng)
      ? emptyEditor(editor)
      : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);
  };
  const backspaceDelete$9 = (editor, _forward) =>
    editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);

  const showCaret = (direction, editor, node, before, scrollIntoView) =>
    Optional.from(
      editor._selectionOverrides.showCaret(
        direction,
        node,
        before,
        scrollIntoView
      )
    );
  const getNodeRange = (node) => {
    const rng = node.ownerDocument.createRange();
    rng.selectNode(node);
    return rng;
  };
  const selectNode = (editor, node) => {
    const e = editor.dispatch("BeforeObjectSelected", { target: node });
    if (e.isDefaultPrevented()) {
      return Optional.none();
    }
    return Optional.some(getNodeRange(node));
  };
  const renderCaretAtRange = (editor, range, scrollIntoView) => {
    const normalizedRange = normalizeRange(1, editor.getBody(), range);
    const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
    const caretPositionNode = caretPosition.getNode();
    if (isInlineFakeCaretTarget(caretPositionNode)) {
      return showCaret(
        1,
        editor,
        caretPositionNode,
        !caretPosition.isAtEnd(),
        false
      );
    }
    const caretPositionBeforeNode = caretPosition.getNode(true);
    if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
      return showCaret(1, editor, caretPositionBeforeNode, false, false);
    }
    const ceRoot = getContentEditableRoot$1(
      editor.dom.getRoot(),
      caretPosition.getNode()
    );
    if (isInlineFakeCaretTarget(ceRoot)) {
      return showCaret(1, editor, ceRoot, false, scrollIntoView);
    }
    return Optional.none();
  };
  const renderRangeCaret = (editor, range, scrollIntoView) =>
    range.collapsed
      ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range)
      : range;

  const isBeforeBoundary = (pos) =>
    isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
  const isAfterBoundary = (pos) =>
    isAfterContentEditableFalse(pos) || isAfterMedia(pos);
  const trimEmptyTextNode = (dom, node) => {
    if (isText$b(node) && node.data.length === 0) {
      dom.remove(node);
    }
  };
  const deleteContentAndShowCaret = (
    editor,
    range,
    node,
    direction,
    forward,
    peekCaretPosition
  ) => {
    showCaret(
      direction,
      editor,
      peekCaretPosition.getNode(!forward),
      forward,
      true
    ).each((caretRange) => {
      if (range.collapsed) {
        const deleteRange = range.cloneRange();
        if (forward) {
          deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
        } else {
          deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
        }
        deleteRange.deleteContents();
      } else {
        range.deleteContents();
      }
      editor.selection.setRng(caretRange);
    });
    trimEmptyTextNode(editor.dom, node);
  };
  const deleteBoundaryText = (editor, forward) => {
    const range = editor.selection.getRng();
    if (!isText$b(range.commonAncestorContainer)) {
      return Optional.none();
    }
    const direction = forward ? 1 : -1;
    const caretWalker = CaretWalker(editor.getBody());
    const getNextPosFn = curry(
      getVisualCaretPosition,
      forward ? caretWalker.next : caretWalker.prev
    );
    const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
    const caretPosition = getNormalizedRangeEndPoint(
      direction,
      editor.getBody(),
      range
    );
    const nextCaretPosition = getNextPosFn(caretPosition);
    const normalizedNextCaretPosition = nextCaretPosition
      ? normalizePosition(forward, nextCaretPosition)
      : nextCaretPosition;
    if (
      !normalizedNextCaretPosition ||
      !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)
    ) {
      return Optional.none();
    } else if (isBeforeFn(normalizedNextCaretPosition)) {
      return Optional.some(() =>
        deleteContentAndShowCaret(
          editor,
          range,
          caretPosition.getNode(),
          direction,
          forward,
          normalizedNextCaretPosition
        )
      );
    }
    const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
      if (
        isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)
      ) {
        return Optional.some(() =>
          deleteContentAndShowCaret(
            editor,
            range,
            caretPosition.getNode(),
            direction,
            forward,
            peekCaretPosition
          )
        );
      }
    }
    return Optional.none();
  };
  const backspaceDelete$8 = (editor, forward) =>
    deleteBoundaryText(editor, forward);

  const getEdgeCefPosition = (editor, atStart) => {
    const root = editor.getBody();
    return atStart
      ? firstPositionIn(root).filter(isBeforeContentEditableFalse)
      : lastPositionIn(root).filter(isAfterContentEditableFalse);
  };
  const isCefAtEdgeSelected = (editor) => {
    const rng = editor.selection.getRng();
    return (
      !rng.collapsed &&
      (getEdgeCefPosition(editor, true).exists((pos) =>
        pos.isEqual(CaretPosition.fromRangeStart(rng))
      ) ||
        getEdgeCefPosition(editor, false).exists((pos) =>
          pos.isEqual(CaretPosition.fromRangeEnd(rng))
        ))
    );
  };

  const isCompoundElement = (node) =>
    isNonNullable(node) &&
    (isTableCell$2(SugarElement.fromDom(node)) ||
      isListItem$1(SugarElement.fromDom(node)));
  const DeleteAction = Adt.generate([
    { remove: ["element"] },
    { moveToElement: ["element"] },
    { moveToPosition: ["position"] },
  ]);
  const isAtContentEditableBlockCaret = (forward, from) => {
    const elm = from.getNode(!forward);
    const caretLocation = forward ? "after" : "before";
    return (
      isElement$6(elm) && elm.getAttribute("data-mce-caret") === caretLocation
    );
  };
  const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {
    const inSameBlock = (elm) =>
      schema.isInline(elm.nodeName.toLowerCase()) &&
      !isInSameBlock(from, to, root);
    return getRelativeCefElm(!forward, from).fold(
      () => getRelativeCefElm(forward, to).fold(never, inSameBlock),
      inSameBlock
    );
  };
  const deleteEmptyBlockOrMoveToCef = (schema, root, forward, from, to) => {
    const toCefElm = to.getNode(!forward);
    return getParentBlock$2(
      SugarElement.fromDom(root),
      SugarElement.fromDom(from.getNode())
    )
      .map((blockElm) =>
        isEmpty$2(schema, blockElm)
          ? DeleteAction.remove(blockElm.dom)
          : DeleteAction.moveToElement(toCefElm)
      )
      .orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
  };
  const findCefPosition = (root, forward, from, schema) =>
    fromPosition(forward, root, from).bind((to) => {
      if (isCompoundElement(to.getNode())) {
        return Optional.none();
      } else if (
        isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)
      ) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(to.getNode())) {
        return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);
      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {
        return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);
      } else if (forward && isAfterContentEditableFalse(from)) {
        return Optional.some(DeleteAction.moveToPosition(to));
      } else if (!forward && isBeforeContentEditableFalse(from)) {
        return Optional.some(DeleteAction.moveToPosition(to));
      } else {
        return Optional.none();
      }
    });
  const getContentEditableBlockAction = (forward, elm) => {
    if (isNullable(elm)) {
      return Optional.none();
    } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {
      return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
    } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {
      return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
    } else {
      return Optional.none();
    }
  };
  const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) =>
    deleteAction.fold(
      (elm) => Optional.some(DeleteAction.remove(elm)),
      (elm) => Optional.some(DeleteAction.moveToElement(elm)),
      (to) => {
        if (isInSameBlock(from, to, root)) {
          return Optional.none();
        } else {
          return Optional.some(DeleteAction.moveToPosition(to));
        }
      }
    );
  const getContentEditableAction = (root, forward, from, schema) => {
    if (isAtContentEditableBlockCaret(forward, from)) {
      return getContentEditableBlockAction(
        forward,
        from.getNode(!forward)
      ).orThunk(() => findCefPosition(root, forward, from, schema));
    } else {
      return findCefPosition(root, forward, from, schema).bind((deleteAction) =>
        skipMoveToActionFromInlineCefToContent(root, from, deleteAction)
      );
    }
  };
  const read = (root, forward, rng, schema) => {
    const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
    const from = CaretPosition.fromRangeStart(normalizedRange);
    const rootElement = SugarElement.fromDom(root);
    if (!forward && isAfterContentEditableFalse(from)) {
      return Optional.some(DeleteAction.remove(from.getNode(true)));
    } else if (forward && isBeforeContentEditableFalse(from)) {
      return Optional.some(DeleteAction.remove(from.getNode()));
    } else if (
      !forward &&
      isBeforeContentEditableFalse(from) &&
      isAfterBr(rootElement, from, schema)
    ) {
      return findPreviousBr(rootElement, from, schema).map((br) =>
        DeleteAction.remove(br.getNode())
      );
    } else if (
      forward &&
      isAfterContentEditableFalse(from) &&
      isBeforeBr$1(rootElement, from, schema)
    ) {
      return findNextBr(rootElement, from, schema).map((br) =>
        DeleteAction.remove(br.getNode())
      );
    } else {
      return getContentEditableAction(root, forward, from, schema);
    }
  };

  const deleteElement$1 = (editor, forward) => (element) => {
    editor._selectionOverrides.hideFakeCaret();
    deleteElement$2(editor, forward, SugarElement.fromDom(element));
    return true;
  };
  const moveToElement = (editor, forward) => (element) => {
    const pos = forward
      ? CaretPosition.before(element)
      : CaretPosition.after(element);
    editor.selection.setRng(pos.toRange());
    return true;
  };
  const moveToPosition = (editor) => (pos) => {
    editor.selection.setRng(pos.toRange());
    return true;
  };
  const getAncestorCe = (editor, node) =>
    Optional.from(getContentEditableRoot$1(editor.getBody(), node));
  const backspaceDeleteCaret = (editor, forward) => {
    const selectedNode = editor.selection.getNode();
    return getAncestorCe(editor, selectedNode)
      .filter(isContentEditableFalse$b)
      .fold(
        () =>
          read(
            editor.getBody(),
            forward,
            editor.selection.getRng(),
            editor.schema
          ).map(
            (deleteAction) => () =>
              deleteAction.fold(
                deleteElement$1(editor, forward),
                moveToElement(editor, forward),
                moveToPosition(editor)
              )
          ),
        () => Optional.some(noop)
      );
  };
  const deleteOffscreenSelection = (rootElement) => {
    each$e(descendants(rootElement, ".mce-offscreen-selection"), remove$4);
  };
  const backspaceDeleteRange = (editor, forward) => {
    const selectedNode = editor.selection.getNode();
    if (
      isContentEditableFalse$b(selectedNode) &&
      !isTableCell$3(selectedNode)
    ) {
      const hasCefAncestor = getAncestorCe(
        editor,
        selectedNode.parentNode
      ).filter(isContentEditableFalse$b);
      return hasCefAncestor.fold(
        () =>
          Optional.some(() => {
            deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
            deleteElement$2(
              editor,
              forward,
              SugarElement.fromDom(editor.selection.getNode())
            );
            paddEmptyBody(editor);
          }),
        () => Optional.some(noop)
      );
    }
    if (isCefAtEdgeSelected(editor)) {
      return Optional.some(() => {
        deleteRangeContents(
          editor,
          editor.selection.getRng(),
          SugarElement.fromDom(editor.getBody())
        );
      });
    }
    return Optional.none();
  };
  const paddEmptyElement = (editor) => {
    const dom = editor.dom,
      selection = editor.selection;
    const ceRoot = getContentEditableRoot$1(
      editor.getBody(),
      selection.getNode()
    );
    if (
      isContentEditableTrue$3(ceRoot) &&
      dom.isBlock(ceRoot) &&
      dom.isEmpty(ceRoot)
    ) {
      const br = dom.create("br", { "data-mce-bogus": "1" });
      dom.setHTML(ceRoot, "");
      ceRoot.appendChild(br);
      selection.setRng(CaretPosition.before(br).toRange());
    }
    return true;
  };
  const backspaceDelete$7 = (editor, forward) => {
    if (editor.selection.isCollapsed()) {
      return backspaceDeleteCaret(editor, forward);
    } else {
      return backspaceDeleteRange(editor, forward);
    }
  };

  const isTextEndpoint = (endpoint) => endpoint.hasOwnProperty("text");
  const isElementEndpoint = (endpoint) => endpoint.hasOwnProperty("marker");
  const getBookmark = (range, createMarker) => {
    const getEndpoint = (container, offset) => {
      if (isText$b(container)) {
        return {
          text: container,
          offset,
        };
      } else {
        const marker = createMarker();
        const children = container.childNodes;
        if (offset < children.length) {
          container.insertBefore(marker, children[offset]);
          return {
            marker,
            before: true,
          };
        } else {
          container.appendChild(marker);
          return {
            marker,
            before: false,
          };
        }
      }
    };
    const end = getEndpoint(range.endContainer, range.endOffset);
    const start = getEndpoint(range.startContainer, range.startOffset);
    return {
      start,
      end,
    };
  };
  const resolveBookmark = (bm) => {
    var _a, _b;
    const { start, end } = bm;
    const rng = new window.Range();
    if (isTextEndpoint(start)) {
      rng.setStart(start.text, start.offset);
    } else {
      if (isElementEndpoint(start)) {
        if (start.before) {
          rng.setStartBefore(start.marker);
        } else {
          rng.setStartAfter(start.marker);
        }
        (_a = start.marker.parentNode) === null || _a === void 0
          ? void 0
          : _a.removeChild(start.marker);
      }
    }
    if (isTextEndpoint(end)) {
      rng.setEnd(end.text, end.offset);
    } else {
      if (isElementEndpoint(end)) {
        if (end.before) {
          rng.setEndBefore(end.marker);
        } else {
          rng.setEndAfter(end.marker);
        }
        (_b = end.marker.parentNode) === null || _b === void 0
          ? void 0
          : _b.removeChild(end.marker);
      }
    }
    return rng;
  };

  const backspaceDelete$6 = (editor, forward) => {
    var _a;
    const dom = editor.dom;
    const startBlock = dom.getParent(editor.selection.getStart(), dom.isBlock);
    const endBlock = dom.getParent(editor.selection.getEnd(), dom.isBlock);
    const body = editor.getBody();
    const startBlockName =
      (_a =
        startBlock === null || startBlock === void 0
          ? void 0
          : startBlock.nodeName) === null || _a === void 0
        ? void 0
        : _a.toLowerCase();
    if (
      startBlockName === "div" &&
      startBlock &&
      endBlock &&
      startBlock === body.firstChild &&
      endBlock === body.lastChild &&
      !dom.isEmpty(body)
    ) {
      const wrapper = startBlock.cloneNode(false);
      const deleteAction = () => {
        if (forward) {
          execNativeForwardDeleteCommand(editor);
        } else {
          execNativeDeleteCommand(editor);
        }
        if (body.firstChild !== startBlock) {
          const bookmark = getBookmark(editor.selection.getRng(), () =>
            document.createElement("span")
          );
          Array.from(body.childNodes).forEach((node) =>
            wrapper.appendChild(node)
          );
          body.appendChild(wrapper);
          editor.selection.setRng(resolveBookmark(bookmark));
        }
      };
      return Optional.some(deleteAction);
    }
    return Optional.none();
  };

  const deleteCaret$2 = (editor, forward) => {
    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
    return fromPosition(forward, editor.getBody(), fromPos)
      .filter((pos) =>
        forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)
      )
      .bind((pos) => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos))
      .map((elm) => () => editor.selection.select(elm));
  };
  const backspaceDelete$5 = (editor, forward) =>
    editor.selection.isCollapsed()
      ? deleteCaret$2(editor, forward)
      : Optional.none();

  const isText$2 = isText$b;
  const startsWithCaretContainer = (node) =>
    isText$2(node) && node.data[0] === ZWSP$1;
  const endsWithCaretContainer = (node) =>
    isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
  const createZwsp = (node) => {
    var _a;
    const doc =
      (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
    return doc.createTextNode(ZWSP$1);
  };
  const insertBefore$1 = (node) => {
    var _a;
    if (isText$2(node.previousSibling)) {
      if (endsWithCaretContainer(node.previousSibling)) {
        return node.previousSibling;
      } else {
        node.previousSibling.appendData(ZWSP$1);
        return node.previousSibling;
      }
    } else if (isText$2(node)) {
      if (startsWithCaretContainer(node)) {
        return node;
      } else {
        node.insertData(0, ZWSP$1);
        return node;
      }
    } else {
      const newNode = createZwsp(node);
      (_a = node.parentNode) === null || _a === void 0
        ? void 0
        : _a.insertBefore(newNode, node);
      return newNode;
    }
  };
  const insertAfter$1 = (node) => {
    var _a, _b;
    if (isText$2(node.nextSibling)) {
      if (startsWithCaretContainer(node.nextSibling)) {
        return node.nextSibling;
      } else {
        node.nextSibling.insertData(0, ZWSP$1);
        return node.nextSibling;
      }
    } else if (isText$2(node)) {
      if (endsWithCaretContainer(node)) {
        return node;
      } else {
        node.appendData(ZWSP$1);
        return node;
      }
    } else {
      const newNode = createZwsp(node);
      if (node.nextSibling) {
        (_a = node.parentNode) === null || _a === void 0
          ? void 0
          : _a.insertBefore(newNode, node.nextSibling);
      } else {
        (_b = node.parentNode) === null || _b === void 0
          ? void 0
          : _b.appendChild(newNode);
      }
      return newNode;
    }
  };
  const insertInline = (before, node) =>
    before ? insertBefore$1(node) : insertAfter$1(node);
  const insertInlineBefore = curry(insertInline, true);
  const insertInlineAfter = curry(insertInline, false);

  const insertInlinePos = (pos, before) => {
    if (isText$b(pos.container())) {
      return insertInline(before, pos.container());
    } else {
      return insertInline(before, pos.getNode());
    }
  };
  const isPosCaretContainer = (pos, caret) => {
    const caretNode = caret.get();
    return (
      caretNode &&
      pos.container() === caretNode &&
      isCaretContainerInline(caretNode)
    );
  };
  const renderCaret = (caret, location) =>
    location.fold(
      (element) => {
        remove$2(caret.get());
        const text = insertInlineBefore(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, text.length - 1));
      },
      (element) =>
        firstPositionIn(element).map((pos) => {
          if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            const text = insertInlinePos(pos, true);
            caret.set(text);
            return CaretPosition(text, 1);
          } else {
            const node = caret.get();
            return CaretPosition(node, 1);
          }
        }),
      (element) =>
        lastPositionIn(element).map((pos) => {
          if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            const text = insertInlinePos(pos, false);
            caret.set(text);
            return CaretPosition(text, text.length - 1);
          } else {
            const node = caret.get();
            return CaretPosition(node, node.length - 1);
          }
        }),
      (element) => {
        remove$2(caret.get());
        const text = insertInlineAfter(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, 1));
      }
    );

  const evaluateUntil = (fns, args) => {
    for (let i = 0; i < fns.length; i++) {
      const result = fns[i].apply(null, args);
      if (result.isSome()) {
        return result;
      }
    }
    return Optional.none();
  };

  const Location = Adt.generate([
    { before: ["element"] },
    { start: ["element"] },
    { end: ["element"] },
    { after: ["element"] },
  ]);
  const rescope$1 = (rootNode, node) => {
    const parentBlock = getParentBlock$3(node, rootNode);
    return parentBlock ? parentBlock : rootNode;
  };
  const before = (isInlineTarget, rootNode, pos) => {
    const nPos = normalizeForwards(pos);
    const scope = rescope$1(rootNode, nPos.container());
    return findRootInline(isInlineTarget, scope, nPos).fold(
      () =>
        nextPosition(scope, nPos)
          .bind(curry(findRootInline, isInlineTarget, scope))
          .map((inline) => Location.before(inline)),
      Optional.none
    );
  };
  const isNotInsideFormatCaretContainer = (rootNode, elm) =>
    getParentCaretContainer(rootNode, elm) === null;
  const findInsideRootInline = (isInlineTarget, rootNode, pos) =>
    findRootInline(isInlineTarget, rootNode, pos).filter(
      curry(isNotInsideFormatCaretContainer, rootNode)
    );
  const start$1 = (isInlineTarget, rootNode, pos) => {
    const nPos = normalizeBackwards(pos);
    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(
      (inline) => {
        const prevPos = prevPosition(inline, nPos);
        return prevPos.isNone()
          ? Optional.some(Location.start(inline))
          : Optional.none();
      }
    );
  };
  const end = (isInlineTarget, rootNode, pos) => {
    const nPos = normalizeForwards(pos);
    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(
      (inline) => {
        const nextPos = nextPosition(inline, nPos);
        return nextPos.isNone()
          ? Optional.some(Location.end(inline))
          : Optional.none();
      }
    );
  };
  const after = (isInlineTarget, rootNode, pos) => {
    const nPos = normalizeBackwards(pos);
    const scope = rescope$1(rootNode, nPos.container());
    return findRootInline(isInlineTarget, scope, nPos).fold(
      () =>
        prevPosition(scope, nPos)
          .bind(curry(findRootInline, isInlineTarget, scope))
          .map((inline) => Location.after(inline)),
      Optional.none
    );
  };
  const isValidLocation = (location) => !isRtl(getElement(location));
  const readLocation = (isInlineTarget, rootNode, pos) => {
    const location = evaluateUntil(
      [before, start$1, end, after],
      [isInlineTarget, rootNode, pos]
    );
    return location.filter(isValidLocation);
  };
  const getElement = (location) =>
    location.fold(identity, identity, identity, identity);
  const getName = (location) =>
    location.fold(
      constant("before"),
      constant("start"),
      constant("end"),
      constant("after")
    );
  const outside = (location) =>
    location.fold(
      Location.before,
      Location.before,
      Location.after,
      Location.after
    );
  const inside = (location) =>
    location.fold(Location.start, Location.start, Location.end, Location.end);
  const isEq = (location1, location2) =>
    getName(location1) === getName(location2) &&
    getElement(location1) === getElement(location2);
  const betweenInlines = (
    forward,
    isInlineTarget,
    rootNode,
    from,
    to,
    location
  ) =>
    lift2(
      findRootInline(isInlineTarget, rootNode, from),
      findRootInline(isInlineTarget, rootNode, to),
      (fromInline, toInline) => {
        if (
          fromInline !== toInline &&
          hasSameParentBlock(rootNode, fromInline, toInline)
        ) {
          return Location.after(forward ? fromInline : toInline);
        } else {
          return location;
        }
      }
    ).getOr(location);
  const skipNoMovement = (fromLocation, toLocation) =>
    fromLocation.fold(
      always,
      (fromLocation) => !isEq(fromLocation, toLocation)
    );
  const findLocationTraverse = (
    forward,
    isInlineTarget,
    rootNode,
    fromLocation,
    pos
  ) => {
    const from = normalizePosition(forward, pos);
    const to = fromPosition(forward, rootNode, from).map(
      curry(normalizePosition, forward)
    );
    const location = to.fold(
      () => fromLocation.map(outside),
      (to) =>
        readLocation(isInlineTarget, rootNode, to)
          .map(
            curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)
          )
          .filter(curry(skipNoMovement, fromLocation))
    );
    return location.filter(isValidLocation);
  };
  const findLocationSimple = (forward, location) => {
    if (forward) {
      return location.fold(
        compose(Optional.some, Location.start),
        Optional.none,
        compose(Optional.some, Location.after),
        Optional.none
      );
    } else {
      return location.fold(
        Optional.none,
        compose(Optional.some, Location.before),
        Optional.none,
        compose(Optional.some, Location.end)
      );
    }
  };
  const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {
    const from = normalizePosition(forward, pos);
    const fromLocation = readLocation(isInlineTarget, rootNode, from);
    return readLocation(isInlineTarget, rootNode, from)
      .bind(curry(findLocationSimple, forward))
      .orThunk(() =>
        findLocationTraverse(
          forward,
          isInlineTarget,
          rootNode,
          fromLocation,
          pos
        )
      );
  };

  const hasSelectionModifyApi = (editor) => {
    return isFunction(editor.selection.getSel().modify);
  };
  const moveRel = (forward, selection, pos) => {
    const delta = forward ? 1 : -1;
    selection.setRng(
      CaretPosition(pos.container(), pos.offset() + delta).toRange()
    );
    selection.getSel().modify("move", forward ? "forward" : "backward", "word");
    return true;
  };
  const moveByWord = (forward, editor) => {
    const rng = editor.selection.getRng();
    const pos = forward
      ? CaretPosition.fromRangeEnd(rng)
      : CaretPosition.fromRangeStart(rng);
    if (!hasSelectionModifyApi(editor)) {
      return false;
    } else if (forward && isBeforeInline(pos)) {
      return moveRel(true, editor.selection, pos);
    } else if (!forward && isAfterInline(pos)) {
      return moveRel(false, editor.selection, pos);
    } else {
      return false;
    }
  };

  var BreakType;
  (function (BreakType) {
    BreakType[(BreakType["Br"] = 0)] = "Br";
    BreakType[(BreakType["Block"] = 1)] = "Block";
    BreakType[(BreakType["Wrap"] = 2)] = "Wrap";
    BreakType[(BreakType["Eol"] = 3)] = "Eol";
  })(BreakType || (BreakType = {}));
  const flip = (direction, positions) =>
    direction === -1 ? reverse(positions) : positions;
  const walk$1 = (direction, caretWalker, pos) =>
    direction === 1 ? caretWalker.next(pos) : caretWalker.prev(pos);
  const getBreakType = (scope, direction, currentPos, nextPos) => {
    if (isBr$6(nextPos.getNode(direction === 1))) {
      return BreakType.Br;
    } else if (isInSameBlock(currentPos, nextPos) === false) {
      return BreakType.Block;
    } else {
      return BreakType.Wrap;
    }
  };
  const getPositionsUntil = (predicate, direction, scope, start) => {
    const caretWalker = CaretWalker(scope);
    let currentPos = start;
    const positions = [];
    while (currentPos) {
      const nextPos = walk$1(direction, caretWalker, currentPos);
      if (!nextPos) {
        break;
      }
      if (isBr$6(nextPos.getNode(false))) {
        if (direction === 1) {
          return {
            positions: flip(direction, positions).concat([nextPos]),
            breakType: BreakType.Br,
            breakAt: Optional.some(nextPos),
          };
        } else {
          return {
            positions: flip(direction, positions),
            breakType: BreakType.Br,
            breakAt: Optional.some(nextPos),
          };
        }
      }
      if (!nextPos.isVisible()) {
        currentPos = nextPos;
        continue;
      }
      if (predicate(currentPos, nextPos)) {
        const breakType = getBreakType(scope, direction, currentPos, nextPos);
        return {
          positions: flip(direction, positions),
          breakType,
          breakAt: Optional.some(nextPos),
        };
      }
      positions.push(nextPos);
      currentPos = nextPos;
    }
    return {
      positions: flip(direction, positions),
      breakType: BreakType.Eol,
      breakAt: Optional.none(),
    };
  };
  const getAdjacentLinePositions = (
    direction,
    getPositionsUntilBreak,
    scope,
    start
  ) =>
    getPositionsUntilBreak(scope, start)
      .breakAt.map((pos) => {
        const positions = getPositionsUntilBreak(scope, pos).positions;
        return direction === -1
          ? positions.concat(pos)
          : [pos].concat(positions);
      })
      .getOr([]);
  const findClosestHorizontalPositionFromPoint = (positions, x) =>
    foldl(
      positions,
      (acc, newPos) =>
        acc.fold(
          () => Optional.some(newPos),
          (lastPos) =>
            lift2(
              head(lastPos.getClientRects()),
              head(newPos.getClientRects()),
              (lastRect, newRect) => {
                const lastDist = Math.abs(x - lastRect.left);
                const newDist = Math.abs(x - newRect.left);
                return newDist <= lastDist ? newPos : lastPos;
              }
            ).or(acc)
        ),
      Optional.none()
    );
  const findClosestHorizontalPosition = (positions, pos) =>
    head(pos.getClientRects()).bind((targetRect) =>
      findClosestHorizontalPositionFromPoint(positions, targetRect.left)
    );
  const getPositionsUntilPreviousLine = curry(
    getPositionsUntil,
    CaretPosition.isAbove,
    -1
  );
  const getPositionsUntilNextLine = curry(
    getPositionsUntil,
    CaretPosition.isBelow,
    1
  );
  const getPositionsAbove = curry(
    getAdjacentLinePositions,
    -1,
    getPositionsUntilPreviousLine
  );
  const getPositionsBelow = curry(
    getAdjacentLinePositions,
    1,
    getPositionsUntilNextLine
  );
  const isAtFirstLine = (scope, pos) =>
    getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
  const isAtLastLine = (scope, pos) =>
    getPositionsUntilNextLine(scope, pos).breakAt.isNone();
  const getFirstLinePositions = (scope) =>
    firstPositionIn(scope)
      .map((pos) =>
        [pos].concat(getPositionsUntilNextLine(scope, pos).positions)
      )
      .getOr([]);
  const getLastLinePositions = (scope) =>
    lastPositionIn(scope)
      .map((pos) =>
        getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)
      )
      .getOr([]);
  const getClosestPositionAbove = (scope, pos) =>
    findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
  const getClosestPositionBelow = (scope, pos) =>
    findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);

  const isContentEditableFalse$5 = isContentEditableFalse$b;
  const distanceToRectLeft$1 = (clientRect, clientX) =>
    Math.abs(clientRect.left - clientX);
  const distanceToRectRight$1 = (clientRect, clientX) =>
    Math.abs(clientRect.right - clientX);
  const isNodeClientRect = (rect) => hasNonNullableKey(rect, "node");
  const findClosestClientRect = (clientRects, clientX) =>
    reduce(clientRects, (oldClientRect, clientRect) => {
      const oldDistance = Math.min(
        distanceToRectLeft$1(oldClientRect, clientX),
        distanceToRectRight$1(oldClientRect, clientX)
      );
      const newDistance = Math.min(
        distanceToRectLeft$1(clientRect, clientX),
        distanceToRectRight$1(clientRect, clientX)
      );
      if (
        newDistance === oldDistance &&
        isNodeClientRect(clientRect) &&
        isContentEditableFalse$5(clientRect.node)
      ) {
        return clientRect;
      }
      if (newDistance < oldDistance) {
        return clientRect;
      }
      return oldClientRect;
    });

  const getNodeClientRects = (node) => {
    const toArrayWithNode = (clientRects) => {
      return map$3(clientRects, (rect) => {
        const clientRect = clone$1(rect);
        clientRect.node = node;
        return clientRect;
      });
    };
    if (isElement$6(node)) {
      return toArrayWithNode(node.getClientRects());
    } else if (isText$b(node)) {
      const rng = node.ownerDocument.createRange();
      rng.setStart(node, 0);
      rng.setEnd(node, node.data.length);
      return toArrayWithNode(rng.getClientRects());
    } else {
      return [];
    }
  };
  const getClientRects = (nodes) => bind$3(nodes, getNodeClientRects);

  var VDirection;
  (function (VDirection) {
    VDirection[(VDirection["Up"] = -1)] = "Up";
    VDirection[(VDirection["Down"] = 1)] = "Down";
  })(VDirection || (VDirection = {}));
  const findUntil = (direction, root, predicateFn, node) => {
    let currentNode = node;
    while (
      (currentNode = findNode(
        currentNode,
        direction,
        isEditableCaretCandidate$1,
        root
      ))
    ) {
      if (predicateFn(currentNode)) {
        return;
      }
    }
  };
  const walkUntil = (
    direction,
    isAboveFn,
    isBeflowFn,
    root,
    predicateFn,
    caretPosition
  ) => {
    let line = 0;
    const result = [];
    const add = (node) => {
      let clientRects = getClientRects([node]);
      if (direction === VDirection.Up) {
        clientRects = clientRects.reverse();
      }
      for (let i = 0; i < clientRects.length; i++) {
        const clientRect = clientRects[i];
        if (isBeflowFn(clientRect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {
          line++;
        }
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return true;
        }
        result.push(clientRect);
      }
      return false;
    };
    const targetClientRect = last$1(caretPosition.getClientRects());
    if (!targetClientRect) {
      return result;
    }
    const node = caretPosition.getNode();
    if (node) {
      add(node);
      findUntil(direction, root, add, node);
    }
    return result;
  };
  const aboveLineNumber = (lineNumber, clientRect) =>
    clientRect.line > lineNumber;
  const isLineNumber = (lineNumber, clientRect) =>
    clientRect.line === lineNumber;
  const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
  const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
  const getLastClientRect = (caretPosition) => {
    return last$1(caretPosition.getClientRects());
  };
  const positionsUntil = (direction, root, predicateFn, node) => {
    const caretWalker = CaretWalker(root);
    let walkFn;
    let isBelowFn;
    let isAboveFn;
    let caretPosition;
    const result = [];
    let line = 0;
    if (direction === VDirection.Down) {
      walkFn = caretWalker.next;
      isBelowFn = isBelow$1;
      isAboveFn = isAbove$1;
      caretPosition = CaretPosition.after(node);
    } else {
      walkFn = caretWalker.prev;
      isBelowFn = isAbove$1;
      isAboveFn = isBelow$1;
      caretPosition = CaretPosition.before(node);
    }
    const targetClientRect = getLastClientRect(caretPosition);
    do {
      if (!caretPosition.isVisible()) {
        continue;
      }
      const rect = getLastClientRect(caretPosition);
      if (isAboveFn(rect, targetClientRect)) {
        continue;
      }
      if (result.length > 0 && isBelowFn(rect, last$1(result))) {
        line++;
      }
      const clientRect = clone$1(rect);
      clientRect.position = caretPosition;
      clientRect.line = line;
      if (predicateFn(clientRect)) {
        return result;
      }
      result.push(clientRect);
    } while ((caretPosition = walkFn(caretPosition)));
    return result;
  };
  const isAboveLine = (lineNumber) => (clientRect) =>
    aboveLineNumber(lineNumber, clientRect);
  const isLine = (lineNumber) => (clientRect) =>
    isLineNumber(lineNumber, clientRect);

  const moveToRange = (editor, rng) => {
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, editor.selection.getRng());
  };
  const renderRangeCaretOpt = (editor, range, scrollIntoView) =>
    Optional.some(renderRangeCaret(editor, range, scrollIntoView));
  const moveHorizontally = (
    editor,
    direction,
    range,
    isBefore,
    isAfter,
    isElement
  ) => {
    const forwards = direction === 1;
    const caretWalker = CaretWalker(editor.getBody());
    const getNextPosFn = curry(
      getVisualCaretPosition,
      forwards ? caretWalker.next : caretWalker.prev
    );
    const isBeforeFn = forwards ? isBefore : isAfter;
    if (!range.collapsed) {
      const node = getSelectedNode(range);
      if (isElement(node)) {
        return showCaret(direction, editor, node, direction === -1, false);
      } else if (isCefAtEdgeSelected(editor)) {
        const newRange = range.cloneRange();
        newRange.collapse(direction === -1);
        return Optional.from(newRange);
      }
    }
    const caretPosition = getNormalizedRangeEndPoint(
      direction,
      editor.getBody(),
      range
    );
    if (isBeforeFn(caretPosition)) {
      return selectNode(editor, caretPosition.getNode(!forwards));
    }
    let nextCaretPosition = getNextPosFn(caretPosition);
    const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
    if (!nextCaretPosition) {
      return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
    } else {
      nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
    }
    if (isBeforeFn(nextCaretPosition)) {
      return showCaret(
        direction,
        editor,
        nextCaretPosition.getNode(!forwards),
        forwards,
        false
      );
    }
    const peekCaretPosition = getNextPosFn(nextCaretPosition);
    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
        return showCaret(
          direction,
          editor,
          peekCaretPosition.getNode(!forwards),
          forwards,
          false
        );
      }
    }
    if (rangeIsInContainerBlock) {
      return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
    }
    return Optional.none();
  };
  const moveVertically = (
    editor,
    direction,
    range,
    isBefore,
    isAfter,
    isElement
  ) => {
    const caretPosition = getNormalizedRangeEndPoint(
      direction,
      editor.getBody(),
      range
    );
    const caretClientRect = last$1(caretPosition.getClientRects());
    const forwards = direction === VDirection.Down;
    const root = editor.getBody();
    if (!caretClientRect) {
      return Optional.none();
    }
    if (isCefAtEdgeSelected(editor)) {
      const caretPosition = forwards
        ? CaretPosition.fromRangeEnd(range)
        : CaretPosition.fromRangeStart(range);
      const getClosestFn = !forwards
        ? getClosestPositionAbove
        : getClosestPositionBelow;
      return getClosestFn(root, caretPosition)
        .orThunk(() => Optional.from(caretPosition))
        .map((pos) => pos.toRange());
    }
    const walkerFn = forwards ? downUntil : upUntil;
    const linePositions = walkerFn(root, isAboveLine(1), caretPosition);
    const nextLinePositions = filter$5(linePositions, isLine(1));
    const clientX = caretClientRect.left;
    const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
    if (nextLineRect && isElement(nextLineRect.node)) {
      const dist1 = Math.abs(clientX - nextLineRect.left);
      const dist2 = Math.abs(clientX - nextLineRect.right);
      return showCaret(
        direction,
        editor,
        nextLineRect.node,
        dist1 < dist2,
        false
      );
    }
    let currentNode;
    if (isBefore(caretPosition)) {
      currentNode = caretPosition.getNode();
    } else if (isAfter(caretPosition)) {
      currentNode = caretPosition.getNode(true);
    } else {
      currentNode = getSelectedNode(range);
    }
    if (currentNode) {
      const caretPositions = positionsUntil(
        direction,
        root,
        isAboveLine(1),
        currentNode
      );
      let closestNextLineRect = findClosestClientRect(
        filter$5(caretPositions, isLine(1)),
        clientX
      );
      if (closestNextLineRect) {
        return renderRangeCaretOpt(
          editor,
          closestNextLineRect.position.toRange(),
          false
        );
      }
      closestNextLineRect = last$1(filter$5(caretPositions, isLine(0)));
      if (closestNextLineRect) {
        return renderRangeCaretOpt(
          editor,
          closestNextLineRect.position.toRange(),
          false
        );
      }
    }
    if (nextLinePositions.length === 0) {
      return getLineEndPoint(editor, forwards)
        .filter(forwards ? isAfter : isBefore)
        .map((pos) => renderRangeCaret(editor, pos.toRange(), false));
    }
    return Optional.none();
  };
  const getLineEndPoint = (editor, forward) => {
    const rng = editor.selection.getRng();
    const from = forward
      ? CaretPosition.fromRangeEnd(rng)
      : CaretPosition.fromRangeStart(rng);
    const host = getEditingHost(from.container(), editor.getBody());
    if (forward) {
      const lineInfo = getPositionsUntilNextLine(host, from);
      return last$2(lineInfo.positions);
    } else {
      const lineInfo = getPositionsUntilPreviousLine(host, from);
      return head(lineInfo.positions);
    }
  };
  const moveToLineEndPoint$3 = (editor, forward, isElementPosition) =>
    getLineEndPoint(editor, forward)
      .filter(isElementPosition)
      .exists((pos) => {
        editor.selection.setRng(pos.toRange());
        return true;
      });

  const setCaretPosition = (editor, pos) => {
    const rng = editor.dom.createRng();
    rng.setStart(pos.container(), pos.offset());
    rng.setEnd(pos.container(), pos.offset());
    editor.selection.setRng(rng);
  };
  const setSelected = (state, elm) => {
    if (state) {
      elm.setAttribute("data-mce-selected", "inline-boundary");
    } else {
      elm.removeAttribute("data-mce-selected");
    }
  };
  const renderCaretLocation = (editor, caret, location) =>
    renderCaret(caret, location).map((pos) => {
      setCaretPosition(editor, pos);
      return location;
    });
  const getPositionFromRange = (range, root, forward) => {
    const start = CaretPosition.fromRangeStart(range);
    if (range.collapsed) {
      return start;
    } else {
      const end = CaretPosition.fromRangeEnd(range);
      return forward
        ? prevPosition(root, end).getOr(end)
        : nextPosition(root, start).getOr(start);
    }
  };
  const findLocation = (editor, caret, forward) => {
    const rootNode = editor.getBody();
    const from = getPositionFromRange(
      editor.selection.getRng(),
      rootNode,
      forward
    );
    const isInlineTarget$1 = curry(isInlineTarget, editor);
    const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);
    return location.bind((location) =>
      renderCaretLocation(editor, caret, location)
    );
  };
  const toggleInlines = (isInlineTarget, dom, elms) => {
    const inlineBoundaries = map$3(
      descendants(
        SugarElement.fromDom(dom.getRoot()),
        '*[data-mce-selected="inline-boundary"]'
      ),
      (e) => e.dom
    );
    const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);
    const targetInlines = filter$5(elms, isInlineTarget);
    each$e(
      difference(selectedInlines, targetInlines),
      curry(setSelected, false)
    );
    each$e(
      difference(targetInlines, selectedInlines),
      curry(setSelected, true)
    );
  };
  const safeRemoveCaretContainer = (editor, caret) => {
    const caretValue = caret.get();
    if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
        setCaretPosition(editor, removeAndReposition(caretValue, pos));
        caret.set(null);
      }
    }
  };
  const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {
    if (editor.selection.isCollapsed()) {
      const inlines = filter$5(elms, isInlineTarget);
      each$e(inlines, (_inline) => {
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        readLocation(isInlineTarget, editor.getBody(), pos).bind((location) =>
          renderCaretLocation(editor, caret, location)
        );
      });
    }
  };
  const move$3 = (editor, caret, forward) =>
    isInlineBoundariesEnabled(editor)
      ? findLocation(editor, caret, forward).isSome()
      : false;
  const moveWord = (forward, editor, _caret) =>
    isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
  const setupSelectedState = (editor) => {
    const caret = Cell(null);
    const isInlineTarget$1 = curry(isInlineTarget, editor);
    editor.on("NodeChange", (e) => {
      if (isInlineBoundariesEnabled(editor)) {
        toggleInlines(isInlineTarget$1, editor.dom, e.parents);
        safeRemoveCaretContainer(editor, caret);
        renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
      }
    });
    return caret;
  };
  const moveNextWord = curry(moveWord, true);
  const movePrevWord = curry(moveWord, false);
  const moveToLineEndPoint$2 = (editor, forward, caret) => {
    if (isInlineBoundariesEnabled(editor)) {
      const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
        const rng = editor.selection.getRng();
        return forward
          ? CaretPosition.fromRangeEnd(rng)
          : CaretPosition.fromRangeStart(rng);
      });
      return readLocation(
        curry(isInlineTarget, editor),
        editor.getBody(),
        linePoint
      ).exists((loc) => {
        const outsideLoc = outside(loc);
        return renderCaret(caret, outsideLoc).exists((pos) => {
          setCaretPosition(editor, pos);
          return true;
        });
      });
    } else {
      return false;
    }
  };

  const rangeFromPositions = (from, to) => {
    const range = document.createRange();
    range.setStart(from.container(), from.offset());
    range.setEnd(to.container(), to.offset());
    return range;
  };
  const hasOnlyTwoOrLessPositionsLeft = (elm) =>
    lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      return nextPosition(elm, normalizedFirstPos).forall((pos) =>
        pos.isEqual(normalizedLastPos)
      );
    }).getOr(true);
  const setCaretLocation = (editor, caret) => (location) =>
    renderCaret(caret, location).map(
      (pos) => () => setCaretPosition(editor, pos)
    );
  const deleteFromTo = (editor, caret, from, to) => {
    const rootNode = editor.getBody();
    const isInlineTarget$1 = curry(isInlineTarget, editor);
    editor.undoManager.ignore(() => {
      editor.selection.setRng(rangeFromPositions(from, to));
      execNativeDeleteCommand(editor);
      readLocation(
        isInlineTarget$1,
        rootNode,
        CaretPosition.fromRangeStart(editor.selection.getRng())
      )
        .map(inside)
        .bind(setCaretLocation(editor, caret))
        .each(call);
    });
    editor.nodeChanged();
  };
  const rescope = (rootNode, node) => {
    const parentBlock = getParentBlock$3(node, rootNode);
    return parentBlock ? parentBlock : rootNode;
  };
  const backspaceDeleteCollapsed = (editor, caret, forward, from) => {
    const rootNode = rescope(editor.getBody(), from.container());
    const isInlineTarget$1 = curry(isInlineTarget, editor);
    const fromLocation = readLocation(isInlineTarget$1, rootNode, from);
    const location = fromLocation.bind((location) => {
      if (forward) {
        return location.fold(
          constant(Optional.some(inside(location))),
          Optional.none,
          constant(Optional.some(outside(location))),
          Optional.none
        );
      } else {
        return location.fold(
          Optional.none,
          constant(Optional.some(outside(location))),
          Optional.none,
          constant(Optional.some(inside(location)))
        );
      }
    });
    return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {
      const toPosition = navigate(forward, rootNode, from);
      const toLocation = toPosition.bind((pos) =>
        readLocation(isInlineTarget$1, rootNode, pos)
      );
      return lift2(fromLocation, toLocation, () =>
        findRootInline(isInlineTarget$1, rootNode, from).bind((elm) => {
          if (hasOnlyTwoOrLessPositionsLeft(elm)) {
            return Optional.some(() => {
              deleteElement$2(editor, forward, SugarElement.fromDom(elm));
            });
          } else {
            return Optional.none();
          }
        })
      ).getOrThunk(() =>
        toLocation.bind(() =>
          toPosition.map((to) => {
            return () => {
              if (forward) {
                deleteFromTo(editor, caret, from, to);
              } else {
                deleteFromTo(editor, caret, to, from);
              }
            };
          })
        )
      );
    });
  };
  const backspaceDelete$4 = (editor, caret, forward) => {
    if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
      const from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return backspaceDeleteCollapsed(editor, caret, forward, from);
    }
    return Optional.none();
  };

  const hasMultipleChildren = (elm) => childNodesCount(elm) > 1;
  const getParentsUntil = (editor, pred) => {
    const rootElm = SugarElement.fromDom(editor.getBody());
    const startElm = SugarElement.fromDom(editor.selection.getStart());
    const parents = parentsAndSelf(startElm, rootElm);
    return findIndex$2(parents, pred).fold(constant(parents), (index) =>
      parents.slice(0, index)
    );
  };
  const hasOnlyOneChild = (elm) => childNodesCount(elm) === 1;
  const getParentInlinesUntilMultichildInline = (editor) =>
    getParentsUntil(
      editor,
      (elm) => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm)
    );
  const getParentInlines = (editor) =>
    getParentsUntil(editor, (el) => editor.schema.isBlock(name(el)));
  const getFormatNodes = (editor, parentInlines) => {
    const isFormatElement$1 = curry(isFormatElement, editor);
    return bind$3(parentInlines, (elm) =>
      isFormatElement$1(elm) ? [elm.dom] : []
    );
  };
  const getFormatNodesAtStart = (editor) => {
    const parentInlines = getParentInlines(editor);
    return getFormatNodes(editor, parentInlines);
  };
  const deleteLastPosition = (forward, editor, target, parentInlines) => {
    const formatNodes = getFormatNodes(editor, parentInlines);
    if (formatNodes.length === 0) {
      deleteElement$2(editor, forward, target);
    } else {
      const pos = replaceWithCaretFormat(target.dom, formatNodes);
      editor.selection.setRng(pos.toRange());
    }
  };
  const deleteCaret$1 = (editor, forward) => {
    const parentInlines = filter$5(
      getParentInlinesUntilMultichildInline(editor),
      hasOnlyOneChild
    );
    return last$2(parentInlines).bind((target) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      if (
        willDeleteLastPositionInElement(forward, fromPos, target.dom) &&
        !isEmptyCaretFormatElement(target)
      ) {
        return Optional.some(() =>
          deleteLastPosition(forward, editor, target, parentInlines)
        );
      } else {
        return Optional.none();
      }
    });
  };
  const isBrInEmptyElement = (editor, elm) => {
    const parentElm = elm.parentElement;
    return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
  };
  const isEmptyCaret = (elm) =>
    isEmptyCaretFormatElement(SugarElement.fromDom(elm));
  const createCaretFormatAtStart = (editor, formatNodes) => {
    const startElm = editor.selection.getStart();
    const pos =
      isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm)
        ? replaceWithCaretFormat(startElm, formatNodes)
        : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);
    editor.selection.setRng(pos.toRange());
  };
  const updateCaretFormat = (editor, updateFormats) => {
    const missingFormats = difference(
      updateFormats,
      getFormatNodesAtStart(editor)
    );
    if (missingFormats.length > 0) {
      createCaretFormatAtStart(editor, missingFormats);
    }
  };
  const rangeStartsAtTextContainer = (rng) => isText$b(rng.startContainer);
  const rangeStartsAtStartOfTextContainer = (rng) =>
    rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
  const rangeStartParentIsFormatElement = (editor, rng) => {
    const startParent = rng.startContainer.parentElement;
    return (
      !isNull(startParent) &&
      isFormatElement(editor, SugarElement.fromDom(startParent))
    );
  };
  const rangeStartAndEndHaveSameParent = (rng) => {
    const startParent = rng.startContainer.parentNode;
    const endParent = rng.endContainer.parentNode;
    return (
      !isNull(startParent) &&
      !isNull(endParent) &&
      startParent.isEqualNode(endParent)
    );
  };
  const rangeEndsAtEndOfEndContainer = (rng) => {
    const endContainer = rng.endContainer;
    return (
      rng.endOffset ===
      (isText$b(endContainer)
        ? endContainer.length
        : endContainer.childNodes.length)
    );
  };
  const rangeEndsAtEndOfStartContainer = (rng) =>
    rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
  const rangeEndsAfterEndOfStartContainer = (rng) =>
    !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
  const rangeEndsAtOrAfterEndOfStartContainer = (rng) =>
    rangeEndsAtEndOfStartContainer(rng) ||
    rangeEndsAfterEndOfStartContainer(rng);
  const requiresDeleteRangeOverride = (editor) => {
    const rng = editor.selection.getRng();
    return (
      rangeStartsAtStartOfTextContainer(rng) &&
      rangeStartParentIsFormatElement(editor, rng) &&
      rangeEndsAtOrAfterEndOfStartContainer(rng)
    );
  };
  const deleteRange$1 = (editor) => {
    if (requiresDeleteRangeOverride(editor)) {
      const formatNodes = getFormatNodesAtStart(editor);
      return Optional.some(() => {
        execNativeDeleteCommand(editor);
        updateCaretFormat(editor, formatNodes);
      });
    } else {
      return Optional.none();
    }
  };
  const backspaceDelete$3 = (editor, forward) =>
    editor.selection.isCollapsed()
      ? deleteCaret$1(editor, forward)
      : deleteRange$1(editor);
  const hasAncestorInlineCaret = (elm, schema) =>
    ancestor$2(
      elm,
      (node) => isCaretNode(node.dom),
      (el) => schema.isBlock(name(el))
    );
  const hasAncestorInlineCaretAtStart = (editor) =>
    hasAncestorInlineCaret(
      SugarElement.fromDom(editor.selection.getStart()),
      editor.schema
    );
  const requiresRefreshCaretOverride = (editor) => {
    const rng = editor.selection.getRng();
    return (
      rng.collapsed &&
      (rangeStartsAtTextContainer(rng) ||
        editor.dom.isEmpty(rng.startContainer)) &&
      !hasAncestorInlineCaretAtStart(editor)
    );
  };
  const refreshCaret = (editor) => {
    if (requiresRefreshCaretOverride(editor)) {
      createCaretFormatAtStart(editor, []);
    }
    return true;
  };

  const deleteElement = (editor, forward, element) => {
    if (isNonNullable(element)) {
      return Optional.some(() => {
        editor._selectionOverrides.hideFakeCaret();
        deleteElement$2(editor, forward, SugarElement.fromDom(element));
      });
    } else {
      return Optional.none();
    }
  };
  const deleteCaret = (editor, forward) => {
    const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
    const direction = forward ? 1 : -1;
    const fromPos = getNormalizedRangeEndPoint(
      direction,
      editor.getBody(),
      editor.selection.getRng()
    );
    if (isNearMedia(fromPos)) {
      return deleteElement(editor, forward, fromPos.getNode(!forward));
    } else {
      return Optional.from(normalizePosition(forward, fromPos))
        .filter(
          (pos) => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)
        )
        .bind((pos) => deleteElement(editor, forward, pos.getNode(!forward)));
    }
  };
  const deleteRange = (editor, forward) => {
    const selectedNode = editor.selection.getNode();
    return isMedia$2(selectedNode)
      ? deleteElement(editor, forward, selectedNode)
      : Optional.none();
  };
  const backspaceDelete$2 = (editor, forward) =>
    editor.selection.isCollapsed()
      ? deleteCaret(editor, forward)
      : deleteRange(editor, forward);

  const isEditable = (target) =>
    closest$4(
      target,
      (elm) =>
        isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)
    ).exists((elm) => isContentEditableTrue$3(elm.dom));
  const parseIndentValue = (value) =>
    toInt(value !== null && value !== void 0 ? value : "").getOr(0);
  const getIndentStyleName = (useMargin, element) => {
    const indentStyleName =
      useMargin || isTable$1(element) ? "margin" : "padding";
    const suffix = get$7(element, "direction") === "rtl" ? "-right" : "-left";
    return indentStyleName + suffix;
  };
  const indentElement = (dom, command, useMargin, value, unit, element) => {
    const indentStyleName = getIndentStyleName(
      useMargin,
      SugarElement.fromDom(element)
    );
    const parsedValue = parseIndentValue(
      dom.getStyle(element, indentStyleName)
    );
    if (command === "outdent") {
      const styleValue = Math.max(0, parsedValue - value);
      dom.setStyle(
        element,
        indentStyleName,
        styleValue ? styleValue + unit : ""
      );
    } else {
      const styleValue = parsedValue + value + unit;
      dom.setStyle(element, indentStyleName, styleValue);
    }
  };
  const validateBlocks = (editor, blocks) =>
    forall(blocks, (block) => {
      const indentStyleName = getIndentStyleName(
        shouldIndentUseMargin(editor),
        block
      );
      const intentValue = getRaw(block, indentStyleName)
        .map(parseIndentValue)
        .getOr(0);
      const contentEditable = editor.dom.getContentEditable(block.dom);
      return contentEditable !== "false" && intentValue > 0;
    });
  const canOutdent = (editor) => {
    const blocks = getBlocksToIndent(editor);
    return (
      !editor.mode.isReadOnly() &&
      (blocks.length > 1 || validateBlocks(editor, blocks))
    );
  };
  const isListComponent = (el) => isList(el) || isListItem$1(el);
  const parentIsListComponent = (el) => parent(el).exists(isListComponent);
  const getBlocksToIndent = (editor) =>
    filter$5(
      fromDom$1(editor.selection.getSelectedBlocks()),
      (el) =>
        !isListComponent(el) && !parentIsListComponent(el) && isEditable(el)
    );
  const handle = (editor, command) => {
    var _a, _b;
    if (editor.mode.isReadOnly()) {
      return;
    }
    const { dom } = editor;
    const indentation = getIndentation(editor);
    const indentUnit =
      (_b =
        (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0
          ? void 0
          : _a[0]) !== null && _b !== void 0
        ? _b
        : "px";
    const indentValue = parseIndentValue(indentation);
    const useMargin = shouldIndentUseMargin(editor);
    each$e(getBlocksToIndent(editor), (block) => {
      indentElement(
        dom,
        command,
        useMargin,
        indentValue,
        indentUnit,
        block.dom
      );
    });
  };
  const indent = (editor) => handle(editor, "indent");
  const outdent = (editor) => handle(editor, "outdent");

  const backspaceDelete$1 = (editor) => {
    if (editor.selection.isCollapsed() && canOutdent(editor)) {
      const dom = editor.dom;
      const rng = editor.selection.getRng();
      const pos = CaretPosition.fromRangeStart(rng);
      const block = dom.getParent(rng.startContainer, dom.isBlock);
      if (
        block !== null &&
        isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)
      ) {
        return Optional.some(() => outdent(editor));
      }
    }
    return Optional.none();
  };

  const findAction = (editor, caret, forward) =>
    findMap(
      [
        backspaceDelete$1,
        backspaceDelete$7,
        backspaceDelete$8,
        (editor, forward) => backspaceDelete$4(editor, caret, forward),
        backspaceDelete$a,
        backspaceDelete$b,
        backspaceDelete$5,
        backspaceDelete$2,
        backspaceDelete$9,
        backspaceDelete$3,
        backspaceDelete$6,
      ],
      (item) => item(editor, forward)
    ).filter((_) => editor.selection.isEditable());
  const deleteCommand = (editor, caret) => {
    const result = findAction(editor, caret, false);
    result.fold(() => {
      if (editor.selection.isEditable()) {
        execNativeDeleteCommand(editor);
        paddEmptyBody(editor);
      }
    }, call);
  };
  const forwardDeleteCommand = (editor, caret) => {
    const result = findAction(editor, caret, true);
    result.fold(() => {
      if (editor.selection.isEditable()) {
        execNativeForwardDeleteCommand(editor);
      }
    }, call);
  };
  const setup$q = (editor, caret) => {
    editor.addCommand("delete", () => {
      deleteCommand(editor, caret);
    });
    editor.addCommand("forwardDelete", () => {
      forwardDeleteCommand(editor, caret);
    });
  };

  const SIGNIFICANT_MOVE = 5;
  const LONGPRESS_DELAY = 400;
  const getTouch = (event) => {
    if (event.touches === undefined || event.touches.length !== 1) {
      return Optional.none();
    }
    return Optional.some(event.touches[0]);
  };
  const isFarEnough = (touch, data) => {
    const distX = Math.abs(touch.clientX - data.x);
    const distY = Math.abs(touch.clientY - data.y);
    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
  };
  const setup$p = (editor) => {
    const startData = value$2();
    const longpressFired = Cell(false);
    const debounceLongpress = last((e) => {
      editor.dispatch("longpress", {
        ...e,
        type: "longpress",
      });
      longpressFired.set(true);
    }, LONGPRESS_DELAY);
    editor.on(
      "touchstart",
      (e) => {
        getTouch(e).each((touch) => {
          debounceLongpress.cancel();
          const data = {
            x: touch.clientX,
            y: touch.clientY,
            target: e.target,
          };
          debounceLongpress.throttle(e);
          longpressFired.set(false);
          startData.set(data);
        });
      },
      true
    );
    editor.on(
      "touchmove",
      (e) => {
        debounceLongpress.cancel();
        getTouch(e).each((touch) => {
          startData.on((data) => {
            if (isFarEnough(touch, data)) {
              startData.clear();
              longpressFired.set(false);
              editor.dispatch("longpresscancel");
            }
          });
        });
      },
      true
    );
    editor.on(
      "touchend touchcancel",
      (e) => {
        debounceLongpress.cancel();
        if (e.type === "touchcancel") {
          return;
        }
        startData
          .get()
          .filter((data) => data.target.isEqualNode(e.target))
          .each(() => {
            if (longpressFired.get()) {
              e.preventDefault();
            } else {
              editor.dispatch("tap", {
                ...e,
                type: "tap",
              });
            }
          });
      },
      true
    );
  };

  const isBlockElement = (blockElements, node) =>
    has$2(blockElements, node.nodeName);
  const isValidTarget = (schema, node) => {
    if (isText$b(node)) {
      return true;
    } else if (isElement$6(node)) {
      return (
        !isBlockElement(schema.getBlockElements(), node) &&
        !isBookmarkNode$1(node) &&
        !isTransparentBlock(schema, node) &&
        !isNonHtmlElementRoot(node)
      );
    } else {
      return false;
    }
  };
  const hasBlockParent = (blockElements, root, node) => {
    return exists(
      parents(SugarElement.fromDom(node), SugarElement.fromDom(root)),
      (elm) => {
        return isBlockElement(blockElements, elm.dom);
      }
    );
  };
  const shouldRemoveTextNode = (blockElements, node) => {
    if (isText$b(node)) {
      if (node.data.length === 0) {
        return true;
      } else if (/^\s+$/.test(node.data)) {
        return (
          !node.nextSibling ||
          isBlockElement(blockElements, node.nextSibling) ||
          isNonHtmlElementRoot(node.nextSibling)
        );
      }
    }
    return false;
  };
  const createRootBlock = (editor) =>
    editor.dom.create(
      getForcedRootBlock(editor),
      getForcedRootBlockAttrs(editor)
    );
  const addRootBlocks = (editor) => {
    const dom = editor.dom,
      selection = editor.selection;
    const schema = editor.schema;
    const blockElements = schema.getBlockElements();
    const startNode = selection.getStart();
    const rootNode = editor.getBody();
    let rootBlockNode;
    let tempNode;
    let bm = null;
    const forcedRootBlock = getForcedRootBlock(editor);
    if (!startNode || !isElement$6(startNode)) {
      return;
    }
    const rootNodeName = rootNode.nodeName.toLowerCase();
    if (
      !schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) ||
      hasBlockParent(blockElements, rootNode, startNode)
    ) {
      return;
    }
    if (
      rootNode.firstChild === rootNode.lastChild &&
      isBr$6(rootNode.firstChild)
    ) {
      rootBlockNode = createRootBlock(editor);
      rootBlockNode.appendChild(createPaddingBr().dom);
      rootNode.replaceChild(rootBlockNode, rootNode.firstChild);
      editor.selection.setCursorLocation(rootBlockNode, 0);
      editor.nodeChanged();
      return;
    }
    let node = rootNode.firstChild;
    while (node) {
      if (isElement$6(node)) {
        updateElement(schema, node);
      }
      if (isValidTarget(schema, node)) {
        if (shouldRemoveTextNode(blockElements, node)) {
          tempNode = node;
          node = node.nextSibling;
          dom.remove(tempNode);
          continue;
        }
        if (!rootBlockNode) {
          if (!bm && editor.hasFocus()) {
            bm = getBookmark(editor.selection.getRng(), () =>
              document.createElement("span")
            );
          }
          if (!node.parentNode) {
            node = null;
            break;
          }
          rootBlockNode = createRootBlock(editor);
          rootNode.insertBefore(rootBlockNode, node);
        }
        tempNode = node;
        node = node.nextSibling;
        rootBlockNode.appendChild(tempNode);
      } else {
        rootBlockNode = null;
        node = node.nextSibling;
      }
    }
    if (bm) {
      editor.selection.setRng(resolveBookmark(bm));
      editor.nodeChanged();
    }
  };
  const insertEmptyLine = (editor, root, insertBlock) => {
    const block = SugarElement.fromDom(createRootBlock(editor));
    const br = createPaddingBr();
    append$1(block, br);
    insertBlock(root, block);
    const rng = document.createRange();
    rng.setStartBefore(br.dom);
    rng.setEndBefore(br.dom);
    return rng;
  };
  const setup$o = (editor) => {
    editor.on("NodeChange", () => addRootBlocks(editor));
  };

  const hasClass = (checkClassName) => (node) =>
    (" " + node.attr("class") + " ").indexOf(checkClassName) !== -1;
  const replaceMatchWithSpan = (editor, content, cls) => {
    return function (match) {
      const args = arguments,
        index = args[args.length - 2];
      const prevChar = index > 0 ? content.charAt(index - 1) : "";
      if (prevChar === '"') {
        return match;
      }
      if (prevChar === ">") {
        const findStartTagIndex = content.lastIndexOf("<", index);
        if (findStartTagIndex !== -1) {
          const tagHtml = content.substring(findStartTagIndex, index);
          if (tagHtml.indexOf('contenteditable="false"') !== -1) {
            return match;
          }
        }
      }
      return (
        '<span class="' +
        cls +
        '" data-mce-content="' +
        editor.dom.encode(args[0]) +
        '">' +
        editor.dom.encode(typeof args[1] === "string" ? args[1] : args[0]) +
        "</span>"
      );
    };
  };
  const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
    let i = nonEditableRegExps.length,
      content = e.content;
    if (e.format === "raw") {
      return;
    }
    while (i--) {
      content = content.replace(
        nonEditableRegExps[i],
        replaceMatchWithSpan(editor, content, getNonEditableClass(editor))
      );
    }
    e.content = content;
  };
  const isValidContent = (nonEditableRegExps, content) => {
    return forall(nonEditableRegExps, (re) => {
      const matches = content.match(re);
      return matches !== null && matches[0].length === content.length;
    });
  };
  const setup$n = (editor) => {
    const contentEditableAttrName = "contenteditable";
    const editClass = " " + Tools.trim(getEditableClass(editor)) + " ";
    const nonEditClass = " " + Tools.trim(getNonEditableClass(editor)) + " ";
    const hasEditClass = hasClass(editClass);
    const hasNonEditClass = hasClass(nonEditClass);
    const nonEditableRegExps = getNonEditableRegExps(editor);
    if (nonEditableRegExps.length > 0) {
      editor.on("BeforeSetContent", (e) => {
        convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
      });
    }
    editor.parser.addAttributeFilter("class", (nodes) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        if (hasEditClass(node)) {
          node.attr(contentEditableAttrName, "true");
        } else if (hasNonEditClass(node)) {
          node.attr(contentEditableAttrName, "false");
        }
      }
    });
    editor.serializer.addAttributeFilter(contentEditableAttrName, (nodes) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        if (!hasEditClass(node) && !hasNonEditClass(node)) {
          continue;
        }
        const content = node.attr("data-mce-content");
        if (nonEditableRegExps.length > 0 && content) {
          if (isValidContent(nonEditableRegExps, content)) {
            node.name = "#text";
            node.type = 3;
            node.raw = true;
            node.value = content;
          } else {
            node.remove();
          }
        } else {
          node.attr(contentEditableAttrName, null);
        }
      }
    });
  };

  const findBlockCaretContainer = (editor) =>
    descendant$1(SugarElement.fromDom(editor.getBody()), "*[data-mce-caret]")
      .map((elm) => elm.dom)
      .getOrNull();
  const showBlockCaretContainer = (editor, blockCaretContainer) => {
    if (blockCaretContainer.hasAttribute("data-mce-caret")) {
      showCaretContainerBlock(blockCaretContainer);
      editor.selection.setRng(editor.selection.getRng());
      editor.selection.scrollIntoView(blockCaretContainer);
    }
  };
  const handleBlockContainer = (editor, e) => {
    const blockCaretContainer = findBlockCaretContainer(editor);
    if (!blockCaretContainer) {
      return;
    }
    if (e.type === "compositionstart") {
      e.preventDefault();
      e.stopPropagation();
      showBlockCaretContainer(editor, blockCaretContainer);
      return;
    }
    if (hasContent(blockCaretContainer)) {
      showBlockCaretContainer(editor, blockCaretContainer);
      editor.undoManager.add();
    }
  };
  const setup$m = (editor) => {
    editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
  };

  const isContentEditableFalse$4 = isContentEditableFalse$b;
  const moveToCeFalseHorizontally = (direction, editor, range) =>
    moveHorizontally(
      editor,
      direction,
      range,
      isBeforeContentEditableFalse,
      isAfterContentEditableFalse,
      isContentEditableFalse$4
    );
  const moveToCeFalseVertically = (direction, editor, range) => {
    const isBefore = (caretPosition) =>
      isBeforeContentEditableFalse(caretPosition) ||
      isBeforeTable(caretPosition);
    const isAfter = (caretPosition) =>
      isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
    return moveVertically(
      editor,
      direction,
      range,
      isBefore,
      isAfter,
      isContentEditableFalse$4
    );
  };
  const createTextBlock = (editor) => {
    const textBlock = editor.dom.create(getForcedRootBlock(editor));
    textBlock.innerHTML = '<br data-mce-bogus="1">';
    return textBlock;
  };
  const exitPreBlock = (editor, direction, range) => {
    const caretWalker = CaretWalker(editor.getBody());
    const getVisualCaretPosition$1 = curry(
      getVisualCaretPosition,
      direction === 1 ? caretWalker.next : caretWalker.prev
    );
    if (range.collapsed) {
      const pre = editor.dom.getParent(range.startContainer, "PRE");
      if (!pre) {
        return;
      }
      const caretPos = getVisualCaretPosition$1(
        CaretPosition.fromRangeStart(range)
      );
      if (!caretPos) {
        const newBlock = SugarElement.fromDom(createTextBlock(editor));
        if (direction === 1) {
          after$4(SugarElement.fromDom(pre), newBlock);
        } else {
          before$3(SugarElement.fromDom(pre), newBlock);
        }
        editor.selection.select(newBlock.dom, true);
        editor.selection.collapse();
      }
    }
  };
  const getHorizontalRange = (editor, forward) => {
    const direction = forward ? 1 : -1;
    const range = editor.selection.getRng();
    return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {
      exitPreBlock(editor, direction, range);
      return Optional.none();
    });
  };
  const getVerticalRange = (editor, down) => {
    const direction = down ? 1 : -1;
    const range = editor.selection.getRng();
    return moveToCeFalseVertically(direction, editor, range).orThunk(() => {
      exitPreBlock(editor, direction, range);
      return Optional.none();
    });
  };
  const flipDirection = (selection, forward) => {
    const elm = forward ? selection.getEnd(true) : selection.getStart(true);
    return isRtl(elm) ? !forward : forward;
  };
  const moveH$2 = (editor, forward) =>
    getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(
      (newRange) => {
        moveToRange(editor, newRange);
        return true;
      }
    );
  const moveV$4 = (editor, down) =>
    getVerticalRange(editor, down).exists((newRange) => {
      moveToRange(editor, newRange);
      return true;
    });
  const moveToLineEndPoint$1 = (editor, forward) => {
    const isCefPosition = forward
      ? isAfterContentEditableFalse
      : isBeforeContentEditableFalse;
    return moveToLineEndPoint$3(editor, forward, isCefPosition);
  };
  const selectToEndPoint = (editor, forward) =>
    getEdgeCefPosition(editor, !forward)
      .map((pos) => {
        const rng = pos.toRange();
        const curRng = editor.selection.getRng();
        if (forward) {
          rng.setStart(curRng.startContainer, curRng.startOffset);
        } else {
          rng.setEnd(curRng.endContainer, curRng.endOffset);
        }
        return rng;
      })
      .exists((rng) => {
        moveToRange(editor, rng);
        return true;
      });

  const isTarget = (node) => contains$2(["figcaption"], name(node));
  const getClosestTargetBlock = (pos, root, schema) => {
    const isRoot = curry(eq, root);
    return closest$4(
      SugarElement.fromDom(pos.container()),
      (el) => schema.isBlock(name(el)),
      isRoot
    ).filter(isTarget);
  };
  const isAtFirstOrLastLine = (root, forward, pos) =>
    forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
  const moveCaretToNewEmptyLine = (editor, forward) => {
    const root = SugarElement.fromDom(editor.getBody());
    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
    return getClosestTargetBlock(pos, root, editor.schema).exists(() => {
      if (isAtFirstOrLastLine(root, forward, pos)) {
        const insertFn = forward ? append$1 : prepend;
        const rng = insertEmptyLine(editor, root, insertFn);
        editor.selection.setRng(rng);
        return true;
      } else {
        return false;
      }
    });
  };
  const moveV$3 = (editor, forward) => {
    if (editor.selection.isCollapsed()) {
      return moveCaretToNewEmptyLine(editor, forward);
    } else {
      return false;
    }
  };

  const moveUp = (editor, details, summary) => {
    const rng = editor.selection.getRng();
    const pos = CaretPosition.fromRangeStart(rng);
    const root = editor.getBody();
    if (root.firstChild === details && isAtFirstLine(summary, pos)) {
      editor.execCommand("InsertNewBlockBefore");
      return true;
    } else {
      return false;
    }
  };
  const moveDown = (editor, details) => {
    const rng = editor.selection.getRng();
    const pos = CaretPosition.fromRangeStart(rng);
    const root = editor.getBody();
    if (root.lastChild === details && isAtLastLine(details, pos)) {
      editor.execCommand("InsertNewBlockAfter");
      return true;
    } else {
      return false;
    }
  };
  const move$2 = (editor, forward) => {
    if (forward) {
      return Optional.from(
        editor.dom.getParent(editor.selection.getNode(), "details")
      )
        .map((details) => moveDown(editor, details))
        .getOr(false);
    } else {
      return Optional.from(
        editor.dom.getParent(editor.selection.getNode(), "summary")
      )
        .bind((summary) =>
          Optional.from(editor.dom.getParent(summary, "details")).map(
            (details) => moveUp(editor, details, summary)
          )
        )
        .getOr(false);
    }
  };
  const moveV$2 = (editor, forward) => move$2(editor, forward);

  const baseKeyPattern = {
    shiftKey: false,
    altKey: false,
    ctrlKey: false,
    metaKey: false,
    keyCode: 0,
  };
  const defaultPatterns = (patterns) =>
    map$3(patterns, (pattern) => ({
      ...baseKeyPattern,
      ...pattern,
    }));
  const defaultDelayedPatterns = (patterns) =>
    map$3(patterns, (pattern) => ({
      ...baseKeyPattern,
      ...pattern,
    }));
  const matchesEvent = (pattern, evt) =>
    evt.keyCode === pattern.keyCode &&
    evt.shiftKey === pattern.shiftKey &&
    evt.altKey === pattern.altKey &&
    evt.ctrlKey === pattern.ctrlKey &&
    evt.metaKey === pattern.metaKey;
  const match$1 = (patterns, evt) =>
    bind$3(defaultPatterns(patterns), (pattern) =>
      matchesEvent(pattern, evt) ? [pattern] : []
    );
  const matchDelayed = (patterns, evt) =>
    bind$3(defaultDelayedPatterns(patterns), (pattern) =>
      matchesEvent(pattern, evt) ? [pattern] : []
    );
  const action =
    (f, ...x) =>
    () =>
      f.apply(null, x);
  const execute = (patterns, evt) =>
    find$2(match$1(patterns, evt), (pattern) => pattern.action());
  const executeWithDelayedAction = (patterns, evt) =>
    findMap(matchDelayed(patterns, evt), (pattern) => pattern.action());

  const moveH$1 = (editor, forward) => {
    const direction = forward ? 1 : -1;
    const range = editor.selection.getRng();
    return moveHorizontally(
      editor,
      direction,
      range,
      isBeforeMedia,
      isAfterMedia,
      isMedia$2
    ).exists((newRange) => {
      moveToRange(editor, newRange);
      return true;
    });
  };
  const moveV$1 = (editor, down) => {
    const direction = down ? 1 : -1;
    const range = editor.selection.getRng();
    return moveVertically(
      editor,
      direction,
      range,
      isBeforeMedia,
      isAfterMedia,
      isMedia$2
    ).exists((newRange) => {
      moveToRange(editor, newRange);
      return true;
    });
  };
  const moveToLineEndPoint = (editor, forward) => {
    const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
    return moveToLineEndPoint$3(editor, forward, isNearMedia);
  };

  const adt = Adt.generate([
    { none: ["current"] },
    { first: ["current"] },
    {
      middle: ["current", "target"],
    },
    { last: ["current"] },
  ]);
  const none = (current) => adt.none(current);
  const CellLocation = {
    ...adt,
    none,
  };

  const firstLayer = (scope, selector) => {
    return filterFirstLayer(scope, selector, always);
  };
  const filterFirstLayer = (scope, selector, predicate) => {
    return bind$3(children$1(scope), (x) => {
      if (is$1(x, selector)) {
        return predicate(x) ? [x] : [];
      } else {
        return filterFirstLayer(x, selector, predicate);
      }
    });
  };

  const lookup$1 = (tags, element, isRoot = never) => {
    if (isRoot(element)) {
      return Optional.none();
    }
    if (contains$2(tags, name(element))) {
      return Optional.some(element);
    }
    const isRootOrUpperTable = (elm) => is$1(elm, "table") || isRoot(elm);
    return ancestor$3(element, tags.join(","), isRootOrUpperTable);
  };
  const cell = (element, isRoot) => lookup$1(["td", "th"], element, isRoot);
  const cells = (ancestor) => firstLayer(ancestor, "th,td");
  const table = (element, isRoot) => closest$3(element, "table", isRoot);

  const walk = (all, current, index, direction, isEligible = always) => {
    const forwards = direction === 1;
    if (!forwards && index <= 0) {
      return CellLocation.first(all[0]);
    } else if (forwards && index >= all.length - 1) {
      return CellLocation.last(all[all.length - 1]);
    } else {
      const newIndex = index + direction;
      const elem = all[newIndex];
      return isEligible(elem)
        ? CellLocation.middle(current, elem)
        : walk(all, current, newIndex, direction, isEligible);
    }
  };
  const detect = (current, isRoot) => {
    return table(current, isRoot).bind((table) => {
      const all = cells(table);
      const index = findIndex$2(all, (x) => eq(current, x));
      return index.map((index) => ({
        index,
        all,
      }));
    });
  };
  const next = (current, isEligible, isRoot) => {
    const detection = detect(current, isRoot);
    return detection.fold(
      () => {
        return CellLocation.none(current);
      },
      (info) => {
        return walk(info.all, current, info.index, 1, isEligible);
      }
    );
  };
  const prev = (current, isEligible, isRoot) => {
    const detection = detect(current, isRoot);
    return detection.fold(
      () => {
        return CellLocation.none();
      },
      (info) => {
        return walk(info.all, current, info.index, -1, isEligible);
      }
    );
  };

  const isTextNodeWithCursorPosition = (el) =>
    getOption(el)
      .filter((text) => text.trim().length !== 0 || text.indexOf(nbsp) > -1)
      .isSome();
  const isContentEditableFalse$3 = (elem) =>
    isHTMLElement$1(elem) && get$9(elem, "contenteditable") === "false";
  const elementsWithCursorPosition = ["img", "br"];
  const isCursorPosition = (elem) => {
    const hasCursorPosition = isTextNodeWithCursorPosition(elem);
    return (
      hasCursorPosition ||
      contains$2(elementsWithCursorPosition, name(elem)) ||
      isContentEditableFalse$3(elem)
    );
  };

  const first = (element) => descendant$2(element, isCursorPosition);

  const deflate = (rect, delta) => ({
    left: rect.left - delta,
    top: rect.top - delta,
    right: rect.right + delta * 2,
    bottom: rect.bottom + delta * 2,
    width: rect.width + delta,
    height: rect.height + delta,
  });
  const getCorners = (getYAxisValue, tds) =>
    bind$3(tds, (td) => {
      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
      return [
        {
          x: rect.left,
          y: getYAxisValue(rect),
          cell: td,
        },
        {
          x: rect.right,
          y: getYAxisValue(rect),
          cell: td,
        },
      ];
    });
  const findClosestCorner = (corners, x, y) =>
    foldl(
      corners,
      (acc, newCorner) =>
        acc.fold(
          () => Optional.some(newCorner),
          (oldCorner) => {
            const oldDist = Math.sqrt(
              Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y)
            );
            const newDist = Math.sqrt(
              Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y)
            );
            return Optional.some(newDist < oldDist ? newCorner : oldCorner);
          }
        ),
      Optional.none()
    );
  const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {
    const cells = descendants(SugarElement.fromDom(table), "td,th,caption").map(
      (e) => e.dom
    );
    const corners = filter$5(getCorners(getYAxisValue, cells), (corner) =>
      isTargetCorner(corner, y)
    );
    return findClosestCorner(corners, x, y).map((corner) => corner.cell);
  };
  const getBottomValue = (rect) => rect.bottom;
  const getTopValue = (rect) => rect.top;
  const isAbove = (corner, y) => corner.y < y;
  const isBelow = (corner, y) => corner.y > y;
  const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
  const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
  const findClosestPositionInAboveCell = (table, pos) =>
    head(pos.getClientRects())
      .bind((rect) => getClosestCellAbove(table, rect.left, rect.top))
      .bind((cell) =>
        findClosestHorizontalPosition(getLastLinePositions(cell), pos)
      );
  const findClosestPositionInBelowCell = (table, pos) =>
    last$2(pos.getClientRects())
      .bind((rect) => getClosestCellBelow(table, rect.left, rect.top))
      .bind((cell) =>
        findClosestHorizontalPosition(getFirstLinePositions(cell), pos)
      );

  const hasNextBreak = (getPositionsUntil, scope, lineInfo) =>
    lineInfo.breakAt.exists((breakPos) =>
      getPositionsUntil(scope, breakPos).breakAt.isSome()
    );
  const startsWithWrapBreak = (lineInfo) =>
    lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
  const startsWithBrBreak = (lineInfo) =>
    lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
  const isAtTableCellLine = (getPositionsUntil, scope, pos) => {
    const lineInfo = getPositionsUntil(scope, pos);
    if (
      startsWithWrapBreak(lineInfo) ||
      (!isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo))
    ) {
      return !hasNextBreak(getPositionsUntil, scope, lineInfo);
    } else {
      return lineInfo.breakAt.isNone();
    }
  };
  const isAtFirstTableCellLine = curry(
    isAtTableCellLine,
    getPositionsUntilPreviousLine
  );
  const isAtLastTableCellLine = curry(
    isAtTableCellLine,
    getPositionsUntilNextLine
  );
  const isCaretAtStartOrEndOfTable = (forward, rng, table) => {
    const caretPos = CaretPosition.fromRangeStart(rng);
    return positionIn(!forward, table).exists((pos) => pos.isEqual(caretPos));
  };
  const navigateHorizontally = (editor, forward, table, _td) => {
    const rng = editor.selection.getRng();
    const direction = forward ? 1 : -1;
    if (
      isFakeCaretTableBrowser() &&
      isCaretAtStartOrEndOfTable(forward, rng, table)
    ) {
      showCaret(direction, editor, table, !forward, false).each((newRng) => {
        moveToRange(editor, newRng);
      });
      return true;
    }
    return false;
  };
  const getClosestAbovePosition = (root, table, start) =>
    findClosestPositionInAboveCell(table, start)
      .orThunk(() =>
        head(start.getClientRects()).bind((rect) =>
          findClosestHorizontalPositionFromPoint(
            getPositionsAbove(root, CaretPosition.before(table)),
            rect.left
          )
        )
      )
      .getOr(CaretPosition.before(table));
  const getClosestBelowPosition = (root, table, start) =>
    findClosestPositionInBelowCell(table, start)
      .orThunk(() =>
        head(start.getClientRects()).bind((rect) =>
          findClosestHorizontalPositionFromPoint(
            getPositionsBelow(root, CaretPosition.after(table)),
            rect.left
          )
        )
      )
      .getOr(CaretPosition.after(table));
  const getTable = (previous, pos) => {
    const node = pos.getNode(previous);
    return isTable$2(node) ? Optional.some(node) : Optional.none();
  };
  const renderBlock = (down, editor, table) => {
    editor.undoManager.transact(() => {
      const insertFn = down ? after$4 : before$3;
      const rng = insertEmptyLine(
        editor,
        SugarElement.fromDom(table),
        insertFn
      );
      moveToRange(editor, rng);
    });
  };
  const moveCaret = (editor, down, pos) => {
    const table = down ? getTable(true, pos) : getTable(false, pos);
    const last = down === false;
    table.fold(
      () => moveToRange(editor, pos.toRange()),
      (table) =>
        positionIn(last, editor.getBody())
          .filter((lastPos) => lastPos.isEqual(pos))
          .fold(
            () => moveToRange(editor, pos.toRange()),
            (_) => renderBlock(down, editor, table)
          )
    );
  };
  const navigateVertically = (editor, down, table, td) => {
    const rng = editor.selection.getRng();
    const pos = CaretPosition.fromRangeStart(rng);
    const root = editor.getBody();
    if (!down && isAtFirstTableCellLine(td, pos)) {
      const newPos = getClosestAbovePosition(root, table, pos);
      moveCaret(editor, down, newPos);
      return true;
    } else if (down && isAtLastTableCellLine(td, pos)) {
      const newPos = getClosestBelowPosition(root, table, pos);
      moveCaret(editor, down, newPos);
      return true;
    } else {
      return false;
    }
  };
  const move$1 = (editor, forward, mover) =>
    Optional.from(editor.dom.getParent(editor.selection.getNode(), "td,th"))
      .bind((td) =>
        Optional.from(editor.dom.getParent(td, "table")).map((table) =>
          mover(editor, forward, table, td)
        )
      )
      .getOr(false);
  const moveH = (editor, forward) =>
    move$1(editor, forward, navigateHorizontally);
  const moveV = (editor, forward) =>
    move$1(editor, forward, navigateVertically);
  const getCellFirstCursorPosition = (cell) => {
    const selection = SimSelection.exact(cell, 0, cell, 0);
    return toNative(selection);
  };
  const tabGo = (editor, isRoot, cell) => {
    return cell.fold(
      Optional.none,
      Optional.none,
      (_current, next) => {
        return first(next).map((cell) => {
          return getCellFirstCursorPosition(cell);
        });
      },
      (current) => {
        if (editor.mode.isReadOnly()) {
          return Optional.none();
        }
        editor.execCommand("mceTableInsertRowAfter");
        return tabForward(editor, isRoot, current);
      }
    );
  };
  const tabForward = (editor, isRoot, cell) =>
    tabGo(editor, isRoot, next(cell, isEditable$2));
  const tabBackward = (editor, isRoot, cell) =>
    tabGo(editor, isRoot, prev(cell, isEditable$2));
  const handleTab = (editor, forward) => {
    const rootElements = ["table", "li", "dl"];
    const body = SugarElement.fromDom(editor.getBody());
    const isRoot = (element) => {
      const name$1 = name(element);
      return eq(element, body) || contains$2(rootElements, name$1);
    };
    const rng = editor.selection.getRng();
    const container = SugarElement.fromDom(
      !forward ? rng.startContainer : rng.endContainer
    );
    return cell(container, isRoot)
      .map((cell) => {
        table(cell, isRoot).each((table) => {
          editor.model.table.clearSelectedCells(table.dom);
        });
        editor.selection.collapse(!forward);
        const navigation = !forward ? tabBackward : tabForward;
        const rng = navigation(editor, isRoot, cell);
        rng.each((range) => {
          editor.selection.setRng(range);
        });
        return true;
      })
      .getOr(false);
  };

  const executeKeydownOverride$4 = (editor, caret, evt) => {
    const isMac = Env.os.isMacOS() || Env.os.isiOS();
    execute(
      [
        {
          keyCode: VK.RIGHT,
          action: action(moveH$2, editor, true),
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$2, editor, false),
        },
        {
          keyCode: VK.UP,
          action: action(moveV$4, editor, false),
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$4, editor, true),
        },
        ...(isMac
          ? [
              {
                keyCode: VK.UP,
                action: action(selectToEndPoint, editor, false),
                metaKey: true,
                shiftKey: true,
              },
              {
                keyCode: VK.DOWN,
                action: action(selectToEndPoint, editor, true),
                metaKey: true,
                shiftKey: true,
              },
            ]
          : []),
        {
          keyCode: VK.RIGHT,
          action: action(moveH, editor, true),
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH, editor, false),
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false),
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV, editor, true),
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false),
        },
        {
          keyCode: VK.UP,
          action: action(moveV$2, editor, false),
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$2, editor, true),
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$1, editor, true),
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$1, editor, false),
        },
        {
          keyCode: VK.UP,
          action: action(moveV$1, editor, false),
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$1, editor, true),
        },
        {
          keyCode: VK.RIGHT,
          action: action(move$3, editor, caret, true),
        },
        {
          keyCode: VK.LEFT,
          action: action(move$3, editor, caret, false),
        },
        {
          keyCode: VK.RIGHT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(moveNextWord, editor, caret),
        },
        {
          keyCode: VK.LEFT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(movePrevWord, editor, caret),
        },
        {
          keyCode: VK.UP,
          action: action(moveV$3, editor, false),
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$3, editor, true),
        },
      ],
      evt
    ).each((_) => {
      evt.preventDefault();
    });
  };
  const setup$l = (editor, caret) => {
    editor.on("keydown", (evt) => {
      if (!evt.isDefaultPrevented()) {
        executeKeydownOverride$4(editor, caret, evt);
      }
    });
  };

  const point = (container, offset) => ({
    container,
    offset,
  });

  const DOM$7 = DOMUtils.DOM;
  const alwaysNext = (startNode) => (node) => startNode === node ? -1 : 0;
  const isBoundary = (dom) => (node) =>
    dom.isBlock(node) ||
    contains$2(["BR", "IMG", "HR", "INPUT"], node.nodeName) ||
    dom.getContentEditable(node) === "false";
  const textBefore = (node, offset, rootNode) => {
    if (isText$b(node) && offset >= 0) {
      return Optional.some(point(node, offset));
    } else {
      const textSeeker = TextSeeker(DOM$7);
      return Optional.from(
        textSeeker.backwards(node, offset, alwaysNext(node), rootNode)
      ).map((prev) => point(prev.container, prev.container.data.length));
    }
  };
  const textAfter = (node, offset, rootNode) => {
    if (isText$b(node) && offset >= node.length) {
      return Optional.some(point(node, offset));
    } else {
      const textSeeker = TextSeeker(DOM$7);
      return Optional.from(
        textSeeker.forwards(node, offset, alwaysNext(node), rootNode)
      ).map((prev) => point(prev.container, 0));
    }
  };
  const scanLeft = (node, offset, rootNode) => {
    if (!isText$b(node)) {
      return Optional.none();
    }
    const text = node.data;
    if (offset >= 0 && offset <= text.length) {
      return Optional.some(point(node, offset));
    } else {
      const textSeeker = TextSeeker(DOM$7);
      return Optional.from(
        textSeeker.backwards(node, offset, alwaysNext(node), rootNode)
      ).bind((prev) => {
        const prevText = prev.container.data;
        return scanLeft(prev.container, offset + prevText.length, rootNode);
      });
    }
  };
  const scanRight = (node, offset, rootNode) => {
    if (!isText$b(node)) {
      return Optional.none();
    }
    const text = node.data;
    if (offset <= text.length) {
      return Optional.some(point(node, offset));
    } else {
      const textSeeker = TextSeeker(DOM$7);
      return Optional.from(
        textSeeker.forwards(node, offset, alwaysNext(node), rootNode)
      ).bind((next) =>
        scanRight(next.container, offset - text.length, rootNode)
      );
    }
  };
  const repeatLeft = (dom, node, offset, process, rootNode) => {
    const search = TextSeeker(dom, isBoundary(dom));
    return Optional.from(search.backwards(node, offset, process, rootNode));
  };

  const isValidTextRange = (rng) =>
    rng.collapsed && isText$b(rng.startContainer);
  const getText = (rng) => trim$2(rng.toString().replace(/\u00A0/g, " "));
  const isWhitespace = (chr) =>
    chr !== "" && " \xA0\uFEFF\f\n\r\t\x0B".indexOf(chr) !== -1;

  const stripTrigger = (text, trigger) => text.substring(trigger.length);
  const findTrigger = (text, index, trigger, includeWhitespace = false) => {
    let i;
    const firstChar = trigger.charAt(0);
    for (i = index - 1; i >= 0; i--) {
      const char = text.charAt(i);
      if (!includeWhitespace && isWhitespace(char)) {
        return Optional.none();
      }
      if (firstChar === char && contains$1(text, trigger, i, index)) {
        break;
      }
    }
    return Optional.some(i);
  };
  const getContext = (dom, initRange, trigger, includeWhitespace = false) => {
    if (!isValidTextRange(initRange)) {
      return Optional.none();
    }
    const buffer = {
      text: "",
      offset: 0,
    };
    const findTriggerIndex = (element, offset, text) => {
      buffer.text = text + buffer.text;
      buffer.offset += offset;
      return findTrigger(
        buffer.text,
        buffer.offset,
        trigger,
        includeWhitespace
      ).getOr(offset);
    };
    const root =
      dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
    return repeatLeft(
      dom,
      initRange.startContainer,
      initRange.startOffset,
      findTriggerIndex,
      root
    ).bind((spot) => {
      const range = initRange.cloneRange();
      range.setStart(spot.container, spot.offset);
      range.setEnd(initRange.endContainer, initRange.endOffset);
      if (range.collapsed) {
        return Optional.none();
      }
      const text = getText(range);
      const triggerIndex = text.lastIndexOf(trigger);
      if (triggerIndex !== 0) {
        return Optional.none();
      } else {
        return Optional.some({
          text: stripTrigger(text, trigger),
          range,
          trigger,
        });
      }
    });
  };

  const isText$1 = (node) => node.nodeType === TEXT;
  const isElement = (node) => node.nodeType === ELEMENT;
  const toLast = (node) => {
    if (isText$1(node)) {
      return point(node, node.data.length);
    } else {
      const children = node.childNodes;
      return children.length > 0
        ? toLast(children[children.length - 1])
        : point(node, children.length);
    }
  };
  const toLeaf = (node, offset) => {
    const children = node.childNodes;
    if (children.length > 0 && offset < children.length) {
      return toLeaf(children[offset], 0);
    } else if (
      children.length > 0 &&
      isElement(node) &&
      children.length === offset
    ) {
      return toLast(children[children.length - 1]);
    } else {
      return point(node, offset);
    }
  };

  const isPreviousCharContent = (dom, leaf) => {
    var _a;
    const root =
      (_a = dom.getParent(leaf.container, dom.isBlock)) !== null &&
      _a !== void 0
        ? _a
        : dom.getRoot();
    return repeatLeft(
      dom,
      leaf.container,
      leaf.offset,
      (_element, offset) => (offset === 0 ? -1 : offset),
      root
    )
      .filter((spot) => {
        const char = spot.container.data.charAt(spot.offset - 1);
        return !isWhitespace(char);
      })
      .isSome();
  };
  const isStartOfWord = (dom) => (rng) => {
    const leaf = toLeaf(rng.startContainer, rng.startOffset);
    return !isPreviousCharContent(dom, leaf);
  };
  const getTriggerContext = (dom, initRange, database) =>
    findMap(database.triggers, (trigger) =>
      getContext(dom, initRange, trigger)
    );
  const lookup = (editor, getDatabase) => {
    const database = getDatabase();
    const rng = editor.selection.getRng();
    return getTriggerContext(editor.dom, rng, database).bind((context) =>
      lookupWithContext(editor, getDatabase, context)
    );
  };
  const lookupWithContext = (
    editor,
    getDatabase,
    context,
    fetchOptions = {}
  ) => {
    var _a;
    const database = getDatabase();
    const rng = editor.selection.getRng();
    const startText =
      (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : "";
    const autocompleters = filter$5(
      database.lookupByTrigger(context.trigger),
      (autocompleter) =>
        context.text.length >= autocompleter.minChars &&
        autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(
          context.range,
          startText,
          context.text
        )
    );
    if (autocompleters.length === 0) {
      return Optional.none();
    }
    const lookupData = Promise.all(
      map$3(autocompleters, (ac) => {
        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
        return fetchResult.then((results) => ({
          matchText: context.text,
          items: results,
          columns: ac.columns,
          onAction: ac.onAction,
          highlightOn: ac.highlightOn,
        }));
      })
    );
    return Optional.some({
      lookupData,
      context,
    });
  };

  var SimpleResultType;
  (function (SimpleResultType) {
    SimpleResultType[(SimpleResultType["Error"] = 0)] = "Error";
    SimpleResultType[(SimpleResultType["Value"] = 1)] = "Value";
  })(SimpleResultType || (SimpleResultType = {}));
  const fold$1 = (res, onError, onValue) =>
    res.stype === SimpleResultType.Error
      ? onError(res.serror)
      : onValue(res.svalue);
  const partition = (results) => {
    const values = [];
    const errors = [];
    each$e(results, (obj) => {
      fold$1(
        obj,
        (err) => errors.push(err),
        (val) => values.push(val)
      );
    });
    return {
      values,
      errors,
    };
  };
  const mapError = (res, f) => {
    if (res.stype === SimpleResultType.Error) {
      return {
        stype: SimpleResultType.Error,
        serror: f(res.serror),
      };
    } else {
      return res;
    }
  };
  const map = (res, f) => {
    if (res.stype === SimpleResultType.Value) {
      return {
        stype: SimpleResultType.Value,
        svalue: f(res.svalue),
      };
    } else {
      return res;
    }
  };
  const bind$1 = (res, f) => {
    if (res.stype === SimpleResultType.Value) {
      return f(res.svalue);
    } else {
      return res;
    }
  };
  const bindError = (res, f) => {
    if (res.stype === SimpleResultType.Error) {
      return f(res.serror);
    } else {
      return res;
    }
  };
  const svalue = (v) => ({
    stype: SimpleResultType.Value,
    svalue: v,
  });
  const serror = (e) => ({
    stype: SimpleResultType.Error,
    serror: e,
  });
  const toResult = (res) => fold$1(res, Result.error, Result.value);
  const fromResult = (res) => res.fold(serror, svalue);
  const SimpleResult = {
    fromResult,
    toResult,
    svalue,
    partition,
    serror,
    bind: bind$1,
    bindError,
    map,
    mapError,
    fold: fold$1,
  };

  const formatObj = (input) => {
    return isObject(input) && keys(input).length > 100
      ? " removed due to size"
      : JSON.stringify(input, null, 2);
  };
  const formatErrors = (errors) => {
    const es =
      errors.length > 10
        ? errors.slice(0, 10).concat([
            {
              path: [],
              getErrorInfo: constant("... (only showing first ten failures)"),
            },
          ])
        : errors;
    return map$3(es, (e) => {
      return "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo();
    });
  };

  const nu = (path, getErrorInfo) => {
    return SimpleResult.serror([
      {
        path,
        getErrorInfo,
      },
    ]);
  };
  const missingRequired = (path, key, obj) =>
    nu(
      path,
      () =>
        'Could not find valid *required* value for "' +
        key +
        '" in ' +
        formatObj(obj)
    );
  const missingKey = (path, key) =>
    nu(path, () => 'Choice schema did not contain choice key: "' + key + '"');
  const missingBranch = (path, branches, branch) =>
    nu(
      path,
      () =>
        'The chosen schema: "' +
        branch +
        '" did not exist in branches: ' +
        formatObj(branches)
    );
  const custom = (path, err) => nu(path, constant(err));

  const chooseFrom = (path, input, branches, ch) => {
    const fields = get$a(branches, ch);
    return fields.fold(
      () => missingBranch(path, branches, ch),
      (vp) => vp.extract(path.concat(["branch: " + ch]), input)
    );
  };
  const choose$1 = (key, branches) => {
    const extract = (path, input) => {
      const choice = get$a(input, key);
      return choice.fold(
        () => missingKey(path, key),
        (chosen) => chooseFrom(path, input, branches, chosen)
      );
    };
    const toString = () =>
      "chooseOn(" + key + "). Possible values: " + keys(branches);
    return {
      extract,
      toString,
    };
  };

  const shallow = (old, nu) => {
    return nu;
  };
  const deep = (old, nu) => {
    const bothObjects = isPlainObject(old) && isPlainObject(nu);
    return bothObjects ? deepMerge(old, nu) : nu;
  };
  const baseMerge = (merger) => {
    return (...objects) => {
      if (objects.length === 0) {
        throw new Error(`Can't merge zero objects`);
      }
      const ret = {};
      for (let j = 0; j < objects.length; j++) {
        const curObject = objects[j];
        for (const key in curObject) {
          if (has$2(curObject, key)) {
            ret[key] = merger(ret[key], curObject[key]);
          }
        }
      }
      return ret;
    };
  };
  const deepMerge = baseMerge(deep);
  const merge = baseMerge(shallow);

  const required = () => ({
    tag: "required",
    process: {},
  });
  const defaultedThunk = (fallbackThunk) => ({
    tag: "defaultedThunk",
    process: fallbackThunk,
  });
  const defaulted$1 = (fallback) => defaultedThunk(constant(fallback));
  const asOption = () => ({
    tag: "option",
    process: {},
  });

  const mergeValues = (values, base) =>
    values.length > 0
      ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values)))
      : SimpleResult.svalue(base);
  const mergeErrors = (errors) => compose(SimpleResult.serror, flatten)(errors);
  const consolidateObj = (objects, base) => {
    const partition = SimpleResult.partition(objects);
    return partition.errors.length > 0
      ? mergeErrors(partition.errors)
      : mergeValues(partition.values, base);
  };
  const consolidateArr = (objects) => {
    const partitions = SimpleResult.partition(objects);
    return partitions.errors.length > 0
      ? mergeErrors(partitions.errors)
      : SimpleResult.svalue(partitions.values);
  };
  const ResultCombine = {
    consolidateObj,
    consolidateArr,
  };

  const field$1 = (key, newKey, presence, prop) => ({
    tag: "field",
    key,
    newKey,
    presence,
    prop,
  });
  const customField$1 = (newKey, instantiator) => ({
    tag: "custom",
    newKey,
    instantiator,
  });
  const fold = (value, ifField, ifCustom) => {
    switch (value.tag) {
      case "field":
        return ifField(value.key, value.newKey, value.presence, value.prop);
      case "custom":
        return ifCustom(value.newKey, value.instantiator);
    }
  };

  const value = (validator) => {
    const extract = (path, val) => {
      return SimpleResult.bindError(validator(val), (err) => custom(path, err));
    };
    const toString = constant("val");
    return {
      extract,
      toString,
    };
  };
  const anyValue$1 = value(SimpleResult.svalue);

  const requiredAccess = (path, obj, key, bundle) =>
    get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);
  const fallbackAccess = (obj, key, fallback, bundle) => {
    const v = get$a(obj, key).getOrThunk(() => fallback(obj));
    return bundle(v);
  };
  const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
  const optionDefaultedAccess = (obj, key, fallback, bundle) => {
    const opt = get$a(obj, key).map((val) =>
      val === true ? fallback(obj) : val
    );
    return bundle(opt);
  };
  const extractField = (field, path, obj, key, prop) => {
    const bundle = (av) => prop.extract(path.concat([key]), av);
    const bundleAsOption = (optValue) =>
      optValue.fold(
        () => SimpleResult.svalue(Optional.none()),
        (ov) => {
          const result = prop.extract(path.concat([key]), ov);
          return SimpleResult.map(result, Optional.some);
        }
      );
    switch (field.tag) {
      case "required":
        return requiredAccess(path, obj, key, bundle);
      case "defaultedThunk":
        return fallbackAccess(obj, key, field.process, bundle);
      case "option":
        return optionAccess(obj, key, bundleAsOption);
      case "defaultedOptionThunk":
        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
      case "mergeWithThunk": {
        return fallbackAccess(obj, key, constant({}), (v) => {
          const result = deepMerge(field.process(obj), v);
          return bundle(result);
        });
      }
    }
  };
  const extractFields = (path, obj, fields) => {
    const success = {};
    const errors = [];
    for (const field of fields) {
      fold(
        field,
        (key, newKey, presence, prop) => {
          const result = extractField(presence, path, obj, key, prop);
          SimpleResult.fold(
            result,
            (err) => {
              errors.push(...err);
            },
            (res) => {
              success[newKey] = res;
            }
          );
        },
        (newKey, instantiator) => {
          success[newKey] = instantiator(obj);
        }
      );
    }
    return errors.length > 0
      ? SimpleResult.serror(errors)
      : SimpleResult.svalue(success);
  };
  const objOf = (values) => {
    const extract = (path, o) => extractFields(path, o, values);
    const toString = () => {
      const fieldStrings = map$3(values, (value) =>
        fold(
          value,
          (key, _okey, _presence, prop) => key + " -> " + prop.toString(),
          (newKey, _instantiator) => "state(" + newKey + ")"
        )
      );
      return "obj{\n" + fieldStrings.join("\n") + "}";
    };
    return {
      extract,
      toString,
    };
  };
  const arrOf = (prop) => {
    const extract = (path, array) => {
      const results = map$3(array, (a, i) =>
        prop.extract(path.concat(["[" + i + "]"]), a)
      );
      return ResultCombine.consolidateArr(results);
    };
    const toString = () => "array(" + prop.toString() + ")";
    return {
      extract,
      toString,
    };
  };
  const oneOf = (props, rawF) => {
    const f = rawF !== undefined ? rawF : identity;
    const extract = (path, val) => {
      const errors = [];
      for (const prop of props) {
        const res = prop.extract(path, val);
        if (res.stype === SimpleResultType.Value) {
          return {
            stype: SimpleResultType.Value,
            svalue: f(res.svalue),
          };
        }
        errors.push(res);
      }
      return ResultCombine.consolidateArr(errors);
    };
    const toString = () =>
      "oneOf(" + map$3(props, (prop) => prop.toString()).join(", ") + ")";
    return {
      extract,
      toString,
    };
  };
  const arrOfObj = compose(arrOf, objOf);

  const valueOf = (validator) =>
    value((v) => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));
  const extractValue = (label, prop, obj) => {
    const res = prop.extract([label], obj);
    return SimpleResult.mapError(res, (errs) => ({
      input: obj,
      errors: errs,
    }));
  };
  const asRaw = (label, prop, obj) =>
    SimpleResult.toResult(extractValue(label, prop, obj));
  const formatError = (errInfo) => {
    return (
      "Errors: \n" +
      formatErrors(errInfo.errors).join("\n") +
      "\n\nInput object: " +
      formatObj(errInfo.input)
    );
  };
  const choose = (key, branches) => choose$1(key, map$2(branches, objOf));

  const anyValue = constant(anyValue$1);
  const typedValue = (validator, expectedType) =>
    value((a) => {
      const actualType = typeof a;
      return validator(a)
        ? SimpleResult.svalue(a)
        : SimpleResult.serror(
            `Expected type: ${expectedType} but got: ${actualType}`
          );
    });
  const number = typedValue(isNumber, "number");
  const string = typedValue(isString, "string");
  const boolean = typedValue(isBoolean, "boolean");
  const functionProcessor = typedValue(isFunction, "function");

  const field = field$1;
  const customField = customField$1;
  const validateEnum = (values) =>
    valueOf((value) =>
      contains$2(values, value)
        ? Result.value(value)
        : Result.error(
            `Unsupported value: "${value}", choose one of "${values.join(
              ", "
            )}".`
          )
    );
  const requiredOf = (key, schema) => field(key, key, required(), schema);
  const requiredString = (key) => requiredOf(key, string);
  const requiredStringEnum = (key, values) =>
    field(key, key, required(), validateEnum(values));
  const requiredFunction = (key) => requiredOf(key, functionProcessor);
  const requiredArrayOf = (key, schema) =>
    field(key, key, required(), arrOf(schema));
  const optionOf = (key, schema) => field(key, key, asOption(), schema);
  const optionString = (key) => optionOf(key, string);
  const optionFunction = (key) => optionOf(key, functionProcessor);
  const defaulted = (key, fallback) =>
    field(key, key, defaulted$1(fallback), anyValue());
  const defaultedOf = (key, fallback, schema) =>
    field(key, key, defaulted$1(fallback), schema);
  const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);
  const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);
  const defaultedStringEnum = (key, fallback, values) =>
    defaultedOf(key, fallback, validateEnum(values));
  const defaultedBoolean = (key, fallback) =>
    defaultedOf(key, fallback, boolean);
  const defaultedFunction = (key, fallback) =>
    defaultedOf(key, fallback, functionProcessor);
  const defaultedArrayOf = (key, fallback, schema) =>
    defaultedOf(key, fallback, arrOf(schema));

  const type = requiredString("type");
  const fetch$1 = requiredFunction("fetch");
  const onAction = requiredFunction("onAction");
  const onSetup = defaultedFunction("onSetup", () => noop);
  const optionalText = optionString("text");
  const optionalIcon = optionString("icon");
  const optionalTooltip = optionString("tooltip");
  const optionalLabel = optionString("label");
  const active = defaultedBoolean("active", false);
  const enabled = defaultedBoolean("enabled", true);
  const primary = defaultedBoolean("primary", false);
  const defaultedColumns = (num) => defaulted("columns", num);
  const defaultedType = (type) => defaultedString("type", type);

  const autocompleterSchema = objOf([
    type,
    requiredString("trigger"),
    defaultedNumber("minChars", 1),
    defaultedColumns(1),
    defaultedNumber("maxResults", 10),
    optionFunction("matches"),
    fetch$1,
    onAction,
    defaultedArrayOf("highlightOn", [], string),
  ]);
  const createAutocompleter = (spec) =>
    asRaw("Autocompleter", autocompleterSchema, spec);

  const baseToolbarButtonFields = [
    enabled,
    optionalTooltip,
    optionalIcon,
    optionalText,
    onSetup,
    defaultedString("context", "mode:design"),
  ];

  const baseToolbarToggleButtonFields = [active].concat(
    baseToolbarButtonFields
  );

  const contextBarFields = [
    defaultedFunction("predicate", never),
    defaultedStringEnum("scope", "node", ["node", "editor"]),
    defaultedStringEnum("position", "selection", ["node", "selection", "line"]),
  ];

  const contextButtonFields = baseToolbarButtonFields.concat([
    defaultedType("contextformbutton"),
    defaultedString("align", "end"),
    primary,
    onAction,
    customField("original", identity),
  ]);
  const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
    defaultedType("contextformbutton"),
    defaultedString("align", "end"),
    primary,
    onAction,
    customField("original", identity),
  ]);
  const launchButtonFields = baseToolbarButtonFields.concat([
    defaultedType("contextformbutton"),
  ]);
  const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([
    defaultedType("contextformtogglebutton"),
  ]);
  const toggleOrNormal = choose("type", {
    contextformbutton: contextButtonFields,
    contextformtogglebutton: contextToggleButtonFields,
  });
  const baseContextFormFields = [
    optionalLabel,
    requiredArrayOf("commands", toggleOrNormal),
    optionOf(
      "launch",
      choose("type", {
        contextformbutton: launchButtonFields,
        contextformtogglebutton: launchToggleButtonFields,
      })
    ),
    defaultedFunction("onInput", noop),
    defaultedFunction("onSetup", noop),
  ];
  const contextFormFields = [
    ...contextBarFields,
    ...baseContextFormFields,
    requiredStringEnum("type", ["contextform"]),
    defaultedFunction("initValue", constant("")),
    optionString("placeholder"),
  ];
  const contextSliderFormFields = [
    ...contextBarFields,
    ...baseContextFormFields,
    requiredStringEnum("type", ["contextsliderform"]),
    defaultedFunction("initValue", constant(0)),
    defaultedFunction("min", constant(0)),
    defaultedFunction("max", constant(100)),
  ];
  const contextSizeInputFormFields = [
    ...contextBarFields,
    ...baseContextFormFields,
    requiredStringEnum("type", ["contextsizeinputform"]),
    defaultedFunction(
      "initValue",
      constant({
        width: "",
        height: "",
      })
    ),
  ];
  choose("type", {
    contextform: contextFormFields,
    contextsliderform: contextSliderFormFields,
    contextsizeinputform: contextSizeInputFormFields,
  });

  objOf(
    [
      defaultedType("contexttoolbar"),
      requiredOf(
        "items",
        oneOf([
          string,
          arrOfObj([
            optionString("name"),
            optionString("label"),
            requiredArrayOf("items", string),
          ]),
        ])
      ),
    ].concat(contextBarFields)
  );

  const register$2 = (editor) => {
    const popups = editor.ui.registry.getAll().popups;
    const dataset = map$2(popups, (popup) =>
      createAutocompleter(popup).fold((err) => {
        throw new Error(formatError(err));
      }, identity)
    );
    const triggers = stringArray(mapToArray(dataset, (v) => v.trigger));
    const datasetValues = values(dataset);
    const lookupByTrigger = (trigger) =>
      filter$5(datasetValues, (dv) => dv.trigger === trigger);
    return {
      dataset,
      triggers,
      lookupByTrigger,
    };
  };

  const setupEditorInput = (editor, api) => {
    const update = last(api.load, 50);
    editor.on("input", (e) => {
      if (e.inputType === "insertCompositionText" && !editor.composing) {
        return;
      }
      update.throttle();
    });
    editor.on(
      "keydown",
      (e) => {
        const keyCode = e.which;
        if (keyCode === 8) {
          update.throttle();
        } else if (keyCode === 27) {
          update.cancel();
          api.cancelIfNecessary();
        } else if (keyCode === 38 || keyCode === 40) {
          update.cancel();
        }
      },
      true
    );
    editor.on("remove", update.cancel);
  };
  const setup$k = (editor) => {
    const activeAutocompleter = value$2();
    const uiActive = Cell(false);
    const isActive = activeAutocompleter.isSet;
    const cancelIfNecessary = () => {
      if (isActive()) {
        fireAutocompleterEnd(editor);
        uiActive.set(false);
        activeAutocompleter.clear();
      }
    };
    const commenceIfNecessary = (context) => {
      if (!isActive()) {
        activeAutocompleter.set({
          trigger: context.trigger,
          matchLength: context.text.length,
        });
      }
    };
    const getAutocompleters = cached(() => register$2(editor));
    const doLookup = (fetchOptions) =>
      activeAutocompleter
        .get()
        .map((ac) =>
          getContext(
            editor.dom,
            editor.selection.getRng(),
            ac.trigger,
            true
          ).bind((newContext) =>
            lookupWithContext(
              editor,
              getAutocompleters,
              newContext,
              fetchOptions
            )
          )
        )
        .getOrThunk(() => lookup(editor, getAutocompleters));
    const load = (fetchOptions) => {
      doLookup(fetchOptions).fold(cancelIfNecessary, (lookupInfo) => {
        commenceIfNecessary(lookupInfo.context);
        lookupInfo.lookupData.then((lookupData) => {
          activeAutocompleter.get().map((ac) => {
            const context = lookupInfo.context;
            if (ac.trigger !== context.trigger) {
              return;
            }
            activeAutocompleter.set({
              ...ac,
              matchLength: context.text.length,
            });
            if (uiActive.get()) {
              fireAutocompleterUpdateActiveRange(editor, {
                range: context.range,
              });
              fireAutocompleterUpdate(editor, { lookupData });
            } else {
              uiActive.set(true);
              fireAutocompleterUpdateActiveRange(editor, {
                range: context.range,
              });
              fireAutocompleterStart(editor, { lookupData });
            }
          });
        });
      });
    };
    const isRangeInsideOrEqual = (innerRange, outerRange) => {
      const startComparison = innerRange.compareBoundaryPoints(
        window.Range.START_TO_START,
        outerRange
      );
      const endComparison = innerRange.compareBoundaryPoints(
        window.Range.END_TO_END,
        outerRange
      );
      return startComparison >= 0 && endComparison <= 0;
    };
    const readActiveRange = () => {
      return activeAutocompleter.get().bind(({ trigger }) => {
        const selRange = editor.selection.getRng();
        return getContext(editor.dom, selRange, trigger, uiActive.get())
          .filter(({ range }) => isRangeInsideOrEqual(selRange, range))
          .map(({ range }) => range);
      });
    };
    editor.addCommand("mceAutocompleterReload", (_ui, value) => {
      const fetchOptions = isObject(value) ? value.fetchOptions : {};
      load(fetchOptions);
    });
    editor.addCommand("mceAutocompleterClose", cancelIfNecessary);
    editor.addCommand("mceAutocompleterRefreshActiveRange", () => {
      readActiveRange().each((range) => {
        fireAutocompleterUpdateActiveRange(editor, { range });
      });
    });
    editor.editorCommands.addQueryStateHandler("mceAutoCompleterInRange", () =>
      readActiveRange().isSome()
    );
    setupEditorInput(editor, {
      cancelIfNecessary,
      load,
    });
  };

  const browser$1 = detect$1().browser;
  const isSafari = browser$1.isSafari();
  const emptyNodeContents = (node) =>
    fillWithPaddingBr(SugarElement.fromDom(node));
  const isEntireNodeSelected = (rng, node) => {
    var _a;
    return (
      rng.startOffset === 0 &&
      rng.endOffset ===
        ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length)
    );
  };
  const getParentDetailsElementAtPos = (dom, pos) =>
    Optional.from(dom.getParent(pos.container(), "details"));
  const isInDetailsElement = (dom, pos) =>
    getParentDetailsElementAtPos(dom, pos).isSome();
  const getDetailsElements = (dom, rng) => {
    const startDetails = Optional.from(
      dom.getParent(rng.startContainer, "details")
    );
    const endDetails = Optional.from(
      dom.getParent(rng.endContainer, "details")
    );
    if (startDetails.isSome() || endDetails.isSome()) {
      const startSummary = startDetails.bind((details) =>
        Optional.from(dom.select("summary", details)[0])
      );
      return Optional.some({
        startSummary,
        startDetails,
        endDetails,
      });
    } else {
      return Optional.none();
    }
  };
  const isCaretInTheBeginningOf = (caretPos, element) =>
    firstPositionIn(element).exists((pos) => pos.isEqual(caretPos));
  const isCaretInTheEndOf = (caretPos, element) => {
    return lastPositionIn(element).exists((pos) => {
      if (isBr$6(pos.getNode())) {
        return (
          prevPosition(element, pos).exists((pos2) => pos2.isEqual(caretPos)) ||
          pos.isEqual(caretPos)
        );
      } else {
        return pos.isEqual(caretPos);
      }
    });
  };
  const isCaretAtStartOfSummary = (caretPos, detailsElements) =>
    detailsElements.startSummary.exists((summary) =>
      isCaretInTheBeginningOf(caretPos, summary)
    );
  const isCaretAtEndOfSummary = (caretPos, detailsElements) =>
    detailsElements.startSummary.exists((summary) =>
      isCaretInTheEndOf(caretPos, summary)
    );
  const isCaretInFirstPositionInBody = (caretPos, detailsElements) =>
    detailsElements.startDetails.exists((details) =>
      prevPosition(details, caretPos).forall((pos) =>
        detailsElements.startSummary.exists(
          (summary) =>
            !summary.contains(caretPos.container()) &&
            summary.contains(pos.container())
        )
      )
    );
  const isCaretInLastPositionInBody = (root, caretPos, detailsElements) =>
    detailsElements.startDetails.exists((details) =>
      nextPosition(root, caretPos).forall(
        (pos) => !details.contains(pos.container())
      )
    );
  const setCaretToPosition = (editor, position) => {
    const node = position.getNode();
    if (!isUndefined(node)) {
      editor.selection.setCursorLocation(node, position.offset());
    }
  };
  const moveCaretToDetailsPos = (editor, pos, forward) => {
    const details = editor.dom.getParent(pos.container(), "details");
    if (details && !details.open) {
      const summary = editor.dom.select("summary", details)[0];
      if (summary) {
        const newPos = forward
          ? firstPositionIn(summary)
          : lastPositionIn(summary);
        newPos.each((pos) => setCaretToPosition(editor, pos));
      }
    } else {
      setCaretToPosition(editor, pos);
    }
  };
  const isPartialDelete = (rng, detailsElements) => {
    const containsStart = (element) => element.contains(rng.startContainer);
    const containsEnd = (element) => element.contains(rng.endContainer);
    const startInSummary = detailsElements.startSummary.exists(containsStart);
    const endInSummary = detailsElements.startSummary.exists(containsEnd);
    const isPartiallySelectedDetailsElements =
      detailsElements.startDetails.forall((startDetails) =>
        detailsElements.endDetails.forall(
          (endDetails) => startDetails !== endDetails
        )
      );
    const isInPartiallySelectedSummary =
      (startInSummary || endInSummary) && !(startInSummary && endInSummary);
    return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;
  };
  const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {
    const { dom, selection } = editor;
    const root = editor.getBody();
    if (granularity === "character") {
      const caretPos = CaretPosition.fromRangeStart(selection.getRng());
      const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);
      const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);
      const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);
      const isFirstBlock = isNull(
        parentBlock === null || parentBlock === void 0
          ? void 0
          : parentBlock.previousSibling
      );
      const isLastBlock = isNull(
        parentBlock === null || parentBlock === void 0
          ? void 0
          : parentBlock.nextSibling
      );
      if (inEmptyParentBlock) {
        const firstOrLast = forward ? isLastBlock : isFirstBlock;
        if (firstOrLast) {
          const isBeforeAfterDetails = navigate(
            !forward,
            root,
            caretPos
          ).exists((pos) => {
            return (
              isInDetailsElement(dom, pos) &&
              !equals(
                parentDetailsAtCaret,
                getParentDetailsElementAtPos(dom, pos)
              )
            );
          });
          if (isBeforeAfterDetails) {
            return true;
          }
        }
      }
      return navigate(forward, root, caretPos).fold(never, (pos) => {
        const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);
        if (
          isInDetailsElement(dom, pos) &&
          !equals(parentDetailsAtCaret, parentDetailsAtNewPos)
        ) {
          if (!forward) {
            moveCaretToDetailsPos(editor, pos, false);
          }
          if (parentBlock && inEmptyParentBlock) {
            if (forward && isFirstBlock) {
              return true;
            } else if (!forward && isLastBlock) {
              return true;
            }
            moveCaretToDetailsPos(editor, pos, forward);
            editor.dom.remove(parentBlock);
          }
          return true;
        } else {
          return false;
        }
      });
    } else {
      return false;
    }
  };
  const shouldPreventDeleteSummaryAction = (
    editor,
    detailElements,
    forward,
    granularity
  ) => {
    const selection = editor.selection;
    const rng = selection.getRng();
    const caretPos = CaretPosition.fromRangeStart(rng);
    const root = editor.getBody();
    if (granularity === "selection") {
      return isPartialDelete(rng, detailElements);
    } else if (forward) {
      return (
        isCaretAtEndOfSummary(caretPos, detailElements) ||
        isCaretInLastPositionInBody(root, caretPos, detailElements)
      );
    } else {
      return (
        isCaretAtStartOfSummary(caretPos, detailElements) ||
        isCaretInFirstPositionInBody(caretPos, detailElements)
      );
    }
  };
  const shouldPreventDeleteAction = (editor, forward, granularity) =>
    getDetailsElements(editor.dom, editor.selection.getRng()).fold(
      () => shouldPreventDeleteIntoDetails(editor, forward, granularity),
      (detailsElements) =>
        shouldPreventDeleteSummaryAction(
          editor,
          detailsElements,
          forward,
          granularity
        ) || shouldPreventDeleteIntoDetails(editor, forward, granularity)
    );
  const handleDeleteActionSafari = (editor, forward, granularity) => {
    const selection = editor.selection;
    const node = selection.getNode();
    const rng = selection.getRng();
    const caretPos = CaretPosition.fromRangeStart(rng);
    if (isSummary$1(node)) {
      if (
        (granularity === "selection" && isEntireNodeSelected(rng, node)) ||
        willDeleteLastPositionInElement(forward, caretPos, node)
      ) {
        emptyNodeContents(node);
      } else {
        editor.undoManager.transact(() => {
          const sel = selection.getSel();
          let { anchorNode, anchorOffset, focusNode, focusOffset } =
            sel !== null && sel !== void 0 ? sel : {};
          const applySelection = () => {
            if (
              isNonNullable(anchorNode) &&
              isNonNullable(anchorOffset) &&
              isNonNullable(focusNode) &&
              isNonNullable(focusOffset)
            ) {
              sel === null || sel === void 0
                ? void 0
                : sel.setBaseAndExtent(
                    anchorNode,
                    anchorOffset,
                    focusNode,
                    focusOffset
                  );
            }
          };
          const updateSelection = () => {
            anchorNode =
              sel === null || sel === void 0 ? void 0 : sel.anchorNode;
            anchorOffset =
              sel === null || sel === void 0 ? void 0 : sel.anchorOffset;
            focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
            focusOffset =
              sel === null || sel === void 0 ? void 0 : sel.focusOffset;
          };
          const appendAllChildNodes = (from, to) => {
            each$e(from.childNodes, (child) => {
              if (isNode(child)) {
                to.appendChild(child);
              }
            });
          };
          const container = editor.dom.create("span", {
            "data-mce-bogus": "1",
          });
          appendAllChildNodes(node, container);
          node.appendChild(container);
          applySelection();
          if (granularity === "word" || granularity === "line") {
            sel === null || sel === void 0
              ? void 0
              : sel.modify("extend", forward ? "right" : "left", granularity);
          }
          if (
            !selection.isCollapsed() &&
            isEntireNodeSelected(selection.getRng(), container)
          ) {
            emptyNodeContents(node);
          } else {
            editor.execCommand(forward ? "ForwardDelete" : "Delete");
            updateSelection();
            appendAllChildNodes(container, node);
            applySelection();
          }
          editor.dom.remove(container);
        });
      }
      return true;
    } else {
      return false;
    }
  };
  const backspaceDelete = (editor, forward, granularity) =>
    shouldPreventDeleteAction(editor, forward, granularity) ||
    (isSafari && handleDeleteActionSafari(editor, forward, granularity))
      ? Optional.some(noop)
      : Optional.none();

  const createAndFireInputEvent =
    (eventType) =>
    (editor, inputType, specifics = {}) => {
      const target = editor.getBody();
      const overrides = {
        bubbles: true,
        composed: true,
        data: null,
        isComposing: false,
        detail: 0,
        view: null,
        target,
        currentTarget: target,
        eventPhase: Event.AT_TARGET,
        originalTarget: target,
        explicitOriginalTarget: target,
        isTrusted: false,
        srcElement: target,
        cancelable: false,
        preventDefault: noop,
        inputType,
      };
      const input = clone$3(new InputEvent(eventType));
      return editor.dispatch(eventType, {
        ...input,
        ...overrides,
        ...specifics,
      });
    };
  const fireInputEvent = createAndFireInputEvent("input");
  const fireBeforeInputEvent = createAndFireInputEvent("beforeinput");

  const platform$2 = detect$1();
  const os = platform$2.os;
  const isMacOSOriOS = os.isMacOS() || os.isiOS();
  const browser = platform$2.browser;
  const isFirefox = browser.isFirefox();
  const executeKeydownOverride$3 = (editor, caret, evt) => {
    const inputType =
      evt.keyCode === VK.BACKSPACE
        ? "deleteContentBackward"
        : "deleteContentForward";
    const isCollapsed = editor.selection.isCollapsed();
    const unmodifiedGranularity = isCollapsed ? "character" : "selection";
    const getModifiedGranularity = (isWord) => {
      if (isCollapsed) {
        return isWord ? "word" : "line";
      } else {
        return "selection";
      }
    };
    executeWithDelayedAction(
      [
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$1, editor),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$7, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$7, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$8, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$8, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$4, editor, caret, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$4, editor, caret, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$b, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$b, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete, editor, false, unmodifiedGranularity),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete, editor, true, unmodifiedGranularity),
        },
        ...(isMacOSOriOS
          ? [
              {
                keyCode: VK.BACKSPACE,
                altKey: true,
                action: action(
                  backspaceDelete,
                  editor,
                  false,
                  getModifiedGranularity(true)
                ),
              },
              {
                keyCode: VK.DELETE,
                altKey: true,
                action: action(
                  backspaceDelete,
                  editor,
                  true,
                  getModifiedGranularity(true)
                ),
              },
              {
                keyCode: VK.BACKSPACE,
                metaKey: true,
                action: action(
                  backspaceDelete,
                  editor,
                  false,
                  getModifiedGranularity(false)
                ),
              },
            ]
          : [
              {
                keyCode: VK.BACKSPACE,
                ctrlKey: true,
                action: action(
                  backspaceDelete,
                  editor,
                  false,
                  getModifiedGranularity(true)
                ),
              },
              {
                keyCode: VK.DELETE,
                ctrlKey: true,
                action: action(
                  backspaceDelete,
                  editor,
                  true,
                  getModifiedGranularity(true)
                ),
              },
            ]),
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$5, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$5, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$2, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$2, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$9, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$9, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$a, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$a, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$3, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$3, editor, true),
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$6, editor, false),
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$6, editor, true),
        },
      ],
      evt
    )
      .filter((_) => editor.selection.isEditable())
      .each((applyAction) => {
        evt.preventDefault();
        const beforeInput = fireBeforeInputEvent(editor, inputType);
        if (!beforeInput.isDefaultPrevented()) {
          applyAction();
          fireInputEvent(editor, inputType);
        }
      });
  };
  const executeKeyupOverride = (editor, evt, isBackspaceKeydown) =>
    execute(
      [
        {
          keyCode: VK.BACKSPACE,
          action: action(paddEmptyElement, editor),
        },
        {
          keyCode: VK.DELETE,
          action: action(paddEmptyElement, editor),
        },
        ...(isMacOSOriOS
          ? [
              {
                keyCode: VK.BACKSPACE,
                altKey: true,
                action: action(refreshCaret, editor),
              },
              {
                keyCode: VK.DELETE,
                altKey: true,
                action: action(refreshCaret, editor),
              },
              ...(isBackspaceKeydown
                ? [
                    {
                      keyCode: isFirefox ? 224 : 91,
                      action: action(refreshCaret, editor),
                    },
                  ]
                : []),
            ]
          : [
              {
                keyCode: VK.BACKSPACE,
                ctrlKey: true,
                action: action(refreshCaret, editor),
              },
              {
                keyCode: VK.DELETE,
                ctrlKey: true,
                action: action(refreshCaret, editor),
              },
            ]),
      ],
      evt
    );
  const setup$j = (editor, caret) => {
    let isBackspaceKeydown = false;
    editor.on("keydown", (evt) => {
      isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
      if (!evt.isDefaultPrevented()) {
        executeKeydownOverride$3(editor, caret, evt);
      }
    });
    editor.on("keyup", (evt) => {
      if (!evt.isDefaultPrevented()) {
        executeKeyupOverride(editor, evt, isBackspaceKeydown);
      }
      isBackspaceKeydown = false;
    });
  };

  const firstNonWhiteSpaceNodeSibling = (node) => {
    while (node) {
      if (
        isElement$6(node) ||
        (isText$b(node) && node.data && /[\r\n\s]/.test(node.data))
      ) {
        return node;
      }
      node = node.nextSibling;
    }
    return null;
  };
  const moveToCaretPosition = (editor, root) => {
    const dom = editor.dom;
    const moveCaretBeforeOnEnterElementsMap =
      editor.schema.getMoveCaretBeforeOnEnterElements();
    if (!root) {
      return;
    }
    if (/^(LI|DT|DD)$/.test(root.nodeName)) {
      const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
      if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
        root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);
      }
    }
    const rng = dom.createRng();
    root.normalize();
    if (root.hasChildNodes()) {
      const walker = new DomTreeWalker(root, root);
      let lastNode = root;
      let node;
      while ((node = walker.current())) {
        if (isText$b(node)) {
          rng.setStart(node, 0);
          rng.setEnd(node, 0);
          break;
        }
        if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
          rng.setStartBefore(node);
          rng.setEndBefore(node);
          break;
        }
        lastNode = node;
        node = walker.next();
      }
      if (!node) {
        rng.setStart(lastNode, 0);
        rng.setEnd(lastNode, 0);
      }
    } else {
      if (isBr$6(root)) {
        if (root.nextSibling && dom.isBlock(root.nextSibling)) {
          rng.setStartBefore(root);
          rng.setEndBefore(root);
        } else {
          rng.setStartAfter(root);
          rng.setEndAfter(root);
        }
      } else {
        rng.setStart(root, 0);
        rng.setEnd(root, 0);
      }
    }
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, rng);
  };
  const getEditableRoot = (dom, node) => {
    const root = dom.getRoot();
    let editableRoot;
    let parent = node;
    while (
      parent !== root &&
      parent &&
      dom.getContentEditable(parent) !== "false"
    ) {
      if (dom.getContentEditable(parent) === "true") {
        editableRoot = parent;
        break;
      }
      parent = parent.parentNode;
    }
    return parent !== root ? editableRoot : root;
  };
  const getParentBlock$1 = (editor) => {
    return Optional.from(
      editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock)
    );
  };
  const getParentBlockName = (editor) => {
    return getParentBlock$1(editor).fold(constant(""), (parentBlock) => {
      return parentBlock.nodeName.toUpperCase();
    });
  };
  const isListItemParentBlock = (editor) => {
    return getParentBlock$1(editor)
      .filter((elm) => {
        return isListItem$1(SugarElement.fromDom(elm));
      })
      .isSome();
  };
  const emptyBlock = (elm) => {
    elm.innerHTML = '<br data-mce-bogus="1">';
  };
  const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
    const dom = editor.dom;
    Optional.from(forcedRootBlockAttrs.style)
      .map(dom.parseStyle)
      .each((attrStyles) => {
        const currentStyles = getAllRaw(SugarElement.fromDom(node));
        const newStyles = {
          ...currentStyles,
          ...attrStyles,
        };
        dom.setStyles(node, newStyles);
      });
    const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(
      (attrClasses) => attrClasses.split(/\s+/)
    );
    const currentClassesOpt = Optional.from(node.className).map(
      (currentClasses) =>
        filter$5(currentClasses.split(/\s+/), (clazz) => clazz !== "")
    );
    lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
      const filteredClasses = filter$5(
        currentClasses,
        (clazz) => !contains$2(attrClasses, clazz)
      );
      const newClasses = [...attrClasses, ...filteredClasses];
      dom.setAttrib(node, "class", newClasses.join(" "));
    });
    const appliedAttrs = ["style", "class"];
    const remainingAttrs = filter$4(
      forcedRootBlockAttrs,
      (_, attrs) => !contains$2(appliedAttrs, attrs)
    );
    dom.setAttribs(node, remainingAttrs);
  };
  const setForcedBlockAttrs = (editor, node) => {
    const forcedRootBlockName = getForcedRootBlock(editor);
    if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
      const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
      applyAttributes(editor, node, forcedRootBlockAttrs);
    }
  };
  const createNewBlock = (
    editor,
    container,
    parentBlock,
    editableRoot,
    keepStyles = true,
    name,
    styles
  ) => {
    const dom = editor.dom;
    const schema = editor.schema;
    const newBlockName = getForcedRootBlock(editor);
    const parentBlockName = parentBlock
      ? parentBlock.nodeName.toUpperCase()
      : "";
    let node = container;
    const textInlineElements = schema.getTextInlineElements();
    let block;
    if (name || parentBlockName === "TABLE" || parentBlockName === "HR") {
      block = dom.create(name || newBlockName, styles || {});
    } else {
      block = parentBlock.cloneNode(false);
    }
    let caretNode = block;
    if (!keepStyles) {
      dom.setAttrib(block, "style", null);
      dom.setAttrib(block, "class", null);
    } else {
      do {
        if (textInlineElements[node.nodeName]) {
          if (isCaretNode(node) || isBookmarkNode$1(node)) {
            continue;
          }
          const clonedNode = node.cloneNode(false);
          dom.setAttrib(clonedNode, "id", "");
          if (block.hasChildNodes()) {
            clonedNode.appendChild(block.firstChild);
            block.appendChild(clonedNode);
          } else {
            caretNode = clonedNode;
            block.appendChild(clonedNode);
          }
        }
      } while ((node = node.parentNode) && node !== editableRoot);
    }
    setForcedBlockAttrs(editor, block);
    emptyBlock(caretNode);
    return block;
  };

  const getDetailsRoot = (editor, element) =>
    editor.dom.getParent(element, isDetails);
  const isAtDetailsEdge = (root, element, isTextBlock) => {
    let node = element;
    while (node && node !== root && isNull(node.nextSibling)) {
      const parent = node.parentElement;
      if (!parent || !isTextBlock(parent)) {
        return isDetails(parent);
      }
      node = parent;
    }
    return false;
  };
  const isLastEmptyBlockInDetails = (editor, shiftKey, element) =>
    !shiftKey &&
    element.nodeName.toLowerCase() === getForcedRootBlock(editor) &&
    editor.dom.isEmpty(element) &&
    isAtDetailsEdge(editor.getBody(), element, (el) =>
      has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase())
    );
  const insertNewLine = (editor, createNewBlock, parentBlock) => {
    var _a, _b, _c;
    const newBlock = createNewBlock(getForcedRootBlock(editor));
    const root = getDetailsRoot(editor, parentBlock);
    if (!root) {
      return;
    }
    editor.dom.insertAfter(newBlock, root);
    moveToCaretPosition(editor, newBlock);
    if (
      ((_c =
        (_b =
          (_a = parentBlock.parentElement) === null || _a === void 0
            ? void 0
            : _a.childNodes) === null || _b === void 0
          ? void 0
          : _b.length) !== null && _c !== void 0
        ? _c
        : 0) > 1
    ) {
      editor.dom.remove(parentBlock);
    }
  };

  const hasFirstChild = (elm, name) => {
    return elm.firstChild && elm.firstChild.nodeName === name;
  };
  const isFirstChild = (elm) => {
    var _a;
    return (
      ((_a = elm.parentNode) === null || _a === void 0
        ? void 0
        : _a.firstChild) === elm
    );
  };
  const hasParent = (elm, parentName) => {
    const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
    return isNonNullable(parentNode) && parentNode.nodeName === parentName;
  };
  const isListBlock = (elm) => {
    return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
  };
  const isListItem = (elm) => {
    return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
  };
  const isNestedList = (elm) => {
    return isListBlock(elm) && isListBlock(elm.parentNode);
  };
  const getContainerBlock = (containerBlock) => {
    const containerBlockParent = containerBlock.parentNode;
    return isListItem(containerBlockParent)
      ? containerBlockParent
      : containerBlock;
  };
  const isFirstOrLastLi = (containerBlock, parentBlock, first) => {
    let node = containerBlock[first ? "firstChild" : "lastChild"];
    while (node) {
      if (isElement$6(node)) {
        break;
      }
      node = node[first ? "nextSibling" : "previousSibling"];
    }
    return node === parentBlock;
  };
  const getStyles = (elm) =>
    foldl(
      mapToArray(
        getAllRaw(SugarElement.fromDom(elm)),
        (style, styleName) => `${styleName}: ${style};`
      ),
      (acc, s) => acc + s,
      ""
    );
  const insert$4 = (
    editor,
    createNewBlock,
    containerBlock,
    parentBlock,
    newBlockName
  ) => {
    const dom = editor.dom;
    const rng = editor.selection.getRng();
    const containerParent = containerBlock.parentNode;
    if (containerBlock === editor.getBody() || !containerParent) {
      return;
    }
    if (isNestedList(containerBlock)) {
      newBlockName = "LI";
    }
    const parentBlockStyles = isListItem(parentBlock)
      ? getStyles(parentBlock)
      : undefined;
    let newBlock =
      isListItem(parentBlock) && parentBlockStyles
        ? createNewBlock(newBlockName, { style: getStyles(parentBlock) })
        : createNewBlock(newBlockName);
    if (
      isFirstOrLastLi(containerBlock, parentBlock, true) &&
      isFirstOrLastLi(containerBlock, parentBlock, false)
    ) {
      if (hasParent(containerBlock, "LI")) {
        const containerBlockParent = getContainerBlock(containerBlock);
        dom.insertAfter(newBlock, containerBlockParent);
        if (isFirstChild(containerBlock)) {
          dom.remove(containerBlockParent);
        } else {
          dom.remove(containerBlock);
        }
      } else {
        dom.replace(newBlock, containerBlock);
      }
    } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
      if (hasParent(containerBlock, "LI")) {
        dom.insertAfter(newBlock, getContainerBlock(containerBlock));
        newBlock.appendChild(dom.doc.createTextNode(" "));
        newBlock.appendChild(containerBlock);
      } else {
        containerParent.insertBefore(newBlock, containerBlock);
      }
      dom.remove(parentBlock);
    } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
      dom.insertAfter(newBlock, getContainerBlock(containerBlock));
      dom.remove(parentBlock);
    } else {
      containerBlock = getContainerBlock(containerBlock);
      const tmpRng = rng.cloneRange();
      tmpRng.setStartAfter(parentBlock);
      tmpRng.setEndAfter(containerBlock);
      const fragment = tmpRng.extractContents();
      if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
        const previousChildren = filter$5(
          map$3(newBlock.children, SugarElement.fromDom),
          not(isTag("br"))
        );
        newBlock = fragment.firstChild;
        dom.insertAfter(fragment, containerBlock);
        each$e(previousChildren, (child) =>
          prepend(SugarElement.fromDom(newBlock), child)
        );
        if (parentBlockStyles) {
          newBlock.setAttribute("style", parentBlockStyles);
        }
      } else {
        dom.insertAfter(fragment, containerBlock);
        dom.insertAfter(newBlock, containerBlock);
      }
      dom.remove(parentBlock);
    }
    moveToCaretPosition(editor, newBlock);
  };

  const trimZwsp = (fragment) => {
    each$e(descendants$1(SugarElement.fromDom(fragment), isText$c), (text) => {
      const rawNode = text.dom;
      rawNode.nodeValue = trim$2(rawNode.data);
    });
  };
  const isWithinNonEditableList = (editor, node) => {
    const parentList = editor.dom.getParent(node, "ol,ul,dl");
    return (
      parentList !== null &&
      editor.dom.getContentEditableParent(parentList) === "false"
    );
  };
  const isEmptyAnchor = (dom, elm) => {
    return elm && elm.nodeName === "A" && dom.isEmpty(elm);
  };
  const containerAndPreviousSiblingName = (container, nodeName) => {
    return (
      container.nodeName === nodeName ||
      (container.previousSibling &&
        container.previousSibling.nodeName === nodeName)
    );
  };
  const containerAndNextSiblingName = (container, nodeName) => {
    return (
      container.nodeName === nodeName ||
      (container.nextSibling && container.nextSibling.nodeName === nodeName)
    );
  };
  const canSplitBlock = (dom, node) => {
    return (
      isNonNullable(node) &&
      dom.isBlock(node) &&
      !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
      !/^(fixed|absolute)/i.test(node.style.position) &&
      dom.isEditable(node.parentNode) &&
      dom.getContentEditable(node) !== "false"
    );
  };
  const trimInlineElementsOnLeftSideOfBlock = (
    dom,
    nonEmptyElementsMap,
    block
  ) => {
    var _a;
    const firstChilds = [];
    if (!block) {
      return;
    }
    let currentNode = block;
    while ((currentNode = currentNode.firstChild)) {
      if (dom.isBlock(currentNode)) {
        return;
      }
      if (
        isElement$6(currentNode) &&
        !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]
      ) {
        firstChilds.push(currentNode);
      }
    }
    let i = firstChilds.length;
    while (i--) {
      currentNode = firstChilds[i];
      if (
        !currentNode.hasChildNodes() ||
        (currentNode.firstChild === currentNode.lastChild &&
          ((_a = currentNode.firstChild) === null || _a === void 0
            ? void 0
            : _a.nodeValue) === "")
      ) {
        dom.remove(currentNode);
      } else {
        if (isEmptyAnchor(dom, currentNode)) {
          dom.remove(currentNode);
        }
      }
    }
  };
  const normalizeZwspOffset = (start, container, offset) => {
    if (!isText$b(container)) {
      return offset;
    } else if (start) {
      return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1
        ? 0
        : offset;
    } else {
      return offset === container.data.length - 1 &&
        container.data.charAt(offset) === ZWSP$1
        ? container.data.length
        : offset;
    }
  };
  const includeZwspInRange = (rng) => {
    const newRng = rng.cloneRange();
    newRng.setStart(
      rng.startContainer,
      normalizeZwspOffset(true, rng.startContainer, rng.startOffset)
    );
    newRng.setEnd(
      rng.endContainer,
      normalizeZwspOffset(false, rng.endContainer, rng.endOffset)
    );
    return newRng;
  };
  const trimLeadingLineBreaks = (node) => {
    let currentNode = node;
    do {
      if (isText$b(currentNode)) {
        currentNode.data = currentNode.data.replace(/^[\r\n]+/, "");
      }
      currentNode = currentNode.firstChild;
    } while (currentNode);
  };
  const wrapSelfAndSiblingsInDefaultBlock = (
    editor,
    newBlockName,
    rng,
    container,
    offset
  ) => {
    var _a, _b;
    const dom = editor.dom;
    const editableRoot =
      (_a = getEditableRoot(dom, container)) !== null && _a !== void 0
        ? _a
        : dom.getRoot();
    let parentBlock = dom.getParent(container, dom.isBlock);
    if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
      parentBlock = parentBlock || editableRoot;
      if (!parentBlock.hasChildNodes()) {
        const newBlock = dom.create(newBlockName);
        setForcedBlockAttrs(editor, newBlock);
        parentBlock.appendChild(newBlock);
        rng.setStart(newBlock, 0);
        rng.setEnd(newBlock, 0);
        return newBlock;
      }
      let node = container;
      while (node && node.parentNode !== parentBlock) {
        node = node.parentNode;
      }
      let startNode;
      while (node && !dom.isBlock(node)) {
        startNode = node;
        node = node.previousSibling;
      }
      const startNodeName =
        (_b =
          startNode === null || startNode === void 0
            ? void 0
            : startNode.parentElement) === null || _b === void 0
          ? void 0
          : _b.nodeName;
      if (
        startNode &&
        startNodeName &&
        editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())
      ) {
        const startNodeParent = startNode.parentNode;
        const newBlock = dom.create(newBlockName);
        setForcedBlockAttrs(editor, newBlock);
        startNodeParent.insertBefore(newBlock, startNode);
        node = startNode;
        while (node && !dom.isBlock(node)) {
          const next = node.nextSibling;
          newBlock.appendChild(node);
          node = next;
        }
        rng.setStart(container, offset);
        rng.setEnd(container, offset);
      }
    }
    return container;
  };
  const addBrToBlockIfNeeded = (dom, block) => {
    block.normalize();
    const lastChild = block.lastChild;
    if (
      !lastChild ||
      (isElement$6(lastChild) &&
        /^(left|right)$/gi.test(dom.getStyle(lastChild, "float", true)))
    ) {
      dom.add(block, "br");
    }
  };
  const shouldEndContainer = (editor, container) => {
    const optionValue = shouldEndContainerOnEmptyBlock(editor);
    if (isNullable(container)) {
      return false;
    } else if (isString(optionValue)) {
      return contains$2(
        Tools.explode(optionValue),
        container.nodeName.toLowerCase()
      );
    } else {
      return optionValue;
    }
  };
  const insert$3 = (editor, evt) => {
    let container;
    let offset;
    let parentBlockName;
    let containerBlock;
    let isAfterLastNodeInContainer = false;
    const dom = editor.dom;
    const schema = editor.schema,
      nonEmptyElementsMap = schema.getNonEmptyElements();
    const rng = editor.selection.getRng();
    const newBlockName = getForcedRootBlock(editor);
    const start = SugarElement.fromDom(rng.startContainer);
    const child = child$1(start, rng.startOffset);
    const isCef = child.exists(
      (element) => isHTMLElement$1(element) && !isEditable$2(element)
    );
    const collapsedAndCef = rng.collapsed && isCef;
    const createNewBlock$1 = (name, styles) => {
      return createNewBlock(
        editor,
        container,
        parentBlock,
        editableRoot,
        shouldKeepStyles(editor),
        name,
        styles
      );
    };
    const isCaretAtStartOrEndOfBlock = (start) => {
      const normalizedOffset = normalizeZwspOffset(start, container, offset);
      if (
        isText$b(container) &&
        (start
          ? normalizedOffset > 0
          : normalizedOffset < container.data.length)
      ) {
        return false;
      }
      if (
        (container.parentNode === parentBlock || container === parentBlock) &&
        isAfterLastNodeInContainer &&
        !start
      ) {
        return true;
      }
      if (
        start &&
        isElement$6(container) &&
        container === parentBlock.firstChild
      ) {
        return true;
      }
      if (
        containerAndPreviousSiblingName(container, "TABLE") ||
        containerAndPreviousSiblingName(container, "HR")
      ) {
        if (containerAndNextSiblingName(container, "BR")) {
          return !start;
        }
        return (
          (isAfterLastNodeInContainer && !start) ||
          (!isAfterLastNodeInContainer && start)
        );
      }
      const walker = new DomTreeWalker(container, parentBlock);
      if (isText$b(container)) {
        if (start && normalizedOffset === 0) {
          walker.prev();
        } else if (!start && normalizedOffset === container.data.length) {
          walker.next();
        }
      }
      let node;
      while ((node = walker.current())) {
        if (isElement$6(node)) {
          if (!node.getAttribute("data-mce-bogus")) {
            const name = node.nodeName.toLowerCase();
            if (nonEmptyElementsMap[name] && name !== "br") {
              return false;
            }
          }
        } else if (isText$b(node) && !isWhitespaceText(node.data)) {
          return false;
        }
        if (start) {
          walker.prev();
        } else {
          walker.next();
        }
      }
      return true;
    };
    const insertNewBlockAfter = () => {
      let block;
      if (
        /^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) &&
        containerBlockName !== "HGROUP"
      ) {
        block = createNewBlock$1(newBlockName);
      } else {
        block = createNewBlock$1();
      }
      if (
        shouldEndContainer(editor, containerBlock) &&
        canSplitBlock(dom, containerBlock) &&
        dom.isEmpty(parentBlock, undefined, { includeZwsp: true })
      ) {
        block = dom.split(containerBlock, parentBlock);
      } else {
        dom.insertAfter(block, parentBlock);
      }
      moveToCaretPosition(editor, block);
      return block;
    };
    normalize$2(dom, rng).each((normRng) => {
      rng.setStart(normRng.startContainer, normRng.startOffset);
      rng.setEnd(normRng.endContainer, normRng.endOffset);
    });
    container = rng.startContainer;
    offset = rng.startOffset;
    const shiftKey = !!(evt && evt.shiftKey);
    const ctrlKey = !!(evt && evt.ctrlKey);
    if (
      isElement$6(container) &&
      container.hasChildNodes() &&
      !collapsedAndCef
    ) {
      isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
      container =
        container.childNodes[
          Math.min(offset, container.childNodes.length - 1)
        ] || container;
      if (isAfterLastNodeInContainer && isText$b(container)) {
        offset = container.data.length;
      } else {
        offset = 0;
      }
    }
    const editableRoot = getEditableRoot(dom, container);
    if (!editableRoot || isWithinNonEditableList(editor, container)) {
      return;
    }
    if (!shiftKey) {
      container = wrapSelfAndSiblingsInDefaultBlock(
        editor,
        newBlockName,
        rng,
        container,
        offset
      );
    }
    let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();
    containerBlock = isNonNullable(
      parentBlock === null || parentBlock === void 0
        ? void 0
        : parentBlock.parentNode
    )
      ? dom.getParent(parentBlock.parentNode, dom.isBlock)
      : null;
    parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
    const containerBlockName = containerBlock
      ? containerBlock.nodeName.toUpperCase()
      : "";
    if (containerBlockName === "LI" && !ctrlKey) {
      const liBlock = containerBlock;
      parentBlock = liBlock;
      containerBlock = liBlock.parentNode;
      parentBlockName = containerBlockName;
    }
    if (
      isElement$6(containerBlock) &&
      isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)
    ) {
      return insertNewLine(editor, createNewBlock$1, parentBlock);
    }
    if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
      if (dom.isEmpty(parentBlock)) {
        insert$4(
          editor,
          createNewBlock$1,
          containerBlock,
          parentBlock,
          newBlockName
        );
        return;
      }
    }
    if (
      !collapsedAndCef &&
      (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))
    ) {
      return;
    }
    const parentBlockParent = parentBlock.parentNode;
    let newBlock;
    if (collapsedAndCef) {
      newBlock = createNewBlock$1(newBlockName);
      child.fold(
        () => {
          append$1(start, SugarElement.fromDom(newBlock));
        },
        (child) => {
          before$3(child, SugarElement.fromDom(newBlock));
        }
      );
      editor.selection.setCursorLocation(newBlock, 0);
    } else if (isCaretContainerBlock$1(parentBlock)) {
      newBlock = showCaretContainerBlock(parentBlock);
      if (dom.isEmpty(parentBlock)) {
        emptyBlock(parentBlock);
      }
      setForcedBlockAttrs(editor, newBlock);
      moveToCaretPosition(editor, newBlock);
    } else if (isCaretAtStartOrEndOfBlock(false)) {
      newBlock = insertNewBlockAfter();
    } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
      const caretPos = CaretPosition.fromRangeStart(rng);
      const afterTable = isAfterTable(caretPos);
      const parentBlockSugar = SugarElement.fromDom(parentBlock);
      const afterBr = isAfterBr(parentBlockSugar, caretPos, editor.schema);
      const prevBrOpt = afterBr
        ? findPreviousBr(parentBlockSugar, caretPos, editor.schema).bind(
            (pos) => Optional.from(pos.getNode())
          )
        : Optional.none();
      newBlock = parentBlockParent.insertBefore(
        createNewBlock$1(),
        parentBlock
      );
      const root =
        containerAndPreviousSiblingName(parentBlock, "HR") || afterTable
          ? newBlock
          : prevBrOpt.getOr(parentBlock);
      moveToCaretPosition(editor, root);
    } else {
      const tmpRng = includeZwspInRange(rng).cloneRange();
      tmpRng.setEndAfter(parentBlock);
      const fragment = tmpRng.extractContents();
      trimZwsp(fragment);
      trimLeadingLineBreaks(fragment);
      newBlock = fragment.firstChild;
      dom.insertAfter(fragment, parentBlock);
      trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
      addBrToBlockIfNeeded(dom, parentBlock);
      if (dom.isEmpty(parentBlock)) {
        emptyBlock(parentBlock);
      }
      newBlock.normalize();
      if (dom.isEmpty(newBlock)) {
        dom.remove(newBlock);
        insertNewBlockAfter();
      } else {
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      }
    }
    dom.setAttrib(newBlock, "id", "");
    editor.dispatch("NewBlock", { newBlock });
  };
  const fakeEventName$1 = "insertParagraph";
  const blockbreak = {
    insert: insert$3,
    fakeEventName: fakeEventName$1,
  };

  const hasRightSideContent = (schema, container, parentBlock) => {
    const walker = new DomTreeWalker(container, parentBlock);
    let node;
    const nonEmptyElementsMap = schema.getNonEmptyElements();
    while ((node = walker.next())) {
      if (
        nonEmptyElementsMap[node.nodeName.toLowerCase()] ||
        (isText$b(node) && node.length > 0)
      ) {
        return true;
      }
    }
    return false;
  };
  const moveSelectionToBr = (editor, brElm, extraBr) => {
    const rng = editor.dom.createRng();
    if (!extraBr) {
      rng.setStartAfter(brElm);
      rng.setEndAfter(brElm);
    } else {
      rng.setStartBefore(brElm);
      rng.setEndBefore(brElm);
    }
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, rng);
  };
  const insertBrAtCaret = (editor, evt) => {
    const selection = editor.selection;
    const dom = editor.dom;
    const rng = selection.getRng();
    let brElm;
    let extraBr = false;
    normalize$2(dom, rng).each((normRng) => {
      rng.setStart(normRng.startContainer, normRng.startOffset);
      rng.setEnd(normRng.endContainer, normRng.endOffset);
    });
    let offset = rng.startOffset;
    let container = rng.startContainer;
    if (isElement$6(container) && container.hasChildNodes()) {
      const isAfterLastNodeInContainer =
        offset > container.childNodes.length - 1;
      container =
        container.childNodes[
          Math.min(offset, container.childNodes.length - 1)
        ] || container;
      if (isAfterLastNodeInContainer && isText$b(container)) {
        offset = container.data.length;
      } else {
        offset = 0;
      }
    }
    let parentBlock = dom.getParent(container, dom.isBlock);
    const containerBlock =
      parentBlock && parentBlock.parentNode
        ? dom.getParent(parentBlock.parentNode, dom.isBlock)
        : null;
    const containerBlockName = containerBlock
      ? containerBlock.nodeName.toUpperCase()
      : "";
    const isControlKey = !!(evt && evt.ctrlKey);
    if (containerBlockName === "LI" && !isControlKey) {
      parentBlock = containerBlock;
    }
    if (isText$b(container) && offset >= container.data.length) {
      if (
        !hasRightSideContent(
          editor.schema,
          container,
          parentBlock || dom.getRoot()
        )
      ) {
        brElm = dom.create("br");
        rng.insertNode(brElm);
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
        extraBr = true;
      }
    }
    brElm = dom.create("br");
    rangeInsertNode(dom, rng, brElm);
    moveSelectionToBr(editor, brElm, extraBr);
    editor.undoManager.add();
  };
  const insertBrBefore = (editor, inline) => {
    const br = SugarElement.fromTag("br");
    before$3(SugarElement.fromDom(inline), br);
    editor.undoManager.add();
  };
  const insertBrAfter = (editor, inline) => {
    if (!hasBrAfter(editor.getBody(), inline)) {
      after$4(SugarElement.fromDom(inline), SugarElement.fromTag("br"));
    }
    const br = SugarElement.fromTag("br");
    after$4(SugarElement.fromDom(inline), br);
    moveSelectionToBr(editor, br.dom, false);
    editor.undoManager.add();
  };
  const isBeforeBr = (pos) => {
    return isBr$6(pos.getNode());
  };
  const hasBrAfter = (rootNode, startNode) => {
    if (isBeforeBr(CaretPosition.after(startNode))) {
      return true;
    } else {
      return nextPosition(rootNode, CaretPosition.after(startNode))
        .map((pos) => {
          return isBr$6(pos.getNode());
        })
        .getOr(false);
    }
  };
  const isAnchorLink = (elm) => {
    return elm && elm.nodeName === "A" && "href" in elm;
  };
  const isInsideAnchor = (location) => {
    return location.fold(never, isAnchorLink, isAnchorLink, never);
  };
  const readInlineAnchorLocation = (editor) => {
    const isInlineTarget$1 = curry(isInlineTarget, editor);
    const position = CaretPosition.fromRangeStart(editor.selection.getRng());
    return readLocation(isInlineTarget$1, editor.getBody(), position).filter(
      isInsideAnchor
    );
  };
  const insertBrOutsideAnchor = (editor, location) => {
    location.fold(
      noop,
      curry(insertBrBefore, editor),
      curry(insertBrAfter, editor),
      noop
    );
  };
  const insert$2 = (editor, evt) => {
    const anchorLocation = readInlineAnchorLocation(editor);
    if (anchorLocation.isSome()) {
      anchorLocation.each(curry(insertBrOutsideAnchor, editor));
    } else {
      insertBrAtCaret(editor, evt);
    }
  };
  const fakeEventName = "insertLineBreak";
  const linebreak = {
    insert: insert$2,
    fakeEventName,
  };

  const matchesSelector = (editor, selector) => {
    return getParentBlock$1(editor)
      .filter((parentBlock) => {
        return (
          selector.length > 0 &&
          is$1(SugarElement.fromDom(parentBlock), selector)
        );
      })
      .isSome();
  };
  const shouldInsertBr = (editor) => {
    return matchesSelector(editor, getBrNewLineSelector(editor));
  };
  const shouldBlockNewLine$1 = (editor) => {
    return matchesSelector(editor, getNoNewLineSelector(editor));
  };

  const newLineAction = Adt.generate([{ br: [] }, { block: [] }, { none: [] }]);
  const shouldBlockNewLine = (editor, _shiftKey) => {
    return shouldBlockNewLine$1(editor);
  };
  const inListBlock = (requiredState) => {
    return (editor, _shiftKey) => {
      return isListItemParentBlock(editor) === requiredState;
    };
  };
  const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
    const state = getParentBlockName(editor) === blockName.toUpperCase();
    return state === requiredState;
  };
  const inCefBlock = (editor) => {
    const editableRoot = getEditableRoot(
      editor.dom,
      editor.selection.getStart()
    );
    return isNullable(editableRoot);
  };
  const inPreBlock = (requiredState) => inBlock("pre", requiredState);
  const inSummaryBlock = () => inBlock("summary", true);
  const shouldPutBrInPre = (requiredState) => {
    return (editor, _shiftKey) => {
      return shouldPutBrInPre$1(editor) === requiredState;
    };
  };
  const inBrContext = (editor, _shiftKey) => {
    return shouldInsertBr(editor);
  };
  const hasShiftKey = (_editor, shiftKey) => {
    return shiftKey;
  };
  const canInsertIntoEditableRoot = (editor) => {
    const forcedRootBlock = getForcedRootBlock(editor);
    const rootEditable = getEditableRoot(
      editor.dom,
      editor.selection.getStart()
    );
    return (
      isNonNullable(rootEditable) &&
      editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock)
    );
  };
  const isInRootWithEmptyOrCEF = (editor) => {
    const rng = editor.selection.getRng();
    const start = SugarElement.fromDom(rng.startContainer);
    const child = child$1(start, rng.startOffset);
    const isCefOpt = child.map(
      (element) => isHTMLElement$1(element) && !isEditable$2(element)
    );
    return rng.collapsed && isCefOpt.getOr(true);
  };
  const match = (predicates, action) => {
    return (editor, shiftKey) => {
      const isMatch = foldl(
        predicates,
        (res, p) => {
          return res && p(editor, shiftKey);
        },
        true
      );
      return isMatch ? Optional.some(action) : Optional.none();
    };
  };
  const getAction = (editor, evt) => {
    return evaluateUntil(
      [
        match([shouldBlockNewLine], newLineAction.none()),
        match([inPreBlock(true), inCefBlock], newLineAction.none()),
        match([inSummaryBlock()], newLineAction.br()),
        match(
          [inPreBlock(true), shouldPutBrInPre(false), hasShiftKey],
          newLineAction.br()
        ),
        match(
          [inPreBlock(true), shouldPutBrInPre(false)],
          newLineAction.block()
        ),
        match(
          [inPreBlock(true), shouldPutBrInPre(true), hasShiftKey],
          newLineAction.block()
        ),
        match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()),
        match([inListBlock(true), hasShiftKey], newLineAction.br()),
        match([inListBlock(true)], newLineAction.block()),
        match([inBrContext], newLineAction.br()),
        match([hasShiftKey], newLineAction.br()),
        match([canInsertIntoEditableRoot], newLineAction.block()),
        match([isInRootWithEmptyOrCEF], newLineAction.block()),
      ],
      [editor, !!(evt && evt.shiftKey)]
    ).getOr(newLineAction.none());
  };

  const insertBreak = (breakType, editor, evt) => {
    if (editor.mode.isReadOnly()) {
      return;
    }
    if (!editor.selection.isCollapsed()) {
      execEditorDeleteCommand(editor);
    }
    if (isNonNullable(evt)) {
      const event = fireBeforeInputEvent(editor, breakType.fakeEventName);
      if (event.isDefaultPrevented()) {
        return;
      }
    }
    breakType.insert(editor, evt);
    if (isNonNullable(evt)) {
      fireInputEvent(editor, breakType.fakeEventName);
    }
  };
  const insert$1 = (editor, evt) => {
    if (editor.mode.isReadOnly()) {
      return;
    }
    const br = () => insertBreak(linebreak, editor, evt);
    const block = () => insertBreak(blockbreak, editor, evt);
    const logicalAction = getAction(editor, evt);
    switch (getNewlineBehavior(editor)) {
      case "linebreak":
        logicalAction.fold(br, br, noop);
        break;
      case "block":
        logicalAction.fold(block, block, noop);
        break;
      case "invert":
        logicalAction.fold(block, br, noop);
        break;
      default:
        logicalAction.fold(br, block, noop);
        break;
    }
  };

  const platform$1 = detect$1();
  const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();
  const handleEnterKeyEvent = (editor, event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    event.preventDefault();
    endTypingLevelIgnoreLocks(editor.undoManager);
    editor.undoManager.transact(() => {
      insert$1(editor, event);
    });
  };
  const isCaretAfterKoreanCharacter = (rng) => {
    if (!rng.collapsed) {
      return false;
    }
    const startContainer = rng.startContainer;
    if (isText$b(startContainer)) {
      const koreanCharRegex =
        /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/;
      const char = startContainer.data.charAt(rng.startOffset - 1);
      return koreanCharRegex.test(char);
    } else {
      return false;
    }
  };
  const setup$i = (editor) => {
    let iOSSafariKeydownBookmark = Optional.none();
    const iOSSafariKeydownOverride = (editor) => {
      iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());
      editor.undoManager.add();
    };
    const iOSSafariKeyupOverride = (editor, event) => {
      editor.undoManager.undo();
      iOSSafariKeydownBookmark.fold(noop, (b) =>
        editor.selection.moveToBookmark(b)
      );
      handleEnterKeyEvent(editor, event);
      iOSSafariKeydownBookmark = Optional.none();
    };
    editor.on("keydown", (event) => {
      if (event.keyCode === VK.ENTER) {
        if (
          isIOSSafari &&
          isCaretAfterKoreanCharacter(editor.selection.getRng())
        ) {
          iOSSafariKeydownOverride(editor);
        } else {
          handleEnterKeyEvent(editor, event);
        }
      }
    });
    editor.on("keyup", (event) => {
      if (event.keyCode === VK.ENTER) {
        iOSSafariKeydownBookmark.each(() =>
          iOSSafariKeyupOverride(editor, event)
        );
      }
    });
  };

  const executeKeydownOverride$2 = (editor, caret, evt) => {
    const isMac = Env.os.isMacOS() || Env.os.isiOS();
    execute(
      [
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$1, editor, true),
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$1, editor, false),
        },
        ...(!isMac
          ? [
              {
                keyCode: VK.HOME,
                action: action(selectToEndPoint, editor, false),
                ctrlKey: true,
                shiftKey: true,
              },
              {
                keyCode: VK.END,
                action: action(selectToEndPoint, editor, true),
                ctrlKey: true,
                shiftKey: true,
              },
            ]
          : []),
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint, editor, true),
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint, editor, false),
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$2, editor, true, caret),
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$2, editor, false, caret),
        },
      ],
      evt
    ).each((_) => {
      evt.preventDefault();
    });
  };
  const setup$h = (editor, caret) => {
    editor.on("keydown", (evt) => {
      if (!evt.isDefaultPrevented()) {
        executeKeydownOverride$2(editor, caret, evt);
      }
    });
  };

  const setup$g = (editor) => {
    editor.on("input", (e) => {
      if (!e.isComposing) {
        normalizeNbspsInEditor(editor);
      }
    });
  };

  const platform = detect$1();
  const executeKeyupAction = (editor, caret, evt) => {
    execute(
      [
        {
          keyCode: VK.PAGE_UP,
          action: action(moveToLineEndPoint$2, editor, false, caret),
        },
        {
          keyCode: VK.PAGE_DOWN,
          action: action(moveToLineEndPoint$2, editor, true, caret),
        },
      ],
      evt
    );
  };
  const stopImmediatePropagation = (e) => e.stopImmediatePropagation();
  const isPageUpDown = (evt) =>
    evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
  const setNodeChangeBlocker = (blocked, editor, block) => {
    if (block && !blocked.get()) {
      editor.on("NodeChange", stopImmediatePropagation, true);
    } else if (!block && blocked.get()) {
      editor.off("NodeChange", stopImmediatePropagation);
    }
    blocked.set(block);
  };
  const setup$f = (editor, caret) => {
    if (platform.os.isMacOS()) {
      return;
    }
    const blocked = Cell(false);
    editor.on("keydown", (evt) => {
      if (isPageUpDown(evt)) {
        setNodeChangeBlocker(blocked, editor, true);
      }
    });
    editor.on("keyup", (evt) => {
      if (!evt.isDefaultPrevented()) {
        executeKeyupAction(editor, caret, evt);
      }
      if (isPageUpDown(evt) && blocked.get()) {
        setNodeChangeBlocker(blocked, editor, false);
        editor.nodeChanged();
      }
    });
  };

  const isValidContainer = (root, container) =>
    root === container || root.contains(container);
  const isInEditableRange = (editor, range) => {
    if (
      !isValidContainer(editor.getBody(), range.startContainer) ||
      !isValidContainer(editor.getBody(), range.endContainer)
    ) {
      return true;
    }
    return isEditableRange(editor.dom, range);
  };
  const setup$e = (editor) => {
    editor.on("beforeinput", (e) => {
      if (
        !editor.selection.isEditable() ||
        exists(e.getTargetRanges(), (rng) => !isInEditableRange(editor, rng))
      ) {
        e.preventDefault();
      }
    });
  };

  const insertTextAtPosition = (text, pos) => {
    const container = pos.container();
    const offset = pos.offset();
    if (isText$b(container)) {
      container.insertData(offset, text);
      return Optional.some(CaretPosition(container, offset + text.length));
    } else {
      return getElementFromPosition(pos).map((elm) => {
        const textNode = SugarElement.fromText(text);
        if (pos.isAtEnd()) {
          after$4(elm, textNode);
        } else {
          before$3(elm, textNode);
        }
        return CaretPosition(textNode.dom, text.length);
      });
    }
  };
  const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
  const insertSpaceAtPosition = curry(insertTextAtPosition, " ");

  const insertSpaceOrNbspAtPosition = (root, pos, schema) =>
    needsToHaveNbsp(root, pos, schema)
      ? insertNbspAtPosition(pos)
      : insertSpaceAtPosition(pos);
  const locationToCaretPosition = (root) => (location) =>
    location.fold(
      (element) => prevPosition(root.dom, CaretPosition.before(element)),
      (element) => firstPositionIn(element),
      (element) => lastPositionIn(element),
      (element) => nextPosition(root.dom, CaretPosition.after(element))
    );
  const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => (checkPos) =>
    needsToHaveNbsp(root, checkPos, schema)
      ? insertNbspAtPosition(pos)
      : insertSpaceAtPosition(pos);
  const setSelection = (editor) => (pos) => {
    editor.selection.setRng(pos.toRange());
    editor.nodeChanged();
  };
  const isInsideSummary = (domUtils, node) =>
    domUtils.isEditable(domUtils.getParent(node, "summary"));
  const insertSpaceOrNbspAtSelection = (editor) => {
    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
    const root = SugarElement.fromDom(editor.getBody());
    if (editor.selection.isCollapsed()) {
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const caretPosition = CaretPosition.fromRangeStart(
        editor.selection.getRng()
      );
      return readLocation(isInlineTarget$1, editor.getBody(), caretPosition)
        .bind(locationToCaretPosition(root))
        .map(
          (checkPos) => () =>
            insertInlineBoundarySpaceOrNbsp(
              root,
              pos,
              editor.schema
            )(checkPos).each(setSelection(editor))
        );
    } else {
      return Optional.none();
    }
  };
  const insertSpaceInSummaryAtSelectionOnFirefox = (editor) => {
    const insertSpaceThunk = () => {
      const root = SugarElement.fromDom(editor.getBody());
      if (!editor.selection.isCollapsed()) {
        editor.getDoc().execCommand("Delete");
      }
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(
        setSelection(editor)
      );
    };
    return someIf(
      Env.browser.isFirefox() &&
        editor.selection.isEditable() &&
        isInsideSummary(editor.dom, editor.selection.getRng().startContainer),
      insertSpaceThunk
    );
  };

  const executeKeydownOverride$1 = (editor, evt) => {
    executeWithDelayedAction(
      [
        {
          keyCode: VK.SPACEBAR,
          action: action(insertSpaceOrNbspAtSelection, editor),
        },
        {
          keyCode: VK.SPACEBAR,
          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor),
        },
      ],
      evt
    ).each((applyAction) => {
      evt.preventDefault();
      const event = fireBeforeInputEvent(editor, "insertText", { data: " " });
      if (!event.isDefaultPrevented()) {
        applyAction();
        fireInputEvent(editor, "insertText", { data: " " });
      }
    });
  };
  const setup$d = (editor) => {
    editor.on("keydown", (evt) => {
      if (!evt.isDefaultPrevented()) {
        executeKeydownOverride$1(editor, evt);
      }
    });
  };

  const tableTabNavigation = (editor) => {
    if (hasTableTabNavigation(editor)) {
      return [
        {
          keyCode: VK.TAB,
          action: action(handleTab, editor, true),
        },
        {
          keyCode: VK.TAB,
          shiftKey: true,
          action: action(handleTab, editor, false),
        },
      ];
    } else {
      return [];
    }
  };
  const executeKeydownOverride = (editor, evt) => {
    execute([...tableTabNavigation(editor)], evt).each((_) => {
      evt.preventDefault();
    });
  };
  const setup$c = (editor) => {
    editor.on("keydown", (evt) => {
      if (!evt.isDefaultPrevented()) {
        executeKeydownOverride(editor, evt);
      }
    });
  };

  const setup$b = (editor) => {
    editor.addShortcut("Meta+P", "", "mcePrint");
    setup$k(editor);
    if (isRtc(editor)) {
      return Cell(null);
    } else {
      const caret = setupSelectedState(editor);
      setup$e(editor);
      setup$m(editor);
      setup$l(editor, caret);
      setup$j(editor, caret);
      setup$i(editor);
      setup$d(editor);
      setup$g(editor);
      setup$c(editor);
      setup$h(editor, caret);
      setup$f(editor, caret);
      return caret;
    }
  };

  class NodeChange {
    constructor(editor) {
      this.lastPath = [];
      this.editor = editor;
      let lastRng;
      const self = this;
      if (!("onselectionchange" in editor.getDoc())) {
        editor.on("NodeChange click mouseup keyup focus", (e) => {
          const nativeRng = editor.selection.getRng();
          const fakeRng = {
            startContainer: nativeRng.startContainer,
            startOffset: nativeRng.startOffset,
            endContainer: nativeRng.endContainer,
            endOffset: nativeRng.endOffset,
          };
          if (e.type === "nodechange" || !isEq$4(fakeRng, lastRng)) {
            editor.dispatch("SelectionChange");
          }
          lastRng = fakeRng;
        });
      }
      editor.on("contextmenu", () => {
        store(editor);
        editor.dispatch("SelectionChange");
      });
      editor.on("SelectionChange", () => {
        const startElm = editor.selection.getStart(true);
        if (!startElm) {
          return;
        }
        if (
          hasAnyRanges(editor) &&
          !self.isSameElementPath(startElm) &&
          editor.dom.isChildOf(startElm, editor.getBody())
        ) {
          editor.nodeChanged({ selectionChange: true });
        }
      });
      editor.on("mouseup", (e) => {
        if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
          if (editor.selection.getNode().nodeName === "IMG") {
            Delay.setEditorTimeout(editor, () => {
              editor.nodeChanged();
            });
          } else {
            editor.nodeChanged();
          }
        }
      });
    }
    nodeChanged(args = {}) {
      const editor = this.editor;
      const selection = editor.selection;
      let node;
      if (
        editor.initialized &&
        selection &&
        !shouldDisableNodeChange(editor) &&
        !isDisabled$1(editor)
      ) {
        const root = editor.getBody();
        node = selection.getStart(true) || root;
        if (
          node.ownerDocument !== editor.getDoc() ||
          !editor.dom.isChildOf(node, root)
        ) {
          node = root;
        }
        const parents = [];
        editor.dom.getParent(node, (node) => {
          if (node === root) {
            return true;
          } else {
            parents.push(node);
            return false;
          }
        });
        editor.dispatch("NodeChange", {
          ...args,
          element: node,
          parents,
        });
      }
    }
    isSameElementPath(startElm) {
      let i;
      const editor = this.editor;
      const currentPath = reverse(
        editor.dom.getParents(startElm, always, editor.getBody())
      );
      if (currentPath.length === this.lastPath.length) {
        for (i = currentPath.length; i >= 0; i--) {
          if (currentPath[i] !== this.lastPath[i]) {
            break;
          }
        }
        if (i === -1) {
          this.lastPath = currentPath;
          return true;
        }
      }
      this.lastPath = currentPath;
      return false;
    }
  }

  const imageId = generate$1("image");
  const getDragImage = (transfer) => {
    const dt = transfer;
    return Optional.from(dt[imageId]);
  };
  const setDragImage = (transfer, imageData) => {
    const dt = transfer;
    dt[imageId] = imageData;
  };

  const eventId = generate$1("event");
  const getEvent = (transfer) => {
    const dt = transfer;
    return Optional.from(dt[eventId]);
  };
  const mkSetEventFn = (type) => (transfer) => {
    const dt = transfer;
    dt[eventId] = type;
  };
  const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);
  const setDragstartEvent = mkSetEventFn(0);
  const setDropEvent = mkSetEventFn(2);
  const setDragendEvent = mkSetEventFn(1);
  const checkEvent = (expectedType) => (transfer) => {
    const dt = transfer;
    return Optional.from(dt[eventId]).exists((type) => type === expectedType);
  };
  const isInDragStartEvent = checkEvent(0);

  const createEmptyFileList = () =>
    Object.freeze({
      length: 0,
      item: (_) => null,
    });

  const modeId = generate$1("mode");
  const getMode = (transfer) => {
    const dt = transfer;
    return Optional.from(dt[modeId]);
  };
  const mkSetModeFn = (mode) => (transfer) => {
    const dt = transfer;
    dt[modeId] = mode;
  };
  const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);
  const setReadWriteMode = mkSetModeFn(0);
  const setReadOnlyMode = mkSetModeFn(2);
  const setProtectedMode = mkSetModeFn(1);
  const checkMode = (expectedMode) => (transfer) => {
    const dt = transfer;
    return Optional.from(dt[modeId]).exists((mode) => mode === expectedMode);
  };
  const isInReadWriteMode = checkMode(0);
  const isInProtectedMode = checkMode(1);

  const normalizeItems = (dataTransfer, itemsImpl) => ({
    ...itemsImpl,
    get length() {
      return itemsImpl.length;
    },
    add: (data, type) => {
      if (isInReadWriteMode(dataTransfer)) {
        if (isString(data)) {
          if (!isUndefined(type)) {
            return itemsImpl.add(data, type);
          }
        } else {
          return itemsImpl.add(data);
        }
      }
      return null;
    },
    remove: (idx) => {
      if (isInReadWriteMode(dataTransfer)) {
        itemsImpl.remove(idx);
      }
    },
    clear: () => {
      if (isInReadWriteMode(dataTransfer)) {
        itemsImpl.clear();
      }
    },
  });

  const validDropEffects = ["none", "copy", "link", "move"];
  const validEffectAlloweds = [
    "none",
    "copy",
    "copyLink",
    "copyMove",
    "link",
    "linkMove",
    "move",
    "all",
    "uninitialized",
  ];
  const createDataTransfer = () => {
    const dataTransferImpl = new window.DataTransfer();
    let dropEffect = "move";
    let effectAllowed = "all";
    const dataTransfer = {
      get dropEffect() {
        return dropEffect;
      },
      set dropEffect(effect) {
        if (contains$2(validDropEffects, effect)) {
          dropEffect = effect;
        }
      },
      get effectAllowed() {
        return effectAllowed;
      },
      set effectAllowed(allowed) {
        if (
          isInDragStartEvent(dataTransfer) &&
          contains$2(validEffectAlloweds, allowed)
        ) {
          effectAllowed = allowed;
        }
      },
      get items() {
        return normalizeItems(dataTransfer, dataTransferImpl.items);
      },
      get files() {
        if (isInProtectedMode(dataTransfer)) {
          return createEmptyFileList();
        } else {
          return dataTransferImpl.files;
        }
      },
      get types() {
        return dataTransferImpl.types;
      },
      setDragImage: (image, x, y) => {
        if (isInReadWriteMode(dataTransfer)) {
          setDragImage(dataTransfer, {
            image,
            x,
            y,
          });
          dataTransferImpl.setDragImage(image, x, y);
        }
      },
      getData: (format) => {
        if (isInProtectedMode(dataTransfer)) {
          return "";
        } else {
          return dataTransferImpl.getData(format);
        }
      },
      setData: (format, data) => {
        if (isInReadWriteMode(dataTransfer)) {
          dataTransferImpl.setData(format, data);
        }
      },
      clearData: (format) => {
        if (isInReadWriteMode(dataTransfer)) {
          dataTransferImpl.clearData(format);
        }
      },
    };
    setReadWriteMode(dataTransfer);
    return dataTransfer;
  };
  const cloneDataTransfer = (original) => {
    const clone = createDataTransfer();
    const originalMode = getMode(original);
    setReadOnlyMode(original);
    setDragstartEvent(clone);
    clone.dropEffect = original.dropEffect;
    clone.effectAllowed = original.effectAllowed;
    getDragImage(original).each((imageData) =>
      clone.setDragImage(imageData.image, imageData.x, imageData.y)
    );
    each$e(original.types, (type) => {
      if (type !== "Files") {
        clone.setData(type, original.getData(type));
      }
    });
    each$e(original.files, (file) => clone.items.add(file));
    getEvent(original).each((type) => {
      setEvent(clone, type);
    });
    originalMode.each((mode) => {
      setMode$1(original, mode);
      setMode$1(clone, mode);
    });
    return clone;
  };

  const getHtmlData = (dataTransfer) => {
    const html = dataTransfer.getData("text/html");
    return html === "" ? Optional.none() : Optional.some(html);
  };
  const setHtmlData = (dataTransfer, html) =>
    dataTransfer.setData("text/html", html);

  const internalMimeType = "x-tinymce/html";
  const internalHtmlMime = constant(internalMimeType);
  const internalMark = "<!-- " + internalMimeType + " -->";
  const mark = (html) => internalMark + html;
  const unmark = (html) => html.replace(internalMark, "");
  const isMarked = (html) => html.indexOf(internalMark) !== -1;

  const isPlainText = (text) => {
    return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(
      text
    );
  };
  const openContainer = (rootTag, rootAttrs) => {
    let tag = "<" + rootTag;
    const attrs = mapToArray(
      rootAttrs,
      (value, key) => key + '="' + Entities.encodeAllRaw(value) + '"'
    );
    if (attrs.length) {
      tag += " " + attrs.join(" ");
    }
    return tag + ">";
  };
  const toBlockElements = (text, rootTag, rootAttrs) => {
    const blocks = text.split(/\n\n/);
    const tagOpen = openContainer(rootTag, rootAttrs);
    const tagClose = "</" + rootTag + ">";
    const paragraphs = map$3(blocks, (p) => {
      return p.split(/\n/).join("<br />");
    });
    const stitch = (p) => {
      return tagOpen + p + tagClose;
    };
    return paragraphs.length === 1
      ? paragraphs[0]
      : map$3(paragraphs, stitch).join("");
  };

  const pasteBinDefaultContent = "%MCEPASTEBIN%";
  const create$6 = (editor, lastRngCell) => {
    const { dom, selection } = editor;
    const body = editor.getBody();
    lastRngCell.set(selection.getRng());
    const pasteBinElm = dom.add(
      editor.getBody(),
      "div",
      {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: true,
        "data-mce-bogus": "all",
        style:
          "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0",
      },
      pasteBinDefaultContent
    );
    if (Env.browser.isFirefox()) {
      dom.setStyle(
        pasteBinElm,
        "left",
        dom.getStyle(body, "direction", true) === "rtl" ? 65535 : -65535
      );
    }
    dom.bind(pasteBinElm, "beforedeactivate focusin focusout", (e) => {
      e.stopPropagation();
    });
    pasteBinElm.focus();
    selection.select(pasteBinElm, true);
  };
  const remove = (editor, lastRngCell) => {
    const dom = editor.dom;
    if (getEl(editor)) {
      let pasteBinClone;
      const lastRng = lastRngCell.get();
      while ((pasteBinClone = getEl(editor))) {
        dom.remove(pasteBinClone);
        dom.unbind(pasteBinClone);
      }
      if (lastRng) {
        editor.selection.setRng(lastRng);
      }
    }
    lastRngCell.set(null);
  };
  const getEl = (editor) => editor.dom.get("mcepastebin");
  const isPasteBin = (elm) => isNonNullable(elm) && elm.id === "mcepastebin";
  const getHtml = (editor) => {
    const dom = editor.dom;
    const copyAndRemove = (toElm, fromElm) => {
      toElm.appendChild(fromElm);
      dom.remove(fromElm, true);
    };
    const [pasteBinElm, ...pasteBinClones] = filter$5(
      editor.getBody().childNodes,
      isPasteBin
    );
    each$e(pasteBinClones, (pasteBinClone) => {
      copyAndRemove(pasteBinElm, pasteBinClone);
    });
    const dirtyWrappers = dom.select("div[id=mcepastebin]", pasteBinElm);
    for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
      const cleanWrapper = dom.create("div");
      pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
      copyAndRemove(cleanWrapper, dirtyWrappers[i]);
    }
    return pasteBinElm ? pasteBinElm.innerHTML : "";
  };
  const isDefaultPasteBinContent = (content) =>
    content === pasteBinDefaultContent;
  const PasteBin = (editor) => {
    const lastRng = Cell(null);
    return {
      create: () => create$6(editor, lastRng),
      remove: () => remove(editor, lastRng),
      getEl: () => getEl(editor),
      getHtml: () => getHtml(editor),
      getLastRng: lastRng.get,
    };
  };

  const filter$1 = (content, items) => {
    Tools.each(items, (v) => {
      if (is$4(v, RegExp)) {
        content = content.replace(v, "");
      } else {
        content = content.replace(v[0], v[1]);
      }
    });
    return content;
  };
  const innerText = (html) => {
    const schema = Schema();
    const domParser = DomParser({}, schema);
    let text = "";
    const voidElements = schema.getVoidElements();
    const ignoreElements = Tools.makeMap(
      "script noscript style textarea video audio iframe object",
      " "
    );
    const blockElements = schema.getBlockElements();
    const walk = (node) => {
      const name = node.name,
        currentNode = node;
      if (name === "br") {
        text += "\n";
        return;
      }
      if (name === "wbr") {
        return;
      }
      if (voidElements[name]) {
        text += " ";
      }
      if (ignoreElements[name]) {
        text += " ";
        return;
      }
      if (node.type === 3) {
        text += node.value;
      }
      if (!(node.name in schema.getVoidElements())) {
        let currentNode = node.firstChild;
        if (currentNode) {
          do {
            walk(currentNode);
          } while ((currentNode = currentNode.next));
        }
      }
      if (blockElements[name] && currentNode.next) {
        text += "\n";
        if (name === "p") {
          text += "\n";
        }
      }
    };
    html = filter$1(html, [/<!\[[^\]]+\]>/g]);
    walk(domParser.parse(html));
    return text;
  };
  const trimHtml = (html) => {
    const trimSpaces = (all, s1, s2) => {
      if (!s1 && !s2) {
        return " ";
      }
      return nbsp;
    };
    html = filter$1(html, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        trimSpaces,
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i,
    ]);
    return html;
  };
  const createIdGenerator = (prefix) => {
    let count = 0;
    return () => {
      return prefix + count++;
    };
  };
  const getImageMimeType = (ext) => {
    const lowerExt = ext.toLowerCase();
    const mimeOverrides = {
      jpg: "jpeg",
      jpe: "jpeg",
      jfi: "jpeg",
      jif: "jpeg",
      jfif: "jpeg",
      pjpeg: "jpeg",
      pjp: "jpeg",
      svg: "svg+xml",
    };
    return Tools.hasOwn(mimeOverrides, lowerExt)
      ? "image/" + mimeOverrides[lowerExt]
      : "image/" + lowerExt;
  };

  const preProcess = (editor, html) => {
    const parser = DomParser(
      {
        sanitize: shouldSanitizeXss(editor),
        sandbox_iframes: shouldSandboxIframes(editor),
        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
        convert_unsafe_embeds: shouldConvertUnsafeEmbeds(editor),
      },
      editor.schema
    );
    parser.addNodeFilter("meta", (nodes) => {
      Tools.each(nodes, (node) => {
        node.remove();
      });
    });
    const fragment = parser.parse(html, {
      forced_root_block: false,
      isRootContent: true,
    });
    return HtmlSerializer({ validate: true }, editor.schema).serialize(
      fragment
    );
  };
  const processResult = (content, cancelled) => ({
    content,
    cancelled,
  });
  const postProcessFilter = (editor, html, internal) => {
    const tempBody = editor.dom.create("div", { style: "display:none" }, html);
    const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
    return processResult(
      postProcessArgs.node.innerHTML,
      postProcessArgs.isDefaultPrevented()
    );
  };
  const filterContent = (editor, content, internal) => {
    const preProcessArgs = firePastePreProcess(editor, content, internal);
    const filteredContent = preProcess(editor, preProcessArgs.content);
    if (
      editor.hasEventListeners("PastePostProcess") &&
      !preProcessArgs.isDefaultPrevented()
    ) {
      return postProcessFilter(editor, filteredContent, internal);
    } else {
      return processResult(
        filteredContent,
        preProcessArgs.isDefaultPrevented()
      );
    }
  };
  const process = (editor, html, internal) => {
    return filterContent(editor, html, internal);
  };

  const pasteHtml$1 = (editor, html) => {
    editor.insertContent(html, {
      merge: shouldPasteMergeFormats(editor),
      paste: true,
    });
    return true;
  };
  const isAbsoluteUrl = (url) =>
    /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
  const isImageUrl = (editor, url) => {
    return (
      isAbsoluteUrl(url) &&
      exists(getAllowedImageFileTypes(editor), (type) =>
        endsWith(url.toLowerCase(), `.${type.toLowerCase()}`)
      )
    );
  };
  const createImage = (editor, url, pasteHtmlFn) => {
    editor.undoManager.extra(
      () => {
        pasteHtmlFn(editor, url);
      },
      () => {
        editor.insertContent('<img src="' + url + '">');
      }
    );
    return true;
  };
  const createLink = (editor, url, pasteHtmlFn) => {
    editor.undoManager.extra(
      () => {
        pasteHtmlFn(editor, url);
      },
      () => {
        editor.execCommand("mceInsertLink", false, url);
      }
    );
    return true;
  };
  const linkSelection = (editor, html, pasteHtmlFn) =>
    !editor.selection.isCollapsed() && isAbsoluteUrl(html)
      ? createLink(editor, html, pasteHtmlFn)
      : false;
  const insertImage = (editor, html, pasteHtmlFn) =>
    isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;
  const smartInsertContent = (editor, html) => {
    Tools.each([linkSelection, insertImage, pasteHtml$1], (action) => {
      return !action(editor, html, pasteHtml$1);
    });
  };
  const insertContent = (editor, html, pasteAsText) => {
    if (pasteAsText || !isSmartPasteEnabled(editor)) {
      pasteHtml$1(editor, html);
    } else {
      smartInsertContent(editor, html);
    }
  };

  const uniqueId = createIdGenerator("mceclip");
  const createPasteDataTransfer = (html) => {
    const dataTransfer = createDataTransfer();
    setHtmlData(dataTransfer, html);
    setReadOnlyMode(dataTransfer);
    return dataTransfer;
  };
  const doPaste = (
    editor,
    content,
    internal,
    pasteAsText,
    shouldSimulateInputEvent
  ) => {
    const res = process(editor, content, internal);
    if (!res.cancelled) {
      const content = res.content;
      const doPasteAction = () => insertContent(editor, content, pasteAsText);
      if (shouldSimulateInputEvent) {
        const args = fireBeforeInputEvent(editor, "insertFromPaste", {
          dataTransfer: createPasteDataTransfer(content),
        });
        if (!args.isDefaultPrevented()) {
          doPasteAction();
          fireInputEvent(editor, "insertFromPaste");
        }
      } else {
        doPasteAction();
      }
    }
  };
  const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {
    const internal = internalFlag ? internalFlag : isMarked(html);
    doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);
  };
  const pasteText = (editor, text, shouldSimulateInputEvent) => {
    const encodedText = editor.dom.encode(text).replace(/\r\n/g, "\n");
    const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
    const html = toBlockElements(
      normalizedText,
      getForcedRootBlock(editor),
      getForcedRootBlockAttrs(editor)
    );
    doPaste(editor, html, false, true, shouldSimulateInputEvent);
  };
  const getDataTransferItems = (dataTransfer) => {
    const items = {};
    if (dataTransfer && dataTransfer.types) {
      for (let i = 0; i < dataTransfer.types.length; i++) {
        const contentType = dataTransfer.types[i];
        try {
          items[contentType] = dataTransfer.getData(contentType);
        } catch (_a) {
          items[contentType] = "";
        }
      }
    }
    return items;
  };
  const hasContentType = (clipboardContent, mimeType) =>
    mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
  const hasHtmlOrText = (content) =>
    hasContentType(content, "text/html") ||
    hasContentType(content, "text/plain");
  const extractFilename = (editor, str) => {
    const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
    return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;
  };
  const createBlobInfo = (editor, blobCache, file, base64) => {
    const id = uniqueId();
    const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
    const name = useFileName ? extractFilename(editor, file.name) : id;
    const filename = useFileName ? file.name : undefined;
    const blobInfo = blobCache.create(id, file, base64, name, filename);
    blobCache.add(blobInfo);
    return blobInfo;
  };
  const pasteImage = (editor, imageItem) => {
    parseDataUri(imageItem.uri).each(({ data, type, base64Encoded }) => {
      const base64 = base64Encoded ? data : btoa(data);
      const file = imageItem.file;
      const blobCache = editor.editorUpload.blobCache;
      const existingBlobInfo = blobCache.getByData(base64, type);
      const blobInfo =
        existingBlobInfo !== null && existingBlobInfo !== void 0
          ? existingBlobInfo
          : createBlobInfo(editor, blobCache, file, base64);
      pasteHtml(editor, `<img src="${blobInfo.blobUri()}">`, false, true);
    });
  };
  const isClipboardEvent = (event) => event.type === "paste";
  const readFilesAsDataUris = (items) =>
    Promise.all(
      map$3(items, (file) => {
        return blobToDataUri(file).then((uri) => ({
          file,
          uri,
        }));
      })
    );
  const isImage = (editor) => {
    const allowedExtensions = getAllowedImageFileTypes(editor);
    return (file) =>
      startsWith(file.type, "image/") &&
      exists(allowedExtensions, (extension) => {
        return getImageMimeType(extension) === file.type;
      });
  };
  const getImagesFromDataTransfer = (editor, dataTransfer) => {
    const items = dataTransfer.items
      ? bind$3(from(dataTransfer.items), (item) => {
          return item.kind === "file" ? [item.getAsFile()] : [];
        })
      : [];
    const files = dataTransfer.files ? from(dataTransfer.files) : [];
    return filter$5(items.length > 0 ? items : files, isImage(editor));
  };
  const pasteImageData = (editor, e, rng) => {
    const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
    if (shouldPasteDataImages(editor) && dataTransfer) {
      const images = getImagesFromDataTransfer(editor, dataTransfer);
      if (images.length > 0) {
        e.preventDefault();
        readFilesAsDataUris(images).then((fileResults) => {
          if (rng) {
            editor.selection.setRng(rng);
          }
          each$e(fileResults, (result) => {
            pasteImage(editor, result);
          });
        });
        return true;
      }
    }
    return false;
  };
  const isBrokenAndroidClipboardEvent = (e) => {
    var _a, _b;
    return (
      Env.os.isAndroid() &&
      ((_b =
        (_a = e.clipboardData) === null || _a === void 0
          ? void 0
          : _a.items) === null || _b === void 0
        ? void 0
        : _b.length) === 0
    );
  };
  const isKeyboardPasteEvent = (e) =>
    (VK.metaKeyPressed(e) && e.keyCode === 86) ||
    (e.shiftKey && e.keyCode === 45);
  const insertClipboardContent = (
    editor,
    clipboardContent,
    html,
    plainTextMode,
    shouldSimulateInputEvent
  ) => {
    let content = trimHtml(html);
    const isInternal =
      hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);
    const isPlainTextHtml = !isInternal && isPlainText(content);
    const isAbsoluteUrl$1 = isAbsoluteUrl(content);
    if (
      isDefaultPasteBinContent(content) ||
      !content.length ||
      (isPlainTextHtml && !isAbsoluteUrl$1)
    ) {
      plainTextMode = true;
    }
    if (plainTextMode || isAbsoluteUrl$1) {
      if (hasContentType(clipboardContent, "text/plain") && isPlainTextHtml) {
        content = clipboardContent["text/plain"];
      } else {
        content = innerText(content);
      }
    }
    if (isDefaultPasteBinContent(content)) {
      return;
    }
    if (plainTextMode) {
      pasteText(editor, content, shouldSimulateInputEvent);
    } else {
      pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);
    }
  };
  const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
    let keyboardPastePlainTextState;
    const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
    editor.on("keydown", (e) => {
      if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
        keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
      }
    });
    editor.on("paste", (e) => {
      if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
        return;
      }
      const plainTextMode =
        pasteFormat.get() === "text" || keyboardPastePlainTextState;
      keyboardPastePlainTextState = false;
      const clipboardContent = getDataTransferItems(e.clipboardData);
      if (
        !hasHtmlOrText(clipboardContent) &&
        pasteImageData(editor, e, getLastRng())
      ) {
        return;
      }
      if (hasContentType(clipboardContent, "text/html")) {
        e.preventDefault();
        insertClipboardContent(
          editor,
          clipboardContent,
          clipboardContent["text/html"],
          plainTextMode,
          true
        );
      } else if (
        hasContentType(clipboardContent, "text/plain") &&
        hasContentType(clipboardContent, "text/uri-list")
      ) {
        e.preventDefault();
        insertClipboardContent(
          editor,
          clipboardContent,
          clipboardContent["text/plain"],
          plainTextMode,
          true
        );
      } else {
        pasteBin.create();
        Delay.setEditorTimeout(
          editor,
          () => {
            const html = pasteBin.getHtml();
            pasteBin.remove();
            insertClipboardContent(
              editor,
              clipboardContent,
              html,
              plainTextMode,
              false
            );
          },
          0
        );
      }
    });
  };
  const registerDataImageFilter = (editor) => {
    const isWebKitFakeUrl = (src) => startsWith(src, "webkit-fake-url");
    const isDataUri = (src) => startsWith(src, "data:");
    const isPasteInsert = (args) => {
      var _a;
      return (
        ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) ===
        true
      );
    };
    editor.parser.addNodeFilter("img", (nodes, name, args) => {
      if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
        for (const node of nodes) {
          const src = node.attr("src");
          if (
            isString(src) &&
            !node.attr("data-mce-object") &&
            src !== Env.transparentSrc
          ) {
            if (isWebKitFakeUrl(src)) {
              node.remove();
            } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
              node.remove();
            }
          }
        }
      }
    });
  };
  const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
    registerEventHandlers(editor, pasteBin, pasteFormat);
    registerDataImageFilter(editor);
  };

  const togglePlainTextPaste = (editor, pasteFormat) => {
    if (pasteFormat.get() === "text") {
      pasteFormat.set("html");
      firePastePlainTextToggle(editor, false);
    } else {
      pasteFormat.set("text");
      firePastePlainTextToggle(editor, true);
    }
    editor.focus();
  };
  const register$1 = (editor, pasteFormat) => {
    editor.addCommand("mceTogglePlainTextPaste", () => {
      togglePlainTextPaste(editor, pasteFormat);
    });
    editor.addCommand("mceInsertClipboardContent", (ui, value) => {
      if (value.html) {
        pasteHtml(editor, value.html, value.internal, false);
      }
      if (value.text) {
        pasteText(editor, value.text, false);
      }
    });
  };

  const setHtml5Clipboard = (clipboardData, html, text) => {
    if (clipboardData) {
      try {
        clipboardData.clearData();
        clipboardData.setData("text/html", html);
        clipboardData.setData("text/plain", text);
        clipboardData.setData(internalHtmlMime(), html);
        return true;
      } catch (_a) {
        return false;
      }
    } else {
      return false;
    }
  };
  const setClipboardData = (evt, data, fallback, done) => {
    if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
      evt.preventDefault();
      done();
    } else {
      fallback(data.html, done);
    }
  };
  const fallback = (editor) => (html, done) => {
    const { dom, selection } = editor;
    const outer = dom.create("div", {
      contenteditable: "false",
      "data-mce-bogus": "all",
    });
    const inner = dom.create("div", { contenteditable: "true" }, html);
    dom.setStyles(outer, {
      position: "fixed",
      top: "0",
      left: "-3000px",
      width: "1000px",
      overflow: "hidden",
    });
    outer.appendChild(inner);
    dom.add(editor.getBody(), outer);
    const range = selection.getRng();
    inner.focus();
    const offscreenRange = dom.createRng();
    offscreenRange.selectNodeContents(inner);
    selection.setRng(offscreenRange);
    Delay.setEditorTimeout(
      editor,
      () => {
        selection.setRng(range);
        dom.remove(outer);
        done();
      },
      0
    );
  };
  const getData = (editor) => ({
    html: mark(editor.selection.getContent({ contextual: true })),
    text: editor.selection.getContent({ format: "text" }),
  });
  const isTableSelection = (editor) =>
    !!editor.dom.getParent(
      editor.selection.getStart(),
      "td[data-mce-selected],th[data-mce-selected]",
      editor.getBody()
    );
  const hasSelectedContent = (editor) =>
    !editor.selection.isCollapsed() || isTableSelection(editor);
  const cut = (editor) => (evt) => {
    if (
      !evt.isDefaultPrevented() &&
      hasSelectedContent(editor) &&
      editor.selection.isEditable()
    ) {
      setClipboardData(evt, getData(editor), fallback(editor), () => {
        if (Env.browser.isChromium() || Env.browser.isFirefox()) {
          const rng = editor.selection.getRng();
          Delay.setEditorTimeout(
            editor,
            () => {
              editor.selection.setRng(rng);
              editor.execCommand("Delete");
            },
            0
          );
        } else {
          editor.execCommand("Delete");
        }
      });
    }
  };
  const copy = (editor) => (evt) => {
    if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
      setClipboardData(evt, getData(editor), fallback(editor), noop);
    }
  };
  const register = (editor) => {
    editor.on("cut", cut(editor));
    editor.on("copy", copy(editor));
  };

  const getCaretRangeFromEvent = (editor, e) => {
    var _a, _b;
    return RangeUtils.getCaretRangeFromPoint(
      (_a = e.clientX) !== null && _a !== void 0 ? _a : 0,
      (_b = e.clientY) !== null && _b !== void 0 ? _b : 0,
      editor.getDoc()
    );
  };
  const isPlainTextFileUrl = (content) => {
    const plainTextContent = content["text/plain"];
    return plainTextContent ? plainTextContent.indexOf("file://") === 0 : false;
  };
  const setFocusedRange = (editor, rng) => {
    editor.focus();
    if (rng) {
      editor.selection.setRng(rng);
    }
  };
  const hasImage = (dataTransfer) =>
    exists(dataTransfer.files, (file) => /^image\//.test(file.type));
  const needsCustomInternalDrop = (dom, schema, target, dropContent) => {
    const parentTransparent = dom.getParent(target, (node) =>
      isTransparentBlock(schema, node)
    );
    const inSummary = !isNull(dom.getParent(target, "summary"));
    if (inSummary) {
      return true;
    } else if (parentTransparent && has$2(dropContent, "text/html")) {
      const fragment = new DOMParser().parseFromString(
        dropContent["text/html"],
        "text/html"
      ).body;
      return !isNull(
        fragment.querySelector(parentTransparent.nodeName.toLowerCase())
      );
    } else {
      return false;
    }
  };
  const setupSummaryDeleteByDragFix = (editor) => {
    editor.on("input", (e) => {
      const hasNoSummary = (el) => isNull(el.querySelector("summary"));
      if (e.inputType === "deleteByDrag") {
        const brokenDetailElements = filter$5(
          editor.dom.select("details"),
          hasNoSummary
        );
        each$e(brokenDetailElements, (details) => {
          if (isBr$6(details.firstChild)) {
            details.firstChild.remove();
          }
          const summary = editor.dom.create("summary");
          summary.appendChild(createPaddingBr().dom);
          details.prepend(summary);
        });
      }
    });
  };
  const setup$a = (editor, draggingInternallyState) => {
    if (shouldPasteBlockDrop(editor)) {
      editor.on("dragend dragover draggesture dragdrop drop drag", (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    }
    if (!shouldPasteDataImages(editor)) {
      editor.on("drop", (e) => {
        const dataTransfer = e.dataTransfer;
        if (dataTransfer && hasImage(dataTransfer)) {
          e.preventDefault();
        }
      });
    }
    editor.on("drop", (e) => {
      if (e.isDefaultPrevented()) {
        return;
      }
      const rng = getCaretRangeFromEvent(editor, e);
      if (isNullable(rng)) {
        return;
      }
      const dropContent = getDataTransferItems(e.dataTransfer);
      const internal = hasContentType(dropContent, internalHtmlMime());
      if (
        (!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) &&
        pasteImageData(editor, e, rng)
      ) {
        return;
      }
      const internalContent = dropContent[internalHtmlMime()];
      const content =
        internalContent ||
        dropContent["text/html"] ||
        dropContent["text/plain"];
      const needsInternalDrop = needsCustomInternalDrop(
        editor.dom,
        editor.schema,
        rng.startContainer,
        dropContent
      );
      const isInternalDrop = draggingInternallyState.get();
      if (isInternalDrop && !needsInternalDrop) {
        return;
      }
      if (content) {
        e.preventDefault();
        Delay.setEditorTimeout(editor, () => {
          editor.undoManager.transact(() => {
            if (internalContent || (isInternalDrop && needsInternalDrop)) {
              editor.execCommand("Delete");
            }
            setFocusedRange(editor, rng);
            const trimmedContent = trimHtml(content);
            if (dropContent["text/html"]) {
              pasteHtml(editor, trimmedContent, internal, true);
            } else {
              pasteText(editor, trimmedContent, true);
            }
          });
        });
      }
    });
    editor.on("dragstart", (_e) => {
      draggingInternallyState.set(true);
    });
    editor.on("dragover dragend", (e) => {
      if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
        e.preventDefault();
        setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
      }
      if (e.type === "dragend") {
        draggingInternallyState.set(false);
      }
    });
    setupSummaryDeleteByDragFix(editor);
  };

  const setup$9 = (editor) => {
    const processEvent = (f) => (e) => {
      f(editor, e);
    };
    const preProcess = getPastePreProcess(editor);
    if (isFunction(preProcess)) {
      editor.on("PastePreProcess", processEvent(preProcess));
    }
    const postProcess = getPastePostProcess(editor);
    if (isFunction(postProcess)) {
      editor.on("PastePostProcess", processEvent(postProcess));
    }
  };

  const addPreProcessFilter = (editor, filterFunc) => {
    editor.on("PastePreProcess", (e) => {
      e.content = filterFunc(editor, e.content, e.internal);
    });
  };
  const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
  const rgbToHex = (value) =>
    Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();
  const removeWebKitStyles = (editor, content, internal) => {
    const webKitStylesOption = getPasteWebkitStyles(editor);
    if (
      internal ||
      webKitStylesOption === "all" ||
      !shouldPasteRemoveWebKitStyles(editor)
    ) {
      return content;
    }
    const webKitStyles = webKitStylesOption
      ? webKitStylesOption.split(/[, ]/)
      : [];
    if (webKitStyles && webKitStylesOption !== "none") {
      const dom = editor.dom,
        node = editor.selection.getNode();
      content = content.replace(
        /(<[^>]+) style="([^"]*)"([^>]*>)/gi,
        (all, before, value, after) => {
          const inputStyles = dom.parseStyle(dom.decode(value));
          const outputStyles = {};
          for (let i = 0; i < webKitStyles.length; i++) {
            const inputValue = inputStyles[webKitStyles[i]];
            let compareInput = inputValue;
            let currentValue = dom.getStyle(node, webKitStyles[i], true);
            if (/color/.test(webKitStyles[i])) {
              compareInput = rgbToHex(compareInput);
              currentValue = rgbToHex(currentValue);
            }
            if (currentValue !== compareInput) {
              outputStyles[webKitStyles[i]] = inputValue;
            }
          }
          const outputStyle = dom.serializeStyle(outputStyles, "span");
          if (outputStyle) {
            return before + ' style="' + outputStyle + '"' + after;
          }
          return before + after;
        }
      );
    } else {
      content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
    }
    content = content.replace(
      /(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi,
      (all, before, value, after) => {
        return before + ' style="' + value + '"' + after;
      }
    );
    return content;
  };
  const setup$8 = (editor) => {
    if (Env.browser.isChromium() || Env.browser.isSafari()) {
      addPreProcessFilter(editor, removeWebKitStyles);
    }
  };

  const setup$7 = (editor) => {
    const draggingInternallyState = Cell(false);
    const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? "text" : "html");
    const pasteBin = PasteBin(editor);
    setup$8(editor);
    register$1(editor, pasteFormat);
    setup$9(editor);
    editor.addQueryStateHandler(
      "mceTogglePlainTextPaste",
      () => pasteFormat.get() === "text"
    );
    editor.on("PreInit", () => {
      register(editor);
      setup$a(editor, draggingInternallyState);
      registerEventsAndFilters(editor, pasteBin, pasteFormat);
    });
  };

  const preventSummaryToggle = (editor) => {
    editor.on("click", (e) => {
      if (editor.dom.getParent(e.target, "details")) {
        e.preventDefault();
      }
    });
  };
  const filterDetails = (editor) => {
    editor.parser.addNodeFilter("details", (elms) => {
      const initialStateOption = getDetailsInitialState(editor);
      each$e(elms, (details) => {
        if (initialStateOption === "expanded") {
          details.attr("open", "open");
        } else if (initialStateOption === "collapsed") {
          details.attr("open", null);
        }
      });
    });
    editor.serializer.addNodeFilter("details", (elms) => {
      const serializedStateOption = getDetailsSerializedState(editor);
      each$e(elms, (details) => {
        if (serializedStateOption === "expanded") {
          details.attr("open", "open");
        } else if (serializedStateOption === "collapsed") {
          details.attr("open", null);
        }
      });
    });
  };
  const setup$6 = (editor) => {
    preventSummaryToggle(editor);
    filterDetails(editor);
  };

  const isBr = isBr$6;
  const isText = isText$b;
  const isContentEditableFalse$2 = (elm) => isContentEditableFalse$b(elm.dom);
  const isContentEditableTrue = (elm) => isContentEditableTrue$3(elm.dom);
  const isRoot = (rootNode) => (elm) => eq(SugarElement.fromDom(rootNode), elm);
  const getClosestScope = (node, rootNode, schema) =>
    closest$4(
      SugarElement.fromDom(node),
      (elm) => isContentEditableTrue(elm) || schema.isBlock(name(elm)),
      isRoot(rootNode)
    ).getOr(SugarElement.fromDom(rootNode)).dom;
  const getClosestCef = (node, rootNode) =>
    closest$4(
      SugarElement.fromDom(node),
      isContentEditableFalse$2,
      isRoot(rootNode)
    );
  const findEdgeCaretCandidate = (startNode, scope, forward) => {
    const walker = new DomTreeWalker(startNode, scope);
    const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
    let result = startNode;
    for (
      let current = forward ? startNode : next();
      current && !isBr(current);
      current = next()
    ) {
      if (isCaretCandidate$3(current)) {
        result = current;
      }
    }
    return result;
  };
  const findClosestBlockRange = (startRng, rootNode, schema) => {
    const startPos = CaretPosition.fromRangeStart(startRng);
    const clickNode = startPos.getNode();
    const scope = getClosestScope(clickNode, rootNode, schema);
    const startNode = findEdgeCaretCandidate(clickNode, scope, false);
    const endNode = findEdgeCaretCandidate(clickNode, scope, true);
    const rng = document.createRange();
    getClosestCef(startNode, scope).fold(
      () => {
        if (isText(startNode)) {
          rng.setStart(startNode, 0);
        } else {
          rng.setStartBefore(startNode);
        }
      },
      (cef) => rng.setStartBefore(cef.dom)
    );
    getClosestCef(endNode, scope).fold(
      () => {
        if (isText(endNode)) {
          rng.setEnd(endNode, endNode.data.length);
        } else {
          rng.setEndAfter(endNode);
        }
      },
      (cef) => rng.setEndAfter(cef.dom)
    );
    return rng;
  };
  const onTripleClickSelect = (editor) => {
    const rng = findClosestBlockRange(
      editor.selection.getRng(),
      editor.getBody(),
      editor.schema
    );
    editor.selection.setRng(normalize(rng));
  };
  const setup$5 = (editor) => {
    editor.on("mousedown", (e) => {
      if (e.detail >= 3) {
        e.preventDefault();
        onTripleClickSelect(editor);
      }
    });
  };

  var FakeCaretPosition;
  (function (FakeCaretPosition) {
    FakeCaretPosition["Before"] = "before";
    FakeCaretPosition["After"] = "after";
  })(FakeCaretPosition || (FakeCaretPosition = {}));
  const distanceToRectLeft = (clientRect, clientX) =>
    Math.abs(clientRect.left - clientX);
  const distanceToRectRight = (clientRect, clientX) =>
    Math.abs(clientRect.right - clientX);
  const isInsideY = (clientY, clientRect) =>
    clientY >= clientRect.top && clientY <= clientRect.bottom;
  const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
  const isOverlapping = (r1, r2) => {
    const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
    return collidesY(r1, r2) && overlap > 0.5;
  };
  const splitRectsPerAxis = (rects, y) => {
    const intersectingRects = filter$5(rects, (rect) => isInsideY(y, rect));
    return boundingClientRectFromRects(intersectingRects).fold(
      () => [[], rects],
      (boundingRect) => {
        const { pass: horizontal, fail: vertical } = partition$2(
          rects,
          (rect) => isOverlapping(rect, boundingRect)
        );
        return [horizontal, vertical];
      }
    );
  };
  const clientInfo = (rect, clientX) => {
    return {
      node: rect.node,
      position:
        distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX)
          ? FakeCaretPosition.Before
          : FakeCaretPosition.After,
    };
  };
  const horizontalDistance = (rect, x, _y) =>
    x > rect.left && x < rect.right
      ? 0
      : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
  const closestChildCaretCandidateNodeRect = (
    children,
    clientX,
    clientY,
    findCloserTextNode
  ) => {
    const caretCandidateRect = (rect) => {
      if (isCaretCandidate$3(rect.node)) {
        return Optional.some(rect);
      } else if (isElement$6(rect.node)) {
        return closestChildCaretCandidateNodeRect(
          from(rect.node.childNodes),
          clientX,
          clientY,
          false
        );
      } else {
        return Optional.none();
      }
    };
    const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {
      return caretCandidateRect(sndClosest).filter((rect) => {
        const deltaDistance = Math.abs(
          distance(closest, clientX, clientY) - distance(rect, clientX, clientY)
        );
        return deltaDistance < 2 && isText$b(rect.node);
      });
    };
    const findClosestCaretCandidateNodeRect = (rects, distance) => {
      const sortedRects = sort(
        rects,
        (r1, r2) =>
          distance(r1, clientX, clientY) - distance(r2, clientX, clientY)
      );
      return findMap(sortedRects, caretCandidateRect).map((closest) => {
        if (
          findCloserTextNode &&
          !isText$b(closest.node) &&
          sortedRects.length > 1
        ) {
          return tryFindSecondBestTextNode(
            closest,
            sortedRects[1],
            distance
          ).getOr(closest);
        } else {
          return closest;
        }
      });
    };
    const [horizontalRects, verticalRects] = splitRectsPerAxis(
      getClientRects(children),
      clientY
    );
    const { pass: above, fail: below } = partition$2(
      verticalRects,
      (rect) => rect.top < clientY
    );
    return findClosestCaretCandidateNodeRect(
      horizontalRects,
      horizontalDistance
    )
      .orThunk(() =>
        findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)
      )
      .orThunk(() =>
        findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY)
      );
  };
  const traverseUp = (rootElm, scope, clientX, clientY) => {
    const helper = (scope, prevScope) => {
      const isDragGhostContainer = (node) =>
        isElement$6(node) && node.classList.contains("mce-drag-container");
      const childNodesWithoutGhost = filter$5(
        scope.dom.childNodes,
        not(isDragGhostContainer)
      );
      return prevScope
        .fold(
          () =>
            closestChildCaretCandidateNodeRect(
              childNodesWithoutGhost,
              clientX,
              clientY,
              true
            ),
          (prevScope) => {
            const uncheckedChildren = filter$5(
              childNodesWithoutGhost,
              (node) => node !== prevScope.dom
            );
            return closestChildCaretCandidateNodeRect(
              uncheckedChildren,
              clientX,
              clientY,
              true
            );
          }
        )
        .orThunk(() => {
          const parent = eq(scope, rootElm)
            ? Optional.none()
            : parentElement(scope);
          return parent.bind((newScope) =>
            helper(newScope, Optional.some(scope))
          );
        });
    };
    return helper(scope, Optional.none());
  };
  const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
    const rootElm = SugarElement.fromDom(root);
    const ownerDoc = documentOrOwner(rootElm);
    const elementAtPoint = SugarElement.fromPoint(
      ownerDoc,
      clientX,
      clientY
    ).filter((elm) => contains(rootElm, elm));
    const element = elementAtPoint.getOr(rootElm);
    return traverseUp(rootElm, element, clientX, clientY);
  };
  const closestFakeCaretCandidate = (root, clientX, clientY) =>
    closestCaretCandidateNodeRect(root, clientX, clientY)
      .filter((rect) => isFakeCaretTarget(rect.node))
      .map((rect) => clientInfo(rect, clientX));

  const getAbsolutePosition = (elm) => {
    var _a, _b;
    const clientRect = elm.getBoundingClientRect();
    const doc = elm.ownerDocument;
    const docElem = doc.documentElement;
    const win = doc.defaultView;
    return {
      top:
        clientRect.top +
        ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !==
          null && _a !== void 0
          ? _a
          : 0) -
        docElem.clientTop,
      left:
        clientRect.left +
        ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !==
          null && _b !== void 0
          ? _b
          : 0) -
        docElem.clientLeft,
    };
  };
  const getBodyPosition = (editor) =>
    editor.inline
      ? getAbsolutePosition(editor.getBody())
      : {
          left: 0,
          top: 0,
        };
  const getScrollPosition = (editor) => {
    const body = editor.getBody();
    return editor.inline
      ? {
          left: body.scrollLeft,
          top: body.scrollTop,
        }
      : {
          left: 0,
          top: 0,
        };
  };
  const getBodyScroll = (editor) => {
    const body = editor.getBody(),
      docElm = editor.getDoc().documentElement;
    const inlineScroll = {
      left: body.scrollLeft,
      top: body.scrollTop,
    };
    const iframeScroll = {
      left: body.scrollLeft || docElm.scrollLeft,
      top: body.scrollTop || docElm.scrollTop,
    };
    return editor.inline ? inlineScroll : iframeScroll;
  };
  const getMousePosition = (editor, event) => {
    if (event.target.ownerDocument !== editor.getDoc()) {
      const iframePosition = getAbsolutePosition(
        editor.getContentAreaContainer()
      );
      const scrollPosition = getBodyScroll(editor);
      return {
        left: event.pageX - iframePosition.left + scrollPosition.left,
        top: event.pageY - iframePosition.top + scrollPosition.top,
      };
    }
    return {
      left: event.pageX,
      top: event.pageY,
    };
  };
  const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
    pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
    pageY: mousePosition.top - bodyPosition.top + scrollPosition.top,
  });
  const calc = (editor, event) =>
    calculatePosition(
      getBodyPosition(editor),
      getScrollPosition(editor),
      getMousePosition(editor, event)
    );

  const getTargetProps = (target) => ({
    target,
    srcElement: target,
  });
  const makeDndEventFromMouseEvent = (
    type,
    mouseEvent,
    target,
    dataTransfer
  ) => ({
    ...mouseEvent,
    dataTransfer,
    type,
    ...getTargetProps(target),
  });
  const makeDndEvent = (type, target, dataTransfer) => {
    const fail = die("Function not supported on simulated event.");
    const event = {
      bubbles: true,
      cancelBubble: false,
      cancelable: true,
      composed: false,
      currentTarget: null,
      defaultPrevented: false,
      eventPhase: 0,
      isTrusted: true,
      returnValue: false,
      timeStamp: 0,
      type,
      composedPath: fail,
      initEvent: fail,
      preventDefault: noop,
      stopImmediatePropagation: noop,
      stopPropagation: noop,
      AT_TARGET: window.Event.AT_TARGET,
      BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
      CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
      NONE: window.Event.NONE,
      altKey: false,
      button: 0,
      buttons: 0,
      clientX: 0,
      clientY: 0,
      ctrlKey: false,
      layerX: 0,
      layerY: 0,
      metaKey: false,
      movementX: 0,
      movementY: 0,
      offsetX: 0,
      offsetY: 0,
      pageX: 0,
      pageY: 0,
      relatedTarget: null,
      screenX: 0,
      screenY: 0,
      shiftKey: false,
      x: 0,
      y: 0,
      detail: 0,
      view: null,
      which: 0,
      initUIEvent: fail,
      initMouseEvent: fail,
      getModifierState: fail,
      dataTransfer,
      ...getTargetProps(target),
    };
    return event;
  };
  const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {
    const copy = cloneDataTransfer(dataTransfer);
    if (eventType === "dragstart") {
      setDragstartEvent(copy);
      setReadWriteMode(copy);
    } else if (eventType === "drop") {
      setDropEvent(copy);
      setReadOnlyMode(copy);
    } else {
      setDragendEvent(copy);
      setProtectedMode(copy);
    }
    return copy;
  };
  const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {
    const dataTransferForDispatch = makeDataTransferCopyForDragEvent(
      dataTransfer,
      type
    );
    return isUndefined(mouseEvent)
      ? makeDndEvent(type, target, dataTransferForDispatch)
      : makeDndEventFromMouseEvent(
          type,
          mouseEvent,
          target,
          dataTransferForDispatch
        );
  };

  const scrollPixelsPerInterval = 32;
  const scrollIntervalValue = 100;
  const mouseRangeToTriggerScrollInsideEditor = 8;
  const mouseRangeToTriggerScrollOutsideEditor = 16;
  const isContentEditableFalse$1 = isContentEditableFalse$b;
  const isContentEditable = or(
    isContentEditableFalse$1,
    isContentEditableTrue$3
  );
  const isDraggable = (dom, rootElm, elm) =>
    isContentEditableFalse$1(elm) &&
    elm !== rootElm &&
    dom.isEditable(elm.parentElement);
  const isValidDropTarget = (editor, targetElement, dragElement) => {
    if (isNullable(targetElement)) {
      return false;
    } else if (
      targetElement === dragElement ||
      editor.dom.isChildOf(targetElement, dragElement)
    ) {
      return false;
    } else {
      return editor.dom.isEditable(targetElement);
    }
  };
  const createGhost = (editor, elm, width, height) => {
    const dom = editor.dom;
    const clonedElm = elm.cloneNode(true);
    dom.setStyles(clonedElm, {
      width,
      height,
    });
    dom.setAttrib(clonedElm, "data-mce-selected", null);
    const ghostElm = dom.create("div", {
      class: "mce-drag-container",
      "data-mce-bogus": "all",
      unselectable: "on",
      contenteditable: "false",
    });
    dom.setStyles(ghostElm, {
      position: "absolute",
      opacity: 0.5,
      overflow: "hidden",
      border: 0,
      padding: 0,
      margin: 0,
      width,
      height,
    });
    dom.setStyles(clonedElm, {
      margin: 0,
      boxSizing: "border-box",
    });
    ghostElm.appendChild(clonedElm);
    return ghostElm;
  };
  const appendGhostToBody = (ghostElm, bodyElm) => {
    if (ghostElm.parentNode !== bodyElm) {
      bodyElm.appendChild(ghostElm);
    }
  };
  const scrollEditor = (direction, amount) => (win) => () => {
    const current = direction === "left" ? win.scrollX : win.scrollY;
    win.scroll({
      [direction]: current + amount,
      behavior: "smooth",
    });
  };
  const scrollLeft = scrollEditor("left", -scrollPixelsPerInterval);
  const scrollRight = scrollEditor("left", scrollPixelsPerInterval);
  const scrollUp = scrollEditor("top", -scrollPixelsPerInterval);
  const scrollDown = scrollEditor("top", scrollPixelsPerInterval);
  const moveGhost = (
    ghostElm,
    position,
    width,
    height,
    maxX,
    maxY,
    mouseY,
    mouseX,
    contentAreaContainer,
    win,
    state,
    mouseEventOriginatedFromWithinTheEditor
  ) => {
    let overflowX = 0,
      overflowY = 0;
    ghostElm.style.left = position.pageX + "px";
    ghostElm.style.top = position.pageY + "px";
    if (position.pageX + width > maxX) {
      overflowX = position.pageX + width - maxX;
    }
    if (position.pageY + height > maxY) {
      overflowY = position.pageY + height - maxY;
    }
    ghostElm.style.width = width - overflowX + "px";
    ghostElm.style.height = height - overflowY + "px";
    const clientHeight = contentAreaContainer.clientHeight;
    const clientWidth = contentAreaContainer.clientWidth;
    const outerMouseY =
      mouseY + contentAreaContainer.getBoundingClientRect().top;
    const outerMouseX =
      mouseX + contentAreaContainer.getBoundingClientRect().left;
    state.on((state) => {
      state.intervalId.clear();
      if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {
        if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
          state.intervalId.set(scrollDown(win));
        } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
          state.intervalId.set(scrollUp(win));
        } else if (
          mouseX + mouseRangeToTriggerScrollInsideEditor >=
          clientWidth
        ) {
          state.intervalId.set(scrollRight(win));
        } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
          state.intervalId.set(scrollLeft(win));
        } else if (
          outerMouseY + mouseRangeToTriggerScrollOutsideEditor >=
          window.innerHeight
        ) {
          state.intervalId.set(scrollDown(window));
        } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
          state.intervalId.set(scrollUp(window));
        } else if (
          outerMouseX + mouseRangeToTriggerScrollOutsideEditor >=
          window.innerWidth
        ) {
          state.intervalId.set(scrollRight(window));
        } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
          state.intervalId.set(scrollLeft(window));
        }
      }
    });
  };
  const removeElement = (elm) => {
    if (elm && elm.parentNode) {
      elm.parentNode.removeChild(elm);
    }
  };
  const removeElementWithPadding = (dom, elm) => {
    const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);
    removeElement(elm);
    if (
      parentBlock &&
      parentBlock !== dom.getRoot() &&
      dom.isEmpty(parentBlock)
    ) {
      fillWithPaddingBr(SugarElement.fromDom(parentBlock));
    }
  };
  const isLeftMouseButtonPressed = (e) => e.button === 0;
  const applyRelPos = (state, position) => ({
    pageX: position.pageX - state.relX,
    pageY: position.pageY + 5,
  });
  const start = (state, editor) => (e) => {
    if (isLeftMouseButtonPressed(e)) {
      const ceElm = find$2(
        editor.dom.getParents(e.target),
        isContentEditable
      ).getOr(null);
      if (
        isNonNullable(ceElm) &&
        isDraggable(editor.dom, editor.getBody(), ceElm)
      ) {
        const elmPos = editor.dom.getPos(ceElm);
        const bodyElm = editor.getBody();
        const docElm = editor.getDoc().documentElement;
        state.set({
          element: ceElm,
          dataTransfer: createDataTransfer(),
          dragging: false,
          screenX: e.screenX,
          screenY: e.screenY,
          maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
          maxY:
            (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
          relX: e.pageX - elmPos.x,
          relY: e.pageY - elmPos.y,
          width: ceElm.offsetWidth,
          height: ceElm.offsetHeight,
          ghost: createGhost(
            editor,
            ceElm,
            ceElm.offsetWidth,
            ceElm.offsetHeight
          ),
          intervalId: repeatable(scrollIntervalValue),
        });
      }
    }
  };
  const placeCaretAt = (editor, clientX, clientY) => {
    editor._selectionOverrides.hideFakeCaret();
    closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(
      () => editor.selection.placeCaretAt(clientX, clientY),
      (caretInfo) => {
        const range = editor._selectionOverrides.showCaret(
          1,
          caretInfo.node,
          caretInfo.position === FakeCaretPosition.Before,
          false
        );
        if (range) {
          editor.selection.setRng(range);
        } else {
          editor.selection.placeCaretAt(clientX, clientY);
        }
      }
    );
  };
  const dispatchDragEvent = (
    editor,
    type,
    target,
    dataTransfer,
    mouseEvent
  ) => {
    if (type === "dragstart") {
      setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));
    }
    const event = makeDragEvent(type, target, dataTransfer, mouseEvent);
    const args = editor.dispatch(type, event);
    return args;
  };
  const move = (state, editor) => {
    const throttledPlaceCaretAt = first$1(
      (clientX, clientY) => placeCaretAt(editor, clientX, clientY),
      0
    );
    editor.on("remove", throttledPlaceCaretAt.cancel);
    const state_ = state;
    return (e) =>
      state.on((state) => {
        const movement = Math.max(
          Math.abs(e.screenX - state.screenX),
          Math.abs(e.screenY - state.screenY)
        );
        if (!state.dragging && movement > 10) {
          const args = dispatchDragEvent(
            editor,
            "dragstart",
            state.element,
            state.dataTransfer,
            e
          );
          if (isNonNullable(args.dataTransfer)) {
            state.dataTransfer = args.dataTransfer;
          }
          if (args.isDefaultPrevented()) {
            return;
          }
          state.dragging = true;
          editor.focus();
        }
        if (state.dragging) {
          const mouseEventOriginatedFromWithinTheEditor =
            e.currentTarget === editor.getDoc().documentElement;
          const targetPos = applyRelPos(state, calc(editor, e));
          appendGhostToBody(state.ghost, editor.getBody());
          moveGhost(
            state.ghost,
            targetPos,
            state.width,
            state.height,
            state.maxX,
            state.maxY,
            e.clientY,
            e.clientX,
            editor.getContentAreaContainer(),
            editor.getWin(),
            state_,
            mouseEventOriginatedFromWithinTheEditor
          );
          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
        }
      });
  };
  const getRawTarget = (selection) => {
    const sel = selection.getSel();
    if (isNonNullable(sel)) {
      const rng = sel.getRangeAt(0);
      const startContainer = rng.startContainer;
      return isText$b(startContainer)
        ? startContainer.parentNode
        : startContainer;
    } else {
      return null;
    }
  };
  const drop = (state, editor) => (e) => {
    state.on((state) => {
      var _a;
      state.intervalId.clear();
      if (state.dragging) {
        if (
          isValidDropTarget(
            editor,
            getRawTarget(editor.selection),
            state.element
          )
        ) {
          const dropTarget =
            (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !==
              null && _a !== void 0
              ? _a
              : editor.getBody();
          const args = dispatchDragEvent(
            editor,
            "drop",
            dropTarget,
            state.dataTransfer,
            e
          );
          if (!args.isDefaultPrevented()) {
            editor.undoManager.transact(() => {
              removeElementWithPadding(editor.dom, state.element);
              getHtmlData(state.dataTransfer).each((content) =>
                editor.insertContent(content)
              );
              editor._selectionOverrides.hideFakeCaret();
            });
          }
        }
        dispatchDragEvent(
          editor,
          "dragend",
          editor.getBody(),
          state.dataTransfer,
          e
        );
      }
    });
    removeDragState(state);
  };
  const stopDragging = (state, editor, e) => {
    state.on((state) => {
      state.intervalId.clear();
      if (state.dragging) {
        e.fold(
          () =>
            dispatchDragEvent(
              editor,
              "dragend",
              state.element,
              state.dataTransfer
            ),
          (mouseEvent) =>
            dispatchDragEvent(
              editor,
              "dragend",
              state.element,
              state.dataTransfer,
              mouseEvent
            )
        );
      }
    });
    removeDragState(state);
  };
  const stop = (state, editor) => (e) =>
    stopDragging(state, editor, Optional.some(e));
  const removeDragState = (state) => {
    state.on((state) => {
      state.intervalId.clear();
      removeElement(state.ghost);
    });
    state.clear();
  };
  const bindFakeDragEvents = (editor) => {
    const state = value$2();
    const pageDom = DOMUtils.DOM;
    const rootDocument = document;
    const dragStartHandler = start(state, editor);
    const dragHandler = move(state, editor);
    const dropHandler = drop(state, editor);
    const dragEndHandler = stop(state, editor);
    editor.on("mousedown", dragStartHandler);
    editor.on("mousemove", dragHandler);
    editor.on("mouseup", dropHandler);
    pageDom.bind(rootDocument, "mousemove", dragHandler);
    pageDom.bind(rootDocument, "mouseup", dragEndHandler);
    editor.on("remove", () => {
      pageDom.unbind(rootDocument, "mousemove", dragHandler);
      pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
    });
    editor.on("keydown", (e) => {
      if (e.keyCode === VK.ESC) {
        stopDragging(state, editor, Optional.none());
      }
    });
  };
  const blockUnsupportedFileDrop = (editor) => {
    const preventFileDrop = (e) => {
      if (!e.isDefaultPrevented()) {
        const dataTransfer = e.dataTransfer;
        if (
          dataTransfer &&
          (contains$2(dataTransfer.types, "Files") ||
            dataTransfer.files.length > 0)
        ) {
          e.preventDefault();
          if (e.type === "drop") {
            displayError(editor, "Dropped file type is not supported");
          }
        }
      }
    };
    const preventFileDropIfUIElement = (e) => {
      if (isUIElement(editor, e.target)) {
        preventFileDrop(e);
      }
    };
    const setup = () => {
      const pageDom = DOMUtils.DOM;
      const dom = editor.dom;
      const doc = document;
      const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
      const eventNames = ["drop", "dragover"];
      each$e(eventNames, (name) => {
        pageDom.bind(doc, name, preventFileDropIfUIElement);
        dom.bind(editorRoot, name, preventFileDrop);
      });
      editor.on("remove", () => {
        each$e(eventNames, (name) => {
          pageDom.unbind(doc, name, preventFileDropIfUIElement);
          dom.unbind(editorRoot, name, preventFileDrop);
        });
      });
    };
    editor.on("init", () => {
      Delay.setEditorTimeout(editor, setup, 0);
    });
  };
  const init$2 = (editor) => {
    bindFakeDragEvents(editor);
    if (shouldBlockUnsupportedDrop(editor)) {
      blockUnsupportedFileDrop(editor);
    }
  };

  const setup$4 = (editor) => {
    const renderFocusCaret = first$1(() => {
      if (
        !editor.removed &&
        editor.getBody().contains(document.activeElement)
      ) {
        const rng = editor.selection.getRng();
        if (rng.collapsed) {
          const caretRange = renderRangeCaret(editor, rng, false);
          editor.selection.setRng(caretRange);
        }
      }
    }, 0);
    editor.on("focus", () => {
      renderFocusCaret.throttle();
    });
    editor.on("blur", () => {
      renderFocusCaret.cancel();
    });
  };

  const setup$3 = (editor) => {
    editor.on("init", () => {
      editor.on("focusin", (e) => {
        const target = e.target;
        if (isMedia$2(target)) {
          const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
          const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
          if (editor.selection.getNode() !== node) {
            selectNode(editor, node).each((rng) =>
              editor.selection.setRng(rng)
            );
          }
        }
      });
    });
  };

  const isContentEditableFalse = isContentEditableFalse$b;
  const getContentEditableRoot = (editor, node) =>
    getContentEditableRoot$1(editor.getBody(), node);
  const SelectionOverrides = (editor) => {
    const selection = editor.selection,
      dom = editor.dom;
    const rootNode = editor.getBody();
    const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () =>
      hasFocus(editor)
    );
    const realSelectionId = "sel-" + dom.uniqueId();
    const elementSelectionAttr = "data-mce-selected";
    let selectedElement;
    const isFakeSelectionElement = (node) =>
      isNonNullable(node) && dom.hasClass(node, "mce-offscreen-selection");
    const isFakeSelectionTargetElement = (node) =>
      node !== rootNode &&
      (isContentEditableFalse(node) || isMedia$2(node)) &&
      dom.isChildOf(node, rootNode) &&
      dom.isEditable(node.parentNode);
    const setRange = (range) => {
      if (range) {
        selection.setRng(range);
      }
    };
    const showCaret = (direction, node, before, scrollIntoView = true) => {
      const e = editor.dispatch("ShowCaret", {
        target: node,
        direction,
        before,
      });
      if (e.isDefaultPrevented()) {
        return null;
      }
      if (scrollIntoView) {
        selection.scrollIntoView(node, direction === -1);
      }
      return fakeCaret.show(before, node);
    };
    const showBlockCaretContainer = (blockCaretContainer) => {
      if (blockCaretContainer.hasAttribute("data-mce-caret")) {
        showCaretContainerBlock(blockCaretContainer);
        selection.scrollIntoView(blockCaretContainer);
      }
    };
    const registerEvents = () => {
      editor.on("click", (e) => {
        if (!dom.isEditable(e.target)) {
          e.preventDefault();
          editor.focus();
        }
      });
      editor.on("blur NewBlock", removeElementSelection);
      editor.on("ResizeWindow FullscreenStateChanged", fakeCaret.reposition);
      editor.on(
        "tap",
        (e) => {
          const targetElm = e.target;
          const contentEditableRoot = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          }
        },
        true
      );
      editor.on("mousedown", (e) => {
        const targetElm = e.target;
        if (
          targetElm !== rootNode &&
          targetElm.nodeName !== "HTML" &&
          !dom.isChildOf(targetElm, rootNode)
        ) {
          return;
        }
        if (!isXYInContentArea(editor, e.clientX, e.clientY)) {
          return;
        }
        removeElementSelection();
        hideFakeCaret();
        const closestContentEditable = getContentEditableRoot(
          editor,
          targetElm
        );
        if (isContentEditableFalse(closestContentEditable)) {
          e.preventDefault();
          selectNode(editor, closestContentEditable).each(setElementSelection);
        } else {
          closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(
            (caretInfo) => {
              e.preventDefault();
              const range = showCaret(
                1,
                caretInfo.node,
                caretInfo.position === FakeCaretPosition.Before,
                false
              );
              setRange(range);
              if (isHTMLElement(closestContentEditable)) {
                closestContentEditable.focus();
              } else {
                editor.getBody().focus();
              }
            }
          );
        }
      });
      editor.on("keypress", (e) => {
        if (VK.modifierPressed(e)) {
          return;
        }
        if (isContentEditableFalse(selection.getNode())) {
          e.preventDefault();
        }
      });
      editor.on("GetSelectionRange", (e) => {
        let rng = e.range;
        if (selectedElement) {
          if (!selectedElement.parentNode) {
            selectedElement = null;
            return;
          }
          rng = rng.cloneRange();
          rng.selectNode(selectedElement);
          e.range = rng;
        }
      });
      editor.on("SetSelectionRange", (e) => {
        e.range = normalizeVoidElementSelection(e.range);
        const rng = setElementSelection(e.range, e.forward);
        if (rng) {
          e.range = rng;
        }
      });
      const isPasteBin = (node) =>
        isElement$6(node) && node.id === "mcepastebin";
      editor.on("AfterSetSelectionRange", (e) => {
        const rng = e.range;
        const parent = rng.startContainer.parentElement;
        if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {
          hideFakeCaret();
        }
        if (!isFakeSelectionElement(parent)) {
          removeElementSelection();
        }
      });
      init$2(editor);
      setup$4(editor);
      setup$3(editor);
    };
    const isWithinCaretContainer = (node) =>
      isCaretContainer$2(node) ||
      startsWithCaretContainer$1(node) ||
      endsWithCaretContainer$1(node);
    const isRangeInCaretContainer = (rng) =>
      isWithinCaretContainer(rng.startContainer) ||
      isWithinCaretContainer(rng.endContainer);
    const normalizeVoidElementSelection = (rng) => {
      const voidElements = editor.schema.getVoidElements();
      const newRng = dom.createRng();
      const startContainer = rng.startContainer;
      const startOffset = rng.startOffset;
      const endContainer = rng.endContainer;
      const endOffset = rng.endOffset;
      if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
        if (startOffset === 0) {
          newRng.setStartBefore(startContainer);
        } else {
          newRng.setStartAfter(startContainer);
        }
      } else {
        newRng.setStart(startContainer, startOffset);
      }
      if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
        if (endOffset === 0) {
          newRng.setEndBefore(endContainer);
        } else {
          newRng.setEndAfter(endContainer);
        }
      } else {
        newRng.setEnd(endContainer, endOffset);
      }
      return newRng;
    };
    const setupOffscreenSelection = (node, targetClone) => {
      const body = SugarElement.fromDom(editor.getBody());
      const doc = editor.getDoc();
      const realSelectionContainer = descendant$1(
        body,
        "#" + realSelectionId
      ).getOrThunk(() => {
        const newContainer = SugarElement.fromHtml(
          '<div data-mce-bogus="all" class="mce-offscreen-selection"></div>',
          doc
        );
        set$4(newContainer, "id", realSelectionId);
        append$1(body, newContainer);
        return newContainer;
      });
      const newRange = dom.createRng();
      empty(realSelectionContainer);
      append(realSelectionContainer, [
        SugarElement.fromText(nbsp, doc),
        SugarElement.fromDom(targetClone),
        SugarElement.fromText(nbsp, doc),
      ]);
      newRange.setStart(realSelectionContainer.dom.firstChild, 1);
      newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
      setAll(realSelectionContainer, {
        top: dom.getPos(node, editor.getBody()).y + "px",
      });
      focus$1(realSelectionContainer);
      const sel = selection.getSel();
      if (sel) {
        sel.removeAllRanges();
        sel.addRange(newRange);
      }
      return newRange;
    };
    const selectElement = (elm) => {
      const targetClone = elm.cloneNode(true);
      const e = editor.dispatch("ObjectSelected", {
        target: elm,
        targetClone,
      });
      if (e.isDefaultPrevented()) {
        return null;
      }
      const range = setupOffscreenSelection(elm, e.targetClone);
      const nodeElm = SugarElement.fromDom(elm);
      each$e(
        descendants(
          SugarElement.fromDom(editor.getBody()),
          `*[${elementSelectionAttr}]`
        ),
        (elm) => {
          if (!eq(nodeElm, elm)) {
            remove$9(elm, elementSelectionAttr);
          }
        }
      );
      if (!dom.getAttrib(elm, elementSelectionAttr)) {
        elm.setAttribute(elementSelectionAttr, "1");
      }
      selectedElement = elm;
      hideFakeCaret();
      return range;
    };
    const setElementSelection = (range, forward) => {
      if (!range) {
        return null;
      }
      if (range.collapsed) {
        if (!isRangeInCaretContainer(range)) {
          const dir = forward ? 1 : -1;
          const caretPosition = getNormalizedRangeEndPoint(
            dir,
            rootNode,
            range
          );
          const beforeNode = caretPosition.getNode(!forward);
          if (isNonNullable(beforeNode)) {
            if (isFakeCaretTarget(beforeNode)) {
              return showCaret(
                dir,
                beforeNode,
                forward ? !caretPosition.isAtEnd() : false,
                false
              );
            }
            if (
              isCaretContainerInline(beforeNode) &&
              isContentEditableFalse$b(beforeNode.nextSibling)
            ) {
              const rng = dom.createRng();
              rng.setStart(beforeNode, 0);
              rng.setEnd(beforeNode, 0);
              return rng;
            }
          }
          const afterNode = caretPosition.getNode(forward);
          if (isNonNullable(afterNode)) {
            if (isFakeCaretTarget(afterNode)) {
              return showCaret(
                dir,
                afterNode,
                forward ? false : !caretPosition.isAtEnd(),
                false
              );
            }
            if (
              isCaretContainerInline(afterNode) &&
              isContentEditableFalse$b(afterNode.previousSibling)
            ) {
              const rng = dom.createRng();
              rng.setStart(afterNode, 1);
              rng.setEnd(afterNode, 1);
              return rng;
            }
          }
        }
        return null;
      }
      let startContainer = range.startContainer;
      let startOffset = range.startOffset;
      const endOffset = range.endOffset;
      if (
        isText$b(startContainer) &&
        startOffset === 0 &&
        isContentEditableFalse(startContainer.parentNode)
      ) {
        startContainer = startContainer.parentNode;
        startOffset = dom.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (!isElement$6(startContainer)) {
        return null;
      }
      if (
        endOffset === startOffset + 1 &&
        startContainer === range.endContainer
      ) {
        const node = startContainer.childNodes[startOffset];
        if (isFakeSelectionTargetElement(node)) {
          return selectElement(node);
        }
      }
      return null;
    };
    const removeElementSelection = () => {
      if (selectedElement) {
        selectedElement.removeAttribute(elementSelectionAttr);
      }
      descendant$1(
        SugarElement.fromDom(editor.getBody()),
        "#" + realSelectionId
      ).each(remove$4);
      selectedElement = null;
    };
    const destroy = () => {
      fakeCaret.destroy();
      selectedElement = null;
    };
    const hideFakeCaret = () => {
      fakeCaret.hide();
    };
    if (!isRtc(editor)) {
      registerEvents();
    }
    return {
      showCaret,
      showBlockCaretContainer,
      hideFakeCaret,
      destroy,
    };
  };

  const getNormalizedTextOffset = (container, offset) => {
    let normalizedOffset = offset;
    for (
      let node = container.previousSibling;
      isText$b(node);
      node = node.previousSibling
    ) {
      normalizedOffset += node.data.length;
    }
    return normalizedOffset;
  };
  const generatePath = (dom, root, node, offset, normalized) => {
    if (isText$b(node) && (offset < 0 || offset > node.data.length)) {
      return [];
    }
    const p =
      normalized && isText$b(node)
        ? [getNormalizedTextOffset(node, offset)]
        : [offset];
    let current = node;
    while (current !== root && current.parentNode) {
      p.push(dom.nodeIndex(current, normalized));
      current = current.parentNode;
    }
    return current === root ? p.reverse() : [];
  };
  const generatePathRange = (
    dom,
    root,
    startNode,
    startOffset,
    endNode,
    endOffset,
    normalized = false
  ) => {
    const start = generatePath(dom, root, startNode, startOffset, normalized);
    const end = generatePath(dom, root, endNode, endOffset, normalized);
    return {
      start,
      end,
    };
  };
  const resolvePath = (root, path) => {
    const nodePath = path.slice();
    const offset = nodePath.pop();
    if (!isNumber(offset)) {
      return Optional.none();
    } else {
      const resolvedNode = foldl(
        nodePath,
        (optNode, index) =>
          optNode.bind((node) => Optional.from(node.childNodes[index])),
        Optional.some(root)
      );
      return resolvedNode.bind((node) => {
        if (isText$b(node) && (offset < 0 || offset > node.data.length)) {
          return Optional.none();
        } else {
          return Optional.some({
            node,
            offset,
          });
        }
      });
    }
  };
  const resolvePathRange = (root, range) =>
    resolvePath(root, range.start).bind(
      ({ node: startNode, offset: startOffset }) =>
        resolvePath(root, range.end).map(
          ({ node: endNode, offset: endOffset }) => {
            const rng = document.createRange();
            rng.setStart(startNode, startOffset);
            rng.setEnd(endNode, endOffset);
            return rng;
          }
        )
    );
  const generatePathRangeFromRange = (dom, root, range, normalized = false) =>
    generatePathRange(
      dom,
      root,
      range.startContainer,
      range.startOffset,
      range.endContainer,
      range.endOffset,
      normalized
    );

  const cleanEmptyNodes = (dom, node, isRoot) => {
    if (node && dom.isEmpty(node) && !isRoot(node)) {
      const parent = node.parentNode;
      dom.remove(
        node,
        isText$b(node.firstChild) && isWhitespaceText(node.firstChild.data)
      );
      cleanEmptyNodes(dom, parent, isRoot);
    }
  };
  const deleteRng = (dom, rng, isRoot, clean = true) => {
    const startParent = rng.startContainer.parentNode;
    const endParent = rng.endContainer.parentNode;
    rng.deleteContents();
    if (clean && !isRoot(rng.startContainer)) {
      if (
        isText$b(rng.startContainer) &&
        rng.startContainer.data.length === 0
      ) {
        dom.remove(rng.startContainer);
      }
      if (isText$b(rng.endContainer) && rng.endContainer.data.length === 0) {
        dom.remove(rng.endContainer);
      }
      cleanEmptyNodes(dom, startParent, isRoot);
      if (startParent !== endParent) {
        cleanEmptyNodes(dom, endParent, isRoot);
      }
    }
  };
  const getParentBlock = (editor, rng) =>
    Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
  const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
    const dynamicPatterns = patternSet.dynamicPatternsLookup({
      text: beforeText,
      block,
    });
    return {
      ...patternSet,
      blockPatterns: getBlockPatterns(dynamicPatterns).concat(
        patternSet.blockPatterns
      ),
      inlinePatterns: getInlinePatterns(dynamicPatterns).concat(
        patternSet.inlinePatterns
      ),
    };
  };
  const getBeforeText = (dom, block, node, offset) => {
    const rng = dom.createRng();
    rng.setStart(block, 0);
    rng.setEnd(node, offset);
    return rng.toString();
  };

  const newMarker = (dom, id) =>
    dom.create("span", {
      "data-mce-type": "bookmark",
      id,
    });
  const rangeFromMarker = (dom, marker) => {
    const rng = dom.createRng();
    rng.setStartAfter(marker.start);
    rng.setEndBefore(marker.end);
    return rng;
  };
  const createMarker = (dom, markerPrefix, pathRange) => {
    const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie(
      "Unable to resolve path range"
    );
    const startNode = rng.startContainer;
    const endNode = rng.endContainer;
    const textEnd =
      rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
    const textStart =
      rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
    const startParentNode = textStart.parentNode;
    const endParentNode = textEnd.parentNode;
    return {
      prefix: markerPrefix,
      end: endParentNode.insertBefore(
        newMarker(dom, markerPrefix + "-end"),
        textEnd
      ),
      start: startParentNode.insertBefore(
        newMarker(dom, markerPrefix + "-start"),
        textStart
      ),
    };
  };
  const removeMarker = (dom, marker, isRoot) => {
    cleanEmptyNodes(dom, dom.get(marker.prefix + "-end"), isRoot);
    cleanEmptyNodes(dom, dom.get(marker.prefix + "-start"), isRoot);
  };

  const isReplacementPattern = (pattern) => pattern.start.length === 0;
  const matchesPattern = (patternContent) => (element, offset) => {
    const text = element.data;
    const searchText = text.substring(0, offset);
    const startEndIndex = searchText.lastIndexOf(
      patternContent.charAt(patternContent.length - 1)
    );
    const startIndex = searchText.lastIndexOf(patternContent);
    if (startIndex !== -1) {
      return startIndex + patternContent.length;
    } else if (startEndIndex !== -1) {
      return startEndIndex + 1;
    } else {
      return -1;
    }
  };
  const findPatternStartFromSpot = (dom, pattern, block, spot) => {
    const startPattern = pattern.start;
    const startSpot = repeatLeft(
      dom,
      spot.container,
      spot.offset,
      matchesPattern(startPattern),
      block
    );
    return startSpot.bind((spot) => {
      var _a, _b;
      const startPatternIndex =
        (_b =
          (_a = block.textContent) === null || _a === void 0
            ? void 0
            : _a.indexOf(startPattern)) !== null && _b !== void 0
          ? _b
          : -1;
      const isCompleteMatch =
        startPatternIndex !== -1 &&
        spot.offset >= startPatternIndex + startPattern.length;
      if (isCompleteMatch) {
        const rng = dom.createRng();
        rng.setStart(spot.container, spot.offset - startPattern.length);
        rng.setEnd(spot.container, spot.offset);
        return Optional.some(rng);
      } else {
        const offset = spot.offset - startPattern.length;
        return scanLeft(spot.container, offset, block)
          .map((nextSpot) => {
            const rng = dom.createRng();
            rng.setStart(nextSpot.container, nextSpot.offset);
            rng.setEnd(spot.container, spot.offset);
            return rng;
          })
          .filter((rng) => rng.toString() === startPattern)
          .orThunk(() =>
            findPatternStartFromSpot(
              dom,
              pattern,
              block,
              point(spot.container, 0)
            )
          );
      }
    });
  };
  const findPatternStart = (
    dom,
    pattern,
    node,
    offset,
    block,
    requireGap = false
  ) => {
    if (pattern.start.length === 0 && !requireGap) {
      const rng = dom.createRng();
      rng.setStart(node, offset);
      rng.setEnd(node, offset);
      return Optional.some(rng);
    }
    return textBefore(node, offset, block).bind((spot) => {
      const start = findPatternStartFromSpot(dom, pattern, block, spot);
      return start.bind((startRange) => {
        var _a;
        if (requireGap) {
          if (
            startRange.endContainer === spot.container &&
            startRange.endOffset === spot.offset
          ) {
            return Optional.none();
          } else if (
            spot.offset === 0 &&
            ((_a = startRange.endContainer.textContent) === null ||
            _a === void 0
              ? void 0
              : _a.length) === startRange.endOffset
          ) {
            return Optional.none();
          }
        }
        return Optional.some(startRange);
      });
    });
  };
  const findPattern$3 = (editor, block, details, normalizedMatches) => {
    const dom = editor.dom;
    const root = dom.getRoot();
    const pattern = details.pattern;
    const endNode = details.position.container;
    const endOffset = details.position.offset;
    return scanLeft(
      endNode,
      endOffset - details.pattern.end.length,
      block
    ).bind((spot) => {
      const endPathRng = generatePathRange(
        dom,
        root,
        spot.container,
        spot.offset,
        endNode,
        endOffset,
        normalizedMatches
      );
      if (isReplacementPattern(pattern)) {
        return Optional.some({
          matches: [
            {
              pattern,
              startRng: endPathRng,
              endRng: endPathRng,
            },
          ],
          position: spot,
        });
      } else {
        const resultsOpt = findPatternsRec(
          editor,
          details.remainingPatterns,
          spot.container,
          spot.offset,
          block,
          normalizedMatches
        );
        const results = resultsOpt.getOr({
          matches: [],
          position: spot,
        });
        const pos = results.position;
        const start = findPatternStart(
          dom,
          pattern,
          pos.container,
          pos.offset,
          block,
          resultsOpt.isNone()
        );
        return start.map((startRng) => {
          const startPathRng = generatePathRangeFromRange(
            dom,
            root,
            startRng,
            normalizedMatches
          );
          return {
            matches: results.matches.concat([
              {
                pattern,
                startRng: startPathRng,
                endRng: endPathRng,
              },
            ]),
            position: point(startRng.startContainer, startRng.startOffset),
          };
        });
      }
    });
  };
  const findPatternsRec = (
    editor,
    patterns,
    node,
    offset,
    block,
    normalizedMatches
  ) => {
    const dom = editor.dom;
    return textBefore(node, offset, dom.getRoot()).bind((endSpot) => {
      const text = getBeforeText(dom, block, node, offset);
      for (let i = 0; i < patterns.length; i++) {
        const pattern = patterns[i];
        if (!endsWith(text, pattern.end)) {
          continue;
        }
        const patternsWithoutCurrent = patterns.slice();
        patternsWithoutCurrent.splice(i, 1);
        const result = findPattern$3(
          editor,
          block,
          {
            pattern,
            remainingPatterns: patternsWithoutCurrent,
            position: endSpot,
          },
          normalizedMatches
        );
        if (result.isNone() && offset > 0) {
          return findPatternsRec(
            editor,
            patterns,
            node,
            offset - 1,
            block,
            normalizedMatches
          );
        }
        if (result.isSome()) {
          return result;
        }
      }
      return Optional.none();
    });
  };
  const applyPattern$2 = (editor, pattern, patternRange) => {
    editor.selection.setRng(patternRange);
    if (pattern.type === "inline-format") {
      each$e(pattern.format, (format) => {
        editor.formatter.apply(format);
      });
    } else {
      editor.execCommand(pattern.cmd, false, pattern.value);
    }
  };
  const applyReplacementPattern = (editor, pattern, marker, isRoot) => {
    const markerRange = rangeFromMarker(editor.dom, marker);
    deleteRng(editor.dom, markerRange, isRoot);
    applyPattern$2(editor, pattern, markerRange);
  };
  const applyPatternWithContent = (
    editor,
    pattern,
    startMarker,
    endMarker,
    isRoot
  ) => {
    const dom = editor.dom;
    const markerEndRange = rangeFromMarker(dom, endMarker);
    const markerStartRange = rangeFromMarker(dom, startMarker);
    deleteRng(dom, markerStartRange, isRoot);
    deleteRng(dom, markerEndRange, isRoot);
    const patternMarker = {
      prefix: startMarker.prefix,
      start: startMarker.end,
      end: endMarker.start,
    };
    const patternRange = rangeFromMarker(dom, patternMarker);
    applyPattern$2(editor, pattern, patternRange);
  };
  const addMarkers = (dom, matches) => {
    const markerPrefix = generate$1("mce_textpattern");
    const matchesWithEnds = foldr(
      matches,
      (acc, match) => {
        const endMarker = createMarker(
          dom,
          markerPrefix + `_end${acc.length}`,
          match.endRng
        );
        return acc.concat([
          {
            ...match,
            endMarker,
          },
        ]);
      },
      []
    );
    return foldr(
      matchesWithEnds,
      (acc, match) => {
        const idx = matchesWithEnds.length - acc.length - 1;
        const startMarker = isReplacementPattern(match.pattern)
          ? match.endMarker
          : createMarker(dom, markerPrefix + `_start${idx}`, match.startRng);
        return acc.concat([
          {
            ...match,
            startMarker,
          },
        ]);
      },
      []
    );
  };
  const sortPatterns$1 = (patterns) =>
    sort(patterns, (a, b) => b.end.length - a.end.length);
  const getBestMatches = (matches, matchesWithSortedPatterns) => {
    const hasSameMatches = forall(matches, (match) =>
      exists(
        matchesWithSortedPatterns,
        (sortedMatch) =>
          match.pattern.start === sortedMatch.pattern.start &&
          match.pattern.end === sortedMatch.pattern.end
      )
    );
    if (matches.length === matchesWithSortedPatterns.length) {
      if (hasSameMatches) {
        return matches;
      } else {
        return matchesWithSortedPatterns;
      }
    }
    return matches.length > matchesWithSortedPatterns.length
      ? matches
      : matchesWithSortedPatterns;
  };
  const findPatterns$2 = (
    editor,
    block,
    node,
    offset,
    patternSet,
    normalizedMatches
  ) => {
    const matches = findPatternsRec(
      editor,
      patternSet.inlinePatterns,
      node,
      offset,
      block,
      normalizedMatches
    ).fold(
      () => [],
      (result) => result.matches
    );
    const matchesWithSortedPatterns = findPatternsRec(
      editor,
      sortPatterns$1(patternSet.inlinePatterns),
      node,
      offset,
      block,
      normalizedMatches
    ).fold(
      () => [],
      (result) => result.matches
    );
    return getBestMatches(matches, matchesWithSortedPatterns);
  };
  const applyMatches$2 = (editor, matches) => {
    if (matches.length === 0) {
      return;
    }
    const dom = editor.dom;
    const bookmark = editor.selection.getBookmark();
    const matchesWithMarkers = addMarkers(dom, matches);
    each$e(matchesWithMarkers, (match) => {
      const block = dom.getParent(match.startMarker.start, dom.isBlock);
      const isRoot = (node) => node === block;
      if (isReplacementPattern(match.pattern)) {
        applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);
      } else {
        applyPatternWithContent(
          editor,
          match.pattern,
          match.startMarker,
          match.endMarker,
          isRoot
        );
      }
      removeMarker(dom, match.endMarker, isRoot);
      removeMarker(dom, match.startMarker, isRoot);
    });
    editor.selection.moveToBookmark(bookmark);
  };

  const stripPattern$1 = (dom, block, pattern) => {
    return textAfter(block, 0, block).map((spot) => {
      const node = spot.container;
      scanRight(node, pattern.start.length, block).each((end) => {
        const rng = dom.createRng();
        rng.setStart(node, 0);
        rng.setEnd(end.container, end.offset);
        deleteRng(dom, rng, (e) => e === block);
      });
      return node;
    });
  };
  const createApplyPattern = (stripPattern) => (editor, match) => {
    const dom = editor.dom;
    const pattern = match.pattern;
    const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie(
      "Unable to resolve path range"
    );
    const isBlockFormatName = (name, formatter) => {
      const formatSet = formatter.get(name);
      return (
        isArray$1(formatSet) &&
        head(formatSet).exists((format) => has$2(format, "block"))
      );
    };
    getParentBlock(editor, rng).each((block) => {
      if (pattern.type === "block-format") {
        if (isBlockFormatName(pattern.format, editor.formatter)) {
          editor.undoManager.transact(() => {
            stripPattern(editor.dom, block, pattern);
            editor.formatter.apply(pattern.format);
          });
        }
      } else if (pattern.type === "block-command") {
        editor.undoManager.transact(() => {
          stripPattern(editor.dom, block, pattern);
          editor.execCommand(pattern.cmd, false, pattern.value);
        });
      }
    });
    return true;
  };
  const sortPatterns = (patterns) =>
    sort(patterns, (a, b) => b.start.length - a.start.length);
  const findPattern$2 = (predicate) => (patterns, text) => {
    const sortedPatterns = sortPatterns(patterns);
    const nuText = text.replace(nbsp, " ");
    return find$2(sortedPatterns, (pattern) =>
      predicate(pattern, text, nuText)
    );
  };
  const createFindPatterns =
    (findPattern, skipFullMatch) =>
    (editor, block, patternSet, normalizedMatches, text) => {
      var _a;
      if (text === void 0) {
        text = (_a = block.textContent) !== null && _a !== void 0 ? _a : "";
      }
      const dom = editor.dom;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!dom.is(block, forcedRootBlock)) {
        return [];
      }
      return findPattern(patternSet.blockPatterns, text)
        .map((pattern) => {
          if (
            skipFullMatch &&
            Tools.trim(text).length === pattern.start.length
          ) {
            return [];
          }
          return [
            {
              pattern,
              range: generatePathRange(
                dom,
                dom.getRoot(),
                block,
                0,
                block,
                0,
                normalizedMatches
              ),
            },
          ];
        })
        .getOr([]);
    };

  const startsWithSingleSpace = (s) => /^\s[^\s]/.test(s);
  const stripPattern = (dom, block, pattern) => {
    stripPattern$1(dom, block, pattern).each((node) => {
      const text = SugarElement.fromDom(node);
      const textContent = get$3(text);
      if (startsWithSingleSpace(textContent)) {
        set(text, textContent.slice(1));
      }
    });
  };
  const applyPattern$1 = createApplyPattern(stripPattern);
  const findPattern$1 = findPattern$2(
    (pattern, text, nuText) =>
      text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0
  );
  const findPatterns$1 = createFindPatterns(findPattern$1, true);
  const getMatches$1 = (editor, patternSet) => {
    const rng = editor.selection.getRng();
    return getParentBlock(editor, rng)
      .map((block) => {
        var _a;
        const offset = Math.max(0, rng.startOffset);
        const dynamicPatternSet = resolveFromDynamicPatterns(
          patternSet,
          block,
          (_a = block.textContent) !== null && _a !== void 0 ? _a : ""
        );
        const inlineMatches = findPatterns$2(
          editor,
          block,
          rng.startContainer,
          offset,
          dynamicPatternSet,
          true
        );
        const blockMatches = findPatterns$1(
          editor,
          block,
          dynamicPatternSet,
          true
        );
        return {
          inlineMatches,
          blockMatches,
        };
      })
      .filter(
        ({ inlineMatches, blockMatches }) =>
          blockMatches.length > 0 || inlineMatches.length > 0
      );
  };
  const applyMatches$1 = (editor, matches) => {
    if (matches.length === 0) {
      return;
    }
    const bookmark = editor.selection.getBookmark();
    each$e(matches, (match) => applyPattern$1(editor, match));
    editor.selection.moveToBookmark(bookmark);
  };

  const applyPattern = createApplyPattern(stripPattern$1);
  const findPattern = findPattern$2(
    (pattern, text, nuText) =>
      text === pattern.start || nuText === pattern.start
  );
  const findPatterns = createFindPatterns(findPattern, false);
  const getMatches = (editor, patternSet) => {
    const rng = editor.selection.getRng();
    return getParentBlock(editor, rng)
      .map((block) => {
        const offset = Math.max(0, rng.startOffset);
        const beforeText = getBeforeText(
          editor.dom,
          block,
          rng.startContainer,
          offset
        );
        const dynamicPatternSet = resolveFromDynamicPatterns(
          patternSet,
          block,
          beforeText
        );
        return findPatterns(
          editor,
          block,
          dynamicPatternSet,
          false,
          beforeText
        );
      })
      .filter((matches) => matches.length > 0);
  };
  const applyMatches = (editor, matches) => {
    each$e(matches, (match) => applyPattern(editor, match));
  };

  const handleEnter = (editor, patternSet) =>
    getMatches$1(editor, patternSet).fold(
      never,
      ({ inlineMatches, blockMatches }) => {
        editor.undoManager.add();
        editor.undoManager.extra(
          () => {
            editor.execCommand("mceInsertNewLine");
          },
          () => {
            insert$5(editor);
            applyMatches$2(editor, inlineMatches);
            applyMatches$1(editor, blockMatches);
            const range = editor.selection.getRng();
            const spot = textBefore(
              range.startContainer,
              range.startOffset,
              editor.dom.getRoot()
            );
            editor.execCommand("mceInsertNewLine");
            spot.each((s) => {
              const node = s.container;
              if (node.data.charAt(s.offset - 1) === zeroWidth) {
                node.deleteData(s.offset - 1, 1);
                cleanEmptyNodes(
                  editor.dom,
                  node.parentNode,
                  (e) => e === editor.dom.getRoot()
                );
              }
            });
          }
        );
        return true;
      }
    );
  const handleInlineKey = (editor, patternSet) => {
    const rng = editor.selection.getRng();
    getParentBlock(editor, rng).map((block) => {
      const offset = Math.max(0, rng.startOffset - 1);
      const beforeText = getBeforeText(
        editor.dom,
        block,
        rng.startContainer,
        offset
      );
      const dynamicPatternSet = resolveFromDynamicPatterns(
        patternSet,
        block,
        beforeText
      );
      const inlineMatches = findPatterns$2(
        editor,
        block,
        rng.startContainer,
        offset,
        dynamicPatternSet,
        false
      );
      if (inlineMatches.length > 0) {
        editor.undoManager.transact(() => {
          applyMatches$2(editor, inlineMatches);
        });
      }
    });
  };
  const handleBlockPatternOnSpace = (editor, patternSet) =>
    getMatches(editor, patternSet).fold(never, (matches) => {
      editor.undoManager.transact(() => {
        applyMatches(editor, matches);
      });
      return true;
    });
  const checkKeyEvent = (codes, event, predicate) => {
    for (let i = 0; i < codes.length; i++) {
      if (predicate(codes[i], event)) {
        return true;
      }
    }
    return false;
  };
  const checkKeyCode = (codes, event) =>
    checkKeyEvent(codes, event, (code, event) => {
      return code === event.keyCode && !VK.modifierPressed(event);
    });
  const checkCharCode = (chars, event) =>
    checkKeyEvent(chars, event, (chr, event) => {
      return chr.charCodeAt(0) === event.charCode;
    });

  const setup$2 = (editor) => {
    const charCodes = [",", ".", ";", ":", "!", "?"];
    const keyCodes = [32];
    const getPatternSet = () =>
      createPatternSet(
        getTextPatterns(editor).filter((pattern) => {
          if (
            pattern.type === "inline-command" ||
            pattern.type === "block-command"
          ) {
            return editor.queryCommandSupported(pattern.cmd);
          }
          return true;
        }),
        getTextPatternsLookup(editor)
      );
    const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
    editor.on(
      "keydown",
      (e) => {
        if (
          e.keyCode === 13 &&
          !VK.modifierPressed(e) &&
          editor.selection.isCollapsed() &&
          editor.selection.isEditable()
        ) {
          const patternSet = filterByTrigger(getPatternSet(), "enter");
          const hasPatterns =
            patternSet.inlinePatterns.length > 0 ||
            patternSet.blockPatterns.length > 0 ||
            hasDynamicPatterns();
          if (hasPatterns && handleEnter(editor, patternSet)) {
            e.preventDefault();
          }
        }
      },
      true
    );
    editor.on(
      "keydown",
      (e) => {
        if (
          e.keyCode === 32 &&
          editor.selection.isCollapsed() &&
          editor.selection.isEditable()
        ) {
          const patternSet = filterByTrigger(getPatternSet(), "space");
          const hasPatterns =
            patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns && handleBlockPatternOnSpace(editor, patternSet)) {
            e.preventDefault();
          }
        }
      },
      true
    );
    const handleInlineTrigger = () => {
      if (editor.selection.isCollapsed() && editor.selection.isEditable()) {
        const patternSet = filterByTrigger(getPatternSet(), "space");
        const hasPatterns =
          patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
        if (hasPatterns) {
          handleInlineKey(editor, patternSet);
        }
      }
    };
    editor.on("keyup", (e) => {
      if (checkKeyCode(keyCodes, e)) {
        handleInlineTrigger();
      }
    });
    editor.on("keypress", (e) => {
      if (checkCharCode(charCodes, e)) {
        Delay.setEditorTimeout(editor, handleInlineTrigger);
      }
    });
  };

  const setup$1 = (editor) => {
    setup$2(editor);
  };

  const Quirks = (editor) => {
    const each = Tools.each;
    const BACKSPACE = VK.BACKSPACE,
      DELETE = VK.DELETE,
      dom = editor.dom,
      selection = editor.selection,
      parser = editor.parser;
    const browser = Env.browser;
    const isGecko = browser.isFirefox();
    const isWebKit = browser.isChromium() || browser.isSafari();
    const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
    const isMac = Env.os.isMacOS() || Env.os.isiOS();
    const setEditorCommandState = (cmd, state) => {
      try {
        editor.getDoc().execCommand(cmd, false, String(state));
      } catch (_a) {}
    };
    const isDefaultPrevented = (e) => {
      return e.isDefaultPrevented();
    };
    const emptyEditorWhenDeleting = () => {
      const serializeRng = (rng) => {
        const body = dom.create("body");
        const contents = rng.cloneContents();
        body.appendChild(contents);
        return selection.serializer.serialize(body, { format: "html" });
      };
      const allContentsSelected = (rng) => {
        const selection = serializeRng(rng);
        const allRng = dom.createRng();
        allRng.selectNode(editor.getBody());
        const allSelection = serializeRng(allRng);
        return selection === allSelection;
      };
      editor.on("keydown", (e) => {
        const keyCode = e.keyCode;
        if (
          !isDefaultPrevented(e) &&
          (keyCode === DELETE || keyCode === BACKSPACE) &&
          editor.selection.isEditable()
        ) {
          const isCollapsed = editor.selection.isCollapsed();
          const body = editor.getBody();
          if (isCollapsed && !isEmptyNode(editor.schema, body)) {
            return;
          }
          if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
            return;
          }
          e.preventDefault();
          editor.setContent("");
          if (body.firstChild && dom.isBlock(body.firstChild)) {
            editor.selection.setCursorLocation(body.firstChild, 0);
          } else {
            editor.selection.setCursorLocation(body, 0);
          }
          editor.nodeChanged();
        }
      });
    };
    const selectAll = () => {
      editor.shortcuts.add("meta+a", null, "SelectAll");
    };
    const documentElementEditingFocus = () => {
      if (!editor.inline) {
        dom.bind(editor.getDoc(), "mousedown mouseup", (e) => {
          let rng;
          if (e.target === editor.getDoc().documentElement) {
            rng = selection.getRng();
            editor.getBody().focus();
            if (e.type === "mousedown") {
              if (isCaretContainer$2(rng.startContainer)) {
                return;
              }
              selection.placeCaretAt(e.clientX, e.clientY);
            } else {
              selection.setRng(rng);
            }
          }
        });
      }
    };
    const removeHrOnBackspace = () => {
      editor.on("keydown", (e) => {
        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
          if (!editor.getBody().getElementsByTagName("hr").length) {
            return;
          }
          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
            const node = selection.getNode();
            const previousSibling = node.previousSibling;
            if (node.nodeName === "HR") {
              dom.remove(node);
              e.preventDefault();
              return;
            }
            if (
              previousSibling &&
              previousSibling.nodeName &&
              previousSibling.nodeName.toLowerCase() === "hr"
            ) {
              dom.remove(previousSibling);
              e.preventDefault();
            }
          }
        }
      });
    };
    const focusBody = () => {
      if (!Range.prototype.getClientRects) {
        editor.on("mousedown", (e) => {
          if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
            const body = editor.getBody();
            body.blur();
            Delay.setEditorTimeout(editor, () => {
              body.focus();
            });
          }
        });
      }
    };
    const selectControlElements = () => {
      const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
      editor.on("click", (e) => {
        const target = e.target;
        if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {
          e.preventDefault();
          editor.selection.select(target);
          editor.nodeChanged();
        }
        if (
          target.nodeName === "A" &&
          dom.hasClass(target, visualAidsAnchorClass) &&
          target.childNodes.length === 0 &&
          dom.isEditable(target.parentNode)
        ) {
          e.preventDefault();
          selection.select(target);
        }
      });
    };
    const removeStylesWhenDeletingAcrossBlockElements = () => {
      const getAttributeApplyFunction = () => {
        const template = dom.getAttribs(selection.getStart().cloneNode(false));
        return () => {
          const target = selection.getStart();
          if (target !== editor.getBody()) {
            dom.setAttrib(target, "style", null);
            each(template, (attr) => {
              target.setAttributeNode(attr.cloneNode(true));
            });
          }
        };
      };
      const isSelectionAcrossElements = () => {
        return (
          !selection.isCollapsed() &&
          dom.getParent(selection.getStart(), dom.isBlock) !==
            dom.getParent(selection.getEnd(), dom.isBlock)
        );
      };
      editor.on("keypress", (e) => {
        let applyAttributes;
        if (
          !isDefaultPrevented(e) &&
          (e.keyCode === 8 || e.keyCode === 46) &&
          isSelectionAcrossElements()
        ) {
          applyAttributes = getAttributeApplyFunction();
          editor.getDoc().execCommand("delete", false);
          applyAttributes();
          e.preventDefault();
          return false;
        } else {
          return true;
        }
      });
      dom.bind(editor.getDoc(), "cut", (e) => {
        if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
          const applyAttributes = getAttributeApplyFunction();
          Delay.setEditorTimeout(editor, () => {
            applyAttributes();
          });
        }
      });
    };
    const disableBackspaceIntoATable = () => {
      editor.on("keydown", (e) => {
        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
            const previousSibling = selection.getNode().previousSibling;
            if (
              previousSibling &&
              previousSibling.nodeName &&
              previousSibling.nodeName.toLowerCase() === "table"
            ) {
              e.preventDefault();
              return false;
            }
          }
        }
        return true;
      });
    };
    const removeBlockQuoteOnBackSpace = () => {
      editor.on("keydown", (e) => {
        if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
          return;
        }
        let rng = selection.getRng();
        const container = rng.startContainer;
        const offset = rng.startOffset;
        const root = dom.getRoot();
        let parent = container;
        if (!rng.collapsed || offset !== 0) {
          return;
        }
        while (
          parent.parentNode &&
          parent.parentNode.firstChild === parent &&
          parent.parentNode !== root
        ) {
          parent = parent.parentNode;
        }
        if (parent.nodeName === "BLOCKQUOTE") {
          editor.formatter.toggle("blockquote", undefined, parent);
          rng = dom.createRng();
          rng.setStart(container, 0);
          rng.setEnd(container, 0);
          selection.setRng(rng);
        }
      });
    };
    const setGeckoEditingOptions = () => {
      const setOpts = () => {
        setEditorCommandState("StyleWithCSS", false);
        setEditorCommandState("enableInlineTableEditing", false);
        if (!getObjectResizing(editor)) {
          setEditorCommandState("enableObjectResizing", false);
        }
      };
      if (!isReadOnly$1(editor)) {
        editor.on("BeforeExecCommand mousedown", setOpts);
      }
    };
    const addBrAfterLastLinks = () => {
      const fixLinks = () => {
        each(dom.select("a:not([data-mce-block])"), (node) => {
          var _a;
          let parentNode = node.parentNode;
          const root = dom.getRoot();
          if (
            (parentNode === null || parentNode === void 0
              ? void 0
              : parentNode.lastChild) === node
          ) {
            while (parentNode && !dom.isBlock(parentNode)) {
              if (
                ((_a = parentNode.parentNode) === null || _a === void 0
                  ? void 0
                  : _a.lastChild) !== parentNode ||
                parentNode === root
              ) {
                return;
              }
              parentNode = parentNode.parentNode;
            }
            dom.add(parentNode, "br", { "data-mce-bogus": 1 });
          }
        });
      };
      editor.on("SetContent ExecCommand", (e) => {
        if (e.type === "setcontent" || e.command === "mceInsertLink") {
          fixLinks();
        }
      });
    };
    const setDefaultBlockType = () => {
      editor.on("init", () => {
        setEditorCommandState(
          "DefaultParagraphSeparator",
          getForcedRootBlock(editor)
        );
      });
    };
    const isAllContentSelected = (editor) => {
      const body = editor.getBody();
      const rng = editor.selection.getRng();
      return (
        rng.startContainer === rng.endContainer &&
        rng.startContainer === body &&
        rng.startOffset === 0 &&
        rng.endOffset === body.childNodes.length
      );
    };
    const normalizeSelection = () => {
      editor.on(
        "keyup focusin mouseup",
        (e) => {
          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {
            selection.normalize();
          }
        },
        true
      );
    };
    const showBrokenImageIcon = () => {
      editor.contentStyles.push(
        "img:-moz-broken {" +
          "-moz-force-broken-image-icon:1;" +
          "min-width:24px;" +
          "min-height:24px" +
          "}"
      );
    };
    const restoreFocusOnKeyDown = () => {
      if (!editor.inline) {
        editor.on("keydown", () => {
          if (document.activeElement === document.body) {
            editor.getWin().focus();
          }
        });
      }
    };
    const bodyHeight = () => {
      if (!editor.inline) {
        editor.contentStyles.push("body {min-height: 150px}");
        editor.on("click", (e) => {
          let rng;
          if (e.target.nodeName === "HTML") {
            rng = editor.selection.getRng();
            editor.getBody().focus();
            editor.selection.setRng(rng);
            editor.selection.normalize();
            editor.nodeChanged();
          }
        });
      }
    };
    const blockCmdArrowNavigation = () => {
      if (isMac) {
        editor.on("keydown", (e) => {
          if (
            VK.metaKeyPressed(e) &&
            !e.shiftKey &&
            (e.keyCode === 37 || e.keyCode === 39)
          ) {
            e.preventDefault();
            const selection = editor.selection.getSel();
            selection.modify(
              "move",
              e.keyCode === 37 ? "backward" : "forward",
              "lineboundary"
            );
          }
        });
      }
    };
    const tapLinksAndImages = () => {
      editor.on("click", (e) => {
        let elm = e.target;
        do {
          if (elm.tagName === "A") {
            e.preventDefault();
            return;
          }
        } while ((elm = elm.parentNode));
      });
      editor.contentStyles.push(
        ".mce-content-body {-webkit-touch-callout: none}"
      );
    };
    const blockFormSubmitInsideEditor = () => {
      editor.on("init", () => {
        editor.dom.bind(editor.getBody(), "submit", (e) => {
          e.preventDefault();
        });
      });
    };
    const removeAppleInterchangeBrs = () => {
      parser.addNodeFilter("br", (nodes) => {
        let i = nodes.length;
        while (i--) {
          if (nodes[i].attr("class") === "Apple-interchange-newline") {
            nodes[i].remove();
          }
        }
      });
    };
    const refreshContentEditable = noop;
    const isHidden = () => {
      if (!isGecko || editor.removed) {
        return false;
      }
      const sel = editor.selection.getSel();
      return !sel || !sel.rangeCount || sel.rangeCount === 0;
    };
    const setupRtc = () => {
      if (isWebKit) {
        documentElementEditingFocus();
        selectControlElements();
        blockFormSubmitInsideEditor();
        selectAll();
        if (isiOS) {
          restoreFocusOnKeyDown();
          bodyHeight();
          tapLinksAndImages();
        }
      }
      if (isGecko) {
        focusBody();
        setGeckoEditingOptions();
        showBrokenImageIcon();
        blockCmdArrowNavigation();
      }
    };
    const setup = () => {
      removeBlockQuoteOnBackSpace();
      emptyEditorWhenDeleting();
      if (!Env.windowsPhone) {
        normalizeSelection();
      }
      if (isWebKit) {
        documentElementEditingFocus();
        selectControlElements();
        setDefaultBlockType();
        blockFormSubmitInsideEditor();
        disableBackspaceIntoATable();
        removeAppleInterchangeBrs();
        if (isiOS) {
          restoreFocusOnKeyDown();
          bodyHeight();
          tapLinksAndImages();
        } else {
          selectAll();
        }
      }
      if (isGecko) {
        removeHrOnBackspace();
        focusBody();
        removeStylesWhenDeletingAcrossBlockElements();
        setGeckoEditingOptions();
        addBrAfterLastLinks();
        showBrokenImageIcon();
        blockCmdArrowNavigation();
        disableBackspaceIntoATable();
      }
    };
    if (isRtc(editor)) {
      setupRtc();
    } else {
      setup();
    }
    return {
      refreshContentEditable,
      isHidden,
    };
  };

  const isGplKey = (key) => key.toLowerCase() === "gpl";
  const isValidGeneratedKey = (key) => key.length >= 64 && key.length <= 255;
  const validateLicenseKey = (key) =>
    isGplKey(key) || isValidGeneratedKey(key) ? "VALID" : "INVALID";
  const validateEditorLicenseKey = (editor) => {
    const licenseKey = getLicenseKey(editor);
    const hasApiKey = isString(getApiKey(editor));
    if (
      !hasApiKey &&
      (isUndefined(licenseKey) || validateLicenseKey(licenseKey) === "INVALID")
    ) {
      console.warn(
        `TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/`
      );
    }
  };

  const DOM$6 = DOMUtils.DOM;
  const appendStyle = (editor, text) => {
    const body = SugarElement.fromDom(editor.getBody());
    const container = getStyleContainer(getRootNode(body));
    const style = SugarElement.fromTag("style");
    set$4(style, "type", "text/css");
    append$1(style, SugarElement.fromText(text));
    append$1(container, style);
    editor.on("remove", () => {
      remove$4(style);
    });
  };
  const getRootName = (editor) =>
    editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;
  const removeUndefined = (obj) =>
    filter$4(obj, (v) => isUndefined(v) === false);
  const mkParserSettings = (editor) => {
    const getOption = editor.options.get;
    const blobCache = editor.editorUpload.blobCache;
    return removeUndefined({
      allow_conditional_comments: getOption("allow_conditional_comments"),
      allow_html_data_urls: getOption("allow_html_data_urls"),
      allow_svg_data_urls: getOption("allow_svg_data_urls"),
      allow_html_in_named_anchor: getOption("allow_html_in_named_anchor"),
      allow_script_urls: getOption("allow_script_urls"),
      allow_mathml_annotation_encodings: getOption(
        "allow_mathml_annotation_encodings"
      ),
      allow_unsafe_link_target: getOption("allow_unsafe_link_target"),
      convert_unsafe_embeds: getOption("convert_unsafe_embeds"),
      convert_fonts_to_spans: getOption("convert_fonts_to_spans"),
      fix_list_elements: getOption("fix_list_elements"),
      font_size_legacy_values: getOption("font_size_legacy_values"),
      forced_root_block: getOption("forced_root_block"),
      forced_root_block_attrs: getOption("forced_root_block_attrs"),
      preserve_cdata: getOption("preserve_cdata"),
      inline_styles: getOption("inline_styles"),
      root_name: getRootName(editor),
      sandbox_iframes: getOption("sandbox_iframes"),
      sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
      sanitize: getOption("xss_sanitization"),
      validate: true,
      blob_cache: blobCache,
      document: editor.getDoc(),
    });
  };
  const mkSchemaSettings = (editor) => {
    const getOption = editor.options.get;
    return removeUndefined({
      custom_elements: getOption("custom_elements"),
      extended_valid_elements: getOption("extended_valid_elements"),
      invalid_elements: getOption("invalid_elements"),
      invalid_styles: getOption("invalid_styles"),
      schema: getOption("schema"),
      valid_children: getOption("valid_children"),
      valid_classes: getOption("valid_classes"),
      valid_elements: getOption("valid_elements"),
      valid_styles: getOption("valid_styles"),
      verify_html: getOption("verify_html"),
      padd_empty_block_inline_children: getOption("format_empty_lines"),
    });
  };
  const mkSerializerSettings = (editor) => {
    const getOption = editor.options.get;
    return {
      ...mkParserSettings(editor),
      ...mkSchemaSettings(editor),
      ...removeUndefined({
        remove_trailing_brs: getOption("remove_trailing_brs"),
        pad_empty_with_br: getOption("pad_empty_with_br"),
        url_converter: getOption("url_converter"),
        url_converter_scope: getOption("url_converter_scope"),
        element_format: getOption("element_format"),
        entities: getOption("entities"),
        entity_encoding: getOption("entity_encoding"),
        indent: getOption("indent"),
        indent_after: getOption("indent_after"),
        indent_before: getOption("indent_before"),
      }),
    };
  };
  const createParser = (editor) => {
    const parser = DomParser(mkParserSettings(editor), editor.schema);
    parser.addAttributeFilter("src,href,style,tabindex", (nodes, name) => {
      const dom = editor.dom;
      const internalName = "data-mce-" + name;
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        let value = node.attr(name);
        if (value && !node.attr(internalName)) {
          if (value.indexOf("data:") === 0 || value.indexOf("blob:") === 0) {
            continue;
          }
          if (name === "style") {
            value = dom.serializeStyle(dom.parseStyle(value), node.name);
            if (!value.length) {
              value = null;
            }
            node.attr(internalName, value);
            node.attr(name, value);
          } else if (name === "tabindex") {
            node.attr(internalName, value);
            node.attr(name, null);
          } else {
            node.attr(internalName, editor.convertURL(value, name, node.name));
          }
        }
      }
    });
    parser.addNodeFilter("script", (nodes) => {
      let i = nodes.length;
      while (i--) {
        const node = nodes[i];
        const type = node.attr("type") || "no/type";
        if (type.indexOf("mce-") !== 0) {
          node.attr("type", "mce-" + type);
        }
      }
    });
    if (shouldPreserveCData(editor)) {
      parser.addNodeFilter("#cdata", (nodes) => {
        var _a;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          node.type = 8;
          node.name = "#comment";
          node.value =
            "[CDATA[" +
            editor.dom.encode(
              (_a = node.value) !== null && _a !== void 0 ? _a : ""
            ) +
            "]]";
        }
      });
    }
    parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (nodes) => {
      let i = nodes.length;
      const nonEmptyElements = editor.schema.getNonEmptyElements();
      while (i--) {
        const node = nodes[i];
        if (node.isEmpty(nonEmptyElements) && node.getAll("br").length === 0) {
          node.append(new AstNode("br", 1));
        }
      }
    });
    return parser;
  };
  const autoFocus = (editor) => {
    const autoFocus = getAutoFocus(editor);
    if (autoFocus) {
      Delay.setEditorTimeout(
        editor,
        () => {
          let focusEditor;
          if (autoFocus === true) {
            focusEditor = editor;
          } else {
            focusEditor = editor.editorManager.get(autoFocus);
          }
          if (focusEditor && !focusEditor.destroyed) {
            focusEditor.focus();
            focusEditor.selection.scrollIntoView();
          }
        },
        100
      );
    }
  };
  const moveSelectionToFirstCaretPosition = (editor) => {
    const root = editor.dom.getRoot();
    if (
      !editor.inline &&
      (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)
    ) {
      firstPositionIn(root).each((pos) => {
        const node = pos.getNode();
        const caretPos = isTable$2(node)
          ? firstPositionIn(node).getOr(pos)
          : pos;
        editor.selection.setRng(caretPos.toRange());
      });
    }
  };
  const initEditor = (editor) => {
    editor.bindPendingEventDelegates();
    editor.initialized = true;
    fireInit(editor);
    editor.focus(true);
    moveSelectionToFirstCaretPosition(editor);
    editor.nodeChanged({ initial: true });
    const initInstanceCallback = getInitInstanceCallback(editor);
    if (isFunction(initInstanceCallback)) {
      initInstanceCallback.call(editor, editor);
    }
    autoFocus(editor);
    if (isDisabled(editor)) {
      toggleDisabled(editor, true);
    }
  };
  const getStyleSheetLoader$1 = (editor) =>
    editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
  const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
    const { pass: bundledCss, fail: normalCss } = partition$2(css, (name) =>
      tinymce.Resource.has(toContentSkinResourceName(name))
    );
    const bundledPromises = bundledCss.map((url) => {
      const css = tinymce.Resource.get(toContentSkinResourceName(url));
      if (isString(css)) {
        return Promise.resolve(
          getStyleSheetLoader$1(editor).loadRawCss(url, css)
        );
      }
      return Promise.resolve();
    });
    const promises = [
      ...bundledPromises,
      getStyleSheetLoader$1(editor).loadAll(normalCss),
    ];
    if (editor.inline) {
      return promises;
    } else {
      return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);
    }
  };
  const loadContentCss = (editor) => {
    const styleSheetLoader = getStyleSheetLoader$1(editor);
    const fontCss = getFontCss(editor);
    const css = editor.contentCSS;
    const removeCss = () => {
      styleSheetLoader.unloadAll(css);
      if (!editor.inline) {
        editor.ui.styleSheetLoader.unloadAll(fontCss);
      }
    };
    const loaded = () => {
      if (editor.removed) {
        removeCss();
      } else {
        editor.on("remove", removeCss);
      }
    };
    if (editor.contentStyles.length > 0) {
      let contentCssText = "";
      Tools.each(editor.contentStyles, (style) => {
        contentCssText += style + "\r\n";
      });
      editor.dom.addStyle(contentCssText);
    }
    const allStylesheets = Promise.all(
      makeStylesheetLoadingPromises(editor, css, fontCss)
    )
      .then(loaded)
      .catch(loaded);
    const contentStyle = getContentStyle(editor);
    if (contentStyle) {
      appendStyle(editor, contentStyle);
    }
    return allStylesheets;
  };
  const preInit = (editor) => {
    const doc = editor.getDoc(),
      body = editor.getBody();
    firePreInit(editor);
    if (!shouldBrowserSpellcheck(editor)) {
      doc.body.spellcheck = false;
      DOM$6.setAttrib(body, "spellcheck", "false");
    }
    editor.quirks = Quirks(editor);
    firePostRender(editor);
    const directionality = getDirectionality(editor);
    if (directionality !== undefined) {
      body.dir = directionality;
    }
    const protect = getProtect(editor);
    if (protect) {
      editor.on("BeforeSetContent", (e) => {
        Tools.each(protect, (pattern) => {
          e.content = e.content.replace(pattern, (str) => {
            return "<!--mce:protected " + escape(str) + "-->";
          });
        });
      });
    }
    editor.on("SetContent", () => {
      editor.addVisual(editor.getBody());
    });
    editor.on("compositionstart compositionend", (e) => {
      editor.composing = e.type === "compositionstart";
    });
  };
  const loadInitialContent = (editor) => {
    if (!isRtc(editor)) {
      editor.load({
        initial: true,
        format: "html",
      });
    }
    editor.startContent = editor.getContent({ format: "raw" });
  };
  const initEditorWithInitialContent = (editor) => {
    if (editor.removed !== true) {
      loadInitialContent(editor);
      initEditor(editor);
    }
  };
  const startProgress = (editor) => {
    let canceled = false;
    const progressTimeout = setTimeout(() => {
      if (!canceled) {
        editor.setProgressState(true);
      }
    }, 500);
    return () => {
      clearTimeout(progressTimeout);
      canceled = true;
      editor.setProgressState(false);
    };
  };
  const contentBodyLoaded = (editor) => {
    const targetElm = editor.getElement();
    let doc = editor.getDoc();
    if (editor.inline) {
      DOM$6.addClass(targetElm, "mce-content-body");
      editor.contentDocument = doc = document;
      editor.contentWindow = window;
      editor.bodyElement = targetElm;
      editor.contentAreaContainer = targetElm;
    }
    const body = editor.getBody();
    body.disabled = true;
    editor.readonly = isReadOnly$1(editor);
    editor._editableRoot = hasEditableRoot$1(editor);
    if (!isDisabled$1(editor) && editor.hasEditableRoot()) {
      if (
        editor.inline &&
        DOM$6.getStyle(body, "position", true) === "static"
      ) {
        body.style.position = "relative";
      }
      body.contentEditable = "true";
    }
    body.disabled = false;
    editor.editorUpload = EditorUpload(editor);
    editor.schema = Schema(mkSchemaSettings(editor));
    editor.dom = DOMUtils(doc, {
      keep_values: true,
      url_converter: editor.convertURL,
      url_converter_scope: editor,
      update_styles: true,
      root_element: editor.inline ? editor.getBody() : null,
      collect: editor.inline,
      schema: editor.schema,
      contentCssCors: shouldUseContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor),
      onSetAttrib: (e) => {
        editor.dispatch("SetAttrib", e);
      },
    });
    editor.parser = createParser(editor);
    editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
    editor.selection = EditorSelection(
      editor.dom,
      editor.getWin(),
      editor.serializer,
      editor
    );
    editor.annotator = Annotator(editor);
    editor.formatter = Formatter(editor);
    editor.undoManager = UndoManager(editor);
    editor._nodeChangeDispatcher = new NodeChange(editor);
    editor._selectionOverrides = SelectionOverrides(editor);
    setup$p(editor);
    setup$6(editor);
    setup$n(editor);
    if (!isRtc(editor)) {
      setup$5(editor);
      setup$1(editor);
    }
    const caret = setup$b(editor);
    setup$q(editor, caret);
    setup$o(editor);
    setup$r(editor);
    setup$7(editor);
    const setupRtcThunk = setup$t(editor);
    preInit(editor);
    validateEditorLicenseKey(editor);
    setupRtcThunk.fold(
      () => {
        const cancelProgress = startProgress(editor);
        loadContentCss(editor).then(() => {
          initEditorWithInitialContent(editor);
          cancelProgress();
        });
      },
      (setupRtc) => {
        editor.setProgressState(true);
        loadContentCss(editor).then(() => {
          setupRtc().then(
            (_rtcMode) => {
              editor.setProgressState(false);
              initEditorWithInitialContent(editor);
              bindEvents(editor);
            },
            (err) => {
              editor.notificationManager.open({
                type: "error",
                text: String(err),
              });
              initEditorWithInitialContent(editor);
              bindEvents(editor);
            }
          );
        });
      }
    );
  };

  const filter = always;
  const bind = (element, event, handler) =>
    bind$2(element, event, filter, handler);

  const DOM$5 = DOMUtils.DOM;
  const createIframeElement = (id, title, customAttrs, tabindex) => {
    const iframe = SugarElement.fromTag("iframe");
    tabindex.each((t) => set$4(iframe, "tabindex", t));
    setAll$1(iframe, customAttrs);
    setAll$1(iframe, {
      id: id + "_ifr",
      frameBorder: "0",
      allowTransparency: "true",
      title,
    });
    add$2(iframe, "tox-edit-area__iframe");
    return iframe;
  };
  const getIframeHtml = (editor) => {
    let iframeHTML = getDocType(editor) + "<html><head>";
    if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
      iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
    }
    iframeHTML +=
      '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
    const bodyId = getBodyId(editor);
    const bodyClass = getBodyClass(editor);
    const translatedAriaText = editor.translate(getIframeAriaText(editor));
    if (getContentSecurityPolicy(editor)) {
      iframeHTML +=
        '<meta http-equiv="Content-Security-Policy" content="' +
        getContentSecurityPolicy(editor) +
        '" />';
    }
    iframeHTML +=
      "</head>" +
      `<body id="${bodyId}" class="mce-content-body ${bodyClass}" data-id="${editor.id}" aria-label="${translatedAriaText}">` +
      "<br>" +
      "</body></html>";
    return iframeHTML;
  };
  const createIframe = (editor, boxInfo) => {
    const iframeTitle = Env.browser.isFirefox()
      ? getIframeAriaText(editor)
      : "Rich Text Area";
    const translatedTitle = editor.translate(iframeTitle);
    const tabindex = getOpt(
      SugarElement.fromDom(editor.getElement()),
      "tabindex"
    ).bind(toInt);
    const ifr = createIframeElement(
      editor.id,
      translatedTitle,
      getIframeAttrs(editor),
      tabindex
    ).dom;
    ifr.onload = () => {
      ifr.onload = null;
      editor.dispatch("load");
    };
    editor.contentAreaContainer = boxInfo.iframeContainer;
    editor.iframeElement = ifr;
    editor.iframeHTML = getIframeHtml(editor);
    DOM$5.add(boxInfo.iframeContainer, ifr);
  };
  const setupIframeBody = (editor) => {
    const iframe = editor.iframeElement;
    const ready = () => {
      editor.contentDocument = iframe.contentDocument;
      contentBodyLoaded(editor);
    };
    if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {
      const doc = editor.getDoc();
      doc.open();
      doc.write(editor.iframeHTML);
      doc.close();
      ready();
    } else {
      const binder = bind(SugarElement.fromDom(iframe), "load", () => {
        binder.unbind();
        ready();
      });
      iframe.srcdoc = editor.iframeHTML;
    }
  };
  const init$1 = (editor, boxInfo) => {
    createIframe(editor, boxInfo);
    if (boxInfo.editorContainer) {
      boxInfo.editorContainer.style.display = editor.orgDisplay;
      editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
    }
    editor.getElement().style.display = "none";
    DOM$5.setAttrib(editor.id, "aria-hidden", "true");
    editor.getElement().style.visibility = editor.orgVisibility;
    setupIframeBody(editor);
  };

  const DOM$4 = DOMUtils.DOM;
  const initPlugin = (editor, initializedPlugins, plugin) => {
    const Plugin = PluginManager.get(plugin);
    const pluginUrl =
      PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, "");
    plugin = Tools.trim(plugin);
    if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
      if (editor.plugins[plugin]) {
        return;
      }
      try {
        const pluginInstance = Plugin(editor, pluginUrl) || {};
        editor.plugins[plugin] = pluginInstance;
        if (isFunction(pluginInstance.init)) {
          pluginInstance.init(editor, pluginUrl);
          initializedPlugins.push(plugin);
        }
      } catch (e) {
        pluginInitError(editor, plugin, e);
      }
    }
  };
  const trimLegacyPrefix = (name) => {
    return name.replace(/^\-/, "");
  };
  const initPlugins = (editor) => {
    const initializedPlugins = [];
    each$e(getPlugins(editor), (name) => {
      initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
    });
  };
  const initIcons = (editor) => {
    const iconPackName = Tools.trim(getIconPackName(editor));
    const currentIcons = editor.ui.registry.getAll().icons;
    const loadIcons = {
      ...IconManager.get("default").icons,
      ...IconManager.get(iconPackName).icons,
    };
    each$d(loadIcons, (svgData, icon) => {
      if (!has$2(currentIcons, icon)) {
        editor.ui.registry.addIcon(icon, svgData);
      }
    });
  };
  const initTheme = (editor) => {
    const theme = getTheme(editor);
    if (isString(theme)) {
      const Theme = ThemeManager.get(theme);
      editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
      if (isFunction(editor.theme.init)) {
        editor.theme.init(
          editor,
          ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, "")
        );
      }
    } else {
      editor.theme = {};
    }
  };
  const initModel = (editor) => {
    const model = getModel(editor);
    const Model = ModelManager.get(model);
    editor.model = Model(editor, ModelManager.urls[model]);
  };
  const renderFromLoadedTheme = (editor) => {
    const render = editor.theme.renderUI;
    return render ? render() : renderThemeFalse(editor);
  };
  const renderFromThemeFunc = (editor) => {
    const elm = editor.getElement();
    const theme = getTheme(editor);
    const info = theme(editor, elm);
    if (info.editorContainer.nodeType) {
      info.editorContainer.id =
        info.editorContainer.id || editor.id + "_parent";
    }
    if (info.iframeContainer && info.iframeContainer.nodeType) {
      info.iframeContainer.id =
        info.iframeContainer.id || editor.id + "_iframecontainer";
    }
    info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
    return info;
  };
  const createThemeFalseResult = (element, iframe) => {
    return {
      editorContainer: element,
      iframeContainer: iframe,
      api: {},
    };
  };
  const renderThemeFalseIframe = (targetElement) => {
    const iframeContainer = DOM$4.create("div");
    DOM$4.insertAfter(iframeContainer, targetElement);
    return createThemeFalseResult(iframeContainer, iframeContainer);
  };
  const renderThemeFalse = (editor) => {
    const targetElement = editor.getElement();
    return editor.inline
      ? createThemeFalseResult(null)
      : renderThemeFalseIframe(targetElement);
  };
  const renderThemeUi = (editor) => {
    const elm = editor.getElement();
    editor.orgDisplay = elm.style.display;
    if (isString(getTheme(editor))) {
      return renderFromLoadedTheme(editor);
    } else if (isFunction(getTheme(editor))) {
      return renderFromThemeFunc(editor);
    } else {
      return renderThemeFalse(editor);
    }
  };
  const augmentEditorUiApi = (editor, api) => {
    const uiApiFacade = {
      show: Optional.from(api.show).getOr(noop),
      hide: Optional.from(api.hide).getOr(noop),
      isEnabled: Optional.from(api.isEnabled).getOr(always),
      setEnabled: (state) => {
        const shouldSkip =
          state && (editor.mode.get() === "readonly" || isDisabled(editor));
        if (!shouldSkip) {
          Optional.from(api.setEnabled).each((f) => f(state));
        }
      },
    };
    editor.ui = {
      ...editor.ui,
      ...uiApiFacade,
    };
  };
  const init = async (editor) => {
    editor.dispatch("ScriptsLoaded");
    initIcons(editor);
    initTheme(editor);
    initModel(editor);
    initPlugins(editor);
    const renderInfo = await renderThemeUi(editor);
    augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
    editor.editorContainer = renderInfo.editorContainer;
    appendContentCssFromSettings(editor);
    if (editor.inline) {
      contentBodyLoaded(editor);
    } else {
      init$1(editor, {
        editorContainer: renderInfo.editorContainer,
        iframeContainer: renderInfo.iframeContainer,
      });
    }
  };

  const DOM$3 = DOMUtils.DOM;
  const hasSkipLoadPrefix = (name) => name.charAt(0) === "-";
  const loadLanguage = (scriptLoader, editor) => {
    const languageCode = getLanguageCode(editor);
    const languageUrl = getLanguageUrl(editor);
    if (!I18n.hasCode(languageCode) && languageCode !== "en") {
      const url = isNotEmpty(languageUrl)
        ? languageUrl
        : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;
      scriptLoader.add(url).catch(() => {
        languageLoadError(editor, url, languageCode);
      });
    }
  };
  const loadTheme = (editor, suffix) => {
    const theme = getTheme(editor);
    if (
      isString(theme) &&
      !hasSkipLoadPrefix(theme) &&
      !has$2(ThemeManager.urls, theme)
    ) {
      const themeUrl = getThemeUrl(editor);
      const url = themeUrl
        ? editor.documentBaseURI.toAbsolute(themeUrl)
        : `themes/${theme}/theme${suffix}.js`;
      ThemeManager.load(theme, url).catch(() => {
        themeLoadError(editor, url, theme);
      });
    }
  };
  const loadModel = (editor, suffix) => {
    const model = getModel(editor);
    if (model !== "plugin" && !has$2(ModelManager.urls, model)) {
      const modelUrl = getModelUrl(editor);
      const url = isString(modelUrl)
        ? editor.documentBaseURI.toAbsolute(modelUrl)
        : `models/${model}/model${suffix}.js`;
      ModelManager.load(model, url).catch(() => {
        modelLoadError(editor, url, model);
      });
    }
  };
  const getIconsUrlMetaFromUrl = (editor) =>
    Optional.from(getIconsUrl(editor))
      .filter(isNotEmpty)
      .map((url) => ({
        url,
        name: Optional.none(),
      }));
  const getIconsUrlMetaFromName = (editor, name, suffix) =>
    Optional.from(name)
      .filter((name) => isNotEmpty(name) && !IconManager.has(name))
      .map((name) => ({
        url: `${editor.editorManager.baseURL}/icons/${name}/icons${suffix}.js`,
        name: Optional.some(name),
      }));
  const loadIcons = (scriptLoader, editor, suffix) => {
    const defaultIconsUrl = getIconsUrlMetaFromName(editor, "default", suffix);
    const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() =>
      getIconsUrlMetaFromName(editor, getIconPackName(editor), "")
    );
    each$e(cat([defaultIconsUrl, customIconsUrl]), (urlMeta) => {
      scriptLoader.add(urlMeta.url).catch(() => {
        iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
      });
    });
  };
  const loadPlugins = (editor, suffix) => {
    const loadPlugin = (name, url) => {
      PluginManager.load(name, url).catch(() => {
        pluginLoadError(editor, url, name);
      });
    };
    each$d(getExternalPlugins$1(editor), (url, name) => {
      loadPlugin(name, url);
      editor.options.set("plugins", getPlugins(editor).concat(name));
    });
    each$e(getPlugins(editor), (plugin) => {
      plugin = Tools.trim(plugin);
      if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {
        loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);
      }
    });
  };
  const isThemeLoaded = (editor) => {
    const theme = getTheme(editor);
    return !isString(theme) || isNonNullable(ThemeManager.get(theme));
  };
  const isModelLoaded = (editor) => {
    const model = getModel(editor);
    return isNonNullable(ModelManager.get(model));
  };
  const loadScripts = (editor, suffix) => {
    const scriptLoader = ScriptLoader.ScriptLoader;
    const initEditor = () => {
      if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {
        init(editor);
      }
    };
    loadTheme(editor, suffix);
    loadModel(editor, suffix);
    loadLanguage(scriptLoader, editor);
    loadIcons(scriptLoader, editor, suffix);
    loadPlugins(editor, suffix);
    scriptLoader.loadQueue().then(initEditor, initEditor);
  };
  const getStyleSheetLoader = (element, editor) =>
    instance.forElement(element, {
      contentCssCors: hasContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor),
    });
  const render = (editor) => {
    const id = editor.id;
    I18n.setCode(getLanguageCode(editor));
    const readyHandler = () => {
      DOM$3.unbind(window, "ready", readyHandler);
      editor.render();
    };
    if (!EventUtils.Event.domLoaded) {
      DOM$3.bind(window, "ready", readyHandler);
      return;
    }
    if (!editor.getElement()) {
      return;
    }
    const element = SugarElement.fromDom(editor.getElement());
    const snapshot = clone$4(element);
    editor.on("remove", () => {
      eachr(element.dom.attributes, (attr) => remove$9(element, attr.name));
      setAll$1(element, snapshot);
    });
    editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
    if (!isInline$1(editor)) {
      editor.orgVisibility = editor.getElement().style.visibility;
      editor.getElement().style.visibility = "hidden";
    } else {
      editor.inline = true;
    }
    const form = editor.getElement().form || DOM$3.getParent(id, "form");
    if (form) {
      editor.formElement = form;
      if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
        DOM$3.insertAfter(
          DOM$3.create("input", {
            type: "hidden",
            name: id,
          }),
          id
        );
        editor.hasHiddenInput = true;
      }
      editor.formEventDelegate = (e) => {
        editor.dispatch(e.type, e);
      };
      DOM$3.bind(form, "submit reset", editor.formEventDelegate);
      editor.on("reset", () => {
        editor.resetContent();
      });
      if (
        shouldPatchSubmit(editor) &&
        !form.submit.nodeType &&
        !form.submit.length &&
        !form._mceOldSubmit
      ) {
        form._mceOldSubmit = form.submit;
        form.submit = () => {
          editor.editorManager.triggerSave();
          editor.setDirty(false);
          return form._mceOldSubmit(form);
        };
      }
    }
    editor.windowManager = WindowManager(editor);
    editor.notificationManager = NotificationManager(editor);
    if (isEncodingXml(editor)) {
      editor.on("GetContent", (e) => {
        if (e.save) {
          e.content = DOM$3.encode(e.content);
        }
      });
    }
    if (shouldAddFormSubmitTrigger(editor)) {
      editor.on("submit", () => {
        if (editor.initialized) {
          editor.save();
        }
      });
    }
    if (shouldAddUnloadTrigger(editor)) {
      editor._beforeUnload = () => {
        if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
          editor.save({
            format: "raw",
            no_events: true,
            set_dirty: false,
          });
        }
      };
      editor.editorManager.on("BeforeUnload", editor._beforeUnload);
    }
    editor.editorManager.add(editor);
    loadScripts(editor, editor.suffix);
  };

  const setEditableRoot = (editor, state) => {
    if (editor._editableRoot !== state) {
      editor._editableRoot = state;
      if (!isDisabled(editor)) {
        editor.getBody().contentEditable = String(editor.hasEditableRoot());
        editor.nodeChanged();
      }
      fireEditableRootStateChange(editor, state);
    }
  };
  const hasEditableRoot = (editor) => editor._editableRoot;

  const sectionResult = (sections, settings) => ({
    sections: constant(sections),
    options: constant(settings),
  });
  const deviceDetection = detect$1().deviceType;
  const isPhone = deviceDetection.isPhone();
  const isTablet = deviceDetection.isTablet();
  const normalizePlugins = (plugins) => {
    if (isNullable(plugins)) {
      return [];
    } else {
      const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);
      const trimmedPlugins = map$3(pluginNames, trim$4);
      return filter$5(trimmedPlugins, isNotEmpty);
    }
  };
  const extractSections = (keys, options) => {
    const result = bifilter(options, (value, key) => {
      return contains$2(keys, key);
    });
    return sectionResult(result.t, result.f);
  };
  const getSection = (sectionResult, name, defaults = {}) => {
    const sections = sectionResult.sections();
    const sectionOptions = get$a(sections, name).getOr({});
    return Tools.extend({}, defaults, sectionOptions);
  };
  const hasSection = (sectionResult, name) => {
    return has$2(sectionResult.sections(), name);
  };
  const getSectionConfig = (sectionResult, name) => {
    return hasSection(sectionResult, name)
      ? sectionResult.sections()[name]
      : {};
  };
  const getMobileOverrideOptions = (mobileOptions, isPhone) => {
    const defaultMobileOptions = {
      table_grid: false,
      object_resizing: false,
      resize: false,
      toolbar_mode: get$a(mobileOptions, "toolbar_mode").getOr("scrolling"),
      toolbar_sticky: false,
    };
    const defaultPhoneOptions = { menubar: false };
    return {
      ...defaultMobileOptions,
      ...(isPhone ? defaultPhoneOptions : {}),
    };
  };
  const getExternalPlugins = (overrideOptions, options) => {
    var _a;
    const userDefinedExternalPlugins =
      (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
    if (overrideOptions && overrideOptions.external_plugins) {
      return Tools.extend(
        {},
        overrideOptions.external_plugins,
        userDefinedExternalPlugins
      );
    } else {
      return userDefinedExternalPlugins;
    }
  };
  const combinePlugins = (forcedPlugins, plugins) => [
    ...normalizePlugins(forcedPlugins),
    ...normalizePlugins(plugins),
  ];
  const getPlatformPlugins = (
    isMobileDevice,
    sectionResult,
    desktopPlugins,
    mobilePlugins
  ) => {
    if (isMobileDevice && hasSection(sectionResult, "mobile")) {
      return mobilePlugins;
    } else {
      return desktopPlugins;
    }
  };
  const processPlugins = (
    isMobileDevice,
    sectionResult,
    defaultOverrideOptions,
    options
  ) => {
    const forcedPlugins = normalizePlugins(
      defaultOverrideOptions.forced_plugins
    );
    const desktopPlugins = normalizePlugins(options.plugins);
    const mobileConfig = getSectionConfig(sectionResult, "mobile");
    const mobilePlugins = mobileConfig.plugins
      ? normalizePlugins(mobileConfig.plugins)
      : desktopPlugins;
    const platformPlugins = getPlatformPlugins(
      isMobileDevice,
      sectionResult,
      desktopPlugins,
      mobilePlugins
    );
    const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
    return Tools.extend(options, {
      forced_plugins: forcedPlugins,
      plugins: combinedPlugins,
    });
  };
  const isOnMobile = (isMobileDevice, sectionResult) => {
    return isMobileDevice && hasSection(sectionResult, "mobile");
  };
  const combineOptions = (
    isMobileDevice,
    isPhone,
    defaultOptions,
    defaultOverrideOptions,
    options
  ) => {
    var _a;
    const deviceOverrideOptions = isMobileDevice
      ? {
          mobile: getMobileOverrideOptions(
            (_a = options.mobile) !== null && _a !== void 0 ? _a : {},
            isPhone
          ),
        }
      : {};
    const sectionResult = extractSections(
      ["mobile"],
      deepMerge(deviceOverrideOptions, options)
    );
    const extendedOptions = Tools.extend(
      defaultOptions,
      defaultOverrideOptions,
      sectionResult.options(),
      isOnMobile(isMobileDevice, sectionResult)
        ? getSection(sectionResult, "mobile")
        : {},
      {
        external_plugins: getExternalPlugins(
          defaultOverrideOptions,
          sectionResult.options()
        ),
      }
    );
    return processPlugins(
      isMobileDevice,
      sectionResult,
      defaultOverrideOptions,
      extendedOptions
    );
  };
  const normalizeOptions = (defaultOverrideOptions, options) => {
    const copiedOptions = merge(options);
    return combineOptions(
      isPhone || isTablet,
      isPhone,
      copiedOptions,
      defaultOverrideOptions,
      copiedOptions
    );
  };

  const addVisual = (editor, elm) => addVisual$1(editor, elm);

  const registerExecCommands$2 = (editor) => {
    const toggleFormat = (name, value) => {
      editor.formatter.toggle(name, value);
      editor.nodeChanged();
    };
    const toggleAlign = (align) => () => {
      each$e("left,center,right,justify".split(","), (name) => {
        if (align !== name) {
          editor.formatter.remove("align" + name);
        }
      });
      if (align !== "none") {
        toggleFormat("align" + align);
      }
    };
    editor.editorCommands.addCommands({
      JustifyLeft: toggleAlign("left"),
      JustifyCenter: toggleAlign("center"),
      JustifyRight: toggleAlign("right"),
      JustifyFull: toggleAlign("justify"),
      JustifyNone: toggleAlign("none"),
    });
  };
  const registerQueryStateCommands = (editor) => {
    const alignStates = (name) => () => {
      const selection = editor.selection;
      const nodes = selection.isCollapsed()
        ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)]
        : selection.getSelectedBlocks();
      return exists(nodes, (node) =>
        isNonNullable(editor.formatter.matchNode(node, name))
      );
    };
    editor.editorCommands.addCommands(
      {
        JustifyLeft: alignStates("alignleft"),
        JustifyCenter: alignStates("aligncenter"),
        JustifyRight: alignStates("alignright"),
        JustifyFull: alignStates("alignjustify"),
      },
      "state"
    );
  };
  const registerCommands$a = (editor) => {
    registerExecCommands$2(editor);
    registerQueryStateCommands(editor);
  };

  const registerCommands$9 = (editor) => {
    editor.editorCommands.addCommands({
      "Cut,Copy,Paste": (command) => {
        const doc = editor.getDoc();
        let failed;
        try {
          doc.execCommand(command);
        } catch (_a) {
          failed = true;
        }
        if (command === "paste" && !doc.queryCommandEnabled(command)) {
          failed = true;
        }
        if (failed || !doc.queryCommandSupported(command)) {
          let msg = editor.translate(
            `Your browser doesn't support direct access to the clipboard. ` +
              "Please use the Ctrl+X/C/V keyboard shortcuts instead."
          );
          if (Env.os.isMacOS() || Env.os.isiOS()) {
            msg = msg.replace(/Ctrl\+/g, "\u2318+");
          }
          editor.notificationManager.open({
            text: msg,
            type: "error",
          });
        }
      },
    });
  };

  const trimOrPadLeftRight = (dom, rng, html, schema) => {
    const root = SugarElement.fromDom(dom.getRoot());
    if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {
      html = html.replace(/^ /, "&nbsp;");
    } else {
      html = html.replace(/^&nbsp;/, " ");
    }
    if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {
      html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;");
    } else {
      html = html.replace(/&nbsp;(<br( \/)?>)?$/, " ");
    }
    return html;
  };

  const processValue$1 = (value) => {
    if (typeof value !== "string") {
      const details = Tools.extend(
        {
          paste: value.paste,
          data: { paste: value.paste },
        },
        value
      );
      return {
        content: value.content,
        details,
      };
    }
    return {
      content: value,
      details: {},
    };
  };
  const trimOrPad = (editor, value) => {
    const selection = editor.selection;
    const dom = editor.dom;
    if (/^ | $/.test(value)) {
      return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);
    } else {
      return value;
    }
  };
  const insertAtCaret = (editor, value) => {
    if (editor.selection.isEditable()) {
      const { content, details } = processValue$1(value);
      preProcessSetContent(editor, {
        ...details,
        content: trimOrPad(editor, content),
        format: "html",
        set: false,
        selection: true,
      }).each((args) => {
        const insertedContent = insertContent$1(editor, args.content, details);
        postProcessSetContent(editor, insertedContent, args);
        editor.addVisual();
      });
    }
  };

  const registerCommands$8 = (editor) => {
    editor.editorCommands.addCommands({
      mceCleanup: () => {
        const bm = editor.selection.getBookmark();
        editor.setContent(editor.getContent());
        editor.selection.moveToBookmark(bm);
      },
      insertImage: (_command, _ui, value) => {
        insertAtCaret(editor, editor.dom.createHTML("img", { src: value }));
      },
      insertHorizontalRule: () => {
        editor.execCommand("mceInsertContent", false, "<hr>");
      },
      insertText: (_command, _ui, value) => {
        insertAtCaret(editor, editor.dom.encode(value));
      },
      insertHTML: (_command, _ui, value) => {
        insertAtCaret(editor, value);
      },
      mceInsertContent: (_command, _ui, value) => {
        insertAtCaret(editor, value);
      },
      mceSetContent: (_command, _ui, value) => {
        editor.setContent(value);
      },
      mceReplaceContent: (_command, _ui, value) => {
        editor.execCommand(
          "mceInsertContent",
          false,
          value.replace(
            /\{\$selection\}/g,
            editor.selection.getContent({ format: "text" })
          )
        );
      },
      mceNewDocument: () => {
        editor.setContent(getNewDocumentContent(editor));
      },
    });
  };

  const legacyPropNames = {
    "font-size": "size",
    "font-family": "face",
  };
  const isFont = isTag("font");
  const getSpecifiedFontProp = (propName, rootElm, elm) => {
    const getProperty = (elm) =>
      getRaw(elm, propName).orThunk(() => {
        if (isFont(elm)) {
          return get$a(legacyPropNames, propName).bind((legacyPropName) =>
            getOpt(elm, legacyPropName)
          );
        } else {
          return Optional.none();
        }
      });
    const isRoot = (elm) => eq(SugarElement.fromDom(rootElm), elm);
    return closest$1(
      SugarElement.fromDom(elm),
      (elm) => getProperty(elm),
      isRoot
    );
  };
  const normalizeFontFamily = (fontFamily) =>
    fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
  const getComputedFontProp = (propName, elm) =>
    Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
  const getFontProp = (propName) => (rootElm, elm) =>
    Optional.from(elm)
      .map(SugarElement.fromDom)
      .filter(isElement$7)
      .bind((element) =>
        getSpecifiedFontProp(propName, rootElm, element.dom).or(
          getComputedFontProp(propName, element.dom)
        )
      )
      .getOr("");
  const getFontSize = getFontProp("font-size");
  const getFontFamily = compose(
    normalizeFontFamily,
    getFontProp("font-family")
  );

  const findFirstCaretElement = (editor) =>
    firstPositionIn(editor.getBody()).bind((caret) => {
      const container = caret.container();
      return Optional.from(
        isText$b(container) ? container.parentNode : container
      );
    });
  const getCaretElement = (editor) =>
    Optional.from(editor.selection.getRng()).bind((rng) => {
      const root = editor.getBody();
      const atStartOfNode =
        rng.startContainer === root && rng.startOffset === 0;
      return atStartOfNode
        ? Optional.none()
        : Optional.from(editor.selection.getStart(true));
    });
  const bindRange = (editor, binder) =>
    getCaretElement(editor)
      .orThunk(curry(findFirstCaretElement, editor))
      .map(SugarElement.fromDom)
      .filter(isElement$7)
      .bind(binder);
  const mapRange = (editor, mapper) =>
    bindRange(editor, compose1(Optional.some, mapper));

  const fromFontSizeNumber = (editor, value) => {
    if (/^[0-9.]+$/.test(value)) {
      const fontSizeNumber = parseInt(value, 10);
      if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
        const fontSizes = getFontStyleValues(editor);
        const fontClasses = getFontSizeClasses(editor);
        if (fontClasses.length > 0) {
          return fontClasses[fontSizeNumber - 1] || value;
        } else {
          return fontSizes[fontSizeNumber - 1] || value;
        }
      } else {
        return value;
      }
    } else {
      return value;
    }
  };
  const normalizeFontNames = (font) => {
    const fonts = font.split(/\s*,\s*/);
    return map$3(fonts, (font) => {
      if (
        font.indexOf(" ") !== -1 &&
        !(startsWith(font, '"') || startsWith(font, `'`))
      ) {
        return `'${font}'`;
      } else {
        return font;
      }
    }).join(",");
  };
  const fontNameAction = (editor, value) => {
    const font = fromFontSizeNumber(editor, value);
    editor.formatter.toggle("fontname", { value: normalizeFontNames(font) });
    editor.nodeChanged();
  };
  const fontNameQuery = (editor) =>
    mapRange(editor, (elm) => getFontFamily(editor.getBody(), elm.dom)).getOr(
      ""
    );
  const fontSizeAction = (editor, value) => {
    editor.formatter.toggle("fontsize", {
      value: fromFontSizeNumber(editor, value),
    });
    editor.nodeChanged();
  };
  const fontSizeQuery = (editor) =>
    mapRange(editor, (elm) => getFontSize(editor.getBody(), elm.dom)).getOr("");

  const lineHeightQuery = (editor) =>
    mapRange(editor, (elm) => {
      const root = SugarElement.fromDom(editor.getBody());
      const specifiedStyle = closest$1(
        elm,
        (elm) => getRaw(elm, "line-height"),
        curry(eq, root)
      );
      const computedStyle = () => {
        const lineHeight = parseFloat(get$7(elm, "line-height"));
        const fontSize = parseFloat(get$7(elm, "font-size"));
        return String(lineHeight / fontSize);
      };
      return specifiedStyle.getOrThunk(computedStyle);
    }).getOr("");
  const lineHeightAction = (editor, lineHeight) => {
    editor.formatter.toggle("lineheight", { value: String(lineHeight) });
    editor.nodeChanged();
  };

  const registerExecCommands$1 = (editor) => {
    const toggleFormat = (name, value) => {
      editor.formatter.toggle(name, value);
      editor.nodeChanged();
    };
    editor.editorCommands.addCommands({
      "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (
        command
      ) => {
        toggleFormat(command);
      },
      "ForeColor,HiliteColor": (command, _ui, value) => {
        toggleFormat(command, { value });
      },
      BackColor: (_command, _ui, value) => {
        toggleFormat("hilitecolor", { value });
      },
      FontName: (_command, _ui, value) => {
        fontNameAction(editor, value);
      },
      FontSize: (_command, _ui, value) => {
        fontSizeAction(editor, value);
      },
      LineHeight: (_command, _ui, value) => {
        lineHeightAction(editor, value);
      },
      Lang: (command, _ui, lang) => {
        var _a;
        toggleFormat(command, {
          value: lang.code,
          customValue:
            (_a = lang.customCode) !== null && _a !== void 0 ? _a : null,
        });
      },
      RemoveFormat: (command) => {
        editor.formatter.remove(command);
      },
      mceBlockQuote: () => {
        toggleFormat("blockquote");
      },
      FormatBlock: (_command, _ui, value) => {
        toggleFormat(isString(value) ? value : "p");
      },
      mceToggleFormat: (_command, _ui, value) => {
        toggleFormat(value);
      },
    });
  };
  const registerQueryValueCommands = (editor) => {
    const isFormatMatch = (name) => editor.formatter.match(name);
    editor.editorCommands.addCommands(
      {
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (
          command
        ) => isFormatMatch(command),
        mceBlockQuote: () => isFormatMatch("blockquote"),
      },
      "state"
    );
    editor.editorCommands.addQueryValueHandler("FontName", () =>
      fontNameQuery(editor)
    );
    editor.editorCommands.addQueryValueHandler("FontSize", () =>
      fontSizeQuery(editor)
    );
    editor.editorCommands.addQueryValueHandler("LineHeight", () =>
      lineHeightQuery(editor)
    );
  };
  const registerCommands$7 = (editor) => {
    registerExecCommands$1(editor);
    registerQueryValueCommands(editor);
  };

  const registerCommands$6 = (editor) => {
    editor.editorCommands.addCommands({
      mceAddUndoLevel: () => {
        editor.undoManager.add();
      },
      mceEndUndoLevel: () => {
        editor.undoManager.add();
      },
      Undo: () => {
        editor.undoManager.undo();
      },
      Redo: () => {
        editor.undoManager.redo();
      },
    });
  };

  const registerCommands$5 = (editor) => {
    editor.editorCommands.addCommands({
      Indent: () => {
        indent(editor);
      },
      Outdent: () => {
        outdent(editor);
      },
    });
    editor.editorCommands.addCommands(
      { Outdent: () => canOutdent(editor) },
      "state"
    );
  };

  const registerCommands$4 = (editor) => {
    const applyLinkToSelection = (_command, _ui, value) => {
      if (editor.mode.isReadOnly()) {
        return;
      }
      const linkDetails = isString(value) ? { href: value } : value;
      const anchor = editor.dom.getParent(editor.selection.getNode(), "a");
      if (isObject(linkDetails) && isString(linkDetails.href)) {
        linkDetails.href = linkDetails.href.replace(/ /g, "%20");
        if (!anchor || !linkDetails.href) {
          editor.formatter.remove("link");
        }
        if (linkDetails.href) {
          editor.formatter.apply("link", linkDetails, anchor);
        }
      }
    };
    editor.editorCommands.addCommands({
      unlink: () => {
        if (editor.selection.isEditable()) {
          if (editor.selection.isCollapsed()) {
            const elm = editor.dom.getParent(editor.selection.getStart(), "a");
            if (elm) {
              editor.dom.remove(elm, true);
            }
            return;
          }
          editor.formatter.remove("link");
        }
      },
      mceInsertLink: applyLinkToSelection,
      createLink: applyLinkToSelection,
    });
  };

  const getTopParentBlock = (editor, node, root, container) => {
    const dom = editor.dom;
    const selector = (node) => dom.isBlock(node) && node.parentElement === root;
    const topParentBlock = selector(node)
      ? node
      : dom.getParent(container, selector, root);
    return Optional.from(topParentBlock).map(SugarElement.fromDom);
  };
  const insert = (editor, before) => {
    if (editor.mode.isReadOnly()) {
      return;
    }
    const dom = editor.dom;
    const rng = editor.selection.getRng();
    const node = before
      ? editor.selection.getStart()
      : editor.selection.getEnd();
    const container = before ? rng.startContainer : rng.endContainer;
    const root = getEditableRoot(dom, container);
    if (!root || !root.isContentEditable) {
      return;
    }
    const insertFn = before ? before$3 : after$4;
    const newBlockName = getForcedRootBlock(editor);
    getTopParentBlock(editor, node, root, container).each((parentBlock) => {
      const newBlock = createNewBlock(
        editor,
        container,
        parentBlock.dom,
        root,
        false,
        newBlockName
      );
      insertFn(parentBlock, SugarElement.fromDom(newBlock));
      editor.selection.setCursorLocation(newBlock, 0);
      editor.dispatch("NewBlock", { newBlock });
      fireInputEvent(editor, "insertParagraph");
    });
  };
  const insertBefore = (editor) => insert(editor, true);
  const insertAfter = (editor) => insert(editor, false);

  const registerCommands$3 = (editor) => {
    editor.editorCommands.addCommands({
      InsertNewBlockBefore: () => {
        insertBefore(editor);
      },
      InsertNewBlockAfter: () => {
        insertAfter(editor);
      },
    });
  };

  const registerCommands$2 = (editor) => {
    editor.editorCommands.addCommands({
      insertParagraph: () => {
        insertBreak(blockbreak, editor);
      },
      mceInsertNewLine: (_command, _ui, value) => {
        insert$1(editor, value);
      },
      InsertLineBreak: (_command, _ui, _value) => {
        insertBreak(linebreak, editor);
      },
    });
  };

  const registerCommands$1 = (editor) => {
    editor.editorCommands.addCommands({
      mceSelectNodeDepth: (_command, _ui, value) => {
        let counter = 0;
        editor.dom.getParent(
          editor.selection.getNode(),
          (node) => {
            if (isElement$6(node) && counter++ === value) {
              editor.selection.select(node);
              return false;
            } else {
              return true;
            }
          },
          editor.getBody()
        );
      },
      mceSelectNode: (_command, _ui, value) => {
        editor.selection.select(value);
      },
      selectAll: () => {
        const editingHost = editor.dom.getParent(
          editor.selection.getStart(),
          isContentEditableTrue$3
        );
        if (editingHost) {
          const rng = editor.dom.createRng();
          rng.selectNodeContents(editingHost);
          editor.selection.setRng(rng);
        }
      },
    });
  };

  const registerExecCommands = (editor) => {
    editor.editorCommands.addCommands({
      mceRemoveNode: (_command, _ui, value) => {
        const node =
          value !== null && value !== void 0
            ? value
            : editor.selection.getNode();
        if (node !== editor.getBody()) {
          const bm = editor.selection.getBookmark();
          editor.dom.remove(node, true);
          editor.selection.moveToBookmark(bm);
        }
      },
      mcePrint: () => {
        editor.getWin().print();
      },
      mceFocus: (_command, _ui, value) => {
        focus(editor, value === true);
      },
      mceToggleVisualAid: () => {
        editor.hasVisual = !editor.hasVisual;
        editor.addVisual();
      },
    });
  };
  const registerCommands = (editor) => {
    registerCommands$a(editor);
    registerCommands$9(editor);
    registerCommands$6(editor);
    registerCommands$1(editor);
    registerCommands$8(editor);
    registerCommands$4(editor);
    registerCommands$5(editor);
    registerCommands$3(editor);
    registerCommands$2(editor);
    registerCommands$7(editor);
    registerExecCommands(editor);
  };

  const selectionSafeCommands = ["toggleview"];
  const isSelectionSafeCommand = (command) =>
    contains$2(selectionSafeCommands, command.toLowerCase());
  class EditorCommands {
    constructor(editor) {
      this.commands = {
        state: {},
        exec: {},
        value: {},
      };
      this.editor = editor;
    }
    execCommand(command, ui = false, value, args) {
      const editor = this.editor;
      const lowerCaseCommand = command.toLowerCase();
      const skipFocus =
        args === null || args === void 0 ? void 0 : args.skip_focus;
      if (editor.removed) {
        return false;
      }
      if (lowerCaseCommand !== "mcefocus") {
        if (
          !/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) &&
          !skipFocus
        ) {
          editor.focus();
        } else {
          restore(editor);
        }
      }
      const eventArgs = editor.dispatch("BeforeExecCommand", {
        command,
        ui,
        value,
      });
      if (eventArgs.isDefaultPrevented()) {
        return false;
      }
      const func = this.commands.exec[lowerCaseCommand];
      if (isFunction(func)) {
        func(lowerCaseCommand, ui, value);
        editor.dispatch("ExecCommand", {
          command,
          ui,
          value,
        });
        return true;
      }
      return false;
    }
    queryCommandState(command) {
      if (
        (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden()) ||
        this.editor.removed
      ) {
        return false;
      }
      const lowerCaseCommand = command.toLowerCase();
      const func = this.commands.state[lowerCaseCommand];
      if (isFunction(func)) {
        return func(lowerCaseCommand);
      }
      return false;
    }
    queryCommandValue(command) {
      if (
        (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden()) ||
        this.editor.removed
      ) {
        return "";
      }
      const lowerCaseCommand = command.toLowerCase();
      const func = this.commands.value[lowerCaseCommand];
      if (isFunction(func)) {
        return func(lowerCaseCommand);
      }
      return "";
    }
    addCommands(commandList, type = "exec") {
      const commands = this.commands;
      each$d(commandList, (callback, command) => {
        each$e(command.toLowerCase().split(","), (command) => {
          commands[type][command] = callback;
        });
      });
    }
    addCommand(command, callback, scope) {
      const lowerCaseCommand = command.toLowerCase();
      this.commands.exec[lowerCaseCommand] = (_command, ui, value) =>
        callback.call(
          scope !== null && scope !== void 0 ? scope : this.editor,
          ui,
          value
        );
    }
    queryCommandSupported(command) {
      const lowerCaseCommand = command.toLowerCase();
      if (this.commands.exec[lowerCaseCommand]) {
        return true;
      } else {
        return false;
      }
    }
    addQueryStateHandler(command, callback, scope) {
      this.commands.state[command.toLowerCase()] = () =>
        callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
    }
    addQueryValueHandler(command, callback, scope) {
      this.commands.value[command.toLowerCase()] = () =>
        callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
    }
  }

  const nativeEvents = Tools.makeMap(
    "focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange " +
      "mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover " +
      "draggesture dragdrop drop drag submit " +
      "compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel",
    " "
  );
  class EventDispatcher {
    static isNative(name) {
      return !!nativeEvents[name.toLowerCase()];
    }
    constructor(settings) {
      this.bindings = {};
      this.settings = settings || {};
      this.scope = this.settings.scope || this;
      this.toggleEvent = this.settings.toggleEvent || never;
    }
    fire(name, args) {
      return this.dispatch(name, args);
    }
    dispatch(name, args) {
      const lcName = name.toLowerCase();
      const event = normalize$3(
        lcName,
        args !== null && args !== void 0 ? args : {},
        this.scope
      );
      if (this.settings.beforeFire) {
        this.settings.beforeFire(event);
      }
      const handlers = this.bindings[lcName];
      if (handlers) {
        for (let i = 0, l = handlers.length; i < l; i++) {
          const callback = handlers[i];
          if (callback.removed) {
            continue;
          }
          if (callback.once) {
            this.off(lcName, callback.func);
          }
          if (event.isImmediatePropagationStopped()) {
            return event;
          }
          if (callback.func.call(this.scope, event) === false) {
            event.preventDefault();
            return event;
          }
        }
      }
      return event;
    }
    on(name, callback, prepend, extra) {
      if (callback === false) {
        callback = never;
      }
      if (callback) {
        const wrappedCallback = {
          func: callback,
          removed: false,
        };
        if (extra) {
          Tools.extend(wrappedCallback, extra);
        }
        const names = name.toLowerCase().split(" ");
        let i = names.length;
        while (i--) {
          const currentName = names[i];
          let handlers = this.bindings[currentName];
          if (!handlers) {
            handlers = [];
            this.toggleEvent(currentName, true);
          }
          if (prepend) {
            handlers = [wrappedCallback, ...handlers];
          } else {
            handlers = [...handlers, wrappedCallback];
          }
          this.bindings[currentName] = handlers;
        }
      }
      return this;
    }
    off(name, callback) {
      if (name) {
        const names = name.toLowerCase().split(" ");
        let i = names.length;
        while (i--) {
          const currentName = names[i];
          let handlers = this.bindings[currentName];
          if (!currentName) {
            each$d(this.bindings, (_value, bindingName) => {
              this.toggleEvent(bindingName, false);
              delete this.bindings[bindingName];
            });
            return this;
          }
          if (handlers) {
            if (!callback) {
              handlers.length = 0;
            } else {
              const filteredHandlers = partition$2(
                handlers,
                (handler) => handler.func === callback
              );
              handlers = filteredHandlers.fail;
              this.bindings[currentName] = handlers;
              each$e(filteredHandlers.pass, (handler) => {
                handler.removed = true;
              });
            }
            if (!handlers.length) {
              this.toggleEvent(name, false);
              delete this.bindings[currentName];
            }
          }
        }
      } else {
        each$d(this.bindings, (_value, name) => {
          this.toggleEvent(name, false);
        });
        this.bindings = {};
      }
      return this;
    }
    once(name, callback, prepend) {
      return this.on(name, callback, prepend, { once: true });
    }
    has(name) {
      name = name.toLowerCase();
      const binding = this.bindings[name];
      return !(!binding || binding.length === 0);
    }
  }

  const getEventDispatcher = (obj) => {
    if (!obj._eventDispatcher) {
      obj._eventDispatcher = new EventDispatcher({
        scope: obj,
        toggleEvent: (name, state) => {
          if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
            obj.toggleNativeEvent(name, state);
          }
        },
      });
    }
    return obj._eventDispatcher;
  };
  const Observable = {
    fire(name, args, bubble) {
      return this.dispatch(name, args, bubble);
    },
    dispatch(name, args, bubble) {
      const self = this;
      if (self.removed && name !== "remove" && name !== "detach") {
        return normalize$3(
          name.toLowerCase(),
          args !== null && args !== void 0 ? args : {},
          self
        );
      }
      const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);
      if (bubble !== false && self.parent) {
        let parent = self.parent();
        while (parent && !dispatcherArgs.isPropagationStopped()) {
          parent.dispatch(name, dispatcherArgs, false);
          parent = parent.parent ? parent.parent() : undefined;
        }
      }
      return dispatcherArgs;
    },
    on(name, callback, prepend) {
      return getEventDispatcher(this).on(name, callback, prepend);
    },
    off(name, callback) {
      return getEventDispatcher(this).off(name, callback);
    },
    once(name, callback) {
      return getEventDispatcher(this).once(name, callback);
    },
    hasEventListeners(name) {
      return getEventDispatcher(this).has(name);
    },
  };

  const DOM$2 = DOMUtils.DOM;
  let customEventRootDelegates;
  const getEventTarget = (editor, eventName) => {
    if (eventName === "selectionchange") {
      return editor.getDoc();
    }
    if (
      !editor.inline &&
      /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)
    ) {
      return editor.getDoc().documentElement;
    }
    const eventRoot = getEventRoot(editor);
    if (eventRoot) {
      if (!editor.eventRoot) {
        editor.eventRoot = DOM$2.select(eventRoot)[0];
      }
      return editor.eventRoot;
    }
    return editor.getBody();
  };
  const isListening = (editor) => !editor.hidden && !isDisabled(editor);
  const fireEvent = (editor, eventName, e) => {
    if (isListening(editor)) {
      editor.dispatch(eventName, e);
    } else if (isDisabled(editor)) {
      processDisabledEvents(editor, e);
    }
  };
  const bindEventDelegate = (editor, eventName) => {
    if (!editor.delegates) {
      editor.delegates = {};
    }
    if (editor.delegates[eventName] || editor.removed) {
      return;
    }
    const eventRootElm = getEventTarget(editor, eventName);
    if (getEventRoot(editor)) {
      if (!customEventRootDelegates) {
        customEventRootDelegates = {};
        editor.editorManager.on("removeEditor", () => {
          if (!editor.editorManager.activeEditor) {
            if (customEventRootDelegates) {
              each$d(customEventRootDelegates, (_value, name) => {
                editor.dom.unbind(getEventTarget(editor, name));
              });
              customEventRootDelegates = null;
            }
          }
        });
      }
      if (customEventRootDelegates[eventName]) {
        return;
      }
      const delegate = (e) => {
        const target = e.target;
        const editors = editor.editorManager.get();
        let i = editors.length;
        while (i--) {
          const body = editors[i].getBody();
          if (body === target || DOM$2.isChildOf(target, body)) {
            fireEvent(editors[i], eventName, e);
          }
        }
      };
      customEventRootDelegates[eventName] = delegate;
      DOM$2.bind(eventRootElm, eventName, delegate);
    } else {
      const delegate = (e) => {
        fireEvent(editor, eventName, e);
      };
      DOM$2.bind(eventRootElm, eventName, delegate);
      editor.delegates[eventName] = delegate;
    }
  };
  const EditorObservable = {
    ...Observable,
    bindPendingEventDelegates() {
      const self = this;
      Tools.each(self._pendingNativeEvents, (name) => {
        bindEventDelegate(self, name);
      });
    },
    toggleNativeEvent(name, state) {
      const self = this;
      if (name === "focus" || name === "blur") {
        return;
      }
      if (self.removed) {
        return;
      }
      if (state) {
        if (self.initialized) {
          bindEventDelegate(self, name);
        } else {
          if (!self._pendingNativeEvents) {
            self._pendingNativeEvents = [name];
          } else {
            self._pendingNativeEvents.push(name);
          }
        }
      } else if (self.initialized && self.delegates) {
        self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
        delete self.delegates[name];
      }
    },
    unbindAllNativeEvents() {
      const self = this;
      const body = self.getBody();
      const dom = self.dom;
      if (self.delegates) {
        each$d(self.delegates, (value, name) => {
          self.dom.unbind(getEventTarget(self, name), name, value);
        });
        delete self.delegates;
      }
      if (!self.inline && body && dom) {
        body.onload = null;
        dom.unbind(self.getWin());
        dom.unbind(self.getDoc());
      }
      if (dom) {
        dom.unbind(body);
        dom.unbind(self.getContainer());
      }
    },
  };

  const stringListProcessor = (value) => {
    if (isString(value)) {
      return {
        value: value.split(/[ ,]/),
        valid: true,
      };
    } else if (isArrayOf(value, isString)) {
      return {
        value,
        valid: true,
      };
    } else {
      return {
        valid: false,
        message: `The value must be a string[] or a comma/space separated string.`,
      };
    }
  };
  const getBuiltInProcessor = (type) => {
    const validator = (() => {
      switch (type) {
        case "array":
          return isArray$1;
        case "boolean":
          return isBoolean;
        case "function":
          return isFunction;
        case "number":
          return isNumber;
        case "object":
          return isObject;
        case "string":
          return isString;
        case "string[]":
          return stringListProcessor;
        case "object[]":
          return (val) => isArrayOf(val, isObject);
        case "regexp":
          return (val) => is$4(val, RegExp);
        default:
          return always;
      }
    })();
    return (value) =>
      processValue(value, validator, `The value must be a ${type}.`);
  };
  const isBuiltInSpec = (spec) => isString(spec.processor);
  const getErrorMessage = (message, result) => {
    const additionalText = isEmpty$3(result.message)
      ? ""
      : `. ${result.message}`;
    return message + additionalText;
  };
  const isValidResult = (result) => result.valid;
  const processValue = (value, processor, message = "") => {
    const result = processor(value);
    if (isBoolean(result)) {
      return result
        ? {
            value: value,
            valid: true,
          }
        : {
            valid: false,
            message,
          };
    } else {
      return result;
    }
  };
  const processDefaultValue = (name, defaultValue, processor) => {
    if (!isUndefined(defaultValue)) {
      const result = processValue(defaultValue, processor);
      if (isValidResult(result)) {
        return result.value;
      } else {
        console.error(
          getErrorMessage(
            `Invalid default value passed for the "${name}" option`,
            result
          )
        );
      }
    }
    return undefined;
  };
  const create$5 = (
    editor,
    initialOptions,
    rawInitialOptions = initialOptions
  ) => {
    const registry = {};
    const values = {};
    const setValue = (name, value, processor) => {
      const result = processValue(value, processor);
      if (isValidResult(result)) {
        values[name] = result.value;
        return true;
      } else {
        console.warn(
          getErrorMessage(`Invalid value passed for the ${name} option`, result)
        );
        return false;
      }
    };
    const register = (name, spec) => {
      const processor = isBuiltInSpec(spec)
        ? getBuiltInProcessor(spec.processor)
        : spec.processor;
      const defaultValue = processDefaultValue(name, spec.default, processor);
      registry[name] = {
        ...spec,
        default: defaultValue,
        processor,
      };
      const initValue = get$a(values, name).orThunk(() =>
        get$a(initialOptions, name)
      );
      initValue.each((value) => setValue(name, value, processor));
    };
    const isRegistered = (name) => has$2(registry, name);
    const get = (name) =>
      get$a(values, name)
        .orThunk(() => get$a(registry, name).map((spec) => spec.default))
        .getOrUndefined();
    const set = (name, value) => {
      if (!isRegistered(name)) {
        console.warn(
          `"${name}" is not a registered option. Ensure the option has been registered before setting a value.`
        );
        return false;
      } else {
        const spec = registry[name];
        if (spec.immutable) {
          console.error(
            `"${name}" is an immutable option and cannot be updated`
          );
          return false;
        } else {
          return setValue(name, value, spec.processor);
        }
      }
    };
    const unset = (name) => {
      const registered = isRegistered(name);
      if (registered) {
        delete values[name];
      }
      return registered;
    };
    const isSet = (name) => has$2(values, name);
    const debug = () => {
      try {
        console.log(
          JSON.parse(
            JSON.stringify(rawInitialOptions, (_key, value) => {
              if (
                isBoolean(value) ||
                isNumber(value) ||
                isString(value) ||
                isNull(value) ||
                isArray$1(value) ||
                isPlainObject(value)
              ) {
                return value;
              }
              return Object.prototype.toString.call(value);
            })
          )
        );
      } catch (error) {
        console.error(error);
      }
    };
    return {
      register,
      isRegistered,
      get,
      set,
      unset,
      isSet,
      debug,
    };
  };

  const setContentEditable = (elm, state) => {
    elm.dom.contentEditable = state ? "true" : "false";
  };
  const toggleReadOnly = (editor, state) => {
    const body = SugarElement.fromDom(editor.getBody());
    if (state) {
      editor.readonly = true;
      if (editor.hasEditableRoot()) {
        setContentEditable(body, true);
      }
      disableEditor(editor);
    } else {
      editor.readonly = false;
      enableEditor(editor);
    }
  };
  const isReadOnly = (editor) => editor.readonly;
  const registerReadOnlyInputBlockers = (editor) => {
    editor.on(
      "beforeinput paste cut dragend dragover draggesture dragdrop drop drag",
      (e) => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      }
    );
    editor.on("BeforeExecCommand", (e) => {
      if (
        (e.command === "Undo" || e.command === "Redo") &&
        isReadOnly(editor)
      ) {
        e.preventDefault();
      }
    });
    editor.on("input", (e) => {
      if (!e.isComposing && isReadOnly(editor)) {
        const undoLevel = editor.undoManager.add();
        if (isNonNullable(undoLevel)) {
          editor.undoManager.undo();
        }
      }
    });
    editor.on("compositionend", () => {
      if (isReadOnly(editor)) {
        const undoLevel = editor.undoManager.add();
        if (isNonNullable(undoLevel)) {
          editor.undoManager.undo();
        }
      }
    });
  };

  const defaultModes = ["design", "readonly"];
  const switchToMode = (editor, activeMode, availableModes, mode) => {
    const oldMode = availableModes[activeMode.get()];
    const newMode = availableModes[mode];
    try {
      newMode.activate();
    } catch (e) {
      console.error(`problem while activating editor mode ${mode}:`, e);
      return;
    }
    oldMode.deactivate();
    if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
      toggleReadOnly(editor, newMode.editorReadOnly);
    }
    activeMode.set(mode);
    fireSwitchMode(editor, mode);
  };
  const setMode = (editor, availableModes, activeMode, mode) => {
    if (
      mode === activeMode.get() ||
      (editor.initialized && isDisabled(editor))
    ) {
      return;
    } else if (!has$2(availableModes, mode)) {
      throw new Error(`Editor mode '${mode}' is invalid`);
    }
    if (editor.initialized) {
      switchToMode(editor, activeMode, availableModes, mode);
    } else {
      editor.on("init", () =>
        switchToMode(editor, activeMode, availableModes, mode)
      );
    }
  };
  const registerMode = (availableModes, mode, api) => {
    if (contains$2(defaultModes, mode)) {
      throw new Error(`Cannot override default mode ${mode}`);
    }
    return {
      ...availableModes,
      [mode]: {
        ...api,
        deactivate: () => {
          try {
            api.deactivate();
          } catch (e) {
            console.error(`problem while deactivating editor mode ${mode}:`, e);
          }
        },
      },
    };
  };

  const create$4 = (editor) => {
    const activeMode = Cell("design");
    const availableModes = Cell({
      design: {
        activate: noop,
        deactivate: noop,
        editorReadOnly: false,
      },
      readonly: {
        activate: noop,
        deactivate: noop,
        editorReadOnly: true,
      },
    });
    registerReadOnlyInputBlockers(editor);
    registerEventsAndFilters$1(editor);
    return {
      isReadOnly: () => isReadOnly(editor),
      set: (mode) => setMode(editor, availableModes.get(), activeMode, mode),
      get: () => activeMode.get(),
      register: (mode, api) => {
        availableModes.set(registerMode(availableModes.get(), mode, api));
      },
    };
  };

  const each$2 = Tools.each,
    explode = Tools.explode;
  const keyCodeLookup = {
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
  };
  const modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
  const isModifier = (key) => key in modifierNames;
  const parseShortcut = (pattern) => {
    const shortcut = {};
    const isMac = Env.os.isMacOS() || Env.os.isiOS();
    each$2(explode(pattern.toLowerCase(), "+"), (value) => {
      if (isModifier(value)) {
        shortcut[value] = true;
      } else {
        if (/^[0-9]{2,}$/.test(value)) {
          shortcut.keyCode = parseInt(value, 10);
        } else {
          shortcut.charCode = value.charCodeAt(0);
          shortcut.keyCode =
            keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
        }
      }
    });
    const id = [shortcut.keyCode];
    let key;
    for (key in modifierNames) {
      if (shortcut[key]) {
        id.push(key);
      } else {
        shortcut[key] = false;
      }
    }
    shortcut.id = id.join(",");
    if (shortcut.access) {
      shortcut.alt = true;
      if (isMac) {
        shortcut.ctrl = true;
      } else {
        shortcut.shift = true;
      }
    }
    if (shortcut.meta) {
      if (isMac) {
        shortcut.meta = true;
      } else {
        shortcut.ctrl = true;
        shortcut.meta = false;
      }
    }
    return shortcut;
  };
  class Shortcuts {
    constructor(editor) {
      this.shortcuts = {};
      this.pendingPatterns = [];
      this.editor = editor;
      const self = this;
      editor.on("keyup keypress keydown", (e) => {
        if (
          (self.hasModifier(e) || self.isFunctionKey(e)) &&
          !e.isDefaultPrevented()
        ) {
          each$2(self.shortcuts, (shortcut) => {
            if (self.matchShortcut(e, shortcut)) {
              self.pendingPatterns = shortcut.subpatterns.slice(0);
              if (e.type === "keydown") {
                self.executeShortcutAction(shortcut);
              }
            }
          });
          if (self.matchShortcut(e, self.pendingPatterns[0])) {
            if (self.pendingPatterns.length === 1) {
              if (e.type === "keydown") {
                self.executeShortcutAction(self.pendingPatterns[0]);
              }
            }
            self.pendingPatterns.shift();
          }
        }
      });
    }
    add(pattern, desc, cmdFunc, scope) {
      const self = this;
      const func = self.normalizeCommandFunc(cmdFunc);
      each$2(explode(Tools.trim(pattern)), (pattern) => {
        const shortcut = self.createShortcut(pattern, desc, func, scope);
        self.shortcuts[shortcut.id] = shortcut;
      });
      return true;
    }
    remove(pattern) {
      const shortcut = this.createShortcut(pattern);
      if (this.shortcuts[shortcut.id]) {
        delete this.shortcuts[shortcut.id];
        return true;
      }
      return false;
    }
    normalizeCommandFunc(cmdFunc) {
      const self = this;
      const cmd = cmdFunc;
      if (typeof cmd === "string") {
        return () => {
          self.editor.execCommand(cmd, false, null);
        };
      } else if (Tools.isArray(cmd)) {
        return () => {
          self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
        };
      } else {
        return cmd;
      }
    }
    createShortcut(pattern, desc, cmdFunc, scope) {
      const shortcuts = Tools.map(explode(pattern, ">"), parseShortcut);
      shortcuts[shortcuts.length - 1] = Tools.extend(
        shortcuts[shortcuts.length - 1],
        {
          func: cmdFunc,
          scope: scope || this.editor,
        }
      );
      return Tools.extend(shortcuts[0], {
        desc: this.editor.translate(desc),
        subpatterns: shortcuts.slice(1),
      });
    }
    hasModifier(e) {
      return e.altKey || e.ctrlKey || e.metaKey;
    }
    isFunctionKey(e) {
      return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
    }
    matchShortcut(e, shortcut) {
      if (!shortcut) {
        return false;
      }
      if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
        return false;
      }
      if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
        return false;
      }
      if (
        e.keyCode === shortcut.keyCode ||
        (e.charCode && e.charCode === shortcut.charCode)
      ) {
        e.preventDefault();
        return true;
      }
      return false;
    }
    executeShortcutAction(shortcut) {
      return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
    }
  }

  const create$3 = () => {
    const buttons = {};
    const menuItems = {};
    const popups = {};
    const icons = {};
    const contextMenus = {};
    const contextToolbars = {};
    const contexts = {};
    const sidebars = {};
    const views = {};
    const add = (collection, type) => (name, spec) => {
      collection[name.toLowerCase()] = {
        ...spec,
        type,
      };
    };
    const addDefaulted = (collection, type) => (name, spec) => {
      collection[name.toLowerCase()] = {
        type,
        ...spec,
      };
    };
    const addIcon = (name, svgData) => (icons[name.toLowerCase()] = svgData);
    const addContext = (name, pred) => (contexts[name.toLowerCase()] = pred);
    return {
      addButton: add(buttons, "button"),
      addGroupToolbarButton: add(buttons, "grouptoolbarbutton"),
      addToggleButton: add(buttons, "togglebutton"),
      addMenuButton: add(buttons, "menubutton"),
      addSplitButton: add(buttons, "splitbutton"),
      addMenuItem: add(menuItems, "menuitem"),
      addNestedMenuItem: add(menuItems, "nestedmenuitem"),
      addToggleMenuItem: add(menuItems, "togglemenuitem"),
      addAutocompleter: add(popups, "autocompleter"),
      addContextMenu: add(contextMenus, "contextmenu"),
      addContextToolbar: add(contextToolbars, "contexttoolbar"),
      addContextForm: addDefaulted(contextToolbars, "contextform"),
      addSidebar: add(sidebars, "sidebar"),
      addView: add(views, "views"),
      addIcon,
      addContext,
      getAll: () => ({
        buttons,
        menuItems,
        icons,
        popups,
        contextMenus,
        contextToolbars,
        sidebars,
        views,
        contexts,
      }),
    };
  };

  const registry = () => {
    const bridge = create$3();
    return {
      addAutocompleter: bridge.addAutocompleter,
      addButton: bridge.addButton,
      addContextForm: bridge.addContextForm,
      addContextMenu: bridge.addContextMenu,
      addContextToolbar: bridge.addContextToolbar,
      addIcon: bridge.addIcon,
      addMenuButton: bridge.addMenuButton,
      addMenuItem: bridge.addMenuItem,
      addNestedMenuItem: bridge.addNestedMenuItem,
      addSidebar: bridge.addSidebar,
      addSplitButton: bridge.addSplitButton,
      addToggleButton: bridge.addToggleButton,
      addGroupToolbarButton: bridge.addGroupToolbarButton,
      addToggleMenuItem: bridge.addToggleMenuItem,
      addView: bridge.addView,
      addContext: bridge.addContext,
      getAll: bridge.getAll,
    };
  };

  const DOM$1 = DOMUtils.DOM;
  const extend = Tools.extend,
    each$1 = Tools.each;
  class Editor {
    constructor(id, options, editorManager) {
      this.plugins = {};
      this.contentCSS = [];
      this.contentStyles = [];
      this.loadedCSS = {};
      this.isNotDirty = false;
      this.composing = false;
      this.destroyed = false;
      this.hasHiddenInput = false;
      this.iframeElement = null;
      this.initialized = false;
      this.readonly = false;
      this.removed = false;
      this.startContent = "";
      this._pendingNativeEvents = [];
      this._skinLoaded = false;
      this._editableRoot = true;
      this.editorManager = editorManager;
      this.documentBaseUrl = editorManager.documentBaseURL;
      extend(this, EditorObservable);
      const self = this;
      this.id = id;
      this.hidden = false;
      const normalizedOptions = normalizeOptions(
        editorManager.defaultOptions,
        options
      );
      this.options = create$5(self, normalizedOptions, options);
      register$7(self);
      const getOption = this.options.get;
      if (getOption("deprecation_warnings")) {
        logWarnings(options, normalizedOptions);
      }
      const suffix = getOption("suffix");
      if (suffix) {
        editorManager.suffix = suffix;
      }
      this.suffix = editorManager.suffix;
      const baseUrl = getOption("base_url");
      if (baseUrl) {
        editorManager._setBaseUrl(baseUrl);
      }
      this.baseUri = editorManager.baseURI;
      const referrerPolicy = getReferrerPolicy(self);
      if (referrerPolicy) {
        ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
        DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
      }
      const contentCssCors = hasContentCssCors(self);
      if (isNonNullable(contentCssCors)) {
        DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
      }
      AddOnManager.languageLoad = getOption("language_load");
      AddOnManager.baseURL = editorManager.baseURL;
      this.setDirty(false);
      this.documentBaseURI = new URI(getDocumentBaseUrl(self), {
        base_uri: this.baseUri,
      });
      this.baseURI = this.baseUri;
      this.inline = isInline$1(self);
      this.hasVisual = isVisualAidsEnabled(self);
      this.shortcuts = new Shortcuts(this);
      this.editorCommands = new EditorCommands(this);
      registerCommands(this);
      const cacheSuffix = getOption("cache_suffix");
      if (cacheSuffix) {
        Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, "");
      }
      this.ui = {
        registry: registry(),
        styleSheetLoader: undefined,
        show: noop,
        hide: noop,
        setEnabled: noop,
        isEnabled: always,
      };
      this.mode = create$4(self);
      editorManager.dispatch("SetupEditor", { editor: this });
      const setupCallback = getSetupCallback(self);
      if (isFunction(setupCallback)) {
        setupCallback.call(self, self);
      }
    }
    render() {
      render(this);
    }
    focus(skipFocus) {
      this.execCommand("mceFocus", false, skipFocus);
    }
    hasFocus() {
      return hasFocus(this);
    }
    translate(text) {
      return I18n.translate(text);
    }
    getParam(name, defaultVal, type) {
      const options = this.options;
      if (!options.isRegistered(name)) {
        if (isNonNullable(type)) {
          options.register(name, {
            processor: type,
            default: defaultVal,
          });
        } else {
          options.register(name, {
            processor: always,
            default: defaultVal,
          });
        }
      }
      return !options.isSet(name) && !isUndefined(defaultVal)
        ? defaultVal
        : options.get(name);
    }
    hasPlugin(name, loaded) {
      const hasPlugin = contains$2(getPlugins(this), name);
      if (hasPlugin) {
        return loaded ? PluginManager.get(name) !== undefined : true;
      } else {
        return false;
      }
    }
    nodeChanged(args) {
      this._nodeChangeDispatcher.nodeChanged(args);
    }
    addCommand(name, callback, scope) {
      this.editorCommands.addCommand(name, callback, scope);
    }
    addQueryStateHandler(name, callback, scope) {
      this.editorCommands.addQueryStateHandler(name, callback, scope);
    }
    addQueryValueHandler(name, callback, scope) {
      this.editorCommands.addQueryValueHandler(name, callback, scope);
    }
    addShortcut(pattern, desc, cmdFunc, scope) {
      this.shortcuts.add(pattern, desc, cmdFunc, scope);
    }
    execCommand(cmd, ui, value, args) {
      return this.editorCommands.execCommand(cmd, ui, value, args);
    }
    queryCommandState(cmd) {
      return this.editorCommands.queryCommandState(cmd);
    }
    queryCommandValue(cmd) {
      return this.editorCommands.queryCommandValue(cmd);
    }
    queryCommandSupported(cmd) {
      return this.editorCommands.queryCommandSupported(cmd);
    }
    show() {
      const self = this;
      if (self.hidden) {
        self.hidden = false;
        if (self.inline) {
          self.getBody().contentEditable = "true";
        } else {
          DOM$1.show(self.getContainer());
          DOM$1.hide(self.id);
        }
        self.load();
        self.dispatch("show");
      }
    }
    hide() {
      const self = this;
      if (!self.hidden) {
        self.save();
        if (self.inline) {
          self.getBody().contentEditable = "false";
          if (self === self.editorManager.focusedEditor) {
            self.editorManager.focusedEditor = null;
          }
        } else {
          DOM$1.hide(self.getContainer());
          DOM$1.setStyle(self.id, "display", self.orgDisplay);
        }
        self.hidden = true;
        self.dispatch("hide");
      }
    }
    isHidden() {
      return this.hidden;
    }
    setProgressState(state, time) {
      this.dispatch("ProgressState", {
        state,
        time,
      });
    }
    load(args = {}) {
      const self = this;
      const elm = self.getElement();
      if (self.removed) {
        return "";
      }
      if (elm) {
        const loadArgs = {
          ...args,
          load: true,
        };
        const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
        const html = self.setContent(value, loadArgs);
        if (!loadArgs.no_events) {
          self.dispatch("LoadContent", {
            ...loadArgs,
            element: elm,
          });
        }
        return html;
      } else {
        return "";
      }
    }
    save(args = {}) {
      const self = this;
      let elm = self.getElement();
      if (!elm || !self.initialized || self.removed) {
        return "";
      }
      const getArgs = {
        ...args,
        save: true,
        element: elm,
      };
      let html = self.getContent(getArgs);
      const saveArgs = {
        ...getArgs,
        content: html,
      };
      if (!saveArgs.no_events) {
        self.dispatch("SaveContent", saveArgs);
      }
      if (saveArgs.format === "raw") {
        self.dispatch("RawSaveContent", saveArgs);
      }
      html = saveArgs.content;
      if (!isTextareaOrInput(elm)) {
        if (args.is_removing || !self.inline) {
          elm.innerHTML = html;
        }
        const form = DOM$1.getParent(self.id, "form");
        if (form) {
          each$1(form.elements, (elm) => {
            if (elm.name === self.id) {
              elm.value = html;
              return false;
            } else {
              return true;
            }
          });
        }
      } else {
        elm.value = html;
      }
      saveArgs.element = getArgs.element = elm = null;
      if (saveArgs.set_dirty !== false) {
        self.setDirty(false);
      }
      return html;
    }
    setContent(content, args) {
      return setContent(this, content, args);
    }
    getContent(args) {
      return getContent(this, args);
    }
    insertContent(content, args) {
      if (args) {
        content = extend({ content }, args);
      }
      this.execCommand("mceInsertContent", false, content);
    }
    resetContent(initialContent) {
      if (initialContent === undefined) {
        setContent(this, this.startContent, { format: "raw" });
      } else {
        setContent(this, initialContent);
      }
      this.undoManager.reset();
      this.setDirty(false);
      this.nodeChanged();
    }
    isDirty() {
      return !this.isNotDirty;
    }
    setDirty(state) {
      const oldState = !this.isNotDirty;
      this.isNotDirty = !state;
      if (state && state !== oldState) {
        this.dispatch("dirty");
      }
    }
    getContainer() {
      const self = this;
      if (!self.container) {
        self.container = self.editorContainer || DOM$1.get(self.id + "_parent");
      }
      return self.container;
    }
    getContentAreaContainer() {
      return this.contentAreaContainer;
    }
    getElement() {
      if (!this.targetElm) {
        this.targetElm = DOM$1.get(this.id);
      }
      return this.targetElm;
    }
    getWin() {
      const self = this;
      if (!self.contentWindow) {
        const elm = self.iframeElement;
        if (elm) {
          self.contentWindow = elm.contentWindow;
        }
      }
      return self.contentWindow;
    }
    getDoc() {
      const self = this;
      if (!self.contentDocument) {
        const win = self.getWin();
        if (win) {
          self.contentDocument = win.document;
        }
      }
      return self.contentDocument;
    }
    getBody() {
      var _a, _b;
      const doc = this.getDoc();
      return (_b =
        (_a = this.bodyElement) !== null && _a !== void 0
          ? _a
          : doc === null || doc === void 0
          ? void 0
          : doc.body) !== null && _b !== void 0
        ? _b
        : null;
    }
    convertURL(url, name, elm) {
      const self = this,
        getOption = self.options.get;
      const urlConverterCallback = getUrlConverterCallback(self);
      if (isFunction(urlConverterCallback)) {
        return urlConverterCallback.call(self, url, elm, true, name);
      }
      if (
        !getOption("convert_urls") ||
        elm === "link" ||
        (isObject(elm) && elm.nodeName === "LINK") ||
        url.indexOf("file:") === 0 ||
        url.length === 0
      ) {
        return url;
      }
      const urlObject = new URI(url);
      if (
        urlObject.protocol !== "http" &&
        urlObject.protocol !== "https" &&
        urlObject.protocol !== ""
      ) {
        return url;
      }
      if (getOption("relative_urls")) {
        return self.documentBaseURI.toRelative(url);
      }
      url = self.documentBaseURI.toAbsolute(
        url,
        getOption("remove_script_host")
      );
      return url;
    }
    addVisual(elm) {
      addVisual(this, elm);
    }
    setEditableRoot(state) {
      setEditableRoot(this, state);
    }
    hasEditableRoot() {
      return hasEditableRoot(this);
    }
    remove() {
      remove$1(this);
    }
    destroy(automatic) {
      destroy(this, automatic);
    }
    uploadImages() {
      return this.editorUpload.uploadImages();
    }
    _scanForImages() {
      return this.editorUpload.scanForImages();
    }
  }

  const DOM = DOMUtils.DOM;
  const each = Tools.each;
  let boundGlobalEvents = false;
  let beforeUnloadDelegate;
  let editors = [];
  const globalEventDelegate = (e) => {
    const type = e.type;
    each(EditorManager.get(), (editor) => {
      switch (type) {
        case "scroll":
          editor.dispatch("ScrollWindow", e);
          break;
        case "resize":
          editor.dispatch("ResizeWindow", e);
          break;
      }
    });
  };
  const toggleGlobalEvents = (state) => {
    if (state !== boundGlobalEvents) {
      const DOM = DOMUtils.DOM;
      if (state) {
        DOM.bind(window, "resize", globalEventDelegate);
        DOM.bind(window, "scroll", globalEventDelegate);
      } else {
        DOM.unbind(window, "resize", globalEventDelegate);
        DOM.unbind(window, "scroll", globalEventDelegate);
      }
      boundGlobalEvents = state;
    }
  };
  const removeEditorFromList = (targetEditor) => {
    const oldEditors = editors;
    editors = filter$5(editors, (editor) => {
      return targetEditor !== editor;
    });
    if (EditorManager.activeEditor === targetEditor) {
      EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
    }
    if (EditorManager.focusedEditor === targetEditor) {
      EditorManager.focusedEditor = null;
    }
    return oldEditors.length !== editors.length;
  };
  const purgeDestroyedEditor = (editor) => {
    if (
      editor &&
      editor.initialized &&
      !(editor.getContainer() || editor.getBody()).parentNode
    ) {
      removeEditorFromList(editor);
      editor.unbindAllNativeEvents();
      editor.destroy(true);
      editor.removed = true;
    }
  };
  const isQuirksMode = document.compatMode !== "CSS1Compat";
  const EditorManager = {
    ...Observable,
    baseURI: null,
    baseURL: null,
    defaultOptions: {},
    documentBaseURL: null,
    suffix: null,
    majorVersion: "7",
    minorVersion: "7.1",
    releaseDate: "2025-03-05",
    i18n: I18n,
    activeEditor: null,
    focusedEditor: null,
    setup() {
      const self = this;
      let baseURL = "";
      let suffix = "";
      let documentBaseURL = URI.getDocumentBaseUrl(document.location);
      if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
        documentBaseURL = documentBaseURL
          .replace(/[\?#].*$/, "")
          .replace(/[\/\\][^\/]+$/, "");
        if (!/[\/\\]$/.test(documentBaseURL)) {
          documentBaseURL += "/";
        }
      }
      const preInit = window.tinymce || window.tinyMCEPreInit;
      if (preInit) {
        baseURL = preInit.base || preInit.baseURL;
        suffix = preInit.suffix;
      } else {
        const scripts = document.getElementsByTagName("script");
        for (let i = 0; i < scripts.length; i++) {
          const src = scripts[i].src || "";
          if (src === "") {
            continue;
          }
          const srcScript = src.substring(src.lastIndexOf("/"));
          if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
            if (srcScript.indexOf(".min") !== -1) {
              suffix = ".min";
            }
            baseURL = src.substring(0, src.lastIndexOf("/"));
            break;
          }
        }
        if (!baseURL && document.currentScript) {
          const src = document.currentScript.src;
          if (src.indexOf(".min") !== -1) {
            suffix = ".min";
          }
          baseURL = src.substring(0, src.lastIndexOf("/"));
        }
      }
      self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
      self.documentBaseURL = documentBaseURL;
      self.baseURI = new URI(self.baseURL);
      self.suffix = suffix;
      setup$w(self);
    },
    overrideDefaults(defaultOptions) {
      const baseUrl = defaultOptions.base_url;
      if (baseUrl) {
        this._setBaseUrl(baseUrl);
      }
      const suffix = defaultOptions.suffix;
      if (suffix) {
        this.suffix = suffix;
      }
      this.defaultOptions = defaultOptions;
      const pluginBaseUrls = defaultOptions.plugin_base_urls;
      if (pluginBaseUrls !== undefined) {
        each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
          AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
        });
      }
    },
    init(options) {
      const self = this;
      let result;
      const invalidInlineTargets = Tools.makeMap(
        "area base basefont br col frame hr img input isindex link meta param embed source wbr track " +
          "colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu",
        " "
      );
      const isInvalidInlineTarget = (options, elm) =>
        options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
      const createId = (elm) => {
        let id = elm.id;
        if (!id) {
          id = get$a(elm, "name")
            .filter((name) => !DOM.get(name))
            .getOrThunk(DOM.uniqueId);
          elm.setAttribute("id", id);
        }
        return id;
      };
      const execCallback = (name) => {
        const callback = options[name];
        if (!callback) {
          return;
        }
        return callback.apply(self, []);
      };
      const findTargets = (options) => {
        if (Env.browser.isIE() || Env.browser.isEdge()) {
          initError(
            "TinyMCE does not support the browser you are using. For a list of supported" +
              " browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers"
          );
          return [];
        } else if (isQuirksMode) {
          initError(
            "Failed to initialize the editor as the document is not in standards mode. " +
              "TinyMCE requires standards mode."
          );
          return [];
        } else if (isString(options.selector)) {
          return DOM.select(options.selector);
        } else if (isNonNullable(options.target)) {
          return [options.target];
        } else {
          return [];
        }
      };
      let provideResults = (editors) => {
        result = editors;
      };
      const initEditors = () => {
        let initCount = 0;
        const editors = [];
        let targets;
        const createEditor = (id, options, targetElm) => {
          const editor = new Editor(id, options, self);
          editors.push(editor);
          editor.on("init", () => {
            if (++initCount === targets.length) {
              provideResults(editors);
            }
          });
          editor.targetElm = editor.targetElm || targetElm;
          editor.render();
        };
        DOM.unbind(window, "ready", initEditors);
        execCallback("onpageload");
        targets = unique$1(findTargets(options));
        Tools.each(targets, (elm) => {
          purgeDestroyedEditor(self.get(elm.id));
        });
        targets = Tools.grep(targets, (elm) => {
          return !self.get(elm.id);
        });
        if (targets.length === 0) {
          provideResults([]);
        } else {
          each(targets, (elm) => {
            if (isInvalidInlineTarget(options, elm)) {
              initError(
                "Could not initialize inline editor on invalid inline target element",
                elm
              );
            } else {
              createEditor(createId(elm), options, elm);
            }
          });
        }
      };
      DOM.bind(window, "ready", initEditors);
      return new Promise((resolve) => {
        if (result) {
          resolve(result);
        } else {
          provideResults = (editors) => {
            resolve(editors);
          };
        }
      });
    },
    get(id) {
      if (arguments.length === 0) {
        return editors.slice(0);
      } else if (isString(id)) {
        return find$2(editors, (editor) => {
          return editor.id === id;
        }).getOr(null);
      } else if (isNumber(id)) {
        return editors[id] ? editors[id] : null;
      } else {
        return null;
      }
    },
    add(editor) {
      const self = this;
      const existingEditor = self.get(editor.id);
      if (existingEditor === editor) {
        return editor;
      }
      if (existingEditor === null) {
        editors.push(editor);
      }
      toggleGlobalEvents(true);
      self.activeEditor = editor;
      self.dispatch("AddEditor", { editor });
      if (!beforeUnloadDelegate) {
        beforeUnloadDelegate = (e) => {
          const event = self.dispatch("BeforeUnload");
          if (event.returnValue) {
            e.preventDefault();
            e.returnValue = event.returnValue;
            return event.returnValue;
          }
        };
        window.addEventListener("beforeunload", beforeUnloadDelegate);
      }
      return editor;
    },
    createEditor(id, options) {
      return this.add(new Editor(id, options, this));
    },
    remove(selector) {
      const self = this;
      let editor;
      if (!selector) {
        for (let i = editors.length - 1; i >= 0; i--) {
          self.remove(editors[i]);
        }
        return;
      }
      if (isString(selector)) {
        each(DOM.select(selector), (elm) => {
          editor = self.get(elm.id);
          if (editor) {
            self.remove(editor);
          }
        });
        return;
      }
      editor = selector;
      if (isNull(self.get(editor.id))) {
        return null;
      }
      if (removeEditorFromList(editor)) {
        self.dispatch("RemoveEditor", { editor });
      }
      if (editors.length === 0) {
        window.removeEventListener("beforeunload", beforeUnloadDelegate);
      }
      editor.remove();
      toggleGlobalEvents(editors.length > 0);
      return editor;
    },
    execCommand(cmd, ui, value) {
      var _a;
      const self = this;
      const editorId = isObject(value)
        ? (_a = value.id) !== null && _a !== void 0
          ? _a
          : value.index
        : value;
      switch (cmd) {
        case "mceAddEditor": {
          if (!self.get(editorId)) {
            const editorOptions = value.options;
            new Editor(editorId, editorOptions, self).render();
          }
          return true;
        }
        case "mceRemoveEditor": {
          const editor = self.get(editorId);
          if (editor) {
            editor.remove();
          }
          return true;
        }
        case "mceToggleEditor": {
          const editor = self.get(editorId);
          if (!editor) {
            self.execCommand("mceAddEditor", false, value);
            return true;
          }
          if (editor.isHidden()) {
            editor.show();
          } else {
            editor.hide();
          }
          return true;
        }
      }
      if (self.activeEditor) {
        return self.activeEditor.execCommand(cmd, ui, value);
      }
      return false;
    },
    triggerSave: () => {
      each(editors, (editor) => {
        editor.save();
      });
    },
    addI18n: (code, items) => {
      I18n.add(code, items);
    },
    translate: (text) => {
      return I18n.translate(text);
    },
    setActive(editor) {
      const activeEditor = this.activeEditor;
      if (this.activeEditor !== editor) {
        if (activeEditor) {
          activeEditor.dispatch("deactivate", { relatedTarget: editor });
        }
        editor.dispatch("activate", { relatedTarget: activeEditor });
      }
      this.activeEditor = editor;
    },
    _setBaseUrl(baseUrl) {
      this.baseURL = new URI(this.documentBaseURL).toAbsolute(
        baseUrl.replace(/\/+$/, "")
      );
      this.baseURI = new URI(this.baseURL);
    },
  };
  EditorManager.setup();

  const setup = () => {
    const dataValue = value$2();
    const FakeClipboardItem = (items) => ({
      items,
      types: keys(items),
      getType: (type) => get$a(items, type).getOrUndefined(),
    });
    const write = (data) => {
      dataValue.set(data);
    };
    const read = () => dataValue.get().getOrUndefined();
    const clear = dataValue.clear;
    return {
      FakeClipboardItem,
      write,
      read,
      clear,
    };
  };
  const FakeClipboard = setup();

  const min = Math.min,
    max = Math.max,
    round = Math.round;
  const relativePosition = (rect, targetRect, rel) => {
    let x = targetRect.x;
    let y = targetRect.y;
    const w = rect.w;
    const h = rect.h;
    const targetW = targetRect.w;
    const targetH = targetRect.h;
    const relChars = (rel || "").split("");
    if (relChars[0] === "b") {
      y += targetH;
    }
    if (relChars[1] === "r") {
      x += targetW;
    }
    if (relChars[0] === "c") {
      y += round(targetH / 2);
    }
    if (relChars[1] === "c") {
      x += round(targetW / 2);
    }
    if (relChars[3] === "b") {
      y -= h;
    }
    if (relChars[4] === "r") {
      x -= w;
    }
    if (relChars[3] === "c") {
      y -= round(h / 2);
    }
    if (relChars[4] === "c") {
      x -= round(w / 2);
    }
    return create$2(x, y, w, h);
  };
  const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
    for (let i = 0; i < rels.length; i++) {
      const pos = relativePosition(rect, targetRect, rels[i]);
      if (
        pos.x >= constrainRect.x &&
        pos.x + pos.w <= constrainRect.w + constrainRect.x &&
        pos.y >= constrainRect.y &&
        pos.y + pos.h <= constrainRect.h + constrainRect.y
      ) {
        return rels[i];
      }
    }
    return null;
  };
  const inflate = (rect, w, h) => {
    return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
  };
  const intersect = (rect, cropRect) => {
    const x1 = max(rect.x, cropRect.x);
    const y1 = max(rect.y, cropRect.y);
    const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
    const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
    if (x2 - x1 < 0 || y2 - y1 < 0) {
      return null;
    }
    return create$2(x1, y1, x2 - x1, y2 - y1);
  };
  const clamp = (rect, clampRect, fixedSize) => {
    let x1 = rect.x;
    let y1 = rect.y;
    let x2 = rect.x + rect.w;
    let y2 = rect.y + rect.h;
    const cx2 = clampRect.x + clampRect.w;
    const cy2 = clampRect.y + clampRect.h;
    const underflowX1 = max(0, clampRect.x - x1);
    const underflowY1 = max(0, clampRect.y - y1);
    const overflowX2 = max(0, x2 - cx2);
    const overflowY2 = max(0, y2 - cy2);
    x1 += underflowX1;
    y1 += underflowY1;
    if (fixedSize) {
      x2 += underflowX1;
      y2 += underflowY1;
      x1 -= overflowX2;
      y1 -= overflowY2;
    }
    x2 -= overflowX2;
    y2 -= overflowY2;
    return create$2(x1, y1, x2 - x1, y2 - y1);
  };
  const create$2 = (x, y, w, h) => {
    return {
      x,
      y,
      w,
      h,
    };
  };
  const fromClientRect = (clientRect) => {
    return create$2(
      clientRect.left,
      clientRect.top,
      clientRect.width,
      clientRect.height
    );
  };
  const Rect = {
    inflate,
    relativePosition,
    findBestRelativePosition,
    intersect,
    clamp,
    create: create$2,
    fromClientRect,
  };

  const awaiter = (resolveCb, rejectCb, timeout = 1000) => {
    let done = false;
    let timer = null;
    const complete =
      (completer) =>
      (...args) => {
        if (!done) {
          done = true;
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }
          completer.apply(null, args);
        }
      };
    const resolve = complete(resolveCb);
    const reject = complete(rejectCb);
    const start = (...args) => {
      if (!done && timer === null) {
        timer = setTimeout(() => reject.apply(null, args), timeout);
      }
    };
    return {
      start,
      resolve,
      reject,
    };
  };
  const create$1 = () => {
    const tasks = {};
    const resultFns = {};
    const resources = {};
    const load = (id, url) => {
      const loadErrMsg = `Script at URL "${url}" failed to load`;
      const runErrMsg = `Script at URL "${url}" did not call \`tinymce.Resource.add('${id}', data)\` within 1 second`;
      if (tasks[id] !== undefined) {
        return tasks[id];
      } else {
        const task = new Promise((resolve, reject) => {
          const waiter = awaiter(resolve, reject);
          resultFns[id] = waiter.resolve;
          ScriptLoader.ScriptLoader.loadScript(url).then(
            () => waiter.start(runErrMsg),
            () => waiter.reject(loadErrMsg)
          );
        });
        tasks[id] = task;
        return task;
      }
    };
    const add = (id, data) => {
      if (resultFns[id] !== undefined) {
        resultFns[id](data);
        delete resultFns[id];
      }
      tasks[id] = Promise.resolve(data);
      resources[id] = data;
    };
    const has = (id) => {
      return id in resources;
    };
    const unload = (id) => {
      delete tasks[id];
      delete resources[id];
    };
    const get = (id) => resources[id];
    return {
      load,
      add,
      has,
      get,
      unload,
    };
  };
  const Resource = create$1();

  const create = () =>
    (() => {
      let data = {};
      let keys = [];
      const storage = {
        getItem: (key) => {
          const item = data[key];
          return item ? item : null;
        },
        setItem: (key, value) => {
          keys.push(key);
          data[key] = String(value);
        },
        key: (index) => {
          return keys[index];
        },
        removeItem: (key) => {
          keys = keys.filter((k) => k === key);
          delete data[key];
        },
        clear: () => {
          keys = [];
          data = {};
        },
        length: 0,
      };
      Object.defineProperty(storage, "length", {
        get: () => keys.length,
        configurable: false,
        enumerable: false,
      });
      return storage;
    })();

  let localStorage;
  try {
    const test = "__storage_test__";
    localStorage = window.localStorage;
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
  } catch (_a) {
    localStorage = create();
  }
  var LocalStorage = localStorage;

  const publicApi = {
    geom: { Rect },
    util: {
      Delay,
      Tools,
      VK,
      URI,
      EventDispatcher,
      Observable,
      I18n,
      LocalStorage,
      ImageUploader,
    },
    dom: {
      EventUtils,
      TreeWalker: DomTreeWalker,
      TextSeeker,
      DOMUtils,
      ScriptLoader,
      RangeUtils,
      Serializer: DomSerializer,
      StyleSheetLoader,
      ControlSelection,
      BookmarkManager,
      Selection: EditorSelection,
      Event: EventUtils.Event,
    },
    html: {
      Styles,
      Entities,
      Node: AstNode,
      Schema,
      DomParser,
      Writer,
      Serializer: HtmlSerializer,
    },
    Env,
    AddOnManager,
    Annotator,
    Formatter,
    UndoManager,
    EditorCommands,
    WindowManager,
    NotificationManager,
    EditorObservable,
    Shortcuts,
    Editor,
    FocusManager,
    EditorManager,
    DOM: DOMUtils.DOM,
    ScriptLoader: ScriptLoader.ScriptLoader,
    PluginManager,
    ThemeManager,
    ModelManager,
    IconManager,
    Resource,
    FakeClipboard,
    trim: Tools.trim,
    isArray: Tools.isArray,
    is: Tools.is,
    toArray: Tools.toArray,
    makeMap: Tools.makeMap,
    each: Tools.each,
    map: Tools.map,
    grep: Tools.grep,
    inArray: Tools.inArray,
    extend: Tools.extend,
    walk: Tools.walk,
    resolve: Tools.resolve,
    explode: Tools.explode,
    _addCacheSuffix: Tools._addCacheSuffix,
  };
  const tinymce$1 = Tools.extend(EditorManager, publicApi);

  const exportToModuleLoaders = (tinymce) => {
    if (typeof module === "object") {
      try {
        module.exports = tinymce;
      } catch (_a) {}
    }
  };
  const exportToWindowGlobal = (tinymce) => {
    window.tinymce = tinymce;
    window.tinyMCE = tinymce;
  };
  exportToWindowGlobal(tinymce$1);
  exportToModuleLoaders(tinymce$1);
})();

/*!
 * Lightbox v2.9.0
 * by Lokesh Dhakar
 *
 * More info:
 * http://lokeshdhakar.com/projects/lightbox2/
 *
 * Copyright 2007, 2015 Lokesh Dhakar
 * Released under the MIT license
 * https://github.com/lokesh/lightbox2/blob/master/LICENSE
 */

// Uses Node, AMD or browser globals to create a module.
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery"], factory);
  } else if (typeof exports === "object") {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    // Browser globals (root is window)
    root.lightbox = factory(root.jQuery);
  }
})(this, function ($) {
  function Lightbox(options) {
    this.album = [];
    this.currentImageIndex = void 0;
    this.init();

    // options
    this.options = $.extend({}, this.constructor.defaults);
    this.option(options);
  }

  // Descriptions of all options available on the demo site:
  // http://lokeshdhakar.com/projects/lightbox2/index.html#options
  Lightbox.defaults = {
    albumLabel: "Image %1 of %2",
    alwaysShowNavOnTouchDevices: false,
    fadeDuration: 600,
    fitImagesInViewport: true,
    imageFadeDuration: 600,
    // maxWidth: 800,
    // maxHeight: 600,
    positionFromTop: 50,
    resizeDuration: 700,
    showImageNumberLabel: true,
    wrapAround: false,
    disableScrolling: false,
    /*
    Sanitize Title
    If the caption data is trusted, for example you are hardcoding it in, then leave this to false.
    This will free you to add html tags, such as links, in the caption.

    If the caption data is user submitted or from some other untrusted source, then set this to true
    to prevent xss and other injection attacks.
     */
    sanitizeTitle: false,
  };

  Lightbox.prototype.option = function (options) {
    $.extend(this.options, options);
  };

  Lightbox.prototype.imageCountLabel = function (currentImageNum, totalImages) {
    return this.options.albumLabel
      .replace(/%1/g, currentImageNum)
      .replace(/%2/g, totalImages);
  };

  Lightbox.prototype.init = function () {
    var self = this;
    // Both enable and build methods require the body tag to be in the DOM.
    $(document).ready(function () {
      self.enable();
      self.build();
    });
  };

  // Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
  // that contain 'lightbox'. When these are clicked, start lightbox.
  Lightbox.prototype.enable = function () {
    var self = this;
    $("body").on(
      "click",
      "a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]",
      function (event) {
        self.start($(event.currentTarget));
        return false;
      }
    );
  };

  // Build html for the lightbox and the overlay.
  // Attach event handlers to the new DOM elements. click click click
  Lightbox.prototype.build = function () {
    var self = this;
    $(
      '<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>'
    ).appendTo($("body"));

    // Cache jQuery objects
    this.$lightbox = $("#lightbox");
    this.$overlay = $("#lightboxOverlay");
    this.$outerContainer = this.$lightbox.find(".lb-outerContainer");
    this.$container = this.$lightbox.find(".lb-container");
    this.$image = this.$lightbox.find(".lb-image");
    this.$nav = this.$lightbox.find(".lb-nav");

    // Store css values for future lookup
    this.containerPadding = {
      top: parseInt(this.$container.css("padding-top"), 10),
      right: parseInt(this.$container.css("padding-right"), 10),
      bottom: parseInt(this.$container.css("padding-bottom"), 10),
      left: parseInt(this.$container.css("padding-left"), 10),
    };

    this.imageBorderWidth = {
      top: parseInt(this.$image.css("border-top-width"), 10),
      right: parseInt(this.$image.css("border-right-width"), 10),
      bottom: parseInt(this.$image.css("border-bottom-width"), 10),
      left: parseInt(this.$image.css("border-left-width"), 10),
    };

    // Attach event handlers to the newly minted DOM elements
    this.$overlay.hide().on("click", function () {
      self.end();
      return false;
    });

    this.$lightbox.hide().on("click", function (event) {
      if ($(event.target).attr("id") === "lightbox") {
        self.end();
      }
      return false;
    });

    this.$outerContainer.on("click", function (event) {
      if ($(event.target).attr("id") === "lightbox") {
        self.end();
      }
      return false;
    });

    this.$lightbox.find(".lb-prev").on("click", function () {
      var start = Date.now();
      if (self.lastRun !== undefined) {
        var elapsed = start - self.lastRun;
        if (elapsed < 100) {
          self.lastRun = start;
          return false;
        } else {
          self.lastRun = start;
        }
      } else {
        self.lastRun = start;
      }
      if (self.currentImageIndex === 0) {
        self.changeImage(self.album.length - 1);
      } else {
        self.changeImage(self.currentImageIndex - 1);
      }
      return false;
    });

    this.$lightbox.find(".lb-next").on("click", function () {
      var start = new Date();
      if (self.lastRun !== undefined) {
        var elapsed = start - self.lastRun;
        if (elapsed < 100) {
          self.lastRun = start;
          return false;
        } else {
          self.lastRun = start;
        }
      } else {
        self.lastRun = start;
      }
      if (self.currentImageIndex === self.album.length - 1) {
        self.changeImage(0);
      } else {
        self.changeImage(self.currentImageIndex + 1);
      }
      return false;
    });

    /*
      Show context menu for image on right-click

      There is a div containing the navigation that spans the entire image and lives above of it. If
      you right-click, you are right clicking this div and not the image. This prevents users from
      saving the image or using other context menu actions with the image.

      To fix this, when we detect the right mouse button is pressed down, but not yet clicked, we
      set pointer-events to none on the nav div. This is so that the upcoming right-click event on
      the next mouseup will bubble down to the image. Once the right-click/contextmenu event occurs
      we set the pointer events back to auto for the nav div so it can capture hover and left-click
      events as usual.
     */
    this.$nav.on("mousedown", function (event) {
      if (event.which === 3) {
        self.$nav.css("pointer-events", "none");

        self.$lightbox.one("contextmenu", function () {
          setTimeout(
            function () {
              this.$nav.css("pointer-events", "auto");
            }.bind(self),
            0
          );
        });
      }
    });

    this.$lightbox.find(".lb-loader, .lb-close").on("click", function () {
      self.end();
      return false;
    });
  };

  // Show overlay and lightbox. If the image is part of a set, add siblings to album array.
  Lightbox.prototype.start = function ($link) {
    var self = this;
    var $window = $(window);

    $window.on("resize", $.proxy(this.sizeOverlay, this));

    $("select, object, embed").css({
      visibility: "hidden",
    });

    this.sizeOverlay();

    this.album = [];
    var imageNumber = 0;

    function addToAlbum($link) {
      self.album.push({
        link: $link.attr("href"),
        title: $link.attr("data-title") || $link.attr("title"),
      });
    }

    // Support both data-lightbox attribute and rel attribute implementations
    var dataLightboxValue = $link.attr("data-lightbox");
    var $links;

    if (dataLightboxValue) {
      $links = $(
        $link.prop("tagName") + '[data-lightbox="' + dataLightboxValue + '"]'
      );
      for (var i = 0; i < $links.length; i = ++i) {
        addToAlbum($($links[i]));
        if ($links[i] === $link[0]) {
          imageNumber = i;
        }
      }
    } else {
      if ($link.attr("rel") === "lightbox") {
        // If image is not part of a set
        addToAlbum($link);
      } else {
        // If image is part of a set
        $links = $($link.prop("tagName") + '[rel="' + $link.attr("rel") + '"]');
        for (var j = 0; j < $links.length; j = ++j) {
          addToAlbum($($links[j]));
          if ($links[j] === $link[0]) {
            imageNumber = j;
          }
        }
      }
    }

    // Position Lightbox
    var top = $window.scrollTop() + this.options.positionFromTop;
    var left = $window.scrollLeft();
    this.$lightbox
      .css({
        top: top + "px",
        left: left + "px",
      })
      .fadeIn(this.options.fadeDuration);

    // Disable scrolling of the page while open
    if (this.options.disableScrolling) {
      $("body").addClass("lb-disable-scrolling");
    }

    this.changeImage(imageNumber);
  };

  // Hide most UI elements in preparation for the animated resizing of the lightbox.
  Lightbox.prototype.changeImage = function (imageNumber) {
    var self = this;

    this.disableKeyboardNav();
    var $image = this.$lightbox.find(".lb-image");

    this.$overlay.fadeIn(this.options.fadeDuration);

    $(".lb-loader").fadeIn("slow");
    this.$lightbox
      .find(
        ".lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption"
      )
      .hide();

    this.$outerContainer.addClass("animating");

    // When image to show is preloaded, we send the width and height to sizeContainer()
    var preloader = new Image();
    preloader.onload = function () {
      var $preloader;
      var imageHeight;
      var imageWidth;
      var maxImageHeight;
      var maxImageWidth;
      var windowHeight;
      var windowWidth;

      $image.attr("src", self.album[imageNumber].link);

      $preloader = $(preloader);

      $image.width(preloader.width);
      $image.height(preloader.height);

      if (self.options.fitImagesInViewport) {
        // Fit image inside the viewport.
        // Take into account the border around the image and an additional 10px gutter on each side.

        windowWidth = $(window).width();
        windowHeight = $(window).height();
        maxImageWidth =
          windowWidth -
          self.containerPadding.left -
          self.containerPadding.right -
          self.imageBorderWidth.left -
          self.imageBorderWidth.right -
          20;
        maxImageHeight =
          windowHeight -
          self.containerPadding.top -
          self.containerPadding.bottom -
          self.imageBorderWidth.top -
          self.imageBorderWidth.bottom -
          120;

        // Check if image size is larger then maxWidth|maxHeight in settings
        if (self.options.maxWidth && self.options.maxWidth < maxImageWidth) {
          maxImageWidth = self.options.maxWidth;
        }
        if (self.options.maxHeight && self.options.maxHeight < maxImageWidth) {
          maxImageHeight = self.options.maxHeight;
        }

        // Is there a fitting issue?
        if (
          preloader.width > maxImageWidth ||
          preloader.height > maxImageHeight
        ) {
          if (
            preloader.width / maxImageWidth >
            preloader.height / maxImageHeight
          ) {
            imageWidth = maxImageWidth;
            imageHeight = parseInt(
              preloader.height / (preloader.width / imageWidth),
              10
            );
            $image.width(imageWidth);
            $image.height(imageHeight);
          } else {
            imageHeight = maxImageHeight;
            imageWidth = parseInt(
              preloader.width / (preloader.height / imageHeight),
              10
            );
            $image.width(imageWidth);
            $image.height(imageHeight);
          }
        }
      }
      self.sizeContainer($image.width(), $image.height());
    };

    preloader.src = this.album[imageNumber].link;
    this.currentImageIndex = imageNumber;
  };

  // Stretch overlay to fit the viewport
  Lightbox.prototype.sizeOverlay = function () {
    this.$overlay.width($(document).width()).height($(document).height());
  };

  // Animate the size of the lightbox to fit the image we are showing
  Lightbox.prototype.sizeContainer = function (imageWidth, imageHeight) {
    var self = this;

    var oldWidth = this.$outerContainer.outerWidth();
    var oldHeight = this.$outerContainer.outerHeight();
    var newWidth =
      imageWidth +
      this.containerPadding.left +
      this.containerPadding.right +
      this.imageBorderWidth.left +
      this.imageBorderWidth.right;
    var newHeight =
      imageHeight +
      this.containerPadding.top +
      this.containerPadding.bottom +
      this.imageBorderWidth.top +
      this.imageBorderWidth.bottom;

    function postResize() {
      self.$lightbox.find(".lb-dataContainer").width(newWidth);
      self.$lightbox.find(".lb-prevLink").height(newHeight);
      self.$lightbox.find(".lb-nextLink").height(newHeight);
      self.showImage();
    }

    if (oldWidth !== newWidth || oldHeight !== newHeight) {
      this.$outerContainer.animate(
        {
          width: newWidth,
          height: newHeight,
        },
        this.options.resizeDuration,
        "swing",
        function () {
          postResize();
        }
      );
    } else {
      postResize();
    }
  };

  // Display the image and its details and begin preload neighboring images.
  Lightbox.prototype.showImage = function () {
    this.$lightbox.find(".lb-loader").stop(true).hide();
    this.$lightbox.find(".lb-image").fadeIn(this.options.imageFadeDuration);

    this.updateNav();
    this.updateDetails();
    this.preloadNeighboringImages();
    this.enableKeyboardNav();
  };

  // Display previous and next navigation if appropriate.
  Lightbox.prototype.updateNav = function () {
    // Check to see if the browser supports touch events. If so, we take the conservative approach
    // and assume that mouse hover events are not supported and always show prev/next navigation
    // arrows in image sets.
    var alwaysShowNav = false;
    try {
      document.createEvent("TouchEvent");
      alwaysShowNav = this.options.alwaysShowNavOnTouchDevices ? true : false;
    } catch (e) {}

    this.$lightbox.find(".lb-nav").show();

    if (this.album.length > 1) {
      if (this.options.wrapAround) {
        if (alwaysShowNav) {
          this.$lightbox.find(".lb-prev, .lb-next").css("opacity", "1");
        }
        this.$lightbox.find(".lb-prev, .lb-next").show();
      } else {
        if (this.currentImageIndex > 0) {
          this.$lightbox.find(".lb-prev").show();
          if (alwaysShowNav) {
            this.$lightbox.find(".lb-prev").css("opacity", "1");
          }
        }
        if (this.currentImageIndex < this.album.length - 1) {
          this.$lightbox.find(".lb-next").show();
          if (alwaysShowNav) {
            this.$lightbox.find(".lb-next").css("opacity", "1");
          }
        }
      }
    }
  };

  // Display caption, image number, and closing button.
  Lightbox.prototype.updateDetails = function () {
    var self = this;

    // Enable anchor clicks in the injected caption html.
    // Thanks Nate Wright for the fix. @https://github.com/NateWr
    if (
      typeof this.album[this.currentImageIndex].title !== "undefined" &&
      this.album[this.currentImageIndex].title !== ""
    ) {
      var $caption = this.$lightbox.find(".lb-caption");
      if (this.options.sanitizeTitle) {
        $caption.text(this.album[this.currentImageIndex].title);
      } else {
        $caption.html(this.album[this.currentImageIndex].title);
      }
      $caption
        .fadeIn("fast")
        .find("a")
        .on("click", function (event) {
          if ($(this).attr("target") !== undefined) {
            window.open($(this).attr("href"), $(this).attr("target"));
          } else {
            location.href = $(this).attr("href");
          }
        });
    }

    if (this.album.length > 1 && this.options.showImageNumberLabel) {
      var labelText = this.imageCountLabel(
        this.currentImageIndex + 1,
        this.album.length
      );
      this.$lightbox.find(".lb-number").text(labelText).fadeIn("fast");
    } else {
      this.$lightbox.find(".lb-number").hide();
    }

    this.$outerContainer.removeClass("animating");

    this.$lightbox
      .find(".lb-dataContainer")
      .fadeIn(this.options.resizeDuration, function () {
        return self.sizeOverlay();
      });
  };

  // Preload previous and next images in set.
  Lightbox.prototype.preloadNeighboringImages = function () {
    if (this.album.length > this.currentImageIndex + 1) {
      var preloadNext = new Image();
      preloadNext.src = this.album[this.currentImageIndex + 1].link;
    }
    if (this.currentImageIndex > 0) {
      var preloadPrev = new Image();
      preloadPrev.src = this.album[this.currentImageIndex - 1].link;
    }
  };

  Lightbox.prototype.enableKeyboardNav = function () {
    $(document).on("keyup.keyboard", $.proxy(this.keyboardAction, this));
  };

  Lightbox.prototype.disableKeyboardNav = function () {
    $(document).off(".keyboard");
  };

  Lightbox.prototype.keyboardAction = function (event) {
    var KEYCODE_ESC = 27;
    var KEYCODE_LEFTARROW = 37;
    var KEYCODE_RIGHTARROW = 39;

    var keycode = event.keyCode;
    var key = String.fromCharCode(keycode).toLowerCase();
    if (keycode === KEYCODE_ESC || key.match(/x|o|c/)) {
      this.end();
    } else if (key === "p" || keycode === KEYCODE_LEFTARROW) {
      var start = new Date();
      if (self.lastRun !== undefined) {
        var elapsed = start - self.lastRun;
        if (elapsed < 100) {
          self.lastRun = start;
          return false;
        } else {
          self.lastRun = start;
        }
      } else {
        self.lastRun = start;
      }
      if (this.currentImageIndex !== 0) {
        this.changeImage(this.currentImageIndex - 1);
      } else if (this.options.wrapAround && this.album.length > 1) {
        this.changeImage(this.album.length - 1);
      }
    } else if (key === "n" || keycode === KEYCODE_RIGHTARROW) {
      var start = new Date();
      if (self.lastRun !== undefined) {
        var elapsed = start - self.lastRun;
        if (elapsed < 100) {
          self.lastRun = start;
          return false;
        } else {
          self.lastRun = start;
        }
      } else {
        self.lastRun = start;
      }
      if (this.currentImageIndex !== this.album.length - 1) {
        this.changeImage(this.currentImageIndex + 1);
      } else if (this.options.wrapAround && this.album.length > 1) {
        this.changeImage(0);
      }
    }
  };

  // Closing time. :-(
  Lightbox.prototype.end = function () {
    this.disableKeyboardNav();
    $(window).off("resize", this.sizeOverlay);
    this.$lightbox.fadeOut(this.options.fadeDuration);
    this.$overlay.fadeOut(this.options.fadeDuration);
    $("select, object, embed").css({
      visibility: "visible",
    });
    if (this.options.disableScrolling) {
      $("body").removeClass("lb-disable-scrolling");
    }
  };

  return new Lightbox();
});
/*!
 * JavaScript Cookie v2.1.4
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function (factory) {
  var registeredInModuleLoader = false;
  if (typeof define === "function" && define.amd) {
    define(factory);
    registeredInModuleLoader = true;
  }
  if (typeof exports === "object") {
    module.exports = factory();
    registeredInModuleLoader = true;
  }
  if (!registeredInModuleLoader) {
    var OldCookies = window.Cookies;
    var api = (window.Cookies = factory());
    api.noConflict = function () {
      window.Cookies = OldCookies;
      return api;
    };
  }
})(function () {
  function extend() {
    var i = 0;
    var result = {};
    for (; i < arguments.length; i++) {
      var attributes = arguments[i];
      for (var key in attributes) {
        result[key] = attributes[key];
      }
    }
    return result;
  }

  function init(converter) {
    function api(key, value, attributes) {
      var result;
      if (typeof document === "undefined") {
        return;
      }

      // Write

      if (arguments.length > 1) {
        attributes = extend(
          {
            path: "/",
          },
          api.defaults,
          attributes
        );

        if (typeof attributes.expires === "number") {
          var expires = new Date();
          expires.setMilliseconds(
            expires.getMilliseconds() + attributes.expires * 864e5
          );
          attributes.expires = expires;
        }

        // We're using "expires" because "max-age" is not supported by IE
        attributes.expires = attributes.expires
          ? attributes.expires.toUTCString()
          : "";

        try {
          result = JSON.stringify(value);
          if (/^[\{\[]/.test(result)) {
            value = result;
          }
        } catch (e) {}

        if (!converter.write) {
          value = encodeURIComponent(String(value)).replace(
            /%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,
            decodeURIComponent
          );
        } else {
          value = converter.write(value, key);
        }

        key = encodeURIComponent(String(key));
        key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
        key = key.replace(/[\(\)]/g, escape);

        var stringifiedAttributes = "";

        for (var attributeName in attributes) {
          if (!attributes[attributeName]) {
            continue;
          }
          stringifiedAttributes += "; " + attributeName;
          if (attributes[attributeName] === true) {
            continue;
          }
          stringifiedAttributes += "=" + attributes[attributeName];
        }
        return (document.cookie = key + "=" + value + stringifiedAttributes);
      }

      // Read

      if (!key) {
        result = {};
      }

      // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all. Also prevents odd result when
      // calling "get()"
      var cookies = document.cookie ? document.cookie.split("; ") : [];
      var rdecode = /(%[0-9A-Z]{2})+/g;
      var i = 0;

      for (; i < cookies.length; i++) {
        var parts = cookies[i].split("=");
        var cookie = parts.slice(1).join("=");

        if (cookie.charAt(0) === '"') {
          cookie = cookie.slice(1, -1);
        }

        try {
          var name = parts[0].replace(rdecode, decodeURIComponent);
          cookie = converter.read
            ? converter.read(cookie, name)
            : converter(cookie, name) ||
              cookie.replace(rdecode, decodeURIComponent);

          if (this.json) {
            try {
              cookie = JSON.parse(cookie);
            } catch (e) {}
          }

          if (key === name) {
            result = cookie;
            break;
          }

          if (!key) {
            result[name] = cookie;
          }
        } catch (e) {}
      }

      return result;
    }

    api.set = api;
    api.get = function (key) {
      return api.call(api, key);
    };
    api.getJSON = function () {
      return api.apply(
        {
          json: true,
        },
        [].slice.call(arguments)
      );
    };
    api.defaults = {};

    api.remove = function (key, attributes) {
      api(
        key,
        "",
        extend(attributes, {
          expires: -1,
        })
      );
    };

    api.withConverter = init;

    return api;
  }

  return init(function () {});
});
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.11.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
    ? define(factory)
    : (global.Popper = factory());
})(this, function () {
  "use strict";

  var nativeHints = ["native code", "[object MutationObserverConstructor]"];

  /**
   * Determine if a function is implemented natively (as opposed to a polyfill).
   * @method
   * @memberof Popper.Utils
   * @argument {Function | undefined} fn the function to check
   * @returns {Boolean}
   */
  var isNative = function (fn) {
    return nativeHints.some(function (hint) {
      return (fn || "").toString().indexOf(hint) > -1;
    });
  };

  var isBrowser = typeof window !== "undefined";
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (
      isBrowser &&
      navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0
    ) {
      timeoutDuration = 1;
      break;
    }
  }

  function microtaskDebounce(fn) {
    var scheduled = false;
    var i = 0;
    var elem = document.createElement("span");

    // MutationObserver provides a mechanism for scheduling microtasks, which
    // are scheduled *before* the next task. This gives us a way to debounce
    // a function but ensure it's called *before* the next paint.
    var observer = new MutationObserver(function () {
      fn();
      scheduled = false;
    });

    observer.observe(elem, { attributes: true });

    return function () {
      if (!scheduled) {
        scheduled = true;
        elem.setAttribute("x-index", i);
        i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8
      }
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  // It's common for MutationObserver polyfills to be seen in the wild, however
  // these rely on Mutation Events which only occur when an element is connected
  // to the DOM. The algorithm used in this module does not use a connected element,
  // and so we must ensure that a *native* MutationObserver is available.
  var supportsNativeMutationObserver =
    isBrowser && isNative(window.MutationObserver);

  /**
   * Create a debounced version of a method, that's asynchronously deferred
   * but called in the minimum time possible.
   *
   * @method
   * @memberof Popper.Utils
   * @argument {Function} fn
   * @returns {Function}
   */
  var debounce = supportsNativeMutationObserver
    ? microtaskDebounce
    : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return (
      functionToCheck &&
      getType.toString.call(functionToCheck) === "[object Function]"
    );
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === "HTML") {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (
      !element ||
      ["HTML", "BODY", "#document"].indexOf(element.nodeName) !== -1
    ) {
      return window.document.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    // NOTE: 1 DOM access here
    var offsetParent = element && element.offsetParent;
    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
      return window.document.documentElement;
    }

    // .offsetParent will return the closest TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (
      ["TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 &&
      getStyleComputedProperty(offsetParent, "position") === "static"
    ) {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === "BODY") {
      return false;
    }
    return (
      nodeName === "HTML" ||
      getOffsetParent(element.firstElementChild) === element
    );
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return window.document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order =
      element1.compareDocumentPosition(element2) &
      Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (
      (element1 !== commonAncestorContainer &&
        element2 !== commonAncestorContainer) ||
      start.contains(end)
    ) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";

    var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
    var nodeName = element.nodeName;

    if (nodeName === "BODY" || nodeName === "HTML") {
      var html = window.document.documentElement;
      var scrollingElement = window.document.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, "top");
    var scrollLeft = getScroll(element, "left");
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === "x" ? "Left" : "Top";
    var sideB = sideA === "Left" ? "Right" : "Bottom";

    return (
      +styles["border" + sideA + "Width"].split("px")[0] +
      +styles["border" + sideB + "Width"].split("px")[0]
    );
  }

  /**
   * Tells if you are running Internet Explorer 10
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean} isIE10
   */
  var isIE10 = undefined;

  var isIE10$1 = function () {
    if (isIE10 === undefined) {
      isIE10 = navigator.appVersion.indexOf("MSIE 10") !== -1;
    }
    return isIE10;
  };

  function getSize(axis, body, html, computedStyle) {
    return Math.max(
      body["offset" + axis],
      html["client" + axis],
      html["offset" + axis],
      isIE10$1()
        ? html["offset" + axis] +
            computedStyle["margin" + (axis === "Height" ? "Top" : "Left")] +
            computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]
        : 0
    );
  }

  function getWindowSizes() {
    var body = window.document.body;
    var html = window.document.documentElement;
    var computedStyle = isIE10$1() && window.getComputedStyle(html);

    return {
      height: getSize("Height", body, html, computedStyle),
      width: getSize("Width", body, html, computedStyle),
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height,
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    if (isIE10$1()) {
      try {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, "top");
        var scrollLeft = getScroll(element, "left");
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } catch (err) {}
    } else {
      rect = element.getBoundingClientRect();
    }

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top,
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === "HTML" ? getWindowSizes() : {};
    var width =
      sizes.width || element.clientWidth || result.right - result.left;
    var height =
      sizes.height || element.clientHeight || result.bottom - result.top;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, "x");
      vertScrollbar -= getBordersSize(styles, "y");

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var isIE10 = isIE10$1();
    var isHTML = parent.nodeName === "HTML";
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = +styles.borderTopWidth.split("px")[0];
    var borderLeftWidth = +styles.borderLeftWidth.split("px")[0];

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height,
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = +styles.marginTop.split("px")[0];
      var marginLeft = +styles.marginLeft.split("px")[0];

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (
      isIE10
        ? parent.contains(scrollParent)
        : parent === scrollParent && scrollParent.nodeName !== "BODY"
    ) {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var html = window.document.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = getScroll(html);
    var scrollLeft = getScroll(html, "left");

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height,
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === "BODY" || nodeName === "HTML") {
      return false;
    }
    if (getStyleComputedProperty(element, "position") === "fixed") {
      return true;
    }
    return isFixed(getParentNode(element));
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    // NOTE: 1 DOM access here
    var boundaries = { top: 0, left: 0 };
    var offsetParent = findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === "viewport") {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === "scrollParent") {
        boundariesNode = getScrollParent(getParentNode(popper));
        if (boundariesNode.nodeName === "BODY") {
          boundariesNode = window.document.documentElement;
        }
      } else if (boundariesElement === "window") {
        boundariesNode = window.document.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(
        boundariesNode,
        offsetParent
      );

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    boundaries.left += padding;
    boundaries.top += padding;
    boundaries.right -= padding;
    boundaries.bottom -= padding;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
      height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(
    placement,
    refRect,
    popper,
    reference,
    boundariesElement
  ) {
    var padding =
      arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf("auto") === -1) {
      return placement;
    }

    var boundaries = getBoundaries(
      popper,
      reference,
      padding,
      boundariesElement
    );

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top,
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height,
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom,
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height,
      },
    };

    var sortedAreas = Object.keys(rects)
      .map(function (key) {
        return _extends(
          {
            key: key,
          },
          rects[key],
          {
            area: getArea(rects[key]),
          }
        );
      })
      .sort(function (a, b) {
        return b.area - a.area;
      });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
        height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement =
      filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split("-")[1];

    return computedPlacement + (variation ? "-" + variation : "");
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var commonOffsetParent = findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x,
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split("-")[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height,
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ["right", "left"].indexOf(placement) !== -1;
    var mainSide = isHoriz ? "top" : "left";
    var secondarySide = isHoriz ? "left" : "top";
    var measurement = isHoriz ? "height" : "width";
    var secondaryMeasurement = !isHoriz ? "height" : "width";

    popperOffsets[mainSide] =
      referenceOffsets[mainSide] +
      referenceOffsets[measurement] / 2 -
      popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] =
        referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] =
        referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun =
      ends === undefined
        ? modifiers
        : modifiers.slice(0, findIndex(modifiers, "name", ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier.function) {
        console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
      }
      var fn = modifier.function || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      attributes: {},
      flipped: false,
      offsets: {},
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(
      this.state,
      this.popper,
      this.reference
    );

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(
      this.options.placement,
      data.offsets.reference,
      this.popper,
      this.reference,
      this.options.modifiers.flip.boundariesElement,
      this.options.modifiers.flip.padding
    );

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(
      this.popper,
      data.offsets.reference,
      data.placement
    );
    data.offsets.popper.position = "absolute";

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
        enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, "ms", "Webkit", "Moz", "O"];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length - 1; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? "" + prefix + upperProp : property;
      if (typeof window.document.body.style[toCheck] !== "undefined") {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroy the popper
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, "applyStyle")) {
      this.popper.removeAttribute("x-placement");
      this.popper.style.left = "";
      this.popper.style.position = "";
      this.popper.style.top = "";
      this.popper.style[getSupportedPropertyName("transform")] = "";
    }

    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === "BODY";
    var target = isBody ? window : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(
        getScrollParent(target.parentNode),
        event,
        callback,
        scrollParents
      );
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    window.addEventListener("resize", state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(
      scrollElement,
      "scroll",
      state.updateBound,
      state.scrollParents
    );
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(
        this.reference,
        this.options,
        this.state,
        this.scheduleUpdate
      );
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    window.removeEventListener("resize", state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener("scroll", state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger onUpdate callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      window.cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = "";
      // add unit if the value is numeric and is one of the following
      if (
        ["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !==
          -1 &&
        isNumeric(styles[prop])
      ) {
        unit = "px";
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if the arrow style has been computed, apply the arrow style
    if (data.offsets.arrow) {
      setStyles(data.arrowElement, data.offsets.arrow);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(
    reference,
    popper,
    options,
    modifierOptions,
    state
  ) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(
      options.placement,
      referenceOffsets,
      popper,
      reference,
      options.modifiers.flip.boundariesElement,
      options.modifiers.flip.padding
    );

    popper.setAttribute("x-placement", placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: "absolute" });

    return options;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
      y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(
      data.instance.modifiers,
      function (modifier) {
        return modifier.name === "applyStyle";
      }
    ).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn(
        "WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!"
      );
    }
    var gpuAcceleration =
      legacyGpuAccelerationOption !== undefined
        ? legacyGpuAccelerationOption
        : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position,
    };

    // floor sides to avoid blurry text
    var offsets = {
      left: Math.floor(popper.left),
      top: Math.floor(popper.top),
      bottom: Math.floor(popper.bottom),
      right: Math.floor(popper.right),
    };

    var sideA = x === "bottom" ? "top" : "bottom";
    var sideB = y === "right" ? "left" : "right";

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName("transform");

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
      top = void 0;
    if (sideA === "bottom") {
      top = -offsetParentRect.height + offsets.bottom;
    } else {
      top = offsets.top;
    }
    if (sideB === "right") {
      left = -offsetParentRect.width + offsets.right;
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] =
        "translate3d(" + left + "px, " + top + "px, 0)";
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = "transform";
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === "bottom" ? -1 : 1;
      var invertLeft = sideB === "right" ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ", " + sideB;
    }

    // Attributes
    var attributes = {
      "x-placement": data.placement,
    };

    // Update attributes and styles of `data`
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired =
      !!requesting &&
      modifiers.some(function (modifier) {
        return (
          modifier.name === requestedName &&
          modifier.enabled &&
          modifier.order < requesting.order
        );
      });

    if (!isRequired) {
      var _requesting = "`" + requestingName + "`";
      var requested = "`" + requestedName + "`";
      console.warn(
        requested +
          " modifier is required by " +
          _requesting +
          " modifier in order to work, be sure to include it before " +
          _requesting +
          "!"
      );
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === "string") {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn(
          "WARNING: `arrow.element` must be child of its popper element!"
        );
        return data;
      }
    }

    var placement = data.placement.split("-")[0];
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

    var isVertical = ["left", "right"].indexOf(placement) !== -1;

    var len = isVertical ? "height" : "width";
    var side = isVertical ? "top" : "left";
    var altSide = isVertical ? "left" : "top";
    var opSide = isVertical ? "bottom" : "right";
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -=
        popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] +=
        reference[side] + arrowElementSize - popper[opSide];
    }

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    var sideValue = center - getClientRect(data.offsets.popper)[side];

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(
      Math.min(popper[len] - arrowElementSize, sideValue),
      0
    );

    data.arrowElement = arrowElement;
    data.offsets.arrow = {};
    data.offsets.arrow[side] = Math.round(sideValue);
    data.offsets.arrow[altSide] = ""; // make sure to unset any eventual altSide value from the DOM node

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === "end") {
      return "start";
    } else if (variation === "start") {
      return "end";
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-right` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = [
    "auto-start",
    "auto",
    "auto-end",
    "top-start",
    "top",
    "top-end",
    "right-start",
    "right",
    "right-end",
    "bottom-end",
    "bottom",
    "bottom-start",
    "left-end",
    "left",
    "left-start",
  ];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements
      .slice(index + 1)
      .concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: "flip",
    CLOCKWISE: "clockwise",
    COUNTERCLOCKWISE: "counterclockwise",
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, "inner")) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(
      data.instance.popper,
      data.instance.reference,
      options.padding,
      options.boundariesElement
    );

    var placement = data.placement.split("-")[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split("-")[1] || "";

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split("-")[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef =
        (placement === "left" &&
          floor(popperOffsets.right) > floor(refOffsets.left)) ||
        (placement === "right" &&
          floor(popperOffsets.left) < floor(refOffsets.right)) ||
        (placement === "top" &&
          floor(popperOffsets.bottom) > floor(refOffsets.top)) ||
        (placement === "bottom" &&
          floor(popperOffsets.top) < floor(refOffsets.bottom));

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom =
        floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries =
        (placement === "left" && overflowsLeft) ||
        (placement === "right" && overflowsRight) ||
        (placement === "top" && overflowsTop) ||
        (placement === "bottom" && overflowsBottom);

      // flip the variation if required
      var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
      var flippedVariation =
        !!options.flipVariations &&
        ((isVertical && variation === "start" && overflowsLeft) ||
          (isVertical && variation === "end" && overflowsRight) ||
          (!isVertical && variation === "start" && overflowsTop) ||
          (!isVertical && variation === "end" && overflowsBottom));

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? "-" + variation : "");

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends(
          {},
          data.offsets.popper,
          getPopperOffsets(
            data.instance.popper,
            data.offsets.reference,
            data.placement
          )
        );

        data = runModifiers(data.instance.modifiers, data, "flip");
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

    var placement = data.placement.split("-")[0];
    var floor = Math.floor;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var side = isVertical ? "right" : "bottom";
    var opSide = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] =
        floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf("%") === 0) {
      var element = void 0;
      switch (unit) {
        case "%p":
          element = popperOffsets;
          break;
        case "%":
        case "%r":
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return (rect[measurement] / 100) * value;
    } else if (unit === "vh" || unit === "vw") {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === "vh") {
        size = Math.max(
          document.documentElement.clientHeight,
          window.innerHeight || 0
        );
      } else {
        size = Math.max(
          document.documentElement.clientWidth,
          window.innerWidth || 0
        );
      }
      return (size / 100) * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(
      find(fragments, function (frag) {
        return frag.search(/,|\s/) !== -1;
      })
    );

    if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
      console.warn(
        "Offsets separated by white space(s) are deprecated, use a comma (,) instead."
      );
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops =
      divider !== -1
        ? [
            fragments
              .slice(0, divider)
              .concat([fragments[divider].split(splitRegex)[0]]),
            [fragments[divider].split(splitRegex)[1]].concat(
              fragments.slice(divider + 1)
            ),
          ]
        : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight)
        ? "height"
        : "width";
      var mergeWithPrevious = false;
      return (
        op
          // This aggregates any `+` or `-` sign that aren't considered operators
          // e.g.: 10 + +5 => [10, +, +5]
          .reduce(function (a, b) {
            if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
              a[a.length - 1] = b;
              mergeWithPrevious = true;
              return a;
            } else if (mergeWithPrevious) {
              a[a.length - 1] += b;
              mergeWithPrevious = false;
              return a;
            } else {
              return a.concat(b);
            }
          }, [])
          // Here we convert the string values into number values (in px)
          .map(function (str) {
            return toValue(str, measurement, popperOffsets, referenceOffsets);
          })
      );
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

    var basePlacement = placement.split("-")[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === "left") {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === "right") {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === "top") {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === "bottom") {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement =
      options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    var boundaries = getBoundaries(
      data.instance.popper,
      data.instance.reference,
      options.padding,
      boundariesElement
    );
    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (
          popper[placement] < boundaries[placement] &&
          !options.escapeWithReference
        ) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === "right" ? "left" : "top";
        var value = popper[mainSide];
        if (
          popper[placement] > boundaries[placement] &&
          !options.escapeWithReference
        ) {
          value = Math.min(
            popper[mainSide],
            boundaries[placement] -
              (placement === "right" ? popper.width : popper.height)
          );
        }
        return defineProperty({}, mainSide, value);
      },
    };

    order.forEach(function (placement) {
      var side =
        ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
      popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split("-")[0];
    var shiftvariation = placement.split("-")[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

      var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
      var side = isVertical ? "left" : "top";
      var measurement = isVertical ? "width" : "height";

      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty(
          {},
          side,
          reference[side] + reference[measurement] - popper[measurement]
        ),
      };

      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (
      !isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")
    ) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === "preventOverflow";
    }).boundaries;

    if (
      refRect.bottom < bound.top ||
      refRect.left > bound.right ||
      refRect.top > bound.bottom ||
      refRect.right < bound.left
    ) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes["x-out-of-boundaries"] = "";
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes["x-out-of-boundaries"] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split("-")[0];
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

    var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;

    var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;

    popper[isHoriz ? "left" : "top"] =
      reference[placement] -
      (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift,
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unitless, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the height.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0,
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * An scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" â or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ["left", "right", "top", "bottom"],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper this makes sure the popper has always a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier, can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: "scrollParent",
    },

    /**
     * Modifier used to make sure the reference and its popper stay near eachothers
     * without leaving any gap between the two. Expecially useful when the arrow is
     * enabled and you want to assure it to point to its reference element.
     * It cares only about the first axis, you can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether,
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjuction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: "[x-arrow]",
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations).
       */
      behavior: "flip",
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position,
       * the popper will never be placed outside of the defined boundaries
       * (except if keepTogether is enabled)
       */
      boundariesElement: "viewport",
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner,
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide,
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: "bottom",
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: "right",
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define you own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: undefined,
    },
  };

  /**
   * The `dataObject` is an object containing all the informations used by Popper.js
   * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overriden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass as 3rd argument an object with the same
   * structure of this object, example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement
     * @prop {Popper.placements} placement='bottom'
     */
    placement: "bottom",

    /**
     * Whether events (resize, scroll) are initially enabled
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated, this callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js
     * @prop {modifiers}
     */
    modifiers: modifiers,
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper = (function () {
    /**
     * Create a new Popper.js instance
     * @class Popper
     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper.
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: [],
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference.jquery ? reference[0] : reference;
      this.popper = popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(
        _extends({}, Popper.Defaults.modifiers, options.modifiers)
      ).forEach(function (name) {
        _this.options.modifiers[name] = _extends(
          {},
          Popper.Defaults.modifiers[name] || {},
          options.modifiers ? options.modifiers[name] : {}
        );
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers)
        .map(function (name) {
          return _extends(
            {
              name: name,
            },
            _this.options.modifiers[name]
          );
        })
        // sort the modifiers by order
        .sort(function (a, b) {
          return a.order - b.order;
        });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(
            _this.reference,
            _this.popper,
            _this.options,
            modifierOptions,
            _this.state
          );
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs

    createClass(Popper, [
      {
        key: "update",
        value: function update$$1() {
          return update.call(this);
        },
      },
      {
        key: "destroy",
        value: function destroy$$1() {
          return destroy.call(this);
        },
      },
      {
        key: "enableEventListeners",
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        },
      },
      {
        key: "disableEventListeners",
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        },

        /**
         * Schedule an update, it will run on the next UI update available
         * @method scheduleUpdate
         * @memberof Popper
         */

        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */
      },
    ]);
    return Popper;
  })();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */

  Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  return Popper;
});

/*!
 * Bootstrap v5.3.3 (https://getbootstrap.com/)
 * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */
(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory(require("@popperjs/core")))
    : typeof define === "function" && define.amd
    ? define(["@popperjs/core"], factory)
    : ((global =
        typeof globalThis !== "undefined" ? globalThis : global || self),
      (global.bootstrap = factory(global.Popper)));
})(this, function (Popper) {
  "use strict";

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, {
      [Symbol.toStringTag]: { value: "Module" },
    });
    if (e) {
      for (const k in e) {
        if (k !== "default") {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(
            n,
            k,
            d.get
              ? d
              : {
                  enumerable: true,
                  get: () => e[k],
                }
          );
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const Popper__namespace = /*#__PURE__*/ _interopNamespaceDefault(Popper);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/data.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const elementMap = new Map();
  const Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, new Map());
      }
      const instanceMap = elementMap.get(element);

      // make it clear we only want one instance per element
      // can be removed later when multiple key/instances are fine to be used
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        // eslint-disable-next-line no-console
        console.error(
          `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
            Array.from(instanceMap.keys())[0]
          }.`
        );
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);

      // free up element references if there are no instances left for an element
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    },
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const MAX_UID = 1000000;
  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = "transitionend";

  /**
   * Properly escape IDs selectors to handle weird IDs
   * @param {string} selector
   * @returns {string}
   */
  const parseSelector = (selector) => {
    if (selector && window.CSS && window.CSS.escape) {
      // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
      selector = selector.replace(
        /#([^\s"#']+)/g,
        (match, id) => `#${CSS.escape(id)}`
      );
    }
    return selector;
  };

  // Shout-out Angus Croll (https://goo.gl/pxwQGp)
  const toType = (object) => {
    if (object === null || object === undefined) {
      return `${object}`;
    }
    return Object.prototype.toString
      .call(object)
      .match(/\s([a-z]+)/i)[1]
      .toLowerCase();
  };

  /**
   * Public Util API
   */

  const getUID = (prefix) => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  const getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }

    // Get transition-duration of the element
    let { transitionDuration, transitionDelay } =
      window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);

    // Return 0 if element or transition duration is not found
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }

    // If multiple durations are defined, take the first
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (
      (Number.parseFloat(transitionDuration) +
        Number.parseFloat(transitionDelay)) *
      MILLISECONDS_MULTIPLIER
    );
  };
  const triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  const isElement = (object) => {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (typeof object.jquery !== "undefined") {
      object = object[0];
    }
    return typeof object.nodeType !== "undefined";
  };
  const getElement = (object) => {
    // it's a jQuery object or a node element
    if (isElement(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === "string" && object.length > 0) {
      return document.querySelector(parseSelector(object));
    }
    return null;
  };
  const isVisible = (element) => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible =
      getComputedStyle(element).getPropertyValue("visibility") === "visible";
    // Handle `details` element as its content may falsie appear visible when it is closed
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest("summary");
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  const isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return (
      element.hasAttribute("disabled") &&
      element.getAttribute("disabled") !== "false"
    );
  };
  const findShadowRoot = (element) => {
    if (!document.documentElement.attachShadow) {
      return null;
    }

    // Can find the shadow root otherwise it'll return the document
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }

    // when we don't find a shadow root
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  const noop = () => {};

  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */
  const reflow = (element) => {
    element.offsetHeight; // eslint-disable-line no-unused-expressions
  };
  const getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return window.jQuery;
    }
    return null;
  };
  const DOMContentLoadedCallbacks = [];
  const onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          for (const callback of DOMContentLoadedCallbacks) {
            callback();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  const isRTL = () => document.documentElement.dir === "rtl";
  const defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  const execute = (
    possibleCallback,
    args = [],
    defaultValue = possibleCallback
  ) => {
    return typeof possibleCallback === "function"
      ? possibleCallback(...args)
      : defaultValue;
  };
  const executeAfterTransition = (
    callback,
    transitionElement,
    waitForTransition = true
  ) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration =
      getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({ target }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };

  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */
  const getNextActiveElement = (
    list,
    activeElement,
    shouldGetNext,
    isCycleAllowed
  ) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);

    // if the element does not exist in the list return an element
    // depending on the direction and if cycle is allowed
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/event-handler.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  const stripNameRegex = /\..*/;
  const stripUidRegex = /::\d+$/;
  const eventRegistry = {}; // Events storage
  let uidEvent = 1;
  const customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout",
  };
  const nativeEvents = new Set([
    "click",
    "dblclick",
    "mouseup",
    "mousedown",
    "contextmenu",
    "mousewheel",
    "DOMMouseScroll",
    "mouseover",
    "mouseout",
    "mousemove",
    "selectstart",
    "selectend",
    "keydown",
    "keypress",
    "keyup",
    "orientationchange",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel",
    "pointerdown",
    "pointermove",
    "pointerup",
    "pointerleave",
    "pointercancel",
    "gesturestart",
    "gesturechange",
    "gestureend",
    "focus",
    "blur",
    "change",
    "reset",
    "select",
    "submit",
    "focusin",
    "focusout",
    "load",
    "unload",
    "beforeunload",
    "resize",
    "move",
    "DOMContentLoaded",
    "readystatechange",
    "error",
    "abort",
    "scroll",
  ]);

  /**
   * Private methods
   */

  function makeEventUid(element, uid) {
    return (uid && `${uid}::${uidEvent++}`) || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element,
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }
      return fn.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (
        let { target } = event;
        target && target !== this;
        target = target.parentNode
      ) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target,
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }
          return fn.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find(
      (event) =>
        event.callable === callable &&
        event.delegationSelector === delegationSelector
    );
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    // TODO: tooltip passes `false` instead of selector, so we need to check
    const callable = isDelegated
      ? delegationFunction
      : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(
    element,
    originalTypeEvent,
    handler,
    delegationFunction,
    oneOff
  ) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(
      originalTypeEvent,
      handler,
      delegationFunction
    );

    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    if (originalTypeEvent in customEvents) {
      const wrapFunction = (fn) => {
        return function (event) {
          if (
            !event.relatedTarget ||
            (event.relatedTarget !== event.delegateTarget &&
              !event.delegateTarget.contains(event.relatedTarget))
          ) {
            return fn.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(
      handlers,
      callable,
      isDelegated ? handler : null
    );
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(
      callable,
      originalTypeEvent.replace(namespaceRegex, "")
    );
    const fn = isDelegated
      ? bootstrapDelegationHandler(element, handler, callable)
      : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
  }
  function removeHandler(
    element,
    events,
    typeEvent,
    handler,
    delegationSelector
  ) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) {
      return;
    }
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        removeHandler(
          element,
          events,
          typeEvent,
          event.callable,
          event.delegationSelector
        );
      }
    }
  }
  function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  const EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(
        originalTypeEvent,
        handler,
        delegationFunction
      );
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof callable !== "undefined") {
        // Simplest case: handler is passed, remove that listener ONLY.
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(
          element,
          events,
          typeEvent,
          callable,
          isDelegated ? handler : null
        );
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(
            element,
            events,
            elementEvent,
            originalTypeEvent.slice(1)
          );
        }
      }
      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          removeHandler(
            element,
            events,
            typeEvent,
            event.callable,
            event.delegationSelector
          );
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      const evt = hydrateObj(
        new Event(event, {
          bubbles,
          cancelable: true,
        }),
        args
      );
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    },
  };
  function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta)) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          },
        });
      }
    }
    return obj;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/manipulator.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  function normalizeData(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === "" || value === "null") {
      return null;
    }
    if (typeof value !== "string") {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  const Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter(
        (key) => key.startsWith("bs") && !key.startsWith("bsConfig")
      );
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, "");
        pureKey =
          pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(
        element.getAttribute(`data-bs-${normalizeDataKey(key)}`)
      );
    },
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/config.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Class definition
   */

  class Config {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error(
        'You have to implement the static method "NAME", for each component!'
      );
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      return config;
    }
    _mergeConfigObj(config, element) {
      const jsonConfig = isElement(element)
        ? Manipulator.getDataAttribute(element, "config")
        : {}; // try to parse

      return {
        ...this.constructor.Default,
        ...(typeof jsonConfig === "object" ? jsonConfig : {}),
        ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),
        ...(typeof config === "object" ? config : {}),
      };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
      for (const [property, expectedTypes] of Object.entries(configTypes)) {
        const value = config[property];
        const valueType = isElement(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(
            `${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`
          );
        }
      }
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap base-component.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const VERSION = "5.3.3";

  /**
   * Class definition
   */

  class BaseComponent extends Config {
    constructor(element, config) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }

    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }

    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return (
        this.getInstance(element) ||
        new this(element, typeof config === "object" ? config : null)
      );
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/selector-engine.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttribute = element.getAttribute("href");

      // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273
      if (
        !hrefAttribute ||
        (!hrefAttribute.includes("#") && !hrefAttribute.startsWith("."))
      ) {
        return null;
      }

      // Just in case some CMS puts out a full URL with the anchor appended
      if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
        hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
      }
      selector =
        hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
    }
    return selector
      ? selector
          .split(",")
          .map((sel) => parseSelector(sel))
          .join(",")
      : null;
  };
  const SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(
        ...Element.prototype.querySelectorAll.call(element, selector)
      );
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return []
        .concat(...element.children)
        .filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = [
        "a",
        "button",
        "input",
        "textarea",
        "select",
        "details",
        "[tabindex]",
        '[contenteditable="true"]',
      ]
        .map((selector) => `${selector}:not([tabindex^="-"])`)
        .join(",");
      return this.find(focusables, element).filter(
        (el) => !isDisabled(el) && isVisible(el)
      );
    },
    getSelectorFromElement(element) {
      const selector = getSelector(element);
      if (selector) {
        return SelectorEngine.findOne(selector) ? selector : null;
      }
      return null;
    },
    getElementFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.find(selector) : [];
    },
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(
      document,
      clickEvent,
      `[data-bs-dismiss="${name}"]`,
      function (event) {
        if (["A", "AREA"].includes(this.tagName)) {
          event.preventDefault();
        }
        if (isDisabled(this)) {
          return;
        }
        const target =
          SelectorEngine.getElementFromSelector(this) ||
          this.closest(`.${name}`);
        const instance = component.getOrCreateInstance(target);

        // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
        instance[method]();
      }
    );
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$f = "alert";
  const DATA_KEY$a = "bs.alert";
  const EVENT_KEY$b = `.${DATA_KEY$a}`;
  const EVENT_CLOSE = `close${EVENT_KEY$b}`;
  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  const CLASS_NAME_FADE$5 = "fade";
  const CLASS_NAME_SHOW$8 = "show";

  /**
   * Class definition
   */

  class Alert extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }

    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        isAnimated
      );
    }

    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Alert.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (
          data[config] === undefined ||
          config.startsWith("_") ||
          config === "constructor"
        ) {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  }

  /**
   * Data API implementation
   */

  enableDismissTrigger(Alert, "close");

  /**
   * jQuery
   */

  defineJQueryPlugin(Alert);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$e = "button";
  const DATA_KEY$9 = "bs.button";
  const EVENT_KEY$a = `.${DATA_KEY$9}`;
  const DATA_API_KEY$6 = ".data-api";
  const CLASS_NAME_ACTIVE$3 = "active";
  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;

  /**
   * Class definition
   */

  class Button extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }

    // Public
    toggle() {
      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
      this._element.setAttribute(
        "aria-pressed",
        this._element.classList.toggle(CLASS_NAME_ACTIVE$3)
      );
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Button.getOrCreateInstance(this);
        if (config === "toggle") {
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API$6,
    SELECTOR_DATA_TOGGLE$5,
    (event) => {
      event.preventDefault();
      const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
      const data = Button.getOrCreateInstance(button);
      data.toggle();
    }
  );

  /**
   * jQuery
   */

  defineJQueryPlugin(Button);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/swipe.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$d = "swipe";
  const EVENT_KEY$9 = ".bs.swipe";
  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  const POINTER_TYPE_TOUCH = "touch";
  const POINTER_TYPE_PEN = "pen";
  const CLASS_NAME_POINTER_EVENT = "pointer-event";
  const SWIPE_THRESHOLD = 40;
  const Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null,
  };
  const DefaultType$c = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)",
  };

  /**
   * Class definition
   */

  class Swipe extends Config {
    constructor(element, config) {
      super();
      this._element = element;
      if (!element || !Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }

    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }

    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }

    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX =
        event.touches && event.touches.length > 1
          ? 0
          : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(
        direction > 0 ? this._config.rightCallback : this._config.leftCallback
      );
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, (event) =>
          this._start(event)
        );
        EventHandler.on(this._element, EVENT_POINTERUP, (event) =>
          this._end(event)
        );
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, (event) =>
          this._start(event)
        );
        EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) =>
          this._move(event)
        );
        EventHandler.on(this._element, EVENT_TOUCHEND, (event) =>
          this._end(event)
        );
      }
    }
    _eventIsPointerPenTouch(event) {
      return (
        this._supportPointerEvents &&
        (event.pointerType === POINTER_TYPE_PEN ||
          event.pointerType === POINTER_TYPE_TOUCH)
      );
    }

    // Static
    static isSupported() {
      return (
        "ontouchstart" in document.documentElement ||
        navigator.maxTouchPoints > 0
      );
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$c = "carousel";
  const DATA_KEY$8 = "bs.carousel";
  const EVENT_KEY$8 = `.${DATA_KEY$8}`;
  const DATA_API_KEY$5 = ".data-api";
  const ARROW_LEFT_KEY$1 = "ArrowLeft";
  const ARROW_RIGHT_KEY$1 = "ArrowRight";
  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  const ORDER_NEXT = "next";
  const ORDER_PREV = "prev";
  const DIRECTION_LEFT = "left";
  const DIRECTION_RIGHT = "right";
  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  const EVENT_SLID = `slid${EVENT_KEY$8}`;
  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const CLASS_NAME_CAROUSEL = "carousel";
  const CLASS_NAME_ACTIVE$2 = "active";
  const CLASS_NAME_SLIDE = "slide";
  const CLASS_NAME_END = "carousel-item-end";
  const CLASS_NAME_START = "carousel-item-start";
  const CLASS_NAME_NEXT = "carousel-item-next";
  const CLASS_NAME_PREV = "carousel-item-prev";
  const SELECTOR_ACTIVE = ".active";
  const SELECTOR_ITEM = ".carousel-item";
  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  const SELECTOR_ITEM_IMG = ".carousel-item img";
  const SELECTOR_INDICATORS = ".carousel-indicators";
  const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  const KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT,
  };
  const Default$b = {
    interval: 5000,
    keyboard: true,
    pause: "hover",
    ride: false,
    touch: true,
    wrap: true,
  };
  const DefaultType$b = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean",
  };

  /**
   * Class definition
   */

  class Carousel extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(
        SELECTOR_INDICATORS,
        this._element
      );
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }

    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }

    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      // FIXME TODO use `document.visibilityState`
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(
        () => this.nextWhenVisible(),
        this._config.interval
      );
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }

    // Private
    _configAfterMerge(config) {
      config.defaultInterval = config.interval;
      return config;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) =>
          this._keydown(event)
        );
      }
      if (this._config.pause === "hover") {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () =>
          this._maybeEnableCycle()
        );
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, (event) =>
          event.preventDefault()
        );
      }
      const endCallBack = () => {
        if (this._config.pause !== "hover") {
          return;
        }

        // If it's a touch-enabled device, mouseenter/leave are fired as
        // part of the mouse compatibility events on first tap - the carousel
        // would stop cycling until user tapped out of it;
        // here, we listen for touchend, explicitly pause the carousel
        // (as if it's the second time we tap on it, mouseenter compat event
        // is NOT fired) and after a timeout (to allow for mouse compatibility
        // events to fire) we explicitly restart cycling

        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(
          () => this._maybeEnableCycle(),
          TOUCHEVENT_COMPAT_WAIT + this._config.interval
        );
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () =>
          this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack,
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(
        SELECTOR_ACTIVE,
        this._indicatorsElement
      );
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute("aria-current");
      const newActiveIndicator = SelectorEngine.findOne(
        `[data-bs-slide-to="${index}"]`,
        this._indicatorsElement
      );
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute("aria-current", "true");
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(
        element.getAttribute("data-bs-interval"),
        10
      );
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext = order === ORDER_NEXT;
      const nextElement =
        element ||
        getNextActiveElement(
          this._getItems(),
          activeElement,
          isNext,
          this._config.wrap
        );
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = (eventName) => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex,
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        // TODO: change tests that use empty divs to avoid this check
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(
          CLASS_NAME_ACTIVE$2,
          orderClassName,
          directionalClassName
        );
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order) {
      if (isRTL()) {
        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Carousel.getOrCreateInstance(this, config);
        if (typeof config === "number") {
          data.to(config);
          return;
        }
        if (typeof config === "string") {
          if (
            data[config] === undefined ||
            config.startsWith("_") ||
            config === "constructor"
          ) {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API$5,
    SELECTOR_DATA_SLIDE,
    function (event) {
      const target = SelectorEngine.getElementFromSelector(this);
      if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
        return;
      }
      event.preventDefault();
      const carousel = Carousel.getOrCreateInstance(target);
      const slideIndex = this.getAttribute("data-bs-slide-to");
      if (slideIndex) {
        carousel.to(slideIndex);
        carousel._maybeEnableCycle();
        return;
      }
      if (Manipulator.getDataAttribute(this, "slide") === "next") {
        carousel.next();
        carousel._maybeEnableCycle();
        return;
      }
      carousel.prev();
      carousel._maybeEnableCycle();
    }
  );
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Carousel);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$b = "collapse";
  const DATA_KEY$7 = "bs.collapse";
  const EVENT_KEY$7 = `.${DATA_KEY$7}`;
  const DATA_API_KEY$4 = ".data-api";
  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  const CLASS_NAME_SHOW$7 = "show";
  const CLASS_NAME_COLLAPSE = "collapse";
  const CLASS_NAME_COLLAPSING = "collapsing";
  const CLASS_NAME_COLLAPSED = "collapsed";
  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  const WIDTH = "width";
  const HEIGHT = "height";
  const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  const Default$a = {
    parent: null,
    toggle: true,
  };
  const DefaultType$a = {
    parent: "(null|element)",
    toggle: "boolean",
  };

  /**
   * Class definition
   */

  class Collapse extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList) {
        const selector = SelectorEngine.getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter(
          (foundElement) => foundElement === this._element
        );
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }

    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }

    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];

      // find active children
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES)
          .filter((element) => element !== this._element)
          .map((element) =>
            Collapse.getOrCreateInstance(element, {
              toggle: false,
            })
          );
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = "";
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension =
        dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${
        this._element.getBoundingClientRect()[dimension]
      }px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = SelectorEngine.getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }

    // Private
    _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle); // Coerce string values
      config.parent = getElement(config.parent);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL)
        ? WIDTH
        : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = SelectorEngine.getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(
        CLASS_NAME_DEEPER_CHILDREN,
        this._config.parent
      );
      // remove children if greater depth
      return SelectorEngine.find(selector, this._config.parent).filter(
        (element) => !children.includes(element)
      );
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute("aria-expanded", isOpen);
      }
    }

    // Static
    static jQueryInterface(config) {
      const _config = {};
      if (typeof config === "string" && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function () {
        const data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API$4,
    SELECTOR_DATA_TOGGLE$4,
    function (event) {
      // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
      if (
        event.target.tagName === "A" ||
        (event.delegateTarget && event.delegateTarget.tagName === "A")
      ) {
        event.preventDefault();
      }
      for (const element of SelectorEngine.getMultipleElementsFromSelector(
        this
      )) {
        Collapse.getOrCreateInstance(element, {
          toggle: false,
        }).toggle();
      }
    }
  );

  /**
   * jQuery
   */

  defineJQueryPlugin(Collapse);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$a = "dropdown";
  const DATA_KEY$6 = "bs.dropdown";
  const EVENT_KEY$6 = `.${DATA_KEY$6}`;
  const DATA_API_KEY$3 = ".data-api";
  const ESCAPE_KEY$2 = "Escape";
  const TAB_KEY$1 = "Tab";
  const ARROW_UP_KEY$1 = "ArrowUp";
  const ARROW_DOWN_KEY$1 = "ArrowDown";
  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const CLASS_NAME_SHOW$6 = "show";
  const CLASS_NAME_DROPUP = "dropup";
  const CLASS_NAME_DROPEND = "dropend";
  const CLASS_NAME_DROPSTART = "dropstart";
  const CLASS_NAME_DROPUP_CENTER = "dropup-center";
  const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  const SELECTOR_DATA_TOGGLE$3 =
    '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  const SELECTOR_MENU = ".dropdown-menu";
  const SELECTOR_NAVBAR = ".navbar";
  const SELECTOR_NAVBAR_NAV = ".navbar-nav";
  const SELECTOR_VISIBLE_ITEMS =
    ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  const PLACEMENT_TOPCENTER = "top";
  const PLACEMENT_BOTTOMCENTER = "bottom";
  const Default$9 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle",
  };
  const DefaultType$9 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)",
  };

  /**
   * Class definition
   */

  class Dropdown extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._popper = null;
      this._parent = this._element.parentNode; // dropdown wrapper
      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      this._menu =
        SelectorEngine.next(this._element, SELECTOR_MENU)[0] ||
        SelectorEngine.prev(this._element, SELECTOR_MENU)[0] ||
        SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }

    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }

    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element,
      };
      const showEvent = EventHandler.trigger(
        this._element,
        EVENT_SHOW$5,
        relatedTarget
      );
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if (
        "ontouchstart" in document.documentElement &&
        !this._parent.closest(SELECTOR_NAVBAR_NAV)
      ) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element,
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }

    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(
        this._element,
        EVENT_HIDE$5,
        relatedTarget
      );
      if (hideEvent.defaultPrevented) {
        return;
      }

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute("aria-expanded", "false");
      Manipulator.removeDataAttribute(this._menu, "popper");
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config) {
      config = super._getConfig(config);
      if (
        typeof config.reference === "object" &&
        !isElement(config.reference) &&
        typeof config.reference.getBoundingClientRect !== "function"
      ) {
        // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(
          `${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
        );
      }
      return config;
    }
    _createPopper() {
      if (typeof Popper__namespace === "undefined") {
        throw new TypeError(
          "Bootstrap's dropdowns require Popper (https://popper.js.org)"
        );
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = this._parent;
      } else if (isElement(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = Popper__namespace.createPopper(
        referenceElement,
        this._menu,
        popperConfig
      );
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }

      // We need to trim the value because custom properties can also include spaces
      const isEnd =
        getComputedStyle(this._menu)
          .getPropertyValue("--bs-position")
          .trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const { offset } = this._config;
      if (typeof offset === "string") {
        return offset.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset === "function") {
        return (popperData) => offset(popperData, this._element);
      }
      return offset;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [
          {
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary,
            },
          },
          {
            name: "offset",
            options: {
              offset: this._getOffset(),
            },
          },
        ],
      };

      // Disable Popper if we have a static display or Dropdown is in Navbar
      if (this._inNavbar || this._config.display === "static") {
        Manipulator.setDataAttribute(this._menu, "popper", "static"); // TODO: v6 remove
        defaultBsPopperConfig.modifiers = [
          {
            name: "applyStyles",
            enabled: false,
          },
        ];
      }
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig]),
      };
    }
    _selectMenuItem({ key, target }) {
      const items = SelectorEngine.find(
        SELECTOR_VISIBLE_ITEMS,
        this._menu
      ).filter((element) => isVisible(element));
      if (!items.length) {
        return;
      }

      // if target isn't included in items (e.g. when expanding the dropdown)
      // allow cycling to get the last item in case key equals ARROW_UP_KEY
      getNextActiveElement(
        items,
        target,
        key === ARROW_DOWN_KEY$1,
        !items.includes(target)
      ).focus();
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (
        event.button === RIGHT_MOUSE_BUTTON ||
        (event.type === "keyup" && event.key !== TAB_KEY$1)
      ) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (
          composedPath.includes(context._element) ||
          (context._config.autoClose === "inside" && !isMenuTarget) ||
          (context._config.autoClose === "outside" && isMenuTarget)
        ) {
          continue;
        }

        // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
        if (
          context._menu.contains(event.target) &&
          ((event.type === "keyup" && event.key === TAB_KEY$1) ||
            /input|select|option|textarea|form/i.test(event.target.tagName))
        ) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element,
        };
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      // If not an UP | DOWN | ESCAPE key => not a dropdown command
      // If input/textarea && if key is other than ESCAPE => not a dropdown command

      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(
        event.key
      );
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();

      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3)
        ? this
        : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] ||
          SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] ||
          SelectorEngine.findOne(
            SELECTOR_DATA_TOGGLE$3,
            event.delegateTarget.parentNode
          );
      const instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        // else is escape and we check if it is shown
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_KEYDOWN_DATA_API,
    SELECTOR_DATA_TOGGLE$3,
    Dropdown.dataApiKeydownHandler
  );
  EventHandler.on(
    document,
    EVENT_KEYDOWN_DATA_API,
    SELECTOR_MENU,
    Dropdown.dataApiKeydownHandler
  );
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API$3,
    SELECTOR_DATA_TOGGLE$3,
    function (event) {
      event.preventDefault();
      Dropdown.getOrCreateInstance(this).toggle();
    }
  );

  /**
   * jQuery
   */

  defineJQueryPlugin(Dropdown);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$9 = "backdrop";
  const CLASS_NAME_FADE$4 = "fade";
  const CLASS_NAME_SHOW$5 = "show";
  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  const Default$8 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body", // give the choice to place backdrop under different elements
  };
  const DefaultType$8 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)",
  };

  /**
   * Class definition
   */

  class Backdrop extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }

    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }

    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config) {
      // use getElement() with the default "body" to get a fresh Element on each instantiation
      config.rootElement = getElement(config.rootElement);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(
        callback,
        this._getElement(),
        this._config.isAnimated
      );
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$8 = "focustrap";
  const DATA_KEY$5 = "bs.focustrap";
  const EVENT_KEY$5 = `.${DATA_KEY$5}`;
  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  const TAB_KEY = "Tab";
  const TAB_NAV_FORWARD = "forward";
  const TAB_NAV_BACKWARD = "backward";
  const Default$7 = {
    autofocus: true,
    trapElement: null, // The element to trap focus inside of
  };
  const DefaultType$7 = {
    autofocus: "boolean",
    trapElement: "element",
  };

  /**
   * Class definition
   */

  class FocusTrap extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }

    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
      EventHandler.on(document, EVENT_FOCUSIN$2, (event) =>
        this._handleFocusin(event)
      );
      EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) =>
        this._handleKeydown(event)
      );
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }

    // Private
    _handleFocusin(event) {
      const { trapElement } = this._config;
      if (
        event.target === document ||
        event.target === trapElement ||
        trapElement.contains(event.target)
      ) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey
        ? TAB_NAV_BACKWARD
        : TAB_NAV_FORWARD;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const SELECTOR_FIXED_CONTENT =
    ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  const SELECTOR_STICKY_CONTENT = ".sticky-top";
  const PROPERTY_PADDING = "padding-right";
  const PROPERTY_MARGIN = "margin-right";

  /**
   * Class definition
   */

  class ScrollBarHelper {
    constructor() {
      this._element = document.body;
    }

    // Public
    getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      // give padding to element to balance the hidden scrollbar width
      this._setElementAttributes(
        this._element,
        PROPERTY_PADDING,
        (calculatedValue) => calculatedValue + width
      );
      // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
      this._setElementAttributes(
        SELECTOR_FIXED_CONTENT,
        PROPERTY_PADDING,
        (calculatedValue) => calculatedValue + width
      );
      this._setElementAttributes(
        SELECTOR_STICKY_CONTENT,
        PROPERTY_MARGIN,
        (calculatedValue) => calculatedValue - width
      );
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }

    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (
          element !== this._element &&
          window.innerWidth > element.clientWidth + scrollbarWidth
        ) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window
          .getComputedStyle(element)
          .getPropertyValue(styleProperty);
        element.style.setProperty(
          styleProperty,
          `${callback(Number.parseFloat(calculatedValue))}px`
        );
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = (element) => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        // We only want to remove the property if the value is `null`; the value can also be zero
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$7 = "modal";
  const DATA_KEY$4 = "bs.modal";
  const EVENT_KEY$4 = `.${DATA_KEY$4}`;
  const DATA_API_KEY$2 = ".data-api";
  const ESCAPE_KEY$1 = "Escape";
  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  const CLASS_NAME_OPEN = "modal-open";
  const CLASS_NAME_FADE$3 = "fade";
  const CLASS_NAME_SHOW$4 = "show";
  const CLASS_NAME_STATIC = "modal-static";
  const OPEN_SELECTOR$1 = ".modal.show";
  const SELECTOR_DIALOG = ".modal-dialog";
  const SELECTOR_MODAL_BODY = ".modal-body";
  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  const Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true,
  };
  const DefaultType$6 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean",
  };

  /**
   * Class definition
   */

  class Modal extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }

    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }

    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget,
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(
        () => this._hideModal(),
        this._element,
        this._isAnimated()
      );
    }
    dispose() {
      EventHandler.off(window, EVENT_KEY$4);
      EventHandler.off(this._dialog, EVENT_KEY$4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }

    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated(),
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element,
      });
    }
    _showElement(relatedTarget) {
      // try to append dynamic modal
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(
        SELECTOR_MODAL_BODY,
        this._dialog
      );
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget,
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
        // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
          if (
            this._element !== event.target ||
            this._element !== event2.target
          ) {
            return;
          }
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(
        this._element,
        EVENT_HIDE_PREVENTED$1
      );
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing =
        this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      // return if the following background transition hasn't yet completed
      if (
        initialOverflowY === "hidden" ||
        this._element.classList.contains(CLASS_NAME_STATIC)
      ) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = "hidden";
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }

    /**
     * The following methods are used to handle overflowing modals
     */

    _adjustDialog() {
      const isModalOverflowing =
        this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? "paddingLeft" : "paddingRight";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? "paddingRight" : "paddingLeft";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }

    // Static
    static jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        const data = Modal.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API$2,
    SELECTOR_DATA_TOGGLE$2,
    function (event) {
      const target = SelectorEngine.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
        if (showEvent.defaultPrevented) {
          // only register focus restorer if modal will actually get shown
          return;
        }
        EventHandler.one(target, EVENT_HIDDEN$4, () => {
          if (isVisible(this)) {
            this.focus();
          }
        });
      });

      // avoid conflict when clicking modal toggler while another one is open
      const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
      if (alreadyOpen) {
        Modal.getInstance(alreadyOpen).hide();
      }
      const data = Modal.getOrCreateInstance(target);
      data.toggle(this);
    }
  );
  enableDismissTrigger(Modal);

  /**
   * jQuery
   */

  defineJQueryPlugin(Modal);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$6 = "offcanvas";
  const DATA_KEY$3 = "bs.offcanvas";
  const EVENT_KEY$3 = `.${DATA_KEY$3}`;
  const DATA_API_KEY$1 = ".data-api";
  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const ESCAPE_KEY = "Escape";
  const CLASS_NAME_SHOW$3 = "show";
  const CLASS_NAME_SHOWING$1 = "showing";
  const CLASS_NAME_HIDING = "hiding";
  const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  const OPEN_SELECTOR = ".offcanvas.show";
  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  const Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false,
  };
  const DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean",
  };

  /**
   * Class definition
   */

  class Offcanvas extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }

    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }

    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget,
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget,
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }

    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === "static") {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };

      // 'static' option will be translated to true, and booleans will keep their value
      const isVisible = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible ? clickCallback : null,
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element,
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
      });
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (
          data[config] === undefined ||
          config.startsWith("_") ||
          config === "constructor"
        ) {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API$1,
    SELECTOR_DATA_TOGGLE$1,
    function (event) {
      const target = SelectorEngine.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$3, () => {
        // focus on trigger when it is closed
        if (isVisible(this)) {
          this.focus();
        }
      });

      // avoid conflict when clicking a toggler of an offcanvas, while another is open
      const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
      if (alreadyOpen && alreadyOpen !== target) {
        Offcanvas.getInstance(alreadyOpen).hide();
      }
      const data = Offcanvas.getOrCreateInstance(target);
      data.toggle(this);
    }
  );
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find(
      "[aria-modal][class*=show][class*=offcanvas-]"
    )) {
      if (getComputedStyle(element).position !== "fixed") {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);

  /**
   * jQuery
   */

  defineJQueryPlugin(Offcanvas);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  // js-docs-start allow-list
  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  const DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: [],
  };
  // js-docs-end allow-list

  const uriAttributes = new Set([
    "background",
    "cite",
    "href",
    "itemtype",
    "longdesc",
    "poster",
    "src",
    "xlink:href",
  ]);

  /**
   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
   * contexts.
   *
   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
   */
  // eslint-disable-next-line unicorn/better-regex
  const SAFE_URL_PATTERN =
    /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
  const allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }

    // Check if a regular expression validates the attribute.
    return allowedAttributeList
      .filter((attributeRegex) => attributeRegex instanceof RegExp)
      .some((regex) => regex.test(attributeName));
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === "function") {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(
        allowList["*"] || [],
        allowList[elementName] || []
      );
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/template-factory.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$5 = "TemplateFactory";
  const Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: "<div></div>",
  };
  const DefaultType$4 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string",
  };
  const DefaultContentType = {
    entry: "(string|element|function|null)",
    selector: "(string|element)",
  };

  /**
   * Class definition
   */

  class TemplateFactory extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
    }

    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }

    // Public
    getContent() {
      return Object.values(this._config.content)
        .map((config) => this._resolvePossibleFunction(config))
        .filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = {
        ...this._config.content,
        ...content,
      };
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement("div");
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(" "));
      }
      return template;
    }

    // Private
    _typeCheckConfig(config) {
      super._typeCheckConfig(config);
      this._checkContent(config.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig(
          {
            selector,
            entry: content,
          },
          DefaultContentType
        );
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize
        ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn)
        : arg;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this]);
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = "";
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$4 = "tooltip";
  const DISALLOWED_ATTRIBUTES = new Set([
    "sanitize",
    "allowList",
    "sanitizeFn",
  ]);
  const CLASS_NAME_FADE$2 = "fade";
  const CLASS_NAME_MODAL = "modal";
  const CLASS_NAME_SHOW$2 = "show";
  const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  const EVENT_MODAL_HIDE = "hide.bs.modal";
  const TRIGGER_HOVER = "hover";
  const TRIGGER_FOCUS = "focus";
  const TRIGGER_CLICK = "click";
  const TRIGGER_MANUAL = "manual";
  const EVENT_HIDE$2 = "hide";
  const EVENT_HIDDEN$2 = "hidden";
  const EVENT_SHOW$2 = "show";
  const EVENT_SHOWN$2 = "shown";
  const EVENT_INSERTED = "inserted";
  const EVENT_CLICK$1 = "click";
  const EVENT_FOCUSIN$1 = "focusin";
  const EVENT_FOCUSOUT$1 = "focusout";
  const EVENT_MOUSEENTER = "mouseenter";
  const EVENT_MOUSELEAVE = "mouseleave";
  const AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left",
  };
  const Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: "clippingParents",
    container: false,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: false,
    offset: [0, 6],
    placement: "top",
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template:
      '<div class="tooltip" role="tooltip">' +
      '<div class="tooltip-arrow"></div>' +
      '<div class="tooltip-inner"></div>' +
      "</div>",
    title: "",
    trigger: "hover focus",
  };
  const DefaultType$3 = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
  };

  /**
   * Class definition
   */

  class Tooltip extends BaseComponent {
    constructor(element, config) {
      if (typeof Popper__namespace === "undefined") {
        throw new TypeError(
          "Bootstrap's tooltips require Popper (https://popper.js.org)"
        );
      }
      super(element, config);

      // Private
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;

      // Protected
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }

    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }

    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      this._activeTrigger.click = !this._activeTrigger.click;
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(
        this._element.closest(SELECTOR_MODAL),
        EVENT_MODAL_HIDE,
        this._hideModalHandler
      );
      if (this._element.getAttribute("data-bs-original-title")) {
        this._element.setAttribute(
          "title",
          this._element.getAttribute("data-bs-original-title")
        );
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(
        this._element,
        this.constructor.eventName(EVENT_SHOW$2)
      );
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (
        shadowRoot || this._element.ownerDocument.documentElement
      ).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }

      // TODO: v6 remove this or make it optional
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
      const { container } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(
          this._element,
          this.constructor.eventName(EVENT_INSERTED)
        );
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      const complete = () => {
        EventHandler.trigger(
          this._element,
          this.constructor.eventName(EVENT_SHOWN$2)
        );
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(
        this._element,
        this.constructor.eventName(EVENT_HIDE$2)
      );
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null; // it is a trick to support manual triggering

      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute("aria-describedby");
        EventHandler.trigger(
          this._element,
          this.constructor.eventName(EVENT_HIDDEN$2)
        );
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }

    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(
          this._newContent || this._getContentForTemplate()
        );
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();

      // TODO: remove this check in v6
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      // TODO: v6 the following can be achieved with CSS only
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute("id", tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory({
          ...this._config,
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass),
        });
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle(),
      };
    }
    _getTitle() {
      return (
        this._resolvePossibleFunction(this._config.title) ||
        this._element.getAttribute("data-bs-original-title")
      );
    }

    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(
        event.delegateTarget,
        this._getDelegateConfig()
      );
    }
    _isAnimated() {
      return (
        this._config.animation ||
        (this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2))
      );
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = execute(this._config.placement, [
        this,
        tip,
        this._element,
      ]);
      const attachment = AttachmentMap[placement.toUpperCase()];
      return Popper__namespace.createPopper(
        this._element,
        tip,
        this._getPopperConfig(attachment)
      );
    }
    _getOffset() {
      const { offset } = this._config;
      if (typeof offset === "string") {
        return offset.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset === "function") {
        return (popperData) => offset(popperData, this._element);
      }
      return offset;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this._element]);
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [
          {
            name: "flip",
            options: {
              fallbackPlacements: this._config.fallbackPlacements,
            },
          },
          {
            name: "offset",
            options: {
              offset: this._getOffset(),
            },
          },
          {
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary,
            },
          },
          {
            name: "arrow",
            options: {
              element: `.${this.constructor.NAME}-arrow`,
            },
          },
          {
            name: "preSetPlacement",
            enabled: true,
            phase: "beforeMain",
            fn: (data) => {
              // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
              // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
              this._getTipElement().setAttribute(
                "data-popper-placement",
                data.state.placement
              );
            },
          },
        ],
      };
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig]),
      };
    }
    _setListeners() {
      const triggers = this._config.trigger.split(" ");
      for (const trigger of triggers) {
        if (trigger === "click") {
          EventHandler.on(
            this._element,
            this.constructor.eventName(EVENT_CLICK$1),
            this._config.selector,
            (event) => {
              const context = this._initializeOnDelegatedTarget(event);
              context.toggle();
            }
          );
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn =
            trigger === TRIGGER_HOVER
              ? this.constructor.eventName(EVENT_MOUSEENTER)
              : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut =
            trigger === TRIGGER_HOVER
              ? this.constructor.eventName(EVENT_MOUSELEAVE)
              : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(
            this._element,
            eventIn,
            this._config.selector,
            (event) => {
              const context = this._initializeOnDelegatedTarget(event);
              context._activeTrigger[
                event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER
              ] = true;
              context._enter();
            }
          );
          EventHandler.on(
            this._element,
            eventOut,
            this._config.selector,
            (event) => {
              const context = this._initializeOnDelegatedTarget(event);
              context._activeTrigger[
                event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER
              ] = context._element.contains(event.relatedTarget);
              context._leave();
            }
          );
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(
        this._element.closest(SELECTOR_MODAL),
        EVENT_MODAL_HIDE,
        this._hideModalHandler
      );
    }
    _fixTitle() {
      const title = this._element.getAttribute("title");
      if (!title) {
        return;
      }
      if (
        !this._element.getAttribute("aria-label") &&
        !this._element.textContent.trim()
      ) {
        this._element.setAttribute("aria-label", title);
      }
      this._element.setAttribute("data-bs-original-title", title); // DO NOT USE IT. Is only for backwards compatibility
      this._element.removeAttribute("title");
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config = {
        ...dataAttributes,
        ...(typeof config === "object" && config ? config : {}),
      };
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      config.container =
        config.container === false
          ? document.body
          : getElement(config.container);
      if (typeof config.delay === "number") {
        config.delay = {
          show: config.delay,
          hide: config.delay,
        };
      }
      if (typeof config.title === "number") {
        config.title = config.title.toString();
      }
      if (typeof config.content === "number") {
        config.content = config.content.toString();
      }
      return config;
    }
    _getDelegateConfig() {
      const config = {};
      for (const [key, value] of Object.entries(this._config)) {
        if (this.constructor.Default[key] !== value) {
          config[key] = value;
        }
      }
      config.selector = false;
      config.trigger = "manual";

      // In the future can be replaced with:
      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
      // `Object.fromEntries(keysWithDifferentValues)`
      return config;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tooltip.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * jQuery
   */

  defineJQueryPlugin(Tooltip);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$3 = "popover";
  const SELECTOR_TITLE = ".popover-header";
  const SELECTOR_CONTENT = ".popover-body";
  const Default$2 = {
    ...Tooltip.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template:
      '<div class="popover" role="tooltip">' +
      '<div class="popover-arrow"></div>' +
      '<h3 class="popover-header"></h3>' +
      '<div class="popover-body"></div>' +
      "</div>",
    trigger: "click",
  };
  const DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: "(null|string|element|function)",
  };

  /**
   * Class definition
   */

  class Popover extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }

    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }

    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent(),
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Popover.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * jQuery
   */

  defineJQueryPlugin(Popover);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$2 = "scrollspy";
  const DATA_KEY$2 = "bs.scrollspy";
  const EVENT_KEY$2 = `.${DATA_KEY$2}`;
  const DATA_API_KEY = ".data-api";
  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  const EVENT_CLICK = `click${EVENT_KEY$2}`;
  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  const CLASS_NAME_ACTIVE$1 = "active";
  const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  const SELECTOR_TARGET_LINKS = "[href]";
  const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  const SELECTOR_NAV_LINKS = ".nav-link";
  const SELECTOR_NAV_ITEMS = ".nav-item";
  const SELECTOR_LIST_ITEMS = ".list-group-item";
  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  const SELECTOR_DROPDOWN = ".dropdown";
  const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  const Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1],
  };
  const DefaultType$1 = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array",
  };

  /**
   * Class definition
   */

  class ScrollSpy extends BaseComponent {
    constructor(element, config) {
      super(element, config);

      // this._element is the observablesContainer and config.target the menu links wrapper
      this._targetLinks = new Map();
      this._observableSections = new Map();
      this._rootElement =
        getComputedStyle(this._element).overflowY === "visible"
          ? null
          : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0,
      };
      this.refresh(); // initialize
    }

    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }

    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }

    // Private
    _configAfterMerge(config) {
      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
      config.target = getElement(config.target) || document.body;

      // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
      config.rootMargin = config.offset
        ? `${config.offset}px 0px -30%`
        : config.rootMargin;
      if (typeof config.threshold === "string") {
        config.threshold = config.threshold
          .split(",")
          .map((value) => Number.parseFloat(value));
      }
      return config;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }

      // unregister any previous listeners
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(
        this._config.target,
        EVENT_CLICK,
        SELECTOR_TARGET_LINKS,
        (event) => {
          const observableSection = this._observableSections.get(
            event.target.hash
          );
          if (observableSection) {
            event.preventDefault();
            const root = this._rootElement || window;
            const height =
              observableSection.offsetTop - this._element.offsetTop;
            if (root.scrollTo) {
              root.scrollTo({
                top: height,
                behavior: "smooth",
              });
              return;
            }

            // Chrome 60 doesn't support `scrollTo`
            root.scrollTop = height;
          }
        }
      );
    }
    _getNewObserver() {
      const options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin,
      };
      return new IntersectionObserver(
        (entries) => this._observerCallback(entries),
        options
      );
    }

    // The logic of selection
    _observerCallback(entries) {
      const targetElement = (entry) =>
        this._targetLinks.get(`#${entry.target.id}`);
      const activate = (entry) => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement)
        .scrollTop;
      const userScrollsDown =
        parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious =
          entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        // if we are scrolling down, pick the bigger offsetTop
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
          if (!parentScrollTop) {
            return;
          }
          continue;
        }

        // if we are scrolling up, pick the smallest offsetTop
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = new Map();
      this._observableSections = new Map();
      const targetLinks = SelectorEngine.find(
        SELECTOR_TARGET_LINKS,
        this._config.target
      );
      for (const anchor of targetLinks) {
        // ensure that the anchor has an id and is not disabled
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(
          decodeURI(anchor.hash),
          this._element
        );

        // ensure that the observableSection exists & is visible
        if (isVisible(observableSection)) {
          this._targetLinks.set(decodeURI(anchor.hash), anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target,
      });
    }
    _activateParents(target) {
      // Activate dropdown parents
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(
          SELECTOR_DROPDOWN_TOGGLE$1,
          target.closest(SELECTOR_DROPDOWN)
        ).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(
        target,
        SELECTOR_NAV_LIST_GROUP
      )) {
        // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
        for (const item of SelectorEngine.prev(
          listGroup,
          SELECTOR_LINK_ITEMS
        )) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(
        `${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`,
        parent
      );
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (
          data[config] === undefined ||
          config.startsWith("_") ||
          config === "constructor"
        ) {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(ScrollSpy);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME$1 = "tab";
  const DATA_KEY$1 = "bs.tab";
  const EVENT_KEY$1 = `.${DATA_KEY$1}`;
  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  const ARROW_LEFT_KEY = "ArrowLeft";
  const ARROW_RIGHT_KEY = "ArrowRight";
  const ARROW_UP_KEY = "ArrowUp";
  const ARROW_DOWN_KEY = "ArrowDown";
  const HOME_KEY = "Home";
  const END_KEY = "End";
  const CLASS_NAME_ACTIVE = "active";
  const CLASS_NAME_FADE$1 = "fade";
  const CLASS_NAME_SHOW$1 = "show";
  const CLASS_DROPDOWN = "dropdown";
  const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  const SELECTOR_OUTER = ".nav-item, .list-group-item";
  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE =
    '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;

  /**
   * Class definition
   */

  class Tab extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
        // TODO: should throw exception in v6
        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
      }

      // Set up initial aria attributes
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, (event) =>
        this._keydown(event)
      );
    }

    // Getters
    static get NAME() {
      return NAME$1;
    }

    // Public
    show() {
      // Shows this elem and deactivate the active sibling if exists
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }

      // Search for active tab on same parent to deactivate it
      const active = this._getActiveElem();
      const hideEvent = active
        ? EventHandler.trigger(active, EVENT_HIDE$1, {
            relatedTarget: innerElem,
          })
        : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active,
      });
      if (
        showEvent.defaultPrevented ||
        (hideEvent && hideEvent.defaultPrevented)
      ) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }

    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section

      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute("tabindex");
        element.setAttribute("aria-selected", true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem,
        });
      };
      this._queueCallback(
        complete,
        element,
        element.classList.contains(CLASS_NAME_FADE$1)
      );
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too

      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute("aria-selected", false);
        element.setAttribute("tabindex", "-1");
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem,
        });
      };
      this._queueCallback(
        complete,
        element,
        element.classList.contains(CLASS_NAME_FADE$1)
      );
    }
    _keydown(event) {
      if (
        ![
          ARROW_LEFT_KEY,
          ARROW_RIGHT_KEY,
          ARROW_UP_KEY,
          ARROW_DOWN_KEY,
          HOME_KEY,
          END_KEY,
        ].includes(event.key)
      ) {
        return;
      }
      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
      event.preventDefault();
      const children = this._getChildren().filter(
        (element) => !isDisabled(element)
      );
      let nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement =
          children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        nextActiveElement = getNextActiveElement(
          children,
          event.target,
          isNext,
          true
        );
      }
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true,
        });
        Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      // collection of inner elements
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return (
        this._getChildren().find((child) => this._elemIsActive(child)) || null
      );
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, "role", "tablist");
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute("aria-selected", isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, "role", "presentation");
      }
      if (!isActive) {
        child.setAttribute("tabindex", "-1");
      }
      this._setAttributeIfNotExists(child, "role", "tab");

      // set attributes to the related panel too
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = SelectorEngine.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, "role", "tabpanel");
      if (child.id) {
        this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element = SelectorEngine.findOne(selector, outerElem);
        if (element) {
          element.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }

    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM)
        ? elem
        : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }

    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tab.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (
          data[config] === undefined ||
          config.startsWith("_") ||
          config === "constructor"
        ) {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(
    document,
    EVENT_CLICK_DATA_API,
    SELECTOR_DATA_TOGGLE,
    function (event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      Tab.getOrCreateInstance(this).show();
    }
  );

  /**
   * Initialize on focus
   */
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Tab);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap toast.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const NAME = "toast";
  const DATA_KEY = "bs.toast";
  const EVENT_KEY = `.${DATA_KEY}`;
  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const CLASS_NAME_FADE = "fade";
  const CLASS_NAME_HIDE = "hide"; // @deprecated - kept here only for backwards compatibility
  const CLASS_NAME_SHOW = "show";
  const CLASS_NAME_SHOWING = "showing";
  const DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number",
  };
  const Default = {
    animation: true,
    autohide: true,
    delay: 5000,
  };

  /**
   * Class definition
   */

  class Toast extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }

    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }

    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }

    // Private

    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case "mouseover":
        case "mouseout": {
          this._hasMouseInteraction = isInteracting;
          break;
        }
        case "focusin":
        case "focusout": {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (
        this._element === nextElement ||
        this._element.contains(nextElement)
      ) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, (event) =>
        this._onInteraction(event, true)
      );
      EventHandler.on(this._element, EVENT_MOUSEOUT, (event) =>
        this._onInteraction(event, false)
      );
      EventHandler.on(this._element, EVENT_FOCUSIN, (event) =>
        this._onInteraction(event, true)
      );
      EventHandler.on(this._element, EVENT_FOCUSOUT, (event) =>
        this._onInteraction(event, false)
      );
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Toast.getOrCreateInstance(this, config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config](this);
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  enableDismissTrigger(Toast);

  /**
   * jQuery
   */

  defineJQueryPlugin(Toast);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap index.umd.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const index_umd = {
    Alert,
    Button,
    Carousel,
    Collapse,
    Dropdown,
    Modal,
    Offcanvas,
    Popover,
    ScrollSpy,
    Tab,
    Toast,
    Tooltip,
  };

  return index_umd;
});
(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports)
    : typeof define === "function" && define.amd
    ? define(["exports"], factory)
    : factory((global.ActionCable = {}));
})(this, function (exports) {
  "use strict";
  var adapters = {
    logger: self.console,
    WebSocket: self.WebSocket,
  };
  var logger = {
    log: function log() {
      if (this.enabled) {
        var _adapters$logger;
        for (
          var _len = arguments.length, messages = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          messages[_key] = arguments[_key];
        }
        messages.push(Date.now());
        (_adapters$logger = adapters.logger).log.apply(
          _adapters$logger,
          ["[ActionCable]"].concat(messages)
        );
      }
    },
  };
  var _typeof =
    typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
      ? function (obj) {
          return typeof obj;
        }
      : function (obj) {
          return obj &&
            typeof Symbol === "function" &&
            obj.constructor === Symbol &&
            obj !== Symbol.prototype
            ? "symbol"
            : typeof obj;
        };
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  var now = function now() {
    return new Date().getTime();
  };
  var secondsSince = function secondsSince(time) {
    return (now() - time) / 1e3;
  };
  var clamp = function clamp(number, min, max) {
    return Math.max(min, Math.min(max, number));
  };
  var ConnectionMonitor = (function () {
    function ConnectionMonitor(connection) {
      classCallCheck(this, ConnectionMonitor);
      this.visibilityDidChange = this.visibilityDidChange.bind(this);
      this.connection = connection;
      this.reconnectAttempts = 0;
    }
    ConnectionMonitor.prototype.start = function start() {
      if (!this.isRunning()) {
        this.startedAt = now();
        delete this.stoppedAt;
        this.startPolling();
        addEventListener("visibilitychange", this.visibilityDidChange);
        logger.log(
          "ConnectionMonitor started. pollInterval = " +
            this.getPollInterval() +
            " ms"
        );
      }
    };
    ConnectionMonitor.prototype.stop = function stop() {
      if (this.isRunning()) {
        this.stoppedAt = now();
        this.stopPolling();
        removeEventListener("visibilitychange", this.visibilityDidChange);
        logger.log("ConnectionMonitor stopped");
      }
    };
    ConnectionMonitor.prototype.isRunning = function isRunning() {
      return this.startedAt && !this.stoppedAt;
    };
    ConnectionMonitor.prototype.recordPing = function recordPing() {
      this.pingedAt = now();
    };
    ConnectionMonitor.prototype.recordConnect = function recordConnect() {
      this.reconnectAttempts = 0;
      this.recordPing();
      delete this.disconnectedAt;
      logger.log("ConnectionMonitor recorded connect");
    };
    ConnectionMonitor.prototype.recordDisconnect = function recordDisconnect() {
      this.disconnectedAt = now();
      logger.log("ConnectionMonitor recorded disconnect");
    };
    ConnectionMonitor.prototype.startPolling = function startPolling() {
      this.stopPolling();
      this.poll();
    };
    ConnectionMonitor.prototype.stopPolling = function stopPolling() {
      clearTimeout(this.pollTimeout);
    };
    ConnectionMonitor.prototype.poll = function poll() {
      var _this = this;
      this.pollTimeout = setTimeout(function () {
        _this.reconnectIfStale();
        _this.poll();
      }, this.getPollInterval());
    };
    ConnectionMonitor.prototype.getPollInterval = function getPollInterval() {
      var _constructor$pollInte = this.constructor.pollInterval,
        min = _constructor$pollInte.min,
        max = _constructor$pollInte.max,
        multiplier = _constructor$pollInte.multiplier;
      var interval = multiplier * Math.log(this.reconnectAttempts + 1);
      return Math.round(clamp(interval, min, max) * 1e3);
    };
    ConnectionMonitor.prototype.reconnectIfStale = function reconnectIfStale() {
      if (this.connectionIsStale()) {
        logger.log(
          "ConnectionMonitor detected stale connection. reconnectAttempts = " +
            this.reconnectAttempts +
            ", pollInterval = " +
            this.getPollInterval() +
            " ms, time disconnected = " +
            secondsSince(this.disconnectedAt) +
            " s, stale threshold = " +
            this.constructor.staleThreshold +
            " s"
        );
        this.reconnectAttempts++;
        if (this.disconnectedRecently()) {
          logger.log("ConnectionMonitor skipping reopening recent disconnect");
        } else {
          logger.log("ConnectionMonitor reopening");
          this.connection.reopen();
        }
      }
    };
    ConnectionMonitor.prototype.connectionIsStale =
      function connectionIsStale() {
        return (
          secondsSince(this.pingedAt ? this.pingedAt : this.startedAt) >
          this.constructor.staleThreshold
        );
      };
    ConnectionMonitor.prototype.disconnectedRecently =
      function disconnectedRecently() {
        return (
          this.disconnectedAt &&
          secondsSince(this.disconnectedAt) < this.constructor.staleThreshold
        );
      };
    ConnectionMonitor.prototype.visibilityDidChange =
      function visibilityDidChange() {
        var _this2 = this;
        if (document.visibilityState === "visible") {
          setTimeout(function () {
            if (_this2.connectionIsStale() || !_this2.connection.isOpen()) {
              logger.log(
                "ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = " +
                  document.visibilityState
              );
              _this2.connection.reopen();
            }
          }, 200);
        }
      };
    return ConnectionMonitor;
  })();
  ConnectionMonitor.pollInterval = {
    min: 3,
    max: 30,
    multiplier: 5,
  };
  ConnectionMonitor.staleThreshold = 6;
  var INTERNAL = {
    message_types: {
      welcome: "welcome",
      disconnect: "disconnect",
      ping: "ping",
      confirmation: "confirm_subscription",
      rejection: "reject_subscription",
    },
    disconnect_reasons: {
      unauthorized: "unauthorized",
      invalid_request: "invalid_request",
      server_restart: "server_restart",
    },
    default_mount_path: "/cable",
    protocols: ["actioncable-v1-json", "actioncable-unsupported"],
  };
  var message_types = INTERNAL.message_types,
    protocols = INTERNAL.protocols;
  var supportedProtocols = protocols.slice(0, protocols.length - 1);
  var indexOf = [].indexOf;
  var Connection = (function () {
    function Connection(consumer) {
      classCallCheck(this, Connection);
      this.open = this.open.bind(this);
      this.consumer = consumer;
      this.subscriptions = this.consumer.subscriptions;
      this.monitor = new ConnectionMonitor(this);
      this.disconnected = true;
    }
    Connection.prototype.send = function send(data) {
      if (this.isOpen()) {
        this.webSocket.send(JSON.stringify(data));
        return true;
      } else {
        return false;
      }
    };
    Connection.prototype.open = function open() {
      if (this.isActive()) {
        logger.log(
          "Attempted to open WebSocket, but existing socket is " +
            this.getState()
        );
        return false;
      } else {
        logger.log(
          "Opening WebSocket, current state is " +
            this.getState() +
            ", subprotocols: " +
            protocols
        );
        if (this.webSocket) {
          this.uninstallEventHandlers();
        }
        this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);
        this.installEventHandlers();
        this.monitor.start();
        return true;
      }
    };
    Connection.prototype.close = function close() {
      var _ref =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : {
                allowReconnect: true,
              },
        allowReconnect = _ref.allowReconnect;
      if (!allowReconnect) {
        this.monitor.stop();
      }
      if (this.isActive()) {
        return this.webSocket.close();
      }
    };
    Connection.prototype.reopen = function reopen() {
      logger.log("Reopening WebSocket, current state is " + this.getState());
      if (this.isActive()) {
        try {
          return this.close();
        } catch (error) {
          logger.log("Failed to reopen WebSocket", error);
        } finally {
          logger.log(
            "Reopening WebSocket in " + this.constructor.reopenDelay + "ms"
          );
          setTimeout(this.open, this.constructor.reopenDelay);
        }
      } else {
        return this.open();
      }
    };
    Connection.prototype.getProtocol = function getProtocol() {
      if (this.webSocket) {
        return this.webSocket.protocol;
      }
    };
    Connection.prototype.isOpen = function isOpen() {
      return this.isState("open");
    };
    Connection.prototype.isActive = function isActive() {
      return this.isState("open", "connecting");
    };
    Connection.prototype.isProtocolSupported = function isProtocolSupported() {
      return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
    };
    Connection.prototype.isState = function isState() {
      for (
        var _len = arguments.length, states = Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        states[_key] = arguments[_key];
      }
      return indexOf.call(states, this.getState()) >= 0;
    };
    Connection.prototype.getState = function getState() {
      if (this.webSocket) {
        for (var state in adapters.WebSocket) {
          if (adapters.WebSocket[state] === this.webSocket.readyState) {
            return state.toLowerCase();
          }
        }
      }
      return null;
    };
    Connection.prototype.installEventHandlers =
      function installEventHandlers() {
        for (var eventName in this.events) {
          var handler = this.events[eventName].bind(this);
          this.webSocket["on" + eventName] = handler;
        }
      };
    Connection.prototype.uninstallEventHandlers =
      function uninstallEventHandlers() {
        for (var eventName in this.events) {
          this.webSocket["on" + eventName] = function () {};
        }
      };
    return Connection;
  })();
  Connection.reopenDelay = 500;
  Connection.prototype.events = {
    message: function message(event) {
      if (!this.isProtocolSupported()) {
        return;
      }
      var _JSON$parse = JSON.parse(event.data),
        identifier = _JSON$parse.identifier,
        message = _JSON$parse.message,
        reason = _JSON$parse.reason,
        reconnect = _JSON$parse.reconnect,
        type = _JSON$parse.type;
      switch (type) {
        case message_types.welcome:
          this.monitor.recordConnect();
          return this.subscriptions.reload();

        case message_types.disconnect:
          logger.log("Disconnecting. Reason: " + reason);
          return this.close({
            allowReconnect: reconnect,
          });

        case message_types.ping:
          return this.monitor.recordPing();

        case message_types.confirmation:
          this.subscriptions.confirmSubscription(identifier);
          return this.subscriptions.notify(identifier, "connected");

        case message_types.rejection:
          return this.subscriptions.reject(identifier);

        default:
          return this.subscriptions.notify(identifier, "received", message);
      }
    },
    open: function open() {
      logger.log(
        "WebSocket onopen event, using '" + this.getProtocol() + "' subprotocol"
      );
      this.disconnected = false;
      if (!this.isProtocolSupported()) {
        logger.log(
          "Protocol is unsupported. Stopping monitor and disconnecting."
        );
        return this.close({
          allowReconnect: false,
        });
      }
    },
    close: function close(event) {
      logger.log("WebSocket onclose event");
      if (this.disconnected) {
        return;
      }
      this.disconnected = true;
      this.monitor.recordDisconnect();
      return this.subscriptions.notifyAll("disconnected", {
        willAttemptReconnect: this.monitor.isRunning(),
      });
    },
    error: function error() {
      logger.log("WebSocket onerror event");
    },
  };
  var extend = function extend(object, properties) {
    if (properties != null) {
      for (var key in properties) {
        var value = properties[key];
        object[key] = value;
      }
    }
    return object;
  };
  var Subscription = (function () {
    function Subscription(consumer) {
      var params =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var mixin = arguments[2];
      classCallCheck(this, Subscription);
      this.consumer = consumer;
      this.identifier = JSON.stringify(params);
      extend(this, mixin);
    }
    Subscription.prototype.perform = function perform(action) {
      var data =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      data.action = action;
      return this.send(data);
    };
    Subscription.prototype.send = function send(data) {
      return this.consumer.send({
        command: "message",
        identifier: this.identifier,
        data: JSON.stringify(data),
      });
    };
    Subscription.prototype.unsubscribe = function unsubscribe() {
      return this.consumer.subscriptions.remove(this);
    };
    return Subscription;
  })();
  var SubscriptionGuarantor = (function () {
    function SubscriptionGuarantor(subscriptions) {
      classCallCheck(this, SubscriptionGuarantor);
      this.subscriptions = subscriptions;
      this.pendingSubscriptions = [];
    }
    SubscriptionGuarantor.prototype.guarantee = function guarantee(
      subscription
    ) {
      if (this.pendingSubscriptions.indexOf(subscription) == -1) {
        logger.log(
          "SubscriptionGuarantor guaranteeing " + subscription.identifier
        );
        this.pendingSubscriptions.push(subscription);
      } else {
        logger.log(
          "SubscriptionGuarantor already guaranteeing " +
            subscription.identifier
        );
      }
      this.startGuaranteeing();
    };
    SubscriptionGuarantor.prototype.forget = function forget(subscription) {
      logger.log("SubscriptionGuarantor forgetting " + subscription.identifier);
      this.pendingSubscriptions = this.pendingSubscriptions.filter(function (
        s
      ) {
        return s !== subscription;
      });
    };
    SubscriptionGuarantor.prototype.startGuaranteeing =
      function startGuaranteeing() {
        this.stopGuaranteeing();
        this.retrySubscribing();
      };
    SubscriptionGuarantor.prototype.stopGuaranteeing =
      function stopGuaranteeing() {
        clearTimeout(this.retryTimeout);
      };
    SubscriptionGuarantor.prototype.retrySubscribing =
      function retrySubscribing() {
        var _this = this;
        this.retryTimeout = setTimeout(function () {
          if (
            _this.subscriptions &&
            typeof _this.subscriptions.subscribe === "function"
          ) {
            _this.pendingSubscriptions.map(function (subscription) {
              logger.log(
                "SubscriptionGuarantor resubscribing " + subscription.identifier
              );
              _this.subscriptions.subscribe(subscription);
            });
          }
        }, 500);
      };
    return SubscriptionGuarantor;
  })();
  var Subscriptions = (function () {
    function Subscriptions(consumer) {
      classCallCheck(this, Subscriptions);
      this.consumer = consumer;
      this.guarantor = new SubscriptionGuarantor(this);
      this.subscriptions = [];
    }
    Subscriptions.prototype.create = function create(channelName, mixin) {
      var channel = channelName;
      var params =
        (typeof channel === "undefined" ? "undefined" : _typeof(channel)) ===
        "object"
          ? channel
          : {
              channel: channel,
            };
      var subscription = new Subscription(this.consumer, params, mixin);
      return this.add(subscription);
    };
    Subscriptions.prototype.add = function add(subscription) {
      this.subscriptions.push(subscription);
      this.consumer.ensureActiveConnection();
      this.notify(subscription, "initialized");
      this.subscribe(subscription);
      return subscription;
    };
    Subscriptions.prototype.remove = function remove(subscription) {
      this.forget(subscription);
      if (!this.findAll(subscription.identifier).length) {
        this.sendCommand(subscription, "unsubscribe");
      }
      return subscription;
    };
    Subscriptions.prototype.reject = function reject(identifier) {
      var _this = this;
      return this.findAll(identifier).map(function (subscription) {
        _this.forget(subscription);
        _this.notify(subscription, "rejected");
        return subscription;
      });
    };
    Subscriptions.prototype.forget = function forget(subscription) {
      this.guarantor.forget(subscription);
      this.subscriptions = this.subscriptions.filter(function (s) {
        return s !== subscription;
      });
      return subscription;
    };
    Subscriptions.prototype.findAll = function findAll(identifier) {
      return this.subscriptions.filter(function (s) {
        return s.identifier === identifier;
      });
    };
    Subscriptions.prototype.reload = function reload() {
      var _this2 = this;
      return this.subscriptions.map(function (subscription) {
        return _this2.subscribe(subscription);
      });
    };
    Subscriptions.prototype.notifyAll = function notifyAll(callbackName) {
      var _this3 = this;
      for (
        var _len = arguments.length,
          args = Array(_len > 1 ? _len - 1 : 0),
          _key = 1;
        _key < _len;
        _key++
      ) {
        args[_key - 1] = arguments[_key];
      }
      return this.subscriptions.map(function (subscription) {
        return _this3.notify.apply(
          _this3,
          [subscription, callbackName].concat(args)
        );
      });
    };
    Subscriptions.prototype.notify = function notify(
      subscription,
      callbackName
    ) {
      for (
        var _len2 = arguments.length,
          args = Array(_len2 > 2 ? _len2 - 2 : 0),
          _key2 = 2;
        _key2 < _len2;
        _key2++
      ) {
        args[_key2 - 2] = arguments[_key2];
      }
      var subscriptions = void 0;
      if (typeof subscription === "string") {
        subscriptions = this.findAll(subscription);
      } else {
        subscriptions = [subscription];
      }
      return subscriptions.map(function (subscription) {
        return typeof subscription[callbackName] === "function"
          ? subscription[callbackName].apply(subscription, args)
          : undefined;
      });
    };
    Subscriptions.prototype.subscribe = function subscribe(subscription) {
      if (this.sendCommand(subscription, "subscribe")) {
        this.guarantor.guarantee(subscription);
      }
    };
    Subscriptions.prototype.confirmSubscription = function confirmSubscription(
      identifier
    ) {
      var _this4 = this;
      logger.log("Subscription confirmed " + identifier);
      this.findAll(identifier).map(function (subscription) {
        return _this4.guarantor.forget(subscription);
      });
    };
    Subscriptions.prototype.sendCommand = function sendCommand(
      subscription,
      command
    ) {
      var identifier = subscription.identifier;
      return this.consumer.send({
        command: command,
        identifier: identifier,
      });
    };
    return Subscriptions;
  })();
  var Consumer = (function () {
    function Consumer(url) {
      classCallCheck(this, Consumer);
      this._url = url;
      this.subscriptions = new Subscriptions(this);
      this.connection = new Connection(this);
    }
    Consumer.prototype.send = function send(data) {
      return this.connection.send(data);
    };
    Consumer.prototype.connect = function connect() {
      return this.connection.open();
    };
    Consumer.prototype.disconnect = function disconnect() {
      return this.connection.close({
        allowReconnect: false,
      });
    };
    Consumer.prototype.ensureActiveConnection =
      function ensureActiveConnection() {
        if (!this.connection.isActive()) {
          return this.connection.open();
        }
      };
    createClass(Consumer, [
      {
        key: "url",
        get: function get$$1() {
          return createWebSocketURL(this._url);
        },
      },
    ]);
    return Consumer;
  })();
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      var a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  function createConsumer() {
    var url =
      arguments.length > 0 && arguments[0] !== undefined
        ? arguments[0]
        : getConfig("url") || INTERNAL.default_mount_path;
    return new Consumer(url);
  }
  function getConfig(name) {
    var element = document.head.querySelector(
      "meta[name='action-cable-" + name + "']"
    );
    if (element) {
      return element.getAttribute("content");
    }
  }
  exports.Connection = Connection;
  exports.ConnectionMonitor = ConnectionMonitor;
  exports.Consumer = Consumer;
  exports.INTERNAL = INTERNAL;
  exports.Subscription = Subscription;
  exports.Subscriptions = Subscriptions;
  exports.SubscriptionGuarantor = SubscriptionGuarantor;
  exports.adapters = adapters;
  exports.createWebSocketURL = createWebSocketURL;
  exports.logger = logger;
  exports.createConsumer = createConsumer;
  exports.getConfig = getConfig;
  Object.defineProperty(exports, "__esModule", {
    value: true,
  });
});
// Action Cable provides the framework to deal with WebSockets in Rails.
// You can generate new channels where WebSocket features live using the `rails generate channel` command.
//

(function () {
  this.App || (this.App = {});

  App.cable = ActionCable.createConsumer();
}).call(this);
(function () {}).call(this);

// This is a manifest file that'll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, or any plugin's
// vendor/assets/javascripts directory can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// compiled file. JavaScript code in this file should be added after the last require_* statement.
//
// Read Sprockets README (https://github.com/rails/sprockets#sprockets-directives) for details
// about supported directives.
//

var ready;
var app = {};

function pageLoad() {
  setTimeout(function () {
    $("#notice_wrapper").fadeOut("slow", function () {
      $(this).remove();
    });
    $("#alert_wrapper").fadeOut("slow", function () {
      $(this).remove();
    });
  }, 4500);

  // re-initialize Lightbox on Turbolinks page load
  $(".sortable").railsSortable();
  if ($("").length > 0) {
    lightbox.init();
  }

  // Only load the map if necessary
  if ($("#bigmap").length > 0 || $(".minimap").length > 0) {
    var zoomControl = true;
    var attributionControl = true;
    var tileOptions = {
      subdomains: "abcd",
      minZoom: 0,
      maxZoom: 20,
      ext: "png",
      opacity: 0.5,
    };
    if ($(".minimap").length === 1) {
      // zoomControl = false;
      attributionControl = false;
    } else {
      tileOptions.attribution =
        'Map tiles by <a href="https://carto.com/">CartoDB</a>, under CC BY 3.0. Data by <a href="http://www.openstreetmap.org/">OpenStreetMap</a>, under ODbL.';
    }
    if (
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent
      )
    ) {
      zoomControl = false;
    }

    app.basemap = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
      tileOptions
    );

    // Return to the last-used map extent, or use a default extent
    var lat = Cookies.get("lat") || 0;
    var lng = Cookies.get("lng") || 27;
    var zoom = Cookies.get("zoom") || 3;
    app.leafletMap = new L.Map("map", {
      center: [lat, lng],
      zoom: zoom,
      maxZoom: 8,
      minZoom: 2,
      layers: [app.basemap],
      maxBounds: L.latLngBounds(L.latLng(-90, -180), L.latLng(90, 180)),
      zoomControl: zoomControl,
      attributionControl: attributionControl,
    });

    // Fetch geocoded posts
    var postId = $(".post_id").data("id") || null;
    var postLat = $(".post_id").data("latitude") || null;
    var postLong = $(".post_id").data("longitude") || null;
    getPosts(postId, postLat, postLong);

    // Store the last map extent in cookies
    app.leafletMap.on("zoomend", function () {
      updateCookies();
    });
    app.leafletMap.on("moveend", function () {
      updateCookies();
    });
  }

  function updateCookies() {
    Cookies.set("lat", app.leafletMap.getCenter().lat);
    Cookies.set("lng", app.leafletMap.getCenter().lng);
    Cookies.set("zoom", app.leafletMap.getZoom());
  }

  function getPosts(postID, postLat, postLong) {
    // Request posts with a lat/long
    var url = window.location.origin + "/getpins/index.json";
    $.ajax({
      dataType: "text",
      url: url,
      beforeSend: function (jqXHR, settings) {
        // send the post ID
        jqXHR.postID = postID;
        jqXHR.postLat = postLat;
        jqXHR.postLong = postLong;
      },
      success: function (data, textStatus, jqXHR) {
        var postID = jqXHR.postID || null;
        var postLat = jqXHR.postLat || null;
        var postLong = jqXHR.postLong || null;
        drawEvents(data, postID, postLat, postLong);
      },
      error: function () {
        console.log("Error with Index map");
      },
    });
  }

  function drawEvents(data, postID, postLat, postLong) {
    var geojson = $.parseJSON(data);
    var geojsonMarkerOptions = {
      radius: 8,
      fillColor: "#FF0000",
      color: "#000",
      weight: 1,
      opacity: 1,
      fillOpacity: 0.8,
    };

    // Add the posts to the map
    var jsonLayer = L.geoJson(geojson, {
      pointToLayer: function (feature, latlng) {
        return L.circleMarker(latlng, geojsonMarkerOptions);
      },
      onEachFeature: function (feature, layer) {
        var popupContent;
        if (feature.properties.title != undefined) {
          popupContent = feature.properties.title;
          if (feature.properties.url != undefined) {
            popupContent =
              "<p><strong><a class='mapTitle' href='" +
              feature.properties.url +
              "''>" +
              feature.properties.title +
              "</a></strong></p>";
          }
          if (feature.properties.photo !== undefined) {
            popupContent +=
              "<a href='" +
              feature.properties.url +
              "''><img width='240px' height='159px' class='mapPhoto' src='" +
              feature.properties.photo +
              "'></a>";
          }
        }
        layer.bindPopup(popupContent);
      },
    });
    // var featureGroup = L.featureGroup();
    // featureGroup.addLayer(jsonLayer);
    var markers = L.markerClusterGroup({
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true,
      spiderfyDistanceMultiplier: 1.5,
    });
    markers.addLayer(jsonLayer);
    app.leafletMap.addLayer(markers);
    // featureGroup.addTo(app.leafletMap);

    // If we are on a Post page, zoom to the post
    if (postLat !== null && postLong !== null) {
      app.leafletMap.flyTo([postLat, postLong], 5);
    }
  }
}

$(document).on("turbolinks:load", pageLoad);
